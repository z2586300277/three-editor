var J4 = Object.defineProperty, $4 = Object.defineProperties;
var eT = Object.getOwnPropertyDescriptors;
var Ax = Object.getOwnPropertySymbols;
var tT = Object.prototype.hasOwnProperty, nT = Object.prototype.propertyIsEnumerable;
var Ix = Math.pow, jf = (i, e, t) => e in i ? J4(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Ee = (i, e) => {
  for (var t in e || (e = {}))
    tT.call(e, t) && jf(i, t, e[t]);
  if (Ax)
    for (var t of Ax(e))
      nT.call(e, t) && jf(i, t, e[t]);
  return i;
}, Qt = (i, e) => $4(i, eT(e));
var Wf = (i, e, t) => (jf(i, typeof e != "symbol" ? e + "" : e, t), t);
var di = (i, e, t) => new Promise((n, r) => {
  var s = (l) => {
    try {
      o(t.next(l));
    } catch (c) {
      r(c);
    }
  }, a = (l) => {
    try {
      o(t.throw(l));
    } catch (c) {
      r(c);
    }
  }, o = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(s, a);
  o((t = t.apply(i, e)).next());
});
const sp = "165", na = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, ia = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, J0 = 1, $0 = 2, nr = 3, Gi = 0, kn = 1, tn = 2, al = 2, Mi = 100, iT = 101, rT = 102, ap = 200, e1 = 201, sT = 202, aT = 203, Ua = 204, ka = 205, oT = 206, lT = 207, cT = 208, hT = 209, uT = 210, dT = 211, pT = 212, fT = 213, mT = 214, Fh = 0, DM = 1, NM = 2, Pr = 0, t1 = 1, n1 = 2, i1 = 3, r1 = 4, OM = 5, s1 = 6, a1 = 7, Ig = "attached", UM = "detached", Vp = 300, Fr = 301, ys = 302, ol = 303, Kc = 304, Il = 306, In = 1e3, ri = 1001, Fa = 1002, lt = 1003, jp = 1004, ma = 1005, Gt = 1006, Zo = 1007, zi = 1008, fs = 1009, ll = 1012, o1 = 1013, Ba = 1014, si = 1015, Vt = 1016, Cg = 1017, Rg = 1018, _s = 1020, ai = 1023, cl = 1026, xs = 1027, l1 = 1028, Pg = 1029, Lg = 1031, Dg = 1033, Gd = 33776, Vd = 33777, jd = 33778, Wd = 33779, Ng = 35840, Og = 35841, Ug = 35842, kg = 35843, Fg = 36196, Bg = 37492, zg = 37496, Hg = 37808, Gg = 37809, Vg = 37810, jg = 37811, Wg = 37812, Xg = 37813, qg = 37814, Yg = 37815, Zg = 37816, Kg = 37817, Qg = 37818, Jg = 37819, $g = 37820, e0 = 37821, Xd = 36492, t0 = 36494, n0 = 36495, i0 = 36284, r0 = 36285, s0 = 36286, c1 = 2200, hl = 2300, ul = 2301, qd = 2302, ga = 2400, va = 2401, Qc = 2402, Cx = 2500, h1 = 2501, u1 = 3201, la = "", yt = "srgb", on = "srgb-linear", op = "display-p3", Jc = "display-p3-linear", $c = "linear", ft = "srgb", eh = "rec709", th = "p3", ra = 7680, gT = 512, vT = 513, yT = 514, _T = 515, xT = 516, bT = 517, MT = 518, wT = 519, nh = 35044, a0 = "300 es", za = 2e3, ih = 2001;
class lr {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const r = n.indexOf(t);
      r !== -1 && n.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const t = this._listeners[e.type];
    if (t !== void 0) {
      e.target = this;
      const n = t.slice(0);
      for (let r = 0, s = n.length; r < s; r++)
        n[r].call(this, e);
      e.target = null;
    }
  }
}
const bn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Rx = 1234567;
const wa = Math.PI / 180, dl = 180 / Math.PI;
function ci() {
  const i = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0;
  return (bn[255 & i] + bn[i >> 8 & 255] + bn[i >> 16 & 255] + bn[i >> 24 & 255] + "-" + bn[255 & e] + bn[e >> 8 & 255] + "-" + bn[e >> 16 & 15 | 64] + bn[e >> 24 & 255] + "-" + bn[63 & t | 128] + bn[t >> 8 & 255] + "-" + bn[t >> 16 & 255] + bn[t >> 24 & 255] + bn[255 & n] + bn[n >> 8 & 255] + bn[n >> 16 & 255] + bn[n >> 24 & 255]).toLowerCase();
}
function Dt(i, e, t) {
  return Math.max(e, Math.min(t, i));
}
function o0(i, e) {
  return (i % e + e) % e;
}
function Uc(i, e, t) {
  return (1 - t) * i + t * e;
}
function On(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return i / 4294967295;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int32Array:
      return Math.max(i / 2147483647, -1);
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function ke(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return Math.round(4294967295 * i);
    case Uint16Array:
      return Math.round(65535 * i);
    case Uint8Array:
      return Math.round(255 * i);
    case Int32Array:
      return Math.round(2147483647 * i);
    case Int16Array:
      return Math.round(32767 * i);
    case Int8Array:
      return Math.round(127 * i);
    default:
      throw new Error("Invalid component type.");
  }
}
const en = { DEG2RAD: wa, RAD2DEG: dl, generateUUID: ci, clamp: Dt, euclideanModulo: o0, mapLinear: function(i, e, t, n, r) {
  return n + (i - e) * (r - n) / (t - e);
}, inverseLerp: function(i, e, t) {
  return i !== e ? (t - i) / (e - i) : 0;
}, lerp: Uc, damp: function(i, e, t, n) {
  return Uc(i, e, 1 - Math.exp(-t * n));
}, pingpong: function(i, e = 1) {
  return e - Math.abs(o0(i, 2 * e) - e);
}, smoothstep: function(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e)) * i * (3 - 2 * i);
}, smootherstep: function(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e)) * i * i * (i * (6 * i - 15) + 10);
}, randInt: function(i, e) {
  return i + Math.floor(Math.random() * (e - i + 1));
}, randFloat: function(i, e) {
  return i + Math.random() * (e - i);
}, randFloatSpread: function(i) {
  return i * (0.5 - Math.random());
}, seededRandom: function(i) {
  i !== void 0 && (Rx = i);
  let e = Rx += 1831565813;
  return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296;
}, degToRad: function(i) {
  return i * wa;
}, radToDeg: function(i) {
  return i * dl;
}, isPowerOfTwo: function(i) {
  return !(i & i - 1) && i !== 0;
}, ceilPowerOfTwo: function(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}, floorPowerOfTwo: function(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}, setQuaternionFromProperEuler: function(i, e, t, n, r) {
  const s = Math.cos, a = Math.sin, o = s(t / 2), l = a(t / 2), c = s((e + n) / 2), h = a((e + n) / 2), u = s((e - n) / 2), d = a((e - n) / 2), p = s((n - e) / 2), f = a((n - e) / 2);
  switch (r) {
    case "XYX":
      i.set(o * h, l * u, l * d, o * c);
      break;
    case "YZY":
      i.set(l * d, o * h, l * u, o * c);
      break;
    case "ZXZ":
      i.set(l * u, l * d, o * h, o * c);
      break;
    case "XZX":
      i.set(o * h, l * f, l * p, o * c);
      break;
    case "YXY":
      i.set(l * p, o * h, l * f, o * c);
      break;
    case "ZYZ":
      i.set(l * f, l * p, o * h, o * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}, normalize: ke, denormalize: On };
class Y {
  constructor(e = 0, t = 0) {
    Y.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Dt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), r = Math.sin(t), s = this.x - e.x, a = this.y - e.y;
    return this.x = s * n - a * r + e.x, this.y = s * r + a * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Ue {
  constructor(e, t, n, r, s, a, o, l, c) {
    Ue.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, r, s, a, o, l, c);
  }
  set(e, t, n, r, s, a, o, l, c) {
    const h = this.elements;
    return h[0] = e, h[1] = r, h[2] = o, h[3] = t, h[4] = s, h[5] = l, h[6] = n, h[7] = a, h[8] = c, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, r = t.elements, s = this.elements, a = n[0], o = n[3], l = n[6], c = n[1], h = n[4], u = n[7], d = n[2], p = n[5], f = n[8], v = r[0], m = r[3], y = r[6], g = r[1], _ = r[4], x = r[7], M = r[2], b = r[5], w = r[8];
    return s[0] = a * v + o * g + l * M, s[3] = a * m + o * _ + l * b, s[6] = a * y + o * x + l * w, s[1] = c * v + h * g + u * M, s[4] = c * m + h * _ + u * b, s[7] = c * y + h * x + u * w, s[2] = d * v + p * g + f * M, s[5] = d * m + p * _ + f * b, s[8] = d * y + p * x + f * w, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8];
    return t * a * h - t * o * c - n * s * h + n * o * l + r * s * c - r * a * l;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8], u = h * a - o * c, d = o * l - h * s, p = c * s - a * l, f = t * u + n * d + r * p;
    if (f === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / f;
    return e[0] = u * v, e[1] = (r * c - h * n) * v, e[2] = (o * n - r * a) * v, e[3] = d * v, e[4] = (h * t - r * l) * v, e[5] = (r * s - o * t) * v, e[6] = p * v, e[7] = (n * l - c * t) * v, e[8] = (a * t - n * s) * v, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, r, s, a, o) {
    const l = Math.cos(s), c = Math.sin(s);
    return this.set(n * l, n * c, -n * (l * a + c * o) + a + e, -r * c, r * l, -r * (-c * a + l * o) + o + t, 0, 0, 1), this;
  }
  scale(e, t) {
    return this.premultiply(Xf.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Xf.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Xf.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let r = 0; r < 9; r++)
      if (t[r] !== n[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Xf = new Ue();
function kM(i) {
  for (let e = i.length - 1; e >= 0; --e)
    if (i[e] >= 65535)
      return !0;
  return !1;
}
const ST = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
function ko(i, e) {
  return new ST[i](e);
}
function rh(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function Px() {
  const i = rh("canvas");
  return i.style.display = "block", i;
}
const Lx = {};
function d1(i) {
  i in Lx || (Lx[i] = !0, console.warn(i));
}
const Dx = new Ue().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199), Nx = new Ue().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735), wu = { [on]: { transfer: $c, primaries: eh, toReference: (i) => i, fromReference: (i) => i }, [yt]: { transfer: ft, primaries: eh, toReference: (i) => i.convertSRGBToLinear(), fromReference: (i) => i.convertLinearToSRGB() }, [Jc]: { transfer: $c, primaries: th, toReference: (i) => i.applyMatrix3(Nx), fromReference: (i) => i.applyMatrix3(Dx) }, [op]: { transfer: ft, primaries: th, toReference: (i) => i.convertSRGBToLinear().applyMatrix3(Nx), fromReference: (i) => i.applyMatrix3(Dx).convertLinearToSRGB() } }, TT = /* @__PURE__ */ new Set([on, Jc]), rt = { enabled: !0, _workingColorSpace: on, get workingColorSpace() {
  return this._workingColorSpace;
}, set workingColorSpace(i) {
  if (!TT.has(i))
    throw new Error(`Unsupported working color space, "${i}".`);
  this._workingColorSpace = i;
}, convert: function(i, e, t) {
  if (this.enabled === !1 || e === t || !e || !t)
    return i;
  const n = wu[e].toReference;
  return (0, wu[t].fromReference)(n(i));
}, fromWorkingColorSpace: function(i, e) {
  return this.convert(i, this._workingColorSpace, e);
}, toWorkingColorSpace: function(i, e) {
  return this.convert(i, e, this._workingColorSpace);
}, getPrimaries: function(i) {
  return wu[i].primaries;
}, getTransfer: function(i) {
  return i === la ? $c : wu[i].transfer;
} };
function Ko(i) {
  return i < 0.04045 ? 0.0773993808 * i : Math.pow(0.9478672986 * i + 0.0521327014, 2.4);
}
function qf(i) {
  return i < 31308e-7 ? 12.92 * i : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let no;
class FM {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      no === void 0 && (no = rh("canvas")), no.width = e.width, no.height = e.height;
      const n = no.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = no;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && e instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && e instanceof ImageBitmap) {
      const t = rh("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const r = n.getImageData(0, 0, e.width, e.height), s = r.data;
      for (let a = 0; a < s.length; a++)
        s[a] = 255 * Ko(s[a] / 255);
      return n.putImageData(r, 0, 0), t;
    }
    if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(255 * Ko(t[n] / 255)) : t[n] = Ko(t[n]);
      return { data: t, width: e.width, height: e.height };
    }
    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let ET = 0;
class ca {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: ET++ }), this.uuid = ci(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let a = 0, o = r.length; a < o; a++)
          r[a].isDataTexture ? s.push(Yf(r[a].image)) : s.push(Yf(r[a]));
      } else
        s = Yf(r);
      n.url = s;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Yf(i) {
  return typeof HTMLImageElement != "undefined" && i instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && i instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && i instanceof ImageBitmap ? FM.getDataURL(i) : i.data ? { data: Array.from(i.data), width: i.width, height: i.height, type: i.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let AT = 0;
class vt extends lr {
  constructor(e = vt.DEFAULT_IMAGE, t = vt.DEFAULT_MAPPING, n = 1001, r = 1001, s = 1006, a = 1008, o = 1023, l = 1009, c = vt.DEFAULT_ANISOTROPY, h = "") {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: AT++ }), this.uuid = ci(), this.name = "", this.source = new ca(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new Y(0, 0), this.repeat = new Y(1, 1), this.center = new Y(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ue(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Vp)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case In:
          e.x = e.x - Math.floor(e.x);
          break;
        case ri:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Fa:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case In:
          e.y = e.y - Math.floor(e.y);
          break;
        case ri:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Fa:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
vt.DEFAULT_IMAGE = null, vt.DEFAULT_MAPPING = Vp, vt.DEFAULT_ANISOTROPY = 1;
class je {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    je.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, r) {
    return this.x = e, this.y = t, this.z = n, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, r = this.z, s = this.w, a = e.elements;
    return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * s, this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * s, this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * s, this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, r, s;
    const l = e.elements, c = l[0], h = l[4], u = l[8], d = l[1], p = l[5], f = l[9], v = l[2], m = l[6], y = l[10];
    if (Math.abs(h - d) < 0.01 && Math.abs(u - v) < 0.01 && Math.abs(f - m) < 0.01) {
      if (Math.abs(h + d) < 0.1 && Math.abs(u + v) < 0.1 && Math.abs(f + m) < 0.1 && Math.abs(c + p + y - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const _ = (c + 1) / 2, x = (p + 1) / 2, M = (y + 1) / 2, b = (h + d) / 4, w = (u + v) / 4, T = (f + m) / 4;
      return _ > x && _ > M ? _ < 0.01 ? (n = 0, r = 0.707106781, s = 0.707106781) : (n = Math.sqrt(_), r = b / n, s = w / n) : x > M ? x < 0.01 ? (n = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(x), n = b / r, s = T / r) : M < 0.01 ? (n = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(M), n = w / s, r = T / s), this.set(n, r, s, t), this;
    }
    let g = Math.sqrt((m - f) * (m - f) + (u - v) * (u - v) + (d - h) * (d - h));
    return Math.abs(g) < 1e-3 && (g = 1), this.x = (m - f) / g, this.y = (u - v) / g, this.z = (d - h) / g, this.w = Math.acos((c + p + y - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class BM extends lr {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new je(0, 0, e, t), this.scissorTest = !1, this.viewport = new je(0, 0, e, t);
    const r = { width: e, height: t, depth: 1 };
    n = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: Gt, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1 }, n);
    const s = new vt(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    s.flipY = !1, s.generateMipmaps = n.generateMipmaps, s.internalFormat = n.internalFormat, this.textures = [];
    const a = n.count;
    for (let o = 0; o < a; o++)
      this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let r = 0, s = this.textures.length; r < s; r++)
        this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, r = e.textures.length; n < r; n++)
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new ca(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class dt extends BM {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class lp extends vt {
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = lt, this.minFilter = lt, this.wrapR = ri, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class l0 extends vt {
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = lt, this.minFilter = lt, this.wrapR = ri, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Qe {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r;
  }
  static slerpFlat(e, t, n, r, s, a, o) {
    let l = n[r + 0], c = n[r + 1], h = n[r + 2], u = n[r + 3];
    const d = s[a + 0], p = s[a + 1], f = s[a + 2], v = s[a + 3];
    if (o === 0)
      return e[t + 0] = l, e[t + 1] = c, e[t + 2] = h, void (e[t + 3] = u);
    if (o === 1)
      return e[t + 0] = d, e[t + 1] = p, e[t + 2] = f, void (e[t + 3] = v);
    if (u !== v || l !== d || c !== p || h !== f) {
      let m = 1 - o;
      const y = l * d + c * p + h * f + u * v, g = y >= 0 ? 1 : -1, _ = 1 - y * y;
      if (_ > Number.EPSILON) {
        const M = Math.sqrt(_), b = Math.atan2(M, y * g);
        m = Math.sin(m * b) / M, o = Math.sin(o * b) / M;
      }
      const x = o * g;
      if (l = l * m + d * x, c = c * m + p * x, h = h * m + f * x, u = u * m + v * x, m === 1 - o) {
        const M = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
        l *= M, c *= M, h *= M, u *= M;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
  }
  static multiplyQuaternionsFlat(e, t, n, r, s, a) {
    const o = n[r], l = n[r + 1], c = n[r + 2], h = n[r + 3], u = s[a], d = s[a + 1], p = s[a + 2], f = s[a + 3];
    return e[t] = o * f + h * u + l * p - c * d, e[t + 1] = l * f + h * d + c * u - o * p, e[t + 2] = c * f + h * p + o * d - l * u, e[t + 3] = h * f - o * u - l * d - c * p, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, r) {
    return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = !0) {
    const n = e._x, r = e._y, s = e._z, a = e._order, o = Math.cos, l = Math.sin, c = o(n / 2), h = o(r / 2), u = o(s / 2), d = l(n / 2), p = l(r / 2), f = l(s / 2);
    switch (a) {
      case "XYZ":
        this._x = d * h * u + c * p * f, this._y = c * p * u - d * h * f, this._z = c * h * f + d * p * u, this._w = c * h * u - d * p * f;
        break;
      case "YXZ":
        this._x = d * h * u + c * p * f, this._y = c * p * u - d * h * f, this._z = c * h * f - d * p * u, this._w = c * h * u + d * p * f;
        break;
      case "ZXY":
        this._x = d * h * u - c * p * f, this._y = c * p * u + d * h * f, this._z = c * h * f + d * p * u, this._w = c * h * u - d * p * f;
        break;
      case "ZYX":
        this._x = d * h * u - c * p * f, this._y = c * p * u + d * h * f, this._z = c * h * f - d * p * u, this._w = c * h * u + d * p * f;
        break;
      case "YZX":
        this._x = d * h * u + c * p * f, this._y = c * p * u + d * h * f, this._z = c * h * f - d * p * u, this._w = c * h * u - d * p * f;
        break;
      case "XZY":
        this._x = d * h * u - c * p * f, this._y = c * p * u - d * h * f, this._z = c * h * f + d * p * u, this._w = c * h * u + d * p * f;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, r = Math.sin(n);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], r = t[4], s = t[8], a = t[1], o = t[5], l = t[9], c = t[2], h = t[6], u = t[10], d = n + o + u;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / p, this._x = (h - l) * p, this._y = (s - c) * p, this._z = (a - r) * p;
    } else if (n > o && n > u) {
      const p = 2 * Math.sqrt(1 + n - o - u);
      this._w = (h - l) / p, this._x = 0.25 * p, this._y = (r + a) / p, this._z = (s + c) / p;
    } else if (o > u) {
      const p = 2 * Math.sqrt(1 + o - n - u);
      this._w = (s - c) / p, this._x = (r + a) / p, this._y = 0.25 * p, this._z = (l + h) / p;
    } else {
      const p = 2 * Math.sqrt(1 + u - n - o);
      this._w = (a - r) / p, this._x = (s + c) / p, this._y = (l + h) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Dt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0)
      return this;
    const r = Math.min(1, t / n);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, r = e._y, s = e._z, a = e._w, o = t._x, l = t._y, c = t._z, h = t._w;
    return this._x = n * h + a * o + r * c - s * l, this._y = r * h + a * l + s * o - n * c, this._z = s * h + a * c + n * l - r * o, this._w = a * h - n * o - r * l - s * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const n = this._x, r = this._y, s = this._z, a = this._w;
    let o = a * e._w + n * e._x + r * e._y + s * e._z;
    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1)
      return this._w = a, this._x = n, this._y = r, this._z = s, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const p = 1 - t;
      return this._w = p * a + t * this._w, this._x = p * n + t * this._x, this._y = p * r + t * this._y, this._z = p * s + t * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(l), h = Math.atan2(c, o), u = Math.sin((1 - t) * h) / c, d = Math.sin(t * h) / c;
    return this._w = a * u + this._w * d, this._x = n * u + this._x * d, this._y = r * u + this._y * d, this._z = s * u + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), r = Math.sqrt(1 - n), s = Math.sqrt(n);
    return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t));
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class S {
  constructor(e = 0, t = 0, n = 0) {
    S.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Ox.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Ox.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * n + s[6] * r, this.y = s[1] * t + s[4] * n + s[7] * r, this.z = s[2] * t + s[5] * n + s[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, r = this.z, s = e.elements, a = 1 / (s[3] * t + s[7] * n + s[11] * r + s[15]);
    return this.x = (s[0] * t + s[4] * n + s[8] * r + s[12]) * a, this.y = (s[1] * t + s[5] * n + s[9] * r + s[13]) * a, this.z = (s[2] * t + s[6] * n + s[10] * r + s[14]) * a, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, r = this.z, s = e.x, a = e.y, o = e.z, l = e.w, c = 2 * (a * r - o * n), h = 2 * (o * t - s * r), u = 2 * (s * n - a * t);
    return this.x = t + l * c + a * u - o * h, this.y = n + l * h + o * c - s * u, this.z = r + l * u + s * h - a * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * n + s[8] * r, this.y = s[1] * t + s[5] * n + s[9] * r, this.z = s[2] * t + s[6] * n + s[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, r = e.y, s = e.z, a = t.x, o = t.y, l = t.z;
    return this.x = r * l - s * o, this.y = s * a - n * l, this.z = n * o - r * a, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Zf.copy(this).projectOnVector(e), this.sub(Zf);
  }
  reflect(e) {
    return this.sub(Zf.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Dt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, r = this.z - e.z;
    return t * t + n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = r, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, 4 * t);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, 3 * t);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = 2 * Math.random() - 1, n = Math.sqrt(1 - t * t);
    return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Zf = new S(), Ox = new Qe();
class sn {
  constructor(e = new S(1 / 0, 1 / 0, 1 / 0), t = new S(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Pi.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Pi.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Pi.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const s = n.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, Pi) : Pi.fromBufferAttribute(s, a), Pi.applyMatrix4(e.matrixWorld), this.expandByPoint(Pi);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Su.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Su.copy(n.boundingBox)), Su.applyMatrix4(e.matrixWorld), this.union(Su);
    }
    const r = e.children;
    for (let s = 0, a = r.length; s < a; s++)
      this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Pi), Pi.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Zl), Tu.subVectors(this.max, Zl), io.subVectors(e.a, Zl), ro.subVectors(e.b, Zl), so.subVectors(e.c, Zl), Wr.subVectors(ro, io), Xr.subVectors(so, ro), Fs.subVectors(io, so);
    let t = [0, -Wr.z, Wr.y, 0, -Xr.z, Xr.y, 0, -Fs.z, Fs.y, Wr.z, 0, -Wr.x, Xr.z, 0, -Xr.x, Fs.z, 0, -Fs.x, -Wr.y, Wr.x, 0, -Xr.y, Xr.x, 0, -Fs.y, Fs.x, 0];
    return !!Kf(t, io, ro, so, Tu) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Kf(t, io, ro, so, Tu) && (Eu.crossVectors(Wr, Xr), t = [Eu.x, Eu.y, Eu.z], Kf(t, io, ro, so, Tu)));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Pi).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = 0.5 * this.getSize(Pi).length()), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() || (mr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), mr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), mr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), mr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), mr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), mr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), mr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), mr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(mr)), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const mr = [new S(), new S(), new S(), new S(), new S(), new S(), new S(), new S()], Pi = new S(), Su = new sn(), io = new S(), ro = new S(), so = new S(), Wr = new S(), Xr = new S(), Fs = new S(), Zl = new S(), Tu = new S(), Eu = new S(), Bs = new S();
function Kf(i, e, t, n, r) {
  for (let s = 0, a = i.length - 3; s <= a; s += 3) {
    Bs.fromArray(i, s);
    const o = r.x * Math.abs(Bs.x) + r.y * Math.abs(Bs.y) + r.z * Math.abs(Bs.z), l = e.dot(Bs), c = t.dot(Bs), h = n.dot(Bs);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > o)
      return !1;
  }
  return !0;
}
const IT = new sn(), Kl = new S(), Qf = new S();
class an {
  constructor(e = new S(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : IT.setFromPoints(e).getCenter(n);
    let r = 0;
    for (let s = 0, a = e.length; s < a; s++)
      r = Math.max(r, n.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Kl.subVectors(e, this.center);
    const t = Kl.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), r = 0.5 * (n - this.radius);
      this.center.addScaledVector(Kl, r / n), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Qf.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Kl.copy(e.center).add(Qf)), this.expandByPoint(Kl.copy(e.center).sub(Qf))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const gr = new S(), Jf = new S(), Au = new S(), qr = new S(), $f = new S(), Iu = new S(), em = new S();
class Ka {
  constructor(e = new S(), t = new S(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, gr)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = gr.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (gr.copy(this.origin).addScaledVector(this.direction, t), gr.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, r) {
    Jf.copy(e).add(t).multiplyScalar(0.5), Au.copy(t).sub(e).normalize(), qr.copy(this.origin).sub(Jf);
    const s = 0.5 * e.distanceTo(t), a = -this.direction.dot(Au), o = qr.dot(this.direction), l = -qr.dot(Au), c = qr.lengthSq(), h = Math.abs(1 - a * a);
    let u, d, p, f;
    if (h > 0)
      if (u = a * l - o, d = a * o - l, f = s * h, u >= 0)
        if (d >= -f)
          if (d <= f) {
            const v = 1 / h;
            u *= v, d *= v, p = u * (u + a * d + 2 * o) + d * (a * u + d + 2 * l) + c;
          } else
            d = s, u = Math.max(0, -(a * d + o)), p = -u * u + d * (d + 2 * l) + c;
        else
          d = -s, u = Math.max(0, -(a * d + o)), p = -u * u + d * (d + 2 * l) + c;
      else
        d <= -f ? (u = Math.max(0, -(-a * s + o)), d = u > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -u * u + d * (d + 2 * l) + c) : d <= f ? (u = 0, d = Math.min(Math.max(-s, -l), s), p = d * (d + 2 * l) + c) : (u = Math.max(0, -(a * s + o)), d = u > 0 ? s : Math.min(Math.max(-s, -l), s), p = -u * u + d * (d + 2 * l) + c);
    else
      d = a > 0 ? -s : s, u = Math.max(0, -(a * d + o)), p = -u * u + d * (d + 2 * l) + c;
    return n && n.copy(this.origin).addScaledVector(this.direction, u), r && r.copy(Jf).addScaledVector(Au, d), p;
  }
  intersectSphere(e, t) {
    gr.subVectors(e.center, this.origin);
    const n = gr.dot(this.direction), r = gr.dot(gr) - n * n, s = e.radius * e.radius;
    if (r > s)
      return null;
    const a = Math.sqrt(s - r), o = n - a, l = n + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 ? !0 : e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, r, s, a, o, l;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
    return c >= 0 ? (n = (e.min.x - d.x) * c, r = (e.max.x - d.x) * c) : (n = (e.max.x - d.x) * c, r = (e.min.x - d.x) * c), h >= 0 ? (s = (e.min.y - d.y) * h, a = (e.max.y - d.y) * h) : (s = (e.max.y - d.y) * h, a = (e.min.y - d.y) * h), n > a || s > r ? null : ((s > n || isNaN(n)) && (n = s), (a < r || isNaN(r)) && (r = a), u >= 0 ? (o = (e.min.z - d.z) * u, l = (e.max.z - d.z) * u) : (o = (e.max.z - d.z) * u, l = (e.min.z - d.z) * u), n > l || o > r ? null : ((o > n || n != n) && (n = o), (l < r || r != r) && (r = l), r < 0 ? null : this.at(n >= 0 ? n : r, t)));
  }
  intersectsBox(e) {
    return this.intersectBox(e, gr) !== null;
  }
  intersectTriangle(e, t, n, r, s) {
    $f.subVectors(t, e), Iu.subVectors(n, e), em.crossVectors($f, Iu);
    let a, o = this.direction.dot(em);
    if (o > 0) {
      if (r)
        return null;
      a = 1;
    } else {
      if (!(o < 0))
        return null;
      a = -1, o = -o;
    }
    qr.subVectors(this.origin, e);
    const l = a * this.direction.dot(Iu.crossVectors(qr, Iu));
    if (l < 0)
      return null;
    const c = a * this.direction.dot($f.cross(qr));
    if (c < 0 || l + c > o)
      return null;
    const h = -a * qr.dot(em);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class fe {
  constructor(e, t, n, r, s, a, o, l, c, h, u, d, p, f, v, m) {
    fe.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, r, s, a, o, l, c, h, u, d, p, f, v, m);
  }
  set(e, t, n, r, s, a, o, l, c, h, u, d, p, f, v, m) {
    const y = this.elements;
    return y[0] = e, y[4] = t, y[8] = n, y[12] = r, y[1] = s, y[5] = a, y[9] = o, y[13] = l, y[2] = c, y[6] = h, y[10] = u, y[14] = d, y[3] = p, y[7] = f, y[11] = v, y[15] = m, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new fe().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, r = 1 / ao.setFromMatrixColumn(e, 0).length(), s = 1 / ao.setFromMatrixColumn(e, 1).length(), a = 1 / ao.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, r = e.y, s = e.z, a = Math.cos(n), o = Math.sin(n), l = Math.cos(r), c = Math.sin(r), h = Math.cos(s), u = Math.sin(s);
    if (e.order === "XYZ") {
      const d = a * h, p = a * u, f = o * h, v = o * u;
      t[0] = l * h, t[4] = -l * u, t[8] = c, t[1] = p + f * c, t[5] = d - v * c, t[9] = -o * l, t[2] = v - d * c, t[6] = f + p * c, t[10] = a * l;
    } else if (e.order === "YXZ") {
      const d = l * h, p = l * u, f = c * h, v = c * u;
      t[0] = d + v * o, t[4] = f * o - p, t[8] = a * c, t[1] = a * u, t[5] = a * h, t[9] = -o, t[2] = p * o - f, t[6] = v + d * o, t[10] = a * l;
    } else if (e.order === "ZXY") {
      const d = l * h, p = l * u, f = c * h, v = c * u;
      t[0] = d - v * o, t[4] = -a * u, t[8] = f + p * o, t[1] = p + f * o, t[5] = a * h, t[9] = v - d * o, t[2] = -a * c, t[6] = o, t[10] = a * l;
    } else if (e.order === "ZYX") {
      const d = a * h, p = a * u, f = o * h, v = o * u;
      t[0] = l * h, t[4] = f * c - p, t[8] = d * c + v, t[1] = l * u, t[5] = v * c + d, t[9] = p * c - f, t[2] = -c, t[6] = o * l, t[10] = a * l;
    } else if (e.order === "YZX") {
      const d = a * l, p = a * c, f = o * l, v = o * c;
      t[0] = l * h, t[4] = v - d * u, t[8] = f * u + p, t[1] = u, t[5] = a * h, t[9] = -o * h, t[2] = -c * h, t[6] = p * u + f, t[10] = d - v * u;
    } else if (e.order === "XZY") {
      const d = a * l, p = a * c, f = o * l, v = o * c;
      t[0] = l * h, t[4] = -u, t[8] = c * h, t[1] = d * u + v, t[5] = a * h, t[9] = p * u - f, t[2] = f * u - p, t[6] = o * h, t[10] = v * u + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(CT, e, RT);
  }
  lookAt(e, t, n) {
    const r = this.elements;
    return Zn.subVectors(e, t), Zn.lengthSq() === 0 && (Zn.z = 1), Zn.normalize(), Yr.crossVectors(n, Zn), Yr.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Zn.x += 1e-4 : Zn.z += 1e-4, Zn.normalize(), Yr.crossVectors(n, Zn)), Yr.normalize(), Cu.crossVectors(Zn, Yr), r[0] = Yr.x, r[4] = Cu.x, r[8] = Zn.x, r[1] = Yr.y, r[5] = Cu.y, r[9] = Zn.y, r[2] = Yr.z, r[6] = Cu.z, r[10] = Zn.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, r = t.elements, s = this.elements, a = n[0], o = n[4], l = n[8], c = n[12], h = n[1], u = n[5], d = n[9], p = n[13], f = n[2], v = n[6], m = n[10], y = n[14], g = n[3], _ = n[7], x = n[11], M = n[15], b = r[0], w = r[4], T = r[8], A = r[12], L = r[1], I = r[5], P = r[9], N = r[13], F = r[2], z = r[6], q = r[10], re = r[14], ie = r[3], me = r[7], Se = r[11], te = r[15];
    return s[0] = a * b + o * L + l * F + c * ie, s[4] = a * w + o * I + l * z + c * me, s[8] = a * T + o * P + l * q + c * Se, s[12] = a * A + o * N + l * re + c * te, s[1] = h * b + u * L + d * F + p * ie, s[5] = h * w + u * I + d * z + p * me, s[9] = h * T + u * P + d * q + p * Se, s[13] = h * A + u * N + d * re + p * te, s[2] = f * b + v * L + m * F + y * ie, s[6] = f * w + v * I + m * z + y * me, s[10] = f * T + v * P + m * q + y * Se, s[14] = f * A + v * N + m * re + y * te, s[3] = g * b + _ * L + x * F + M * ie, s[7] = g * w + _ * I + x * z + M * me, s[11] = g * T + _ * P + x * q + M * Se, s[15] = g * A + _ * N + x * re + M * te, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], r = e[8], s = e[12], a = e[1], o = e[5], l = e[9], c = e[13], h = e[2], u = e[6], d = e[10], p = e[14];
    return e[3] * (+s * l * u - r * c * u - s * o * d + n * c * d + r * o * p - n * l * p) + e[7] * (+t * l * p - t * c * d + s * a * d - r * a * p + r * c * h - s * l * h) + e[11] * (+t * c * u - t * o * p - s * a * u + n * a * p + s * o * h - n * c * h) + e[15] * (-r * o * h - t * l * u + t * o * d + r * a * u - n * a * d + n * l * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8], u = e[9], d = e[10], p = e[11], f = e[12], v = e[13], m = e[14], y = e[15], g = u * m * c - v * d * c + v * l * p - o * m * p - u * l * y + o * d * y, _ = f * d * c - h * m * c - f * l * p + a * m * p + h * l * y - a * d * y, x = h * v * c - f * u * c + f * o * p - a * v * p - h * o * y + a * u * y, M = f * u * l - h * v * l - f * o * d + a * v * d + h * o * m - a * u * m, b = t * g + n * _ + r * x + s * M;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / b;
    return e[0] = g * w, e[1] = (v * d * s - u * m * s - v * r * p + n * m * p + u * r * y - n * d * y) * w, e[2] = (o * m * s - v * l * s + v * r * c - n * m * c - o * r * y + n * l * y) * w, e[3] = (u * l * s - o * d * s - u * r * c + n * d * c + o * r * p - n * l * p) * w, e[4] = _ * w, e[5] = (h * m * s - f * d * s + f * r * p - t * m * p - h * r * y + t * d * y) * w, e[6] = (f * l * s - a * m * s - f * r * c + t * m * c + a * r * y - t * l * y) * w, e[7] = (a * d * s - h * l * s + h * r * c - t * d * c - a * r * p + t * l * p) * w, e[8] = x * w, e[9] = (f * u * s - h * v * s - f * n * p + t * v * p + h * n * y - t * u * y) * w, e[10] = (a * v * s - f * o * s + f * n * c - t * v * c - a * n * y + t * o * y) * w, e[11] = (h * o * s - a * u * s - h * n * c + t * u * c + a * n * p - t * o * p) * w, e[12] = M * w, e[13] = (h * v * r - f * u * r + f * n * d - t * v * d - h * n * m + t * u * m) * w, e[14] = (f * o * r - a * v * r - f * n * l + t * v * l + a * n * m - t * o * m) * w, e[15] = (a * u * r - h * o * r + h * n * l - t * u * l - a * n * d + t * o * d) * w, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, r = e.y, s = e.z;
    return t[0] *= n, t[4] *= r, t[8] *= s, t[1] *= n, t[5] *= r, t[9] *= s, t[2] *= n, t[6] *= r, t[10] *= s, t[3] *= n, t[7] *= r, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, r));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), r = Math.sin(t), s = 1 - n, a = e.x, o = e.y, l = e.z, c = s * a, h = s * o;
    return this.set(c * a + n, c * o - r * l, c * l + r * o, 0, c * o + r * l, h * o + n, h * l - r * a, 0, c * l - r * o, h * l + r * a, s * l * l + n, 0, 0, 0, 0, 1), this;
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, r, s, a) {
    return this.set(1, n, s, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const r = this.elements, s = t._x, a = t._y, o = t._z, l = t._w, c = s + s, h = a + a, u = o + o, d = s * c, p = s * h, f = s * u, v = a * h, m = a * u, y = o * u, g = l * c, _ = l * h, x = l * u, M = n.x, b = n.y, w = n.z;
    return r[0] = (1 - (v + y)) * M, r[1] = (p + x) * M, r[2] = (f - _) * M, r[3] = 0, r[4] = (p - x) * b, r[5] = (1 - (d + y)) * b, r[6] = (m + g) * b, r[7] = 0, r[8] = (f + _) * w, r[9] = (m - g) * w, r[10] = (1 - (d + v)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, t, n) {
    const r = this.elements;
    let s = ao.set(r[0], r[1], r[2]).length();
    const a = ao.set(r[4], r[5], r[6]).length(), o = ao.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], Li.copy(this);
    const l = 1 / s, c = 1 / a, h = 1 / o;
    return Li.elements[0] *= l, Li.elements[1] *= l, Li.elements[2] *= l, Li.elements[4] *= c, Li.elements[5] *= c, Li.elements[6] *= c, Li.elements[8] *= h, Li.elements[9] *= h, Li.elements[10] *= h, t.setFromRotationMatrix(Li), n.x = s, n.y = a, n.z = o, this;
  }
  makePerspective(e, t, n, r, s, a, o = 2e3) {
    const l = this.elements, c = 2 * s / (t - e), h = 2 * s / (n - r), u = (t + e) / (t - e), d = (n + r) / (n - r);
    let p, f;
    if (o === za)
      p = -(a + s) / (a - s), f = -2 * a * s / (a - s);
    else {
      if (o !== ih)
        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
      p = -a / (a - s), f = -a * s / (a - s);
    }
    return l[0] = c, l[4] = 0, l[8] = u, l[12] = 0, l[1] = 0, l[5] = h, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = f, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, t, n, r, s, a, o = 2e3) {
    const l = this.elements, c = 1 / (t - e), h = 1 / (n - r), u = 1 / (a - s), d = (t + e) * c, p = (n + r) * h;
    let f, v;
    if (o === za)
      f = (a + s) * u, v = -2 * u;
    else {
      if (o !== ih)
        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
      f = s * u, v = -1 * u;
    }
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = v, l[14] = -f, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let r = 0; r < 16; r++)
      if (t[r] !== n[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const ao = new S(), Li = new fe(), CT = new S(0, 0, 0), RT = new S(1, 1, 1), Yr = new S(), Cu = new S(), Zn = new S(), Ux = new fe(), kx = new Qe();
class bt {
  constructor(e = 0, t = 0, n = 0, r = bt.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, r = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const r = e.elements, s = r[0], a = r[4], o = r[8], l = r[1], c = r[5], h = r[9], u = r[2], d = r[6], p = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Dt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(d, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Dt(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Dt(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, s));
        break;
      case "ZYX":
        this._y = Math.asin(-Dt(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-a, c));
        break;
      case "YZX":
        this._z = Math.asin(Dt(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, s)) : (this._x = 0, this._y = Math.atan2(o, p));
        break;
      case "XZY":
        this._z = Math.asin(-Dt(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-h, p), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return Ux.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Ux, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return kx.setFromEuler(this), this.setFromQuaternion(kx, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
bt.DEFAULT_ORDER = "XYZ";
class Wp {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = 1 << e >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e;
  }
  disable(e) {
    this.mask &= ~(1 << e);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return !!(this.mask & e.mask);
  }
  isEnabled(e) {
    return !!(this.mask & 1 << e);
  }
}
let PT = 0;
const Fx = new S(), oo = new Qe(), vr = new fe(), Ru = new S(), Ql = new S(), LT = new S(), DT = new Qe(), Bx = new S(1, 0, 0), zx = new S(0, 1, 0), Hx = new S(0, 0, 1), Gx = { type: "added" }, NT = { type: "removed" }, lo = { type: "childadded", child: null }, tm = { type: "childremoved", child: null };
class Fe extends lr {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: PT++ }), this.uuid = ci(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Fe.DEFAULT_UP.clone();
    const e = new S(), t = new bt(), n = new Qe(), r = new S(1, 1, 1);
    t._onChange(function() {
      n.setFromEuler(t, !1);
    }), n._onChange(function() {
      t.setFromQuaternion(n, void 0, !1);
    }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new fe() }, normalMatrix: { value: new Ue() } }), this.matrix = new fe(), this.matrixWorld = new fe(), this.matrixAutoUpdate = Fe.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Fe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Wp(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return oo.setFromAxisAngle(e, t), this.quaternion.multiply(oo), this;
  }
  rotateOnWorldAxis(e, t) {
    return oo.setFromAxisAngle(e, t), this.quaternion.premultiply(oo), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Bx, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(zx, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Hx, e);
  }
  translateOnAxis(e, t) {
    return Fx.copy(e).applyQuaternion(this.quaternion), this.position.add(Fx.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Bx, e);
  }
  translateY(e) {
    return this.translateOnAxis(zx, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Hx, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(vr.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? Ru.copy(e) : Ru.set(e, t, n);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), Ql.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? vr.lookAt(Ql, Ru, this.up) : vr.lookAt(Ru, Ql, this.up), this.quaternion.setFromRotationMatrix(vr), r && (vr.extractRotation(r.matrixWorld), oo.setFromRotationMatrix(vr), this.quaternion.premultiply(oo.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Gx), lo.child = e, this.dispatchEvent(lo), lo.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(NT), tm.child = e, this.dispatchEvent(tm), tm.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), vr.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), vr.multiply(e.parent.matrixWorld)), e.applyMatrix4(vr), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Gx), lo.child = e, this.dispatchEvent(lo), lo.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const s = this.children[n].getObjectByProperty(e, t);
      if (s !== void 0)
        return s;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const r = this.children;
    for (let s = 0, a = r.length; s < a; s++)
      r[s].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ql, e, LT), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ql, DT, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      s.matrixWorldAutoUpdate !== !0 && e !== !0 || s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const r = this.children;
      for (let s = 0, a = r.length; s < a; s++) {
        const o = r[s];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" });
    const r = {};
    function s(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((o) => ({ boxInitialized: o.boxInitialized, boxMin: o.box.min.toArray(), boxMax: o.box.max.toArray(), sphereInitialized: o.sphereInitialized, sphereRadius: o.sphere.radius, sphereCenter: o.sphere.center.toArray() })), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (r.boundingSphere = { center: r.boundingSphere.center.toArray(), radius: r.boundingSphere.radius }), this.boundingBox !== null && (r.boundingBox = { min: r.boundingBox.min.toArray(), max: r.boundingBox.max.toArray() })), this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const u = l[c];
            s(e.shapes, u);
          }
        else
          s(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(s(e.materials, this.material[l]));
        r.material = o;
      } else
        r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let o = 0; o < this.children.length; o++)
        r.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries), l = a(e.materials), c = a(e.textures), h = a(e.images), u = a(e.shapes), d = a(e.skeletons), p = a(e.animations), f = a(e.nodes);
      o.length > 0 && (n.geometries = o), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), u.length > 0 && (n.shapes = u), d.length > 0 && (n.skeletons = d), p.length > 0 && (n.animations = p), f.length > 0 && (n.nodes = f);
    }
    return n.object = r, n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const h = o[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const r = e.children[n];
        this.add(r.clone());
      }
    return this;
  }
}
Fe.DEFAULT_UP = new S(0, 1, 0), Fe.DEFAULT_MATRIX_AUTO_UPDATE = !0, Fe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Di = new S(), yr = new S(), nm = new S(), _r = new S(), co = new S(), ho = new S(), Vx = new S(), im = new S(), rm = new S(), sm = new S();
class ni {
  constructor(e = new S(), t = new S(), n = new S()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, r) {
    r.subVectors(n, t), Di.subVectors(e, t), r.cross(Di);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, r, s) {
    Di.subVectors(r, t), yr.subVectors(n, t), nm.subVectors(e, t);
    const a = Di.dot(Di), o = Di.dot(yr), l = Di.dot(nm), c = yr.dot(yr), h = yr.dot(nm), u = a * c - o * o;
    if (u === 0)
      return s.set(0, 0, 0), null;
    const d = 1 / u, p = (c * l - o * h) * d, f = (a * h - o * l) * d;
    return s.set(1 - p - f, f, p);
  }
  static containsPoint(e, t, n, r) {
    return this.getBarycoord(e, t, n, r, _r) !== null && _r.x >= 0 && _r.y >= 0 && _r.x + _r.y <= 1;
  }
  static getInterpolation(e, t, n, r, s, a, o, l) {
    return this.getBarycoord(e, t, n, r, _r) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, _r.x), l.addScaledVector(a, _r.y), l.addScaledVector(o, _r.z), l);
  }
  static isFrontFacing(e, t, n, r) {
    return Di.subVectors(n, t), yr.subVectors(e, t), Di.cross(yr).dot(r) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, r) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, n, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Di.subVectors(this.c, this.b), yr.subVectors(this.a, this.b), 0.5 * Di.cross(yr).length();
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ni.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ni.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, r, s) {
    return ni.getInterpolation(e, this.a, this.b, this.c, t, n, r, s);
  }
  containsPoint(e) {
    return ni.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ni.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, r = this.b, s = this.c;
    let a, o;
    co.subVectors(r, n), ho.subVectors(s, n), im.subVectors(e, n);
    const l = co.dot(im), c = ho.dot(im);
    if (l <= 0 && c <= 0)
      return t.copy(n);
    rm.subVectors(e, r);
    const h = co.dot(rm), u = ho.dot(rm);
    if (h >= 0 && u <= h)
      return t.copy(r);
    const d = l * u - h * c;
    if (d <= 0 && l >= 0 && h <= 0)
      return a = l / (l - h), t.copy(n).addScaledVector(co, a);
    sm.subVectors(e, s);
    const p = co.dot(sm), f = ho.dot(sm);
    if (f >= 0 && p <= f)
      return t.copy(s);
    const v = p * c - l * f;
    if (v <= 0 && c >= 0 && f <= 0)
      return o = c / (c - f), t.copy(n).addScaledVector(ho, o);
    const m = h * f - p * u;
    if (m <= 0 && u - h >= 0 && p - f >= 0)
      return Vx.subVectors(s, r), o = (u - h) / (u - h + (p - f)), t.copy(r).addScaledVector(Vx, o);
    const y = 1 / (m + v + d);
    return a = v * y, o = d * y, t.copy(n).addScaledVector(co, a).addScaledVector(ho, o);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const zM = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Zr = { h: 0, s: 0, l: 0 }, Pu = { h: 0, s: 0, l: 0 };
function am(i, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + 6 * (e - i) * t : t < 0.5 ? e : t < 2 / 3 ? i + 6 * (e - i) * (2 / 3 - t) : i;
}
let ce = class {
  constructor(i, e, t) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(i, e, t);
  }
  set(i, e, t) {
    if (e === void 0 && t === void 0) {
      const n = i;
      n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
    } else
      this.setRGB(i, e, t);
    return this;
  }
  setScalar(i) {
    return this.r = i, this.g = i, this.b = i, this;
  }
  setHex(i, e = yt) {
    return i = Math.floor(i), this.r = (i >> 16 & 255) / 255, this.g = (i >> 8 & 255) / 255, this.b = (255 & i) / 255, rt.toWorkingColorSpace(this, e), this;
  }
  setRGB(i, e, t, n = rt.workingColorSpace) {
    return this.r = i, this.g = e, this.b = t, rt.toWorkingColorSpace(this, n), this;
  }
  setHSL(i, e, t, n = rt.workingColorSpace) {
    if (i = o0(i, 1), e = Dt(e, 0, 1), t = Dt(t, 0, 1), e === 0)
      this.r = this.g = this.b = t;
    else {
      const r = t <= 0.5 ? t * (1 + e) : t + e - t * e, s = 2 * t - r;
      this.r = am(s, r, i + 1 / 3), this.g = am(s, r, i), this.b = am(s, r, i - 1 / 3);
    }
    return rt.toWorkingColorSpace(this, n), this;
  }
  setStyle(i, e = yt) {
    function t(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + i + " will be ignored.");
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(i)) {
      let r;
      const s = n[1], a = n[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return t(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return t(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return t(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + i);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(i)) {
      const r = n[1], s = r.length;
      if (s === 3)
        return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, e);
      if (s === 6)
        return this.setHex(parseInt(r, 16), e);
      console.warn("THREE.Color: Invalid hex color " + i);
    } else if (i && i.length > 0)
      return this.setColorName(i, e);
    return this;
  }
  setColorName(i, e = yt) {
    const t = zM[i.toLowerCase()];
    return t !== void 0 ? this.setHex(t, e) : console.warn("THREE.Color: Unknown color " + i), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(i) {
    return this.r = i.r, this.g = i.g, this.b = i.b, this;
  }
  copySRGBToLinear(i) {
    return this.r = Ko(i.r), this.g = Ko(i.g), this.b = Ko(i.b), this;
  }
  copyLinearToSRGB(i) {
    return this.r = qf(i.r), this.g = qf(i.g), this.b = qf(i.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(i = yt) {
    return rt.fromWorkingColorSpace(Mn.copy(this), i), 65536 * Math.round(Dt(255 * Mn.r, 0, 255)) + 256 * Math.round(Dt(255 * Mn.g, 0, 255)) + Math.round(Dt(255 * Mn.b, 0, 255));
  }
  getHexString(i = yt) {
    return ("000000" + this.getHex(i).toString(16)).slice(-6);
  }
  getHSL(i, e = rt.workingColorSpace) {
    rt.fromWorkingColorSpace(Mn.copy(this), e);
    const t = Mn.r, n = Mn.g, r = Mn.b, s = Math.max(t, n, r), a = Math.min(t, n, r);
    let o, l;
    const c = (a + s) / 2;
    if (a === s)
      o = 0, l = 0;
    else {
      const h = s - a;
      switch (l = c <= 0.5 ? h / (s + a) : h / (2 - s - a), s) {
        case t:
          o = (n - r) / h + (n < r ? 6 : 0);
          break;
        case n:
          o = (r - t) / h + 2;
          break;
        case r:
          o = (t - n) / h + 4;
      }
      o /= 6;
    }
    return i.h = o, i.s = l, i.l = c, i;
  }
  getRGB(i, e = rt.workingColorSpace) {
    return rt.fromWorkingColorSpace(Mn.copy(this), e), i.r = Mn.r, i.g = Mn.g, i.b = Mn.b, i;
  }
  getStyle(i = yt) {
    rt.fromWorkingColorSpace(Mn.copy(this), i);
    const e = Mn.r, t = Mn.g, n = Mn.b;
    return i !== yt ? `color(${i} ${e.toFixed(3)} ${t.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(255 * e)},${Math.round(255 * t)},${Math.round(255 * n)})`;
  }
  offsetHSL(i, e, t) {
    return this.getHSL(Zr), this.setHSL(Zr.h + i, Zr.s + e, Zr.l + t);
  }
  add(i) {
    return this.r += i.r, this.g += i.g, this.b += i.b, this;
  }
  addColors(i, e) {
    return this.r = i.r + e.r, this.g = i.g + e.g, this.b = i.b + e.b, this;
  }
  addScalar(i) {
    return this.r += i, this.g += i, this.b += i, this;
  }
  sub(i) {
    return this.r = Math.max(0, this.r - i.r), this.g = Math.max(0, this.g - i.g), this.b = Math.max(0, this.b - i.b), this;
  }
  multiply(i) {
    return this.r *= i.r, this.g *= i.g, this.b *= i.b, this;
  }
  multiplyScalar(i) {
    return this.r *= i, this.g *= i, this.b *= i, this;
  }
  lerp(i, e) {
    return this.r += (i.r - this.r) * e, this.g += (i.g - this.g) * e, this.b += (i.b - this.b) * e, this;
  }
  lerpColors(i, e, t) {
    return this.r = i.r + (e.r - i.r) * t, this.g = i.g + (e.g - i.g) * t, this.b = i.b + (e.b - i.b) * t, this;
  }
  lerpHSL(i, e) {
    this.getHSL(Zr), i.getHSL(Pu);
    const t = Uc(Zr.h, Pu.h, e), n = Uc(Zr.s, Pu.s, e), r = Uc(Zr.l, Pu.l, e);
    return this.setHSL(t, n, r), this;
  }
  setFromVector3(i) {
    return this.r = i.x, this.g = i.y, this.b = i.z, this;
  }
  applyMatrix3(i) {
    const e = this.r, t = this.g, n = this.b, r = i.elements;
    return this.r = r[0] * e + r[3] * t + r[6] * n, this.g = r[1] * e + r[4] * t + r[7] * n, this.b = r[2] * e + r[5] * t + r[8] * n, this;
  }
  equals(i) {
    return i.r === this.r && i.g === this.g && i.b === this.b;
  }
  fromArray(i, e = 0) {
    return this.r = i[e], this.g = i[e + 1], this.b = i[e + 2], this;
  }
  toArray(i = [], e = 0) {
    return i[e] = this.r, i[e + 1] = this.g, i[e + 2] = this.b, i;
  }
  fromBufferAttribute(i, e) {
    return this.r = i.getX(e), this.g = i.getY(e), this.b = i.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const Mn = new ce();
ce.NAMES = zM;
let OT = 0;
class Wt extends lr {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: OT++ }), this.uuid = ci(), this.name = "", this.type = "Material", this.blending = 1, this.side = Gi, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Ua, this.blendDst = ka, this.blendEquation = Mi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new ce(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ra, this.stencilZFail = ra, this.stencilZPass = ra, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const r = this[t];
        r !== void 0 ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
    function r(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n.blending = this.blending), this.side !== Gi && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Ua && (n.blendSrc = this.blendSrc), this.blendDst !== ka && (n.blendDst = this.blendDst), this.blendEquation !== Mi && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== 3 && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== 519 && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== ra && (n.stencilFail = this.stencilFail), this.stencilZFail !== ra && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== ra && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) {
      const s = r(e.textures), a = r(e.images);
      s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const r = t.length;
      n = new Array(r);
      for (let s = 0; s !== r; ++s)
        n[s] = t[s].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class nn extends Wt {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new ce(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bt(), this.combine = Fh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Ir = UT();
function UT() {
  const i = new ArrayBuffer(4), e = new Float32Array(i), t = new Uint32Array(i), n = new Uint32Array(512), r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27 ? (n[l] = 0, n[256 | l] = 32768, r[l] = 24, r[256 | l] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[256 | l] = 1024 >> -c - 14 | 32768, r[l] = -c - 1, r[256 | l] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[256 | l] = c + 15 << 10 | 32768, r[l] = 13, r[256 | l] = 13) : c < 128 ? (n[l] = 31744, n[256 | l] = 64512, r[l] = 24, r[256 | l] = 24) : (n[l] = 31744, n[256 | l] = 64512, r[l] = 13, r[256 | l] = 13);
  }
  const s = new Uint32Array(2048), a = new Uint32Array(64), o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13, h = 0;
    for (; !(8388608 & c); )
      c <<= 1, h -= 8388608;
    c &= -8388609, h += 947912704, s[l] = c | h;
  }
  for (let l = 1024; l < 2048; ++l)
    s[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    a[l] = l << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    a[l] = 2147483648 + (l - 32 << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (o[l] = 1024);
  return { floatView: e, uint32View: t, baseTable: n, shiftTable: r, mantissaTable: s, exponentTable: a, offsetTable: o };
}
function Bn(i) {
  Math.abs(i) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), i = Dt(i, -65504, 65504), Ir.floatView[0] = i;
  const e = Ir.uint32View[0], t = e >> 23 & 511;
  return Ir.baseTable[t] + ((8388607 & e) >> Ir.shiftTable[t]);
}
function Tc(i) {
  const e = i >> 10;
  return Ir.uint32View[0] = Ir.mantissaTable[Ir.offsetTable[e] + (1023 & i)] + Ir.exponentTable[e], Ir.floatView[0];
}
const kT = { toHalfFloat: Bn, fromHalfFloat: Tc }, qt = new S(), Lu = new Y();
class it {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = nh, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = si, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return d1("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Lu.fromBufferAttribute(this, t), Lu.applyMatrix3(e), this.setXY(t, Lu.x, Lu.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        qt.fromBufferAttribute(this, t), qt.applyMatrix3(e), this.setXYZ(t, qt.x, qt.y, qt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      qt.fromBufferAttribute(this, t), qt.applyMatrix4(e), this.setXYZ(t, qt.x, qt.y, qt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      qt.fromBufferAttribute(this, t), qt.applyNormalMatrix(e), this.setXYZ(t, qt.x, qt.y, qt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      qt.fromBufferAttribute(this, t), qt.transformDirection(e), this.setXYZ(t, qt.x, qt.y, qt.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = On(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = ke(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = On(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = ke(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = On(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = ke(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = On(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = ke(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = On(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = ke(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = ke(t, this.array), n = ke(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, r) {
    return e *= this.itemSize, this.normalized && (t = ke(t, this.array), n = ke(n, this.array), r = ke(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this;
  }
  setXYZW(e, t, n, r, s) {
    return e *= this.itemSize, this.normalized && (t = ke(t, this.array), n = ke(n, this.array), r = ke(r, this.array), s = ke(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return this.name !== "" && (e.name = this.name), this.usage !== nh && (e.usage = this.usage), e;
  }
}
class Xp extends it {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class p1 extends it {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class ye extends it {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let FT = 0;
const pi = new fe(), om = new Fe(), uo = new S(), Kn = new sn(), Jl = new sn(), un = new S();
class Re extends lr {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: FT++ }), this.uuid = ci(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (kM(e) ? p1 : Xp)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new Ue().getNormalMatrix(e);
      n.applyNormalMatrix(s), n.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return pi.makeRotationFromQuaternion(e), this.applyMatrix4(pi), this;
  }
  rotateX(e) {
    return pi.makeRotationX(e), this.applyMatrix4(pi), this;
  }
  rotateY(e) {
    return pi.makeRotationY(e), this.applyMatrix4(pi), this;
  }
  rotateZ(e) {
    return pi.makeRotationZ(e), this.applyMatrix4(pi), this;
  }
  translate(e, t, n) {
    return pi.makeTranslation(e, t, n), this.applyMatrix4(pi), this;
  }
  scale(e, t, n) {
    return pi.makeScale(e, t, n), this.applyMatrix4(pi), this;
  }
  lookAt(e) {
    return om.lookAt(e), om.updateMatrix(), this.applyMatrix4(om.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(uo).negate(), this.translate(uo.x, uo.y, uo.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new ye(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new sn());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute)
      return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new S(-1 / 0, -1 / 0, -1 / 0), new S(1 / 0, 1 / 0, 1 / 0));
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, r = t.length; n < r; n++) {
          const s = t[n];
          Kn.setFromBufferAttribute(s), this.morphTargetsRelative ? (un.addVectors(this.boundingBox.min, Kn.min), this.boundingBox.expandByPoint(un), un.addVectors(this.boundingBox.max, Kn.max), this.boundingBox.expandByPoint(un)) : (this.boundingBox.expandByPoint(Kn.min), this.boundingBox.expandByPoint(Kn.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new an());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute)
      return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new S(), 1 / 0);
    if (e) {
      const n = this.boundingSphere.center;
      if (Kn.setFromBufferAttribute(e), t)
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s];
          Jl.setFromBufferAttribute(o), this.morphTargetsRelative ? (un.addVectors(Kn.min, Jl.min), Kn.expandByPoint(un), un.addVectors(Kn.max, Jl.max), Kn.expandByPoint(un)) : (Kn.expandByPoint(Jl.min), Kn.expandByPoint(Jl.max));
        }
      Kn.getCenter(n);
      let r = 0;
      for (let s = 0, a = e.count; s < a; s++)
        un.fromBufferAttribute(e, s), r = Math.max(r, n.distanceToSquared(un));
      if (t)
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s], l = this.morphTargetsRelative;
          for (let c = 0, h = o.count; c < h; c++)
            un.fromBufferAttribute(o, c), l && (uo.fromBufferAttribute(e, c), un.add(uo)), r = Math.max(r, n.distanceToSquared(un));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0)
      return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
    const n = t.position, r = t.normal, s = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new it(new Float32Array(4 * n.count), 4));
    const a = this.getAttribute("tangent"), o = [], l = [];
    for (let T = 0; T < n.count; T++)
      o[T] = new S(), l[T] = new S();
    const c = new S(), h = new S(), u = new S(), d = new Y(), p = new Y(), f = new Y(), v = new S(), m = new S();
    function y(T, A, L) {
      c.fromBufferAttribute(n, T), h.fromBufferAttribute(n, A), u.fromBufferAttribute(n, L), d.fromBufferAttribute(s, T), p.fromBufferAttribute(s, A), f.fromBufferAttribute(s, L), h.sub(c), u.sub(c), p.sub(d), f.sub(d);
      const I = 1 / (p.x * f.y - f.x * p.y);
      isFinite(I) && (v.copy(h).multiplyScalar(f.y).addScaledVector(u, -p.y).multiplyScalar(I), m.copy(u).multiplyScalar(p.x).addScaledVector(h, -f.x).multiplyScalar(I), o[T].add(v), o[A].add(v), o[L].add(v), l[T].add(m), l[A].add(m), l[L].add(m));
    }
    let g = this.groups;
    g.length === 0 && (g = [{ start: 0, count: e.count }]);
    for (let T = 0, A = g.length; T < A; ++T) {
      const L = g[T], I = L.start;
      for (let P = I, N = I + L.count; P < N; P += 3)
        y(e.getX(P + 0), e.getX(P + 1), e.getX(P + 2));
    }
    const _ = new S(), x = new S(), M = new S(), b = new S();
    function w(T) {
      M.fromBufferAttribute(r, T), b.copy(M);
      const A = o[T];
      _.copy(A), _.sub(M.multiplyScalar(M.dot(A))).normalize(), x.crossVectors(b, A);
      const L = x.dot(l[T]) < 0 ? -1 : 1;
      a.setXYZW(T, _.x, _.y, _.z, L);
    }
    for (let T = 0, A = g.length; T < A; ++T) {
      const L = g[T], I = L.start;
      for (let P = I, N = I + L.count; P < N; P += 3)
        w(e.getX(P + 0)), w(e.getX(P + 1)), w(e.getX(P + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new it(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
      else
        for (let d = 0, p = n.count; d < p; d++)
          n.setXYZ(d, 0, 0, 0);
      const r = new S(), s = new S(), a = new S(), o = new S(), l = new S(), c = new S(), h = new S(), u = new S();
      if (e)
        for (let d = 0, p = e.count; d < p; d += 3) {
          const f = e.getX(d + 0), v = e.getX(d + 1), m = e.getX(d + 2);
          r.fromBufferAttribute(t, f), s.fromBufferAttribute(t, v), a.fromBufferAttribute(t, m), h.subVectors(a, s), u.subVectors(r, s), h.cross(u), o.fromBufferAttribute(n, f), l.fromBufferAttribute(n, v), c.fromBufferAttribute(n, m), o.add(h), l.add(h), c.add(h), n.setXYZ(f, o.x, o.y, o.z), n.setXYZ(v, l.x, l.y, l.z), n.setXYZ(m, c.x, c.y, c.z);
        }
      else
        for (let d = 0, p = t.count; d < p; d += 3)
          r.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), h.subVectors(a, s), u.subVectors(r, s), h.cross(u), n.setXYZ(d + 0, h.x, h.y, h.z), n.setXYZ(d + 1, h.x, h.y, h.z), n.setXYZ(d + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      un.fromBufferAttribute(e, t), un.normalize(), e.setXYZ(t, un.x, un.y, un.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array, h = o.itemSize, u = o.normalized, d = new c.constructor(l.length * h);
      let p = 0, f = 0;
      for (let v = 0, m = l.length; v < m; v++) {
        p = o.isInterleavedBufferAttribute ? l[v] * o.data.stride + o.offset : l[v] * h;
        for (let y = 0; y < h; y++)
          d[f++] = c[p++];
      }
      return new it(d, h, u);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Re(), n = this.index.array, r = this.attributes;
    for (const o in r) {
      const l = e(r[o], n);
      t.setAttribute(o, l);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const l = [], c = s[o];
      for (let h = 0, u = c.length; h < u; h++) {
        const d = e(c[h], n);
        l.push(d);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], h = [];
      for (let u = 0, d = c.length; u < d; u++) {
        const p = c[u];
        h.push(p.toJSON(e.data));
      }
      h.length > 0 && (r[l] = h, s = !0);
    }
    s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return o !== null && (e.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const r = e.attributes;
    for (const c in r) {
      const h = r[c];
      this.setAttribute(c, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const h = [], u = s[c];
      for (let d = 0, p = u.length; d < p; d++)
        h.push(u[d].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, h = a.length; c < h; c++) {
      const u = a[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const jx = new fe(), zs = new Ka(), Du = new an(), Wx = new S(), po = new S(), fo = new S(), mo = new S(), lm = new S(), Nu = new S(), Ou = new Y(), Uu = new Y(), ku = new Y(), Xx = new S(), qx = new S(), Yx = new S(), Fu = new S(), Bu = new S();
class ve extends Fe {
  constructor(e = new Re(), t = new nn()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const n = e[t[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, s = n.length; r < s; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, r = n.attributes.position, s = n.morphAttributes.position, a = n.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const o = this.morphTargetInfluences;
    if (s && o) {
      Nu.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const h = o[l], u = s[l];
        h !== 0 && (lm.fromBufferAttribute(u, e), a ? Nu.addScaledVector(lm, h) : Nu.addScaledVector(lm.sub(t), h));
      }
      t.add(Nu);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, r = this.material, s = this.matrixWorld;
    if (r !== void 0) {
      if (n.boundingSphere === null && n.computeBoundingSphere(), Du.copy(n.boundingSphere), Du.applyMatrix4(s), zs.copy(e.ray).recast(e.near), Du.containsPoint(zs.origin) === !1 && (zs.intersectSphere(Du, Wx) === null || zs.origin.distanceToSquared(Wx) > Ix(e.far - e.near, 2)))
        return;
      jx.copy(s).invert(), zs.copy(e.ray).applyMatrix4(jx), n.boundingBox !== null && zs.intersectsBox(n.boundingBox) === !1 || this._computeIntersections(e, t, zs);
    }
  }
  _computeIntersections(e, t, n) {
    let r;
    const s = this.geometry, a = this.material, o = s.index, l = s.attributes.position, c = s.attributes.uv, h = s.attributes.uv1, u = s.attributes.normal, d = s.groups, p = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let f = 0, v = d.length; f < v; f++) {
          const m = d[f], y = a[m.materialIndex];
          for (let g = Math.max(m.start, p.start), _ = Math.min(o.count, Math.min(m.start + m.count, p.start + p.count)); g < _; g += 3)
            r = zu(this, y, e, n, c, h, u, o.getX(g), o.getX(g + 1), o.getX(g + 2)), r && (r.faceIndex = Math.floor(g / 3), r.face.materialIndex = m.materialIndex, t.push(r));
        }
      else
        for (let f = Math.max(0, p.start), v = Math.min(o.count, p.start + p.count); f < v; f += 3)
          r = zu(this, a, e, n, c, h, u, o.getX(f), o.getX(f + 1), o.getX(f + 2)), r && (r.faceIndex = Math.floor(f / 3), t.push(r));
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let f = 0, v = d.length; f < v; f++) {
          const m = d[f], y = a[m.materialIndex];
          for (let g = Math.max(m.start, p.start), _ = Math.min(l.count, Math.min(m.start + m.count, p.start + p.count)); g < _; g += 3)
            r = zu(this, y, e, n, c, h, u, g, g + 1, g + 2), r && (r.faceIndex = Math.floor(g / 3), r.face.materialIndex = m.materialIndex, t.push(r));
        }
      else
        for (let f = Math.max(0, p.start), v = Math.min(l.count, p.start + p.count); f < v; f += 3)
          r = zu(this, a, e, n, c, h, u, f, f + 1, f + 2), r && (r.faceIndex = Math.floor(f / 3), t.push(r));
  }
}
function zu(i, e, t, n, r, s, a, o, l, c) {
  i.getVertexPosition(o, po), i.getVertexPosition(l, fo), i.getVertexPosition(c, mo);
  const h = function(u, d, p, f, v, m, y, g) {
    let _;
    if (_ = d.side === kn ? f.intersectTriangle(y, m, v, !0, g) : f.intersectTriangle(v, m, y, d.side === Gi, g), _ === null)
      return null;
    Bu.copy(g), Bu.applyMatrix4(u.matrixWorld);
    const x = p.ray.origin.distanceTo(Bu);
    return x < p.near || x > p.far ? null : { distance: x, point: Bu.clone(), object: u };
  }(i, e, t, n, po, fo, mo, Fu);
  if (h) {
    r && (Ou.fromBufferAttribute(r, o), Uu.fromBufferAttribute(r, l), ku.fromBufferAttribute(r, c), h.uv = ni.getInterpolation(Fu, po, fo, mo, Ou, Uu, ku, new Y())), s && (Ou.fromBufferAttribute(s, o), Uu.fromBufferAttribute(s, l), ku.fromBufferAttribute(s, c), h.uv1 = ni.getInterpolation(Fu, po, fo, mo, Ou, Uu, ku, new Y())), a && (Xx.fromBufferAttribute(a, o), qx.fromBufferAttribute(a, l), Yx.fromBufferAttribute(a, c), h.normal = ni.getInterpolation(Fu, po, fo, mo, Xx, qx, Yx, new S()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const u = { a: o, b: l, c, normal: new S(), materialIndex: 0 };
    ni.getNormal(po, fo, mo, u.normal), h.face = u;
  }
  return h;
}
class Pt extends Re {
  constructor(e = 1, t = 1, n = 1, r = 1, s = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: r, heightSegments: s, depthSegments: a };
    const o = this;
    r = Math.floor(r), s = Math.floor(s), a = Math.floor(a);
    const l = [], c = [], h = [], u = [];
    let d = 0, p = 0;
    function f(v, m, y, g, _, x, M, b, w, T, A) {
      const L = x / w, I = M / T, P = x / 2, N = M / 2, F = b / 2, z = w + 1, q = T + 1;
      let re = 0, ie = 0;
      const me = new S();
      for (let Se = 0; Se < q; Se++) {
        const te = Se * I - N;
        for (let se = 0; se < z; se++) {
          const he = se * L - P;
          me[v] = he * g, me[m] = te * _, me[y] = F, c.push(me.x, me.y, me.z), me[v] = 0, me[m] = 0, me[y] = b > 0 ? 1 : -1, h.push(me.x, me.y, me.z), u.push(se / w), u.push(1 - Se / T), re += 1;
        }
      }
      for (let Se = 0; Se < T; Se++)
        for (let te = 0; te < w; te++) {
          const se = d + te + z * Se, he = d + te + z * (Se + 1), ae = d + (te + 1) + z * (Se + 1), D = d + (te + 1) + z * Se;
          l.push(se, he, D), l.push(he, ae, D), ie += 6;
        }
      o.addGroup(p, ie, A), p += ie, d += re;
    }
    f("z", "y", "x", -1, -1, n, t, e, a, s, 0), f("z", "y", "x", 1, -1, n, t, -e, a, s, 1), f("x", "z", "y", 1, 1, e, n, t, r, a, 2), f("x", "z", "y", 1, -1, e, n, -t, r, a, 3), f("x", "y", "z", 1, -1, e, t, n, r, s, 4), f("x", "y", "z", -1, -1, e, t, -n, r, s, 5), this.setIndex(l), this.setAttribute("position", new ye(c, 3)), this.setAttribute("normal", new ye(h, 3)), this.setAttribute("uv", new ye(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Pt(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function pl(i) {
  const e = {};
  for (const t in i) {
    e[t] = {};
    for (const n in i[t]) {
      const r = i[t][n];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = r.clone() : Array.isArray(r) ? e[t][n] = r.slice() : e[t][n] = r;
    }
  }
  return e;
}
function Rn(i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
    const n = pl(i[t]);
    for (const r in n)
      e[r] = n[r];
  }
  return e;
}
function HM(i) {
  const e = i.getRenderTarget();
  return e === null ? i.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : rt.workingColorSpace;
}
const rn = { clone: pl, merge: Rn };
class st extends Wt {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { clipCullDistance: !1, multiDraw: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = pl(e.uniforms), this.uniformsGroups = function(t) {
      const n = [];
      for (let r = 0; r < t.length; r++)
        n.push(t[r].clone());
      return n;
    }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const s = this.uniforms[r].value;
      s && s.isTexture ? t.uniforms[r] = { type: "t", value: s.toJSON(e).uuid } : s && s.isColor ? t.uniforms[r] = { type: "c", value: s.getHex() } : s && s.isVector2 ? t.uniforms[r] = { type: "v2", value: s.toArray() } : s && s.isVector3 ? t.uniforms[r] = { type: "v3", value: s.toArray() } : s && s.isVector4 ? t.uniforms[r] = { type: "v4", value: s.toArray() } : s && s.isMatrix3 ? t.uniforms[r] = { type: "m3", value: s.toArray() } : s && s.isMatrix4 ? t.uniforms[r] = { type: "m4", value: s.toArray() } : t.uniforms[r] = { value: s };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (n[r] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class qp extends Fe {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new fe(), this.projectionMatrix = new fe(), this.projectionMatrixInverse = new fe(), this.coordinateSystem = za;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Kr = new S(), Zx = new Y(), Kx = new Y();
class jt extends qp {
  constructor(e = 50, t = 1, n = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = 2 * dl * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(0.5 * wa * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return 2 * dl * Math.atan(Math.tan(0.5 * wa * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, n) {
    Kr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Kr.x, Kr.y).multiplyScalar(-e / Kr.z), Kr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Kr.x, Kr.y).multiplyScalar(-e / Kr.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, Zx, Kx), t.subVectors(Kx, Zx);
  }
  setViewOffset(e, t, n, r, s, a) {
    this.aspect = e / t, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(0.5 * wa * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, s = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, c = a.fullHeight;
      s += a.offsetX * r / l, t -= a.offsetY * n / c, r *= a.width / l, n *= a.height / c;
    }
    const o = this.filmOffset;
    o !== 0 && (s += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const go = -90;
class GM extends Fe {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new jt(go, 1, e, t);
    r.layers = this.layers, this.add(r);
    const s = new jt(go, 1, e, t);
    s.layers = this.layers, this.add(s);
    const a = new jt(go, 1, e, t);
    a.layers = this.layers, this.add(a);
    const o = new jt(go, 1, e, t);
    o.layers = this.layers, this.add(o);
    const l = new jt(go, 1, e, t);
    l.layers = this.layers, this.add(l);
    const c = new jt(go, 1, e, t);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, r, s, a, o, l] = t;
    for (const c of t)
      this.remove(c);
    if (e === za)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else {
      if (e !== ih)
        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    }
    for (const c of t)
      this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [s, a, o, l, c, h] = this.children, u = e.getRenderTarget(), d = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), f = e.xr.enabled;
    e.xr.enabled = !1;
    const v = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, r), e.render(t, s), e.setRenderTarget(n, 1, r), e.render(t, a), e.setRenderTarget(n, 2, r), e.render(t, o), e.setRenderTarget(n, 3, r), e.render(t, l), e.setRenderTarget(n, 4, r), e.render(t, c), n.texture.generateMipmaps = v, e.setRenderTarget(n, 5, r), e.render(t, h), e.setRenderTarget(u, d, p), e.xr.enabled = f, n.texture.needsPMREMUpdate = !0;
  }
}
class kc extends vt {
  constructor(e, t, n, r, s, a, o, l, c, h) {
    super(e = e !== void 0 ? e : [], t = t !== void 0 ? t : Fr, n, r, s, a, o, l, c, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class VM extends dt {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, r = [n, n, n, n, n, n];
    this.texture = new kc(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 && t.generateMipmaps, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Gt;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, r = new Pt(5, 5, 5), s = new st({ name: "CubemapFromEquirect", uniforms: pl(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: kn, blending: 0 });
    s.uniforms.tEquirect.value = t;
    const a = new ve(r, s), o = t.minFilter;
    return t.minFilter === zi && (t.minFilter = Gt), new GM(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, t, n, r) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(t, n, r);
    e.setRenderTarget(s);
  }
}
const cm = new S(), BT = new S(), zT = new Ue();
class Fi {
  constructor(e = new S(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, r) {
    return this.normal.set(e, t, n), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const r = cm.subVectors(n, t).cross(BT.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(cm), r = this.normal.dot(n);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || zT.getNormalMatrix(e), r = this.coplanarPoint(cm).applyMatrix4(e), s = this.normal.applyMatrix3(n).normalize();
    return this.constant = -r.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Hs = new an(), Hu = new S();
class sh {
  constructor(e = new Fi(), t = new Fi(), n = new Fi(), r = new Fi(), s = new Fi(), a = new Fi()) {
    this.planes = [e, t, n, r, s, a];
  }
  set(e, t, n, r, s, a) {
    const o = this.planes;
    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(s), o[5].copy(a), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = 2e3) {
    const n = this.planes, r = e.elements, s = r[0], a = r[1], o = r[2], l = r[3], c = r[4], h = r[5], u = r[6], d = r[7], p = r[8], f = r[9], v = r[10], m = r[11], y = r[12], g = r[13], _ = r[14], x = r[15];
    if (n[0].setComponents(l - s, d - c, m - p, x - y).normalize(), n[1].setComponents(l + s, d + c, m + p, x + y).normalize(), n[2].setComponents(l + a, d + h, m + f, x + g).normalize(), n[3].setComponents(l - a, d - h, m - f, x - g).normalize(), n[4].setComponents(l - o, d - u, m - v, x - _).normalize(), t === za)
      n[5].setComponents(l + o, d + u, m + v, x + _).normalize();
    else {
      if (t !== ih)
        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
      n[5].setComponents(o, u, v, _).normalize();
    }
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Hs.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), Hs.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Hs);
  }
  intersectsSprite(e) {
    return Hs.center.set(0, 0, 0), Hs.radius = 0.7071067811865476, Hs.applyMatrix4(e.matrixWorld), this.intersectsSphere(Hs);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, r = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(n) < r)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const r = t[n];
      if (Hu.x = r.normal.x > 0 ? e.max.x : e.min.x, Hu.y = r.normal.y > 0 ? e.max.y : e.min.y, Hu.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Hu) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function jM() {
  let i = null, e = !1, t = null, n = null;
  function r(s, a) {
    t(s, a), n = i.requestAnimationFrame(r);
  }
  return { start: function() {
    e !== !0 && t !== null && (n = i.requestAnimationFrame(r), e = !0);
  }, stop: function() {
    i.cancelAnimationFrame(n), e = !1;
  }, setAnimationLoop: function(s) {
    t = s;
  }, setContext: function(s) {
    i = s;
  } };
}
function HT(i) {
  const e = /* @__PURE__ */ new WeakMap();
  return { get: function(t) {
    return t.isInterleavedBufferAttribute && (t = t.data), e.get(t);
  }, remove: function(t) {
    t.isInterleavedBufferAttribute && (t = t.data);
    const n = e.get(t);
    n && (i.deleteBuffer(n.buffer), e.delete(t));
  }, update: function(t, n) {
    if (t.isGLBufferAttribute) {
      const s = e.get(t);
      return void ((!s || s.version < t.version) && e.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version }));
    }
    t.isInterleavedBufferAttribute && (t = t.data);
    const r = e.get(t);
    if (r === void 0)
      e.set(t, function(s, a) {
        const o = s.array, l = s.usage, c = o.byteLength, h = i.createBuffer();
        let u;
        if (i.bindBuffer(a, h), i.bufferData(a, o, l), s.onUploadCallback(), o instanceof Float32Array)
          u = i.FLOAT;
        else if (o instanceof Uint16Array)
          u = s.isFloat16BufferAttribute ? i.HALF_FLOAT : i.UNSIGNED_SHORT;
        else if (o instanceof Int16Array)
          u = i.SHORT;
        else if (o instanceof Uint32Array)
          u = i.UNSIGNED_INT;
        else if (o instanceof Int32Array)
          u = i.INT;
        else if (o instanceof Int8Array)
          u = i.BYTE;
        else if (o instanceof Uint8Array)
          u = i.UNSIGNED_BYTE;
        else {
          if (!(o instanceof Uint8ClampedArray))
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + o);
          u = i.UNSIGNED_BYTE;
        }
        return { buffer: h, type: u, bytesPerElement: o.BYTES_PER_ELEMENT, version: s.version, size: c };
      }(t, n));
    else if (r.version < t.version) {
      if (r.size !== t.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      (function(s, a, o) {
        const l = a.array, c = a._updateRange, h = a.updateRanges;
        if (i.bindBuffer(o, s), c.count === -1 && h.length === 0 && i.bufferSubData(o, 0, l), h.length !== 0) {
          for (let u = 0, d = h.length; u < d; u++) {
            const p = h[u];
            i.bufferSubData(o, p.start * l.BYTES_PER_ELEMENT, l, p.start, p.count);
          }
          a.clearUpdateRanges();
        }
        c.count !== -1 && (i.bufferSubData(o, c.offset * l.BYTES_PER_ELEMENT, l, c.offset, c.count), c.count = -1), a.onUploadCallback();
      })(r.buffer, t, n), r.version = t.version;
    }
  } };
}
class Qa extends Re {
  constructor(e = 1, t = 1, n = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: r };
    const s = e / 2, a = t / 2, o = Math.floor(n), l = Math.floor(r), c = o + 1, h = l + 1, u = e / o, d = t / l, p = [], f = [], v = [], m = [];
    for (let y = 0; y < h; y++) {
      const g = y * d - a;
      for (let _ = 0; _ < c; _++) {
        const x = _ * u - s;
        f.push(x, -g, 0), v.push(0, 0, 1), m.push(_ / o), m.push(1 - y / l);
      }
    }
    for (let y = 0; y < l; y++)
      for (let g = 0; g < o; g++) {
        const _ = g + c * y, x = g + c * (y + 1), M = g + 1 + c * (y + 1), b = g + 1 + c * y;
        p.push(_, x, b), p.push(x, M, b);
      }
    this.setIndex(p), this.setAttribute("position", new ye(f, 3)), this.setAttribute("normal", new ye(v, 3)), this.setAttribute("uv", new ye(m, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Qa(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
const Ge = { alphahash_fragment: `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, alphahash_pars_fragment: `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, alphatest_fragment: `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, batching_pars_vertex: `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, batching_vertex: `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, begin_vertex: `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, bsdfs: `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( batchId );
	vColor.xyz *= batchingColor.xyz;
#endif`, common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", colorspace_pars_fragment: `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, envmap_physical_pars_fragment: `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, map_particle_pars_fragment: `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, morphinstance_vertex: `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, morphcolor_vertex: `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, normal_fragment_maps: `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, opaque_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, uv_pars_fragment: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_pars_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}` }, _e = { common: { diffuse: { value: new ce(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Ue() }, alphaMap: { value: null }, alphaMapTransform: { value: new Ue() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Ue() } }, envmap: { envMap: { value: null }, envMapRotation: { value: new Ue() }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Ue() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Ue() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Ue() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Ue() }, normalScale: { value: new Y(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Ue() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Ue() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Ue() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Ue() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new ce(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new ce(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Ue() }, alphaTest: { value: 0 }, uvTransform: { value: new Ue() } }, sprite: { diffuse: { value: new ce(16777215) }, opacity: { value: 1 }, center: { value: new Y(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Ue() }, alphaMap: { value: null }, alphaMapTransform: { value: new Ue() }, alphaTest: { value: 0 } } }, Dn = { basic: { uniforms: Rn([_e.common, _e.specularmap, _e.envmap, _e.aomap, _e.lightmap, _e.fog]), vertexShader: Ge.meshbasic_vert, fragmentShader: Ge.meshbasic_frag }, lambert: { uniforms: Rn([_e.common, _e.specularmap, _e.envmap, _e.aomap, _e.lightmap, _e.emissivemap, _e.bumpmap, _e.normalmap, _e.displacementmap, _e.fog, _e.lights, { emissive: { value: new ce(0) } }]), vertexShader: Ge.meshlambert_vert, fragmentShader: Ge.meshlambert_frag }, phong: { uniforms: Rn([_e.common, _e.specularmap, _e.envmap, _e.aomap, _e.lightmap, _e.emissivemap, _e.bumpmap, _e.normalmap, _e.displacementmap, _e.fog, _e.lights, { emissive: { value: new ce(0) }, specular: { value: new ce(1118481) }, shininess: { value: 30 } }]), vertexShader: Ge.meshphong_vert, fragmentShader: Ge.meshphong_frag }, standard: { uniforms: Rn([_e.common, _e.envmap, _e.aomap, _e.lightmap, _e.emissivemap, _e.bumpmap, _e.normalmap, _e.displacementmap, _e.roughnessmap, _e.metalnessmap, _e.fog, _e.lights, { emissive: { value: new ce(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Ge.meshphysical_vert, fragmentShader: Ge.meshphysical_frag }, toon: { uniforms: Rn([_e.common, _e.aomap, _e.lightmap, _e.emissivemap, _e.bumpmap, _e.normalmap, _e.displacementmap, _e.gradientmap, _e.fog, _e.lights, { emissive: { value: new ce(0) } }]), vertexShader: Ge.meshtoon_vert, fragmentShader: Ge.meshtoon_frag }, matcap: { uniforms: Rn([_e.common, _e.bumpmap, _e.normalmap, _e.displacementmap, _e.fog, { matcap: { value: null } }]), vertexShader: Ge.meshmatcap_vert, fragmentShader: Ge.meshmatcap_frag }, points: { uniforms: Rn([_e.points, _e.fog]), vertexShader: Ge.points_vert, fragmentShader: Ge.points_frag }, dashed: { uniforms: Rn([_e.common, _e.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Ge.linedashed_vert, fragmentShader: Ge.linedashed_frag }, depth: { uniforms: Rn([_e.common, _e.displacementmap]), vertexShader: Ge.depth_vert, fragmentShader: Ge.depth_frag }, normal: { uniforms: Rn([_e.common, _e.bumpmap, _e.normalmap, _e.displacementmap, { opacity: { value: 1 } }]), vertexShader: Ge.meshnormal_vert, fragmentShader: Ge.meshnormal_frag }, sprite: { uniforms: Rn([_e.sprite, _e.fog]), vertexShader: Ge.sprite_vert, fragmentShader: Ge.sprite_frag }, background: { uniforms: { uvTransform: { value: new Ue() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Ge.background_vert, fragmentShader: Ge.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new Ue() } }, vertexShader: Ge.backgroundCube_vert, fragmentShader: Ge.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Ge.cube_vert, fragmentShader: Ge.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Ge.equirect_vert, fragmentShader: Ge.equirect_frag }, distanceRGBA: { uniforms: Rn([_e.common, _e.displacementmap, { referencePosition: { value: new S() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Ge.distanceRGBA_vert, fragmentShader: Ge.distanceRGBA_frag }, shadow: { uniforms: Rn([_e.lights, _e.fog, { color: { value: new ce(0) }, opacity: { value: 1 } }]), vertexShader: Ge.shadow_vert, fragmentShader: Ge.shadow_frag } };
Dn.physical = { uniforms: Rn([Dn.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Ue() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Ue() }, clearcoatNormalScale: { value: new Y(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Ue() }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Ue() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Ue() }, sheen: { value: 0 }, sheenColor: { value: new ce(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Ue() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Ue() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Ue() }, transmissionSamplerSize: { value: new Y() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Ue() }, attenuationDistance: { value: 0 }, attenuationColor: { value: new ce(0) }, specularColor: { value: new ce(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Ue() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Ue() }, anisotropyVector: { value: new Y() }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Ue() } }]), vertexShader: Ge.meshphysical_vert, fragmentShader: Ge.meshphysical_frag };
const Gu = { r: 0, b: 0, g: 0 }, Gs = new bt(), GT = new fe();
function VT(i, e, t, n, r, s, a) {
  const o = new ce(0);
  let l, c, h = s === !0 ? 0 : 1, u = null, d = 0, p = null;
  function f(m) {
    let y = m.isScene === !0 ? m.background : null;
    return y && y.isTexture && (y = (m.backgroundBlurriness > 0 ? t : e).get(y)), y;
  }
  function v(m, y) {
    m.getRGB(Gu, HM(i)), n.buffers.color.setClear(Gu.r, Gu.g, Gu.b, y, a);
  }
  return { getClearColor: function() {
    return o;
  }, setClearColor: function(m, y = 1) {
    o.set(m), h = y, v(o, h);
  }, getClearAlpha: function() {
    return h;
  }, setClearAlpha: function(m) {
    h = m, v(o, h);
  }, render: function(m) {
    let y = !1;
    const g = f(m);
    g === null ? v(o, h) : g && g.isColor && (v(g, 1), y = !0);
    const _ = i.xr.getEnvironmentBlendMode();
    _ === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : _ === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (i.autoClear || y) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil));
  }, addToRenderList: function(m, y) {
    const g = f(y);
    g && (g.isCubeTexture || g.mapping === Il) ? (c === void 0 && (c = new ve(new Pt(1, 1, 1), new st({ name: "BackgroundCubeMaterial", uniforms: pl(Dn.backgroundCube.uniforms), vertexShader: Dn.backgroundCube.vertexShader, fragmentShader: Dn.backgroundCube.fragmentShader, side: kn, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(_, x, M) {
      this.matrixWorld.copyPosition(M.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), r.update(c)), Gs.copy(y.backgroundRotation), Gs.x *= -1, Gs.y *= -1, Gs.z *= -1, g.isCubeTexture && g.isRenderTargetTexture === !1 && (Gs.y *= -1, Gs.z *= -1), c.material.uniforms.envMap.value = g, c.material.uniforms.flipEnvMap.value = g.isCubeTexture && g.isRenderTargetTexture === !1 ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = y.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(GT.makeRotationFromEuler(Gs)), c.material.toneMapped = rt.getTransfer(g.colorSpace) !== ft, u === g && d === g.version && p === i.toneMapping || (c.material.needsUpdate = !0, u = g, d = g.version, p = i.toneMapping), c.layers.enableAll(), m.unshift(c, c.geometry, c.material, 0, 0, null)) : g && g.isTexture && (l === void 0 && (l = new ve(new Qa(2, 2), new st({ name: "BackgroundMaterial", uniforms: pl(Dn.background.uniforms), vertexShader: Dn.background.vertexShader, fragmentShader: Dn.background.fragmentShader, side: Gi, depthTest: !1, depthWrite: !1, fog: !1 })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), r.update(l)), l.material.uniforms.t2D.value = g, l.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, l.material.toneMapped = rt.getTransfer(g.colorSpace) !== ft, g.matrixAutoUpdate === !0 && g.updateMatrix(), l.material.uniforms.uvTransform.value.copy(g.matrix), u === g && d === g.version && p === i.toneMapping || (l.material.needsUpdate = !0, u = g, d = g.version, p = i.toneMapping), l.layers.enableAll(), m.unshift(l, l.geometry, l.material, 0, 0, null));
  } };
}
function jT(i, e) {
  const t = i.getParameter(i.MAX_VERTEX_ATTRIBS), n = {}, r = c(null);
  let s = r, a = !1;
  function o(y) {
    return i.bindVertexArray(y);
  }
  function l(y) {
    return i.deleteVertexArray(y);
  }
  function c(y) {
    const g = [], _ = [], x = [];
    for (let M = 0; M < t; M++)
      g[M] = 0, _[M] = 0, x[M] = 0;
    return { geometry: null, program: null, wireframe: !1, newAttributes: g, enabledAttributes: _, attributeDivisors: x, object: y, attributes: {}, index: null };
  }
  function h() {
    const y = s.newAttributes;
    for (let g = 0, _ = y.length; g < _; g++)
      y[g] = 0;
  }
  function u(y) {
    d(y, 0);
  }
  function d(y, g) {
    const _ = s.newAttributes, x = s.enabledAttributes, M = s.attributeDivisors;
    _[y] = 1, x[y] === 0 && (i.enableVertexAttribArray(y), x[y] = 1), M[y] !== g && (i.vertexAttribDivisor(y, g), M[y] = g);
  }
  function p() {
    const y = s.newAttributes, g = s.enabledAttributes;
    for (let _ = 0, x = g.length; _ < x; _++)
      g[_] !== y[_] && (i.disableVertexAttribArray(_), g[_] = 0);
  }
  function f(y, g, _, x, M, b, w) {
    w === !0 ? i.vertexAttribIPointer(y, g, _, M, b) : i.vertexAttribPointer(y, g, _, x, M, b);
  }
  function v() {
    m(), a = !0, s !== r && (s = r, o(s.object));
  }
  function m() {
    r.geometry = null, r.program = null, r.wireframe = !1;
  }
  return { setup: function(y, g, _, x, M) {
    let b = !1;
    const w = function(T, A, L) {
      const I = L.wireframe === !0;
      let P = n[T.id];
      P === void 0 && (P = {}, n[T.id] = P);
      let N = P[A.id];
      N === void 0 && (N = {}, P[A.id] = N);
      let F = N[I];
      return F === void 0 && (F = c(i.createVertexArray()), N[I] = F), F;
    }(x, _, g);
    s !== w && (s = w, o(s.object)), b = function(T, A, L, I) {
      const P = s.attributes, N = A.attributes;
      let F = 0;
      const z = L.getAttributes();
      for (const q in z)
        if (z[q].location >= 0) {
          const re = P[q];
          let ie = N[q];
          if (ie === void 0 && (q === "instanceMatrix" && T.instanceMatrix && (ie = T.instanceMatrix), q === "instanceColor" && T.instanceColor && (ie = T.instanceColor)), re === void 0 || re.attribute !== ie || ie && re.data !== ie.data)
            return !0;
          F++;
        }
      return s.attributesNum !== F || s.index !== I;
    }(y, x, _, M), b && function(T, A, L, I) {
      const P = {}, N = A.attributes;
      let F = 0;
      const z = L.getAttributes();
      for (const q in z)
        if (z[q].location >= 0) {
          let re = N[q];
          re === void 0 && (q === "instanceMatrix" && T.instanceMatrix && (re = T.instanceMatrix), q === "instanceColor" && T.instanceColor && (re = T.instanceColor));
          const ie = {};
          ie.attribute = re, re && re.data && (ie.data = re.data), P[q] = ie, F++;
        }
      s.attributes = P, s.attributesNum = F, s.index = I;
    }(y, x, _, M), M !== null && e.update(M, i.ELEMENT_ARRAY_BUFFER), (b || a) && (a = !1, function(T, A, L, I) {
      h();
      const P = I.attributes, N = L.getAttributes(), F = A.defaultAttributeValues;
      for (const z in N) {
        const q = N[z];
        if (q.location >= 0) {
          let re = P[z];
          if (re === void 0 && (z === "instanceMatrix" && T.instanceMatrix && (re = T.instanceMatrix), z === "instanceColor" && T.instanceColor && (re = T.instanceColor)), re !== void 0) {
            const ie = re.normalized, me = re.itemSize, Se = e.get(re);
            if (Se === void 0)
              continue;
            const te = Se.buffer, se = Se.type, he = Se.bytesPerElement, ae = se === i.INT || se === i.UNSIGNED_INT || re.gpuType === o1;
            if (re.isInterleavedBufferAttribute) {
              const D = re.data, R = D.stride, X = re.offset;
              if (D.isInstancedInterleavedBuffer) {
                for (let Q = 0; Q < q.locationSize; Q++)
                  d(q.location + Q, D.meshPerAttribute);
                T.isInstancedMesh !== !0 && I._maxInstanceCount === void 0 && (I._maxInstanceCount = D.meshPerAttribute * D.count);
              } else
                for (let Q = 0; Q < q.locationSize; Q++)
                  u(q.location + Q);
              i.bindBuffer(i.ARRAY_BUFFER, te);
              for (let Q = 0; Q < q.locationSize; Q++)
                f(q.location + Q, me / q.locationSize, se, ie, R * he, (X + me / q.locationSize * Q) * he, ae);
            } else {
              if (re.isInstancedBufferAttribute) {
                for (let D = 0; D < q.locationSize; D++)
                  d(q.location + D, re.meshPerAttribute);
                T.isInstancedMesh !== !0 && I._maxInstanceCount === void 0 && (I._maxInstanceCount = re.meshPerAttribute * re.count);
              } else
                for (let D = 0; D < q.locationSize; D++)
                  u(q.location + D);
              i.bindBuffer(i.ARRAY_BUFFER, te);
              for (let D = 0; D < q.locationSize; D++)
                f(q.location + D, me / q.locationSize, se, ie, me * he, me / q.locationSize * D * he, ae);
            }
          } else if (F !== void 0) {
            const ie = F[z];
            if (ie !== void 0)
              switch (ie.length) {
                case 2:
                  i.vertexAttrib2fv(q.location, ie);
                  break;
                case 3:
                  i.vertexAttrib3fv(q.location, ie);
                  break;
                case 4:
                  i.vertexAttrib4fv(q.location, ie);
                  break;
                default:
                  i.vertexAttrib1fv(q.location, ie);
              }
          }
        }
      }
      p();
    }(y, g, _, x), M !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(M).buffer));
  }, reset: v, resetDefaultState: m, dispose: function() {
    v();
    for (const y in n) {
      const g = n[y];
      for (const _ in g) {
        const x = g[_];
        for (const M in x)
          l(x[M].object), delete x[M];
        delete g[_];
      }
      delete n[y];
    }
  }, releaseStatesOfGeometry: function(y) {
    if (n[y.id] === void 0)
      return;
    const g = n[y.id];
    for (const _ in g) {
      const x = g[_];
      for (const M in x)
        l(x[M].object), delete x[M];
      delete g[_];
    }
    delete n[y.id];
  }, releaseStatesOfProgram: function(y) {
    for (const g in n) {
      const _ = n[g];
      if (_[y.id] === void 0)
        continue;
      const x = _[y.id];
      for (const M in x)
        l(x[M].object), delete x[M];
      delete _[y.id];
    }
  }, initAttributes: h, enableAttribute: u, disableUnusedAttributes: p };
}
function WT(i, e, t) {
  let n;
  function r(s, a, o) {
    o !== 0 && (i.drawArraysInstanced(n, s, a, o), t.update(a, n, o));
  }
  this.setMode = function(s) {
    n = s;
  }, this.render = function(s, a) {
    i.drawArrays(n, s, a), t.update(a, n, 1);
  }, this.renderInstances = r, this.renderMultiDraw = function(s, a, o) {
    if (o === 0)
      return;
    const l = e.get("WEBGL_multi_draw");
    if (l === null)
      for (let c = 0; c < o; c++)
        this.render(s[c], a[c]);
    else {
      l.multiDrawArraysWEBGL(n, s, 0, a, 0, o);
      let c = 0;
      for (let h = 0; h < o; h++)
        c += a[h];
      t.update(c, n, 1);
    }
  }, this.renderMultiDrawInstances = function(s, a, o, l) {
    if (o === 0)
      return;
    const c = e.get("WEBGL_multi_draw");
    if (c === null)
      for (let h = 0; h < s.length; h++)
        r(s[h], a[h], l[h]);
    else {
      c.multiDrawArraysInstancedWEBGL(n, s, 0, a, 0, l, 0, o);
      let h = 0;
      for (let u = 0; u < o; u++)
        h += a[u];
      for (let u = 0; u < l.length; u++)
        t.update(h, n, l[u]);
    }
  };
}
function XT(i, e, t, n) {
  let r;
  function s(u) {
    if (u === "highp") {
      if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0)
        return "highp";
      u = "mediump";
    }
    return u === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let a = t.precision !== void 0 ? t.precision : "highp";
  const o = s(a);
  o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
  const l = t.logarithmicDepthBuffer === !0, c = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), h = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  return { isWebGL2: !0, getMaxAnisotropy: function() {
    if (r !== void 0)
      return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const u = e.get("EXT_texture_filter_anisotropic");
      r = i.getParameter(u.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }, getMaxPrecision: s, textureFormatReadable: function(u) {
    return u === ai || n.convert(u) === i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT);
  }, textureTypeReadable: function(u) {
    const d = u === Vt && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(u !== fs && n.convert(u) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) && u !== si && !d);
  }, precision: a, logarithmicDepthBuffer: l, maxTextures: c, maxVertexTextures: h, maxTextureSize: i.getParameter(i.MAX_TEXTURE_SIZE), maxCubemapSize: i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE), maxAttributes: i.getParameter(i.MAX_VERTEX_ATTRIBS), maxVertexUniforms: i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS), maxVaryings: i.getParameter(i.MAX_VARYING_VECTORS), maxFragmentUniforms: i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures: h > 0, maxSamples: i.getParameter(i.MAX_SAMPLES) };
}
function qT(i) {
  const e = this;
  let t = null, n = 0, r = !1, s = !1;
  const a = new Fi(), o = new Ue(), l = { value: null, needsUpdate: !1 };
  function c(h, u, d, p) {
    const f = h !== null ? h.length : 0;
    let v = null;
    if (f !== 0) {
      if (v = l.value, p !== !0 || v === null) {
        const m = d + 4 * f, y = u.matrixWorldInverse;
        o.getNormalMatrix(y), (v === null || v.length < m) && (v = new Float32Array(m));
        for (let g = 0, _ = d; g !== f; ++g, _ += 4)
          a.copy(h[g]).applyMatrix4(y, o), a.normal.toArray(v, _), v[_ + 3] = a.constant;
      }
      l.value = v, l.needsUpdate = !0;
    }
    return e.numPlanes = f, e.numIntersection = 0, v;
  }
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, u) {
    const d = h.length !== 0 || u || n !== 0 || r;
    return r = u, n = h.length, d;
  }, this.beginShadows = function() {
    s = !0, c(null);
  }, this.endShadows = function() {
    s = !1;
  }, this.setGlobalState = function(h, u) {
    t = c(h, u, 0);
  }, this.setState = function(h, u, d) {
    const p = h.clippingPlanes, f = h.clipIntersection, v = h.clipShadows, m = i.get(h);
    if (!r || p === null || p.length === 0 || s && !v)
      s ? c(null) : function() {
        l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
      }();
    else {
      const y = s ? 0 : n, g = 4 * y;
      let _ = m.clippingState || null;
      l.value = _, _ = c(p, u, g, d);
      for (let x = 0; x !== g; ++x)
        _[x] = t[x];
      m.clippingState = _, this.numIntersection = f ? this.numPlanes : 0, this.numPlanes += y;
    }
  };
}
function YT(i) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(r, s) {
    return s === ol ? r.mapping = Fr : s === Kc && (r.mapping = ys), r;
  }
  function n(r) {
    const s = r.target;
    s.removeEventListener("dispose", n);
    const a = e.get(s);
    a !== void 0 && (e.delete(s), a.dispose());
  }
  return { get: function(r) {
    if (r && r.isTexture) {
      const s = r.mapping;
      if (s === ol || s === Kc) {
        if (e.has(r))
          return t(e.get(r).texture, r.mapping);
        {
          const a = r.image;
          if (a && a.height > 0) {
            const o = new VM(a.height);
            return o.fromEquirectangularTexture(i, r), e.set(r, o), r.addEventListener("dispose", n), t(o.texture, r.mapping);
          }
          return null;
        }
      }
    }
    return r;
  }, dispose: function() {
    e = /* @__PURE__ */ new WeakMap();
  } };
}
class Ha extends qp {
  constructor(e = -1, t = 1, n = 1, r = -1, s = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = s, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, r, s, a) {
    this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = n - e, a = n + e, o = r + t, l = r - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += c * this.view.offsetX, a = s + c * this.view.width, o -= h * this.view.offsetY, l = o - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Qx = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], $l = 20, hm = new Ha(), Jx = new ce();
let um = null, dm = 0, pm = 0, fm = !1;
const sa = (1 + Math.sqrt(5)) / 2, vo = 1 / sa, $x = [new S(-sa, vo, 0), new S(sa, vo, 0), new S(-vo, 0, sa), new S(vo, 0, sa), new S(0, sa, -vo), new S(0, sa, vo), new S(-1, 1, -1), new S(1, 1, -1), new S(-1, 1, 1), new S(1, 1, 1)];
class c0 {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, r = 100) {
    um = this._renderer.getRenderTarget(), dm = this._renderer.getActiveCubeFace(), pm = this._renderer.getActiveMipmapLevel(), fm = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(e, n, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = n2(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = t2(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(um, dm, pm), this._renderer.xr.enabled = fm, e.scissorTest = !1, Vu(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Fr || e.mapping === ys ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), um = this._renderer.getRenderTarget(), dm = this._renderer.getActiveCubeFace(), pm = this._renderer.getActiveMipmapLevel(), fm = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = { magFilter: Gt, minFilter: Gt, generateMipmaps: !1, type: Vt, format: ai, colorSpace: on, depthBuffer: !1 }, r = e2(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = e2(e, t, n);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function(a) {
        const o = [], l = [], c = [];
        let h = a;
        const u = a - 4 + 1 + Qx.length;
        for (let d = 0; d < u; d++) {
          const p = Math.pow(2, h);
          l.push(p);
          let f = 1 / p;
          d > a - 4 ? f = Qx[d - a + 4 - 1] : d === 0 && (f = 0), c.push(f);
          const v = 1 / (p - 2), m = -v, y = 1 + v, g = [m, m, y, m, y, y, m, m, y, y, m, y], _ = 6, x = 6, M = 3, b = 2, w = 1, T = new Float32Array(M * x * _), A = new Float32Array(b * x * _), L = new Float32Array(w * x * _);
          for (let P = 0; P < _; P++) {
            const N = P % 3 * 2 / 3 - 1, F = P > 2 ? 0 : -1, z = [N, F, 0, N + 2 / 3, F, 0, N + 2 / 3, F + 1, 0, N, F, 0, N + 2 / 3, F + 1, 0, N, F + 1, 0];
            T.set(z, M * x * P), A.set(g, b * x * P);
            const q = [P, P, P, P, P, P];
            L.set(q, w * x * P);
          }
          const I = new Re();
          I.setAttribute("position", new it(T, M)), I.setAttribute("uv", new it(A, b)), I.setAttribute("faceIndex", new it(L, w)), o.push(I), h > 4 && h--;
        }
        return { lodPlanes: o, sizeLods: l, sigmas: c };
      }(s)), this._blurMaterial = function(a, o, l) {
        const c = new Float32Array($l), h = new S(0, 1, 0);
        return new st({ name: "SphericalGaussianBlur", defines: { n: $l, CUBEUV_TEXEL_WIDTH: 1 / o, CUBEUV_TEXEL_HEIGHT: 1 / l, CUBEUV_MAX_MIP: `${a}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: c }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: h } }, vertexShader: f1(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: 0, depthTest: !1, depthWrite: !1 });
      }(s, e, t);
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new ve(this._lodPlanes[0], e);
    this._renderer.compile(t, hm);
  }
  _sceneToCubeUV(e, t, n, r) {
    const s = new jt(90, 1, t, n), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], l = this._renderer, c = l.autoClear, h = l.toneMapping;
    l.getClearColor(Jx), l.toneMapping = Pr, l.autoClear = !1;
    const u = new nn({ name: "PMREM.Background", side: kn, depthWrite: !1, depthTest: !1 }), d = new ve(new Pt(), u);
    let p = !1;
    const f = e.background;
    f ? f.isColor && (u.color.copy(f), e.background = null, p = !0) : (u.color.copy(Jx), p = !0);
    for (let v = 0; v < 6; v++) {
      const m = v % 3;
      m === 0 ? (s.up.set(0, a[v], 0), s.lookAt(o[v], 0, 0)) : m === 1 ? (s.up.set(0, 0, a[v]), s.lookAt(0, o[v], 0)) : (s.up.set(0, a[v], 0), s.lookAt(0, 0, o[v]));
      const y = this._cubeSize;
      Vu(r, m * y, v > 2 ? y : 0, y, y), l.setRenderTarget(r), p && l.render(d, s), l.render(e, s);
    }
    d.geometry.dispose(), d.material.dispose(), l.toneMapping = h, l.autoClear = c, e.background = f;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, r = e.mapping === Fr || e.mapping === ys;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = n2()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = t2());
    const s = r ? this._cubemapMaterial : this._equirectMaterial, a = new ve(this._lodPlanes[0], s);
    s.uniforms.envMap.value = e;
    const o = this._cubeSize;
    Vu(t, 0, 0, 3 * o, 2 * o), n.setRenderTarget(t), n.render(a, hm);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    const r = this._lodPlanes.length;
    for (let s = 1; s < r; s++) {
      const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), o = $x[(r - s - 1) % $x.length];
      this._blur(e, s - 1, s, a, o);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, r, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, t, n, r, "latitudinal", s), this._halfBlur(a, e, n, n, r, "longitudinal", s);
  }
  _halfBlur(e, t, n, r, s, a, o) {
    const l = this._renderer, c = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const h = new ve(this._lodPlanes[r], c), u = c.uniforms, d = this._sizeLods[n] - 1, p = isFinite(s) ? Math.PI / (2 * d) : 2 * Math.PI / 39, f = s / p, v = isFinite(s) ? 1 + Math.floor(3 * f) : $l;
    v > $l && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${v} samples when the maximum is set to 20`);
    const m = [];
    let y = 0;
    for (let x = 0; x < $l; ++x) {
      const M = x / f, b = Math.exp(-M * M / 2);
      m.push(b), x === 0 ? y += b : x < v && (y += 2 * b);
    }
    for (let x = 0; x < m.length; x++)
      m[x] = m[x] / y;
    u.envMap.value = e.texture, u.samples.value = v, u.weights.value = m, u.latitudinal.value = a === "latitudinal", o && (u.poleAxis.value = o);
    const { _lodMax: g } = this;
    u.dTheta.value = p, u.mipInt.value = g - n;
    const _ = this._sizeLods[r];
    Vu(t, 3 * _ * (r > g - 4 ? r - g + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _), l.setRenderTarget(t), l.render(h, hm);
  }
}
function e2(i, e, t) {
  const n = new dt(i, e, t);
  return n.texture.mapping = Il, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Vu(i, e, t, n, r) {
  i.viewport.set(e, t, n, r), i.scissor.set(e, t, n, r);
}
function t2() {
  return new st({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: f1(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1 });
}
function n2() {
  return new st({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: f1(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1 });
}
function f1() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function ZT(i) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(r) {
    const s = r.target;
    s.removeEventListener("dispose", n);
    const a = e.get(s);
    a !== void 0 && (e.delete(s), a.dispose());
  }
  return { get: function(r) {
    if (r && r.isTexture) {
      const s = r.mapping, a = s === ol || s === Kc, o = s === Fr || s === ys;
      if (a || o) {
        let l = e.get(r);
        const c = l !== void 0 ? l.texture.pmremVersion : 0;
        if (r.isRenderTargetTexture && r.pmremVersion !== c)
          return t === null && (t = new c0(i)), l = a ? t.fromEquirectangular(r, l) : t.fromCubemap(r, l), l.texture.pmremVersion = r.pmremVersion, e.set(r, l), l.texture;
        if (l !== void 0)
          return l.texture;
        {
          const h = r.image;
          return a && h && h.height > 0 || o && h && function(u) {
            let d = 0;
            const p = 6;
            for (let f = 0; f < p; f++)
              u[f] !== void 0 && d++;
            return d === p;
          }(h) ? (t === null && (t = new c0(i)), l = a ? t.fromEquirectangular(r) : t.fromCubemap(r), l.texture.pmremVersion = r.pmremVersion, e.set(r, l), r.addEventListener("dispose", n), l.texture) : null;
        }
      }
    }
    return r;
  }, dispose: function() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  } };
}
function KT(i) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let r;
    switch (n) {
      case "WEBGL_depth_texture":
        r = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = i.getExtension(n);
    }
    return e[n] = r, r;
  }
  return { has: function(n) {
    return t(n) !== null;
  }, init: function() {
    t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
  }, get: function(n) {
    const r = t(n);
    return r === null && d1("THREE.WebGLRenderer: " + n + " extension not supported."), r;
  } };
}
function QT(i, e, t, n) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function a(l) {
    const c = l.target;
    c.index !== null && e.remove(c.index);
    for (const u in c.attributes)
      e.remove(c.attributes[u]);
    for (const u in c.morphAttributes) {
      const d = c.morphAttributes[u];
      for (let p = 0, f = d.length; p < f; p++)
        e.remove(d[p]);
    }
    c.removeEventListener("dispose", a), delete r[c.id];
    const h = s.get(c);
    h && (e.remove(h), s.delete(c)), n.releaseStatesOfGeometry(c), c.isInstancedBufferGeometry === !0 && delete c._maxInstanceCount, t.memory.geometries--;
  }
  function o(l) {
    const c = [], h = l.index, u = l.attributes.position;
    let d = 0;
    if (h !== null) {
      const v = h.array;
      d = h.version;
      for (let m = 0, y = v.length; m < y; m += 3) {
        const g = v[m + 0], _ = v[m + 1], x = v[m + 2];
        c.push(g, _, _, x, x, g);
      }
    } else {
      if (u === void 0)
        return;
      {
        const v = u.array;
        d = u.version;
        for (let m = 0, y = v.length / 3 - 1; m < y; m += 3) {
          const g = m + 0, _ = m + 1, x = m + 2;
          c.push(g, _, _, x, x, g);
        }
      }
    }
    const p = new (kM(c) ? p1 : Xp)(c, 1);
    p.version = d;
    const f = s.get(l);
    f && e.remove(f), s.set(l, p);
  }
  return { get: function(l, c) {
    return r[c.id] === !0 || (c.addEventListener("dispose", a), r[c.id] = !0, t.memory.geometries++), c;
  }, update: function(l) {
    const c = l.attributes;
    for (const u in c)
      e.update(c[u], i.ARRAY_BUFFER);
    const h = l.morphAttributes;
    for (const u in h) {
      const d = h[u];
      for (let p = 0, f = d.length; p < f; p++)
        e.update(d[p], i.ARRAY_BUFFER);
    }
  }, getWireframeAttribute: function(l) {
    const c = s.get(l);
    if (c) {
      const h = l.index;
      h !== null && c.version < h.version && o(l);
    } else
      o(l);
    return s.get(l);
  } };
}
function JT(i, e, t) {
  let n, r, s;
  function a(o, l, c) {
    c !== 0 && (i.drawElementsInstanced(n, l, r, o * s, c), t.update(l, n, c));
  }
  this.setMode = function(o) {
    n = o;
  }, this.setIndex = function(o) {
    r = o.type, s = o.bytesPerElement;
  }, this.render = function(o, l) {
    i.drawElements(n, l, r, o * s), t.update(l, n, 1);
  }, this.renderInstances = a, this.renderMultiDraw = function(o, l, c) {
    if (c === 0)
      return;
    const h = e.get("WEBGL_multi_draw");
    if (h === null)
      for (let u = 0; u < c; u++)
        this.render(o[u] / s, l[u]);
    else {
      h.multiDrawElementsWEBGL(n, l, 0, r, o, 0, c);
      let u = 0;
      for (let d = 0; d < c; d++)
        u += l[d];
      t.update(u, n, 1);
    }
  }, this.renderMultiDrawInstances = function(o, l, c, h) {
    if (c === 0)
      return;
    const u = e.get("WEBGL_multi_draw");
    if (u === null)
      for (let d = 0; d < o.length; d++)
        a(o[d] / s, l[d], h[d]);
    else {
      u.multiDrawElementsInstancedWEBGL(n, l, 0, r, o, 0, h, 0, c);
      let d = 0;
      for (let p = 0; p < c; p++)
        d += l[p];
      for (let p = 0; p < h.length; p++)
        t.update(d, n, h[p]);
    }
  };
}
function $T(i) {
  const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function() {
    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
  }, update: function(t, n, r) {
    switch (e.calls++, n) {
      case i.TRIANGLES:
        e.triangles += r * (t / 3);
        break;
      case i.LINES:
        e.lines += r * (t / 2);
        break;
      case i.LINE_STRIP:
        e.lines += r * (t - 1);
        break;
      case i.LINE_LOOP:
        e.lines += r * t;
        break;
      case i.POINTS:
        e.points += r * t;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", n);
    }
  } };
}
function eE(i, e, t) {
  const n = /* @__PURE__ */ new WeakMap(), r = new je();
  return { update: function(s, a, o) {
    const l = s.morphTargetInfluences, c = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, h = c !== void 0 ? c.length : 0;
    let u = n.get(a);
    if (u === void 0 || u.count !== h) {
      u !== void 0 && u.texture.dispose();
      const d = a.morphAttributes.position !== void 0, p = a.morphAttributes.normal !== void 0, f = a.morphAttributes.color !== void 0, v = a.morphAttributes.position || [], m = a.morphAttributes.normal || [], y = a.morphAttributes.color || [];
      let g = 0;
      d === !0 && (g = 1), p === !0 && (g = 2), f === !0 && (g = 3);
      let _ = a.attributes.position.count * g, x = 1;
      _ > e.maxTextureSize && (x = Math.ceil(_ / e.maxTextureSize), _ = e.maxTextureSize);
      const M = new Float32Array(_ * x * 4 * h), b = new lp(M, _, x, h);
      b.type = si, b.needsUpdate = !0;
      const w = 4 * g;
      for (let T = 0; T < h; T++) {
        const A = v[T], L = m[T], I = y[T], P = _ * x * 4 * T;
        for (let N = 0; N < A.count; N++) {
          const F = N * w;
          d === !0 && (r.fromBufferAttribute(A, N), M[P + F + 0] = r.x, M[P + F + 1] = r.y, M[P + F + 2] = r.z, M[P + F + 3] = 0), p === !0 && (r.fromBufferAttribute(L, N), M[P + F + 4] = r.x, M[P + F + 5] = r.y, M[P + F + 6] = r.z, M[P + F + 7] = 0), f === !0 && (r.fromBufferAttribute(I, N), M[P + F + 8] = r.x, M[P + F + 9] = r.y, M[P + F + 10] = r.z, M[P + F + 11] = I.itemSize === 4 ? r.w : 1);
        }
      }
      u = { count: h, texture: b, size: new Y(_, x) }, n.set(a, u), a.addEventListener("dispose", function T() {
        b.dispose(), n.delete(a), a.removeEventListener("dispose", T);
      });
    }
    if (s.isInstancedMesh === !0 && s.morphTexture !== null)
      o.getUniforms().setValue(i, "morphTexture", s.morphTexture, t);
    else {
      let d = 0;
      for (let f = 0; f < l.length; f++)
        d += l[f];
      const p = a.morphTargetsRelative ? 1 : 1 - d;
      o.getUniforms().setValue(i, "morphTargetBaseInfluence", p), o.getUniforms().setValue(i, "morphTargetInfluences", l);
    }
    o.getUniforms().setValue(i, "morphTargetsTexture", u.texture, t), o.getUniforms().setValue(i, "morphTargetsTextureSize", u.size);
  } };
}
function tE(i, e, t, n) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(a) {
    const o = a.target;
    o.removeEventListener("dispose", s), t.remove(o.instanceMatrix), o.instanceColor !== null && t.remove(o.instanceColor);
  }
  return { update: function(a) {
    const o = n.render.frame, l = a.geometry, c = e.get(a, l);
    if (r.get(c) !== o && (e.update(c), r.set(c, o)), a.isInstancedMesh && (a.hasEventListener("dispose", s) === !1 && a.addEventListener("dispose", s), r.get(a) !== o && (t.update(a.instanceMatrix, i.ARRAY_BUFFER), a.instanceColor !== null && t.update(a.instanceColor, i.ARRAY_BUFFER), r.set(a, o))), a.isSkinnedMesh) {
      const h = a.skeleton;
      r.get(h) !== o && (h.update(), r.set(h, o));
    }
    return c;
  }, dispose: function() {
    r = /* @__PURE__ */ new WeakMap();
  } };
}
class Bh extends vt {
  constructor(e, t, n, r, s, a, o, l, c, h = 1026) {
    if (h !== cl && h !== xs)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && h === cl && (n = Ba), n === void 0 && h === xs && (n = _s), super(null, r, s, a, o, l, h, n, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = o !== void 0 ? o : lt, this.minFilter = l !== void 0 ? l : lt, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const WM = new vt(), XM = new Bh(1, 1);
XM.compareFunction = 515;
const qM = new lp(), YM = new l0(), ZM = new kc(), i2 = [], r2 = [], s2 = new Float32Array(16), a2 = new Float32Array(9), o2 = new Float32Array(4);
function Cl(i, e, t) {
  const n = i[0];
  if (n <= 0 || n > 0)
    return i;
  const r = e * t;
  let s = i2[r];
  if (s === void 0 && (s = new Float32Array(r), i2[r] = s), e !== 0) {
    n.toArray(s, 0);
    for (let a = 1, o = 0; a !== e; ++a)
      o += t, i[a].toArray(s, o);
  }
  return s;
}
function ln(i, e) {
  if (i.length !== e.length)
    return !1;
  for (let t = 0, n = i.length; t < n; t++)
    if (i[t] !== e[t])
      return !1;
  return !0;
}
function cn(i, e) {
  for (let t = 0, n = e.length; t < n; t++)
    i[t] = e[t];
}
function Yp(i, e) {
  let t = r2[e];
  t === void 0 && (t = new Int32Array(e), r2[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = i.allocateTextureUnit();
  return t;
}
function nE(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e);
}
function iE(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y || (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (ln(t, e))
      return;
    i.uniform2fv(this.addr, e), cn(t, e);
  }
}
function rE(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z || (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    t[0] === e.r && t[1] === e.g && t[2] === e.b || (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (ln(t, e))
      return;
    i.uniform3fv(this.addr, e), cn(t, e);
  }
}
function sE(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z && t[3] === e.w || (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (ln(t, e))
      return;
    i.uniform4fv(this.addr, e), cn(t, e);
  }
}
function aE(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (ln(t, e))
      return;
    i.uniformMatrix2fv(this.addr, !1, e), cn(t, e);
  } else {
    if (ln(t, n))
      return;
    o2.set(n), i.uniformMatrix2fv(this.addr, !1, o2), cn(t, n);
  }
}
function oE(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (ln(t, e))
      return;
    i.uniformMatrix3fv(this.addr, !1, e), cn(t, e);
  } else {
    if (ln(t, n))
      return;
    a2.set(n), i.uniformMatrix3fv(this.addr, !1, a2), cn(t, n);
  }
}
function lE(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (ln(t, e))
      return;
    i.uniformMatrix4fv(this.addr, !1, e), cn(t, e);
  } else {
    if (ln(t, n))
      return;
    s2.set(n), i.uniformMatrix4fv(this.addr, !1, s2), cn(t, n);
  }
}
function cE(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e);
}
function hE(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y || (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (ln(t, e))
      return;
    i.uniform2iv(this.addr, e), cn(t, e);
  }
}
function uE(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z || (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (ln(t, e))
      return;
    i.uniform3iv(this.addr, e), cn(t, e);
  }
}
function dE(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z && t[3] === e.w || (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (ln(t, e))
      return;
    i.uniform4iv(this.addr, e), cn(t, e);
  }
}
function pE(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e);
}
function fE(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y || (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (ln(t, e))
      return;
    i.uniform2uiv(this.addr, e), cn(t, e);
  }
}
function mE(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z || (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (ln(t, e))
      return;
    i.uniform3uiv(this.addr, e), cn(t, e);
  }
}
function gE(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z && t[3] === e.w || (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (ln(t, e))
      return;
    i.uniform4uiv(this.addr, e), cn(t, e);
  }
}
function vE(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r);
  const s = this.type === i.SAMPLER_2D_SHADOW ? XM : WM;
  t.setTexture2D(e || s, r);
}
function yE(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture3D(e || YM, r);
}
function _E(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTextureCube(e || ZM, r);
}
function xE(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture2DArray(e || qM, r);
}
function bE(i, e) {
  i.uniform1fv(this.addr, e);
}
function ME(i, e) {
  const t = Cl(e, this.size, 2);
  i.uniform2fv(this.addr, t);
}
function wE(i, e) {
  const t = Cl(e, this.size, 3);
  i.uniform3fv(this.addr, t);
}
function SE(i, e) {
  const t = Cl(e, this.size, 4);
  i.uniform4fv(this.addr, t);
}
function TE(i, e) {
  const t = Cl(e, this.size, 4);
  i.uniformMatrix2fv(this.addr, !1, t);
}
function EE(i, e) {
  const t = Cl(e, this.size, 9);
  i.uniformMatrix3fv(this.addr, !1, t);
}
function AE(i, e) {
  const t = Cl(e, this.size, 16);
  i.uniformMatrix4fv(this.addr, !1, t);
}
function IE(i, e) {
  i.uniform1iv(this.addr, e);
}
function CE(i, e) {
  i.uniform2iv(this.addr, e);
}
function RE(i, e) {
  i.uniform3iv(this.addr, e);
}
function PE(i, e) {
  i.uniform4iv(this.addr, e);
}
function LE(i, e) {
  i.uniform1uiv(this.addr, e);
}
function DE(i, e) {
  i.uniform2uiv(this.addr, e);
}
function NE(i, e) {
  i.uniform3uiv(this.addr, e);
}
function OE(i, e) {
  i.uniform4uiv(this.addr, e);
}
function UE(i, e, t) {
  const n = this.cache, r = e.length, s = Yp(t, r);
  ln(n, s) || (i.uniform1iv(this.addr, s), cn(n, s));
  for (let a = 0; a !== r; ++a)
    t.setTexture2D(e[a] || WM, s[a]);
}
function kE(i, e, t) {
  const n = this.cache, r = e.length, s = Yp(t, r);
  ln(n, s) || (i.uniform1iv(this.addr, s), cn(n, s));
  for (let a = 0; a !== r; ++a)
    t.setTexture3D(e[a] || YM, s[a]);
}
function FE(i, e, t) {
  const n = this.cache, r = e.length, s = Yp(t, r);
  ln(n, s) || (i.uniform1iv(this.addr, s), cn(n, s));
  for (let a = 0; a !== r; ++a)
    t.setTextureCube(e[a] || ZM, s[a]);
}
function BE(i, e, t) {
  const n = this.cache, r = e.length, s = Yp(t, r);
  ln(n, s) || (i.uniform1iv(this.addr, s), cn(n, s));
  for (let a = 0; a !== r; ++a)
    t.setTexture2DArray(e[a] || qM, s[a]);
}
class zE {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = function(r) {
      switch (r) {
        case 5126:
          return nE;
        case 35664:
          return iE;
        case 35665:
          return rE;
        case 35666:
          return sE;
        case 35674:
          return aE;
        case 35675:
          return oE;
        case 35676:
          return lE;
        case 5124:
        case 35670:
          return cE;
        case 35667:
        case 35671:
          return hE;
        case 35668:
        case 35672:
          return uE;
        case 35669:
        case 35673:
          return dE;
        case 5125:
          return pE;
        case 36294:
          return fE;
        case 36295:
          return mE;
        case 36296:
          return gE;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return vE;
        case 35679:
        case 36299:
        case 36307:
          return yE;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return _E;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return xE;
      }
    }(t.type);
  }
}
class HE {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function(r) {
      switch (r) {
        case 5126:
          return bE;
        case 35664:
          return ME;
        case 35665:
          return wE;
        case 35666:
          return SE;
        case 35674:
          return TE;
        case 35675:
          return EE;
        case 35676:
          return AE;
        case 5124:
        case 35670:
          return IE;
        case 35667:
        case 35671:
          return CE;
        case 35668:
        case 35672:
          return RE;
        case 35669:
        case 35673:
          return PE;
        case 5125:
          return LE;
        case 36294:
          return DE;
        case 36295:
          return NE;
        case 36296:
          return OE;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return UE;
        case 35679:
        case 36299:
        case 36307:
          return kE;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return FE;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return BE;
      }
    }(t.type);
  }
}
class GE {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const r = this.seq;
    for (let s = 0, a = r.length; s !== a; ++s) {
      const o = r[s];
      o.setValue(e, t[o.id], n);
    }
  }
}
const mm = /(\w+)(\])?(\[|\.)?/g;
function l2(i, e) {
  i.seq.push(e), i.map[e.id] = e;
}
function VE(i, e, t) {
  const n = i.name, r = n.length;
  for (mm.lastIndex = 0; ; ) {
    const s = mm.exec(n), a = mm.lastIndex;
    let o = s[1];
    const l = s[2] === "]", c = s[3];
    if (l && (o |= 0), c === void 0 || c === "[" && a + 2 === r) {
      l2(t, c === void 0 ? new zE(o, i, e) : new HE(o, i, e));
      break;
    }
    {
      let h = t.map[o];
      h === void 0 && (h = new GE(o), l2(t, h)), t = h;
    }
  }
}
class Yd {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < n; ++r) {
      const s = e.getActiveUniform(t, r);
      VE(s, e.getUniformLocation(t, s.name), this);
    }
  }
  setValue(e, t, n, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, r);
  }
  setOptional(e, t, n) {
    const r = t[n];
    r !== void 0 && this.setValue(e, n, r);
  }
  static upload(e, t, n, r) {
    for (let s = 0, a = t.length; s !== a; ++s) {
      const o = t[s], l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const a = e[r];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function c2(i, e, t) {
  const n = i.createShader(e);
  return i.shaderSource(n, t), i.compileShader(n), n;
}
const jE = 37297;
let WE = 0;
function h2(i, e, t) {
  const n = i.getShaderParameter(e, i.COMPILE_STATUS), r = i.getShaderInfoLog(e).trim();
  if (n && r === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const a = parseInt(s[1]);
    return t.toUpperCase() + `

` + r + `

` + function(o, l) {
      const c = o.split(`
`), h = [], u = Math.max(l - 6, 0), d = Math.min(l + 6, c.length);
      for (let p = u; p < d; p++) {
        const f = p + 1;
        h.push(`${f === l ? ">" : " "} ${f}: ${c[p]}`);
      }
      return h.join(`
`);
    }(i.getShaderSource(e), a);
  }
  return r;
}
function XE(i, e) {
  const t = function(n) {
    const r = rt.getPrimaries(rt.workingColorSpace), s = rt.getPrimaries(n);
    let a;
    switch (r === s ? a = "" : r === th && s === eh ? a = "LinearDisplayP3ToLinearSRGB" : r === eh && s === th && (a = "LinearSRGBToLinearDisplayP3"), n) {
      case on:
      case Jc:
        return [a, "LinearTransferOETF"];
      case yt:
      case op:
        return [a, "sRGBTransferOETF"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", n), [a, "LinearTransferOETF"];
    }
  }(e);
  return `vec4 ${i}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function qE(i, e) {
  let t;
  switch (e) {
    case t1:
      t = "Linear";
      break;
    case n1:
      t = "Reinhard";
      break;
    case i1:
      t = "OptimizedCineon";
      break;
    case r1:
      t = "ACESFilmic";
      break;
    case s1:
      t = "AgX";
      break;
    case a1:
      t = "Neutral";
      break;
    case OM:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function ec(i) {
  return i !== "";
}
function u2(i, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function d2(i, e) {
  return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const YE = /^[ \t]*#include +<([\w\d./]+)>/gm;
function h0(i) {
  return i.replace(YE, KE);
}
const ZE = /* @__PURE__ */ new Map();
function KE(i, e) {
  let t = Ge[e];
  if (t === void 0) {
    const n = ZE.get(e);
    if (n === void 0)
      throw new Error("Can not resolve #include <" + e + ">");
    t = Ge[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
  }
  return h0(t);
}
const QE = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function p2(i) {
  return i.replace(QE, JE);
}
function JE(i, e, t, n) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function f2(i) {
  let e = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
  return i.precision === "highp" ? e += `
#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function $E(i, e, t, n) {
  const r = i.getContext(), s = t.defines;
  let a = t.vertexShader, o = t.fragmentShader;
  const l = function(I) {
    let P = "SHADOWMAP_TYPE_BASIC";
    return I.shadowMapType === J0 ? P = "SHADOWMAP_TYPE_PCF" : I.shadowMapType === $0 ? P = "SHADOWMAP_TYPE_PCF_SOFT" : I.shadowMapType === nr && (P = "SHADOWMAP_TYPE_VSM"), P;
  }(t), c = function(I) {
    let P = "ENVMAP_TYPE_CUBE";
    if (I.envMap)
      switch (I.envMapMode) {
        case Fr:
        case ys:
          P = "ENVMAP_TYPE_CUBE";
          break;
        case Il:
          P = "ENVMAP_TYPE_CUBE_UV";
      }
    return P;
  }(t), h = function(I) {
    let P = "ENVMAP_MODE_REFLECTION";
    return I.envMap && I.envMapMode === ys && (P = "ENVMAP_MODE_REFRACTION"), P;
  }(t), u = function(I) {
    let P = "ENVMAP_BLENDING_NONE";
    if (I.envMap)
      switch (I.combine) {
        case Fh:
          P = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case DM:
          P = "ENVMAP_BLENDING_MIX";
          break;
        case NM:
          P = "ENVMAP_BLENDING_ADD";
      }
    return P;
  }(t), d = function(I) {
    const P = I.envMapCubeUVHeight;
    if (P === null)
      return null;
    const N = Math.log2(P) - 2, F = 1 / P;
    return { texelWidth: 1 / (3 * Math.max(Math.pow(2, N), 112)), texelHeight: F, maxMip: N };
  }(t), p = function(I) {
    return [I.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", I.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(ec).join(`
`);
  }(t), f = function(I) {
    const P = [];
    for (const N in I) {
      const F = I[N];
      F !== !1 && P.push("#define " + N + " " + F);
    }
    return P.join(`
`);
  }(s), v = r.createProgram();
  let m, y, g = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, f].filter(ec).join(`
`), m.length > 0 && (m += `
`), y = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, f].filter(ec).join(`
`), y.length > 0 && (y += `
`)) : (m = [f2(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, f, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(ec).join(`
`), y = [f2(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, f, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Pr ? "#define TONE_MAPPING" : "", t.toneMapping !== Pr ? Ge.tonemapping_pars_fragment : "", t.toneMapping !== Pr ? qE("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Ge.colorspace_pars_fragment, XE("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(ec).join(`
`)), a = h0(a), a = u2(a, t), a = d2(a, t), o = h0(o), o = u2(o, t), o = d2(o, t), a = p2(a), o = p2(o), t.isRawShaderMaterial !== !0 && (g = `#version 300 es
`, m = [p, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + m, y = ["#define varying in", t.glslVersion === a0 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === a0 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + y);
  const _ = g + m + a, x = g + y + o, M = c2(r, r.VERTEX_SHADER, _), b = c2(r, r.FRAGMENT_SHADER, x);
  function w(I) {
    if (i.debug.checkShaderErrors) {
      const P = r.getProgramInfoLog(v).trim(), N = r.getShaderInfoLog(M).trim(), F = r.getShaderInfoLog(b).trim();
      let z = !0, q = !0;
      if (r.getProgramParameter(v, r.LINK_STATUS) === !1)
        if (z = !1, typeof i.debug.onShaderError == "function")
          i.debug.onShaderError(r, v, M, b);
        else {
          const re = h2(r, M, "vertex"), ie = h2(r, b, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, r.VALIDATE_STATUS) + `

Material Name: ` + I.name + `
Material Type: ` + I.type + `

Program Info Log: ` + P + `
` + re + `
` + ie);
        }
      else
        P !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", P) : N !== "" && F !== "" || (q = !1);
      q && (I.diagnostics = { runnable: z, programLog: P, vertexShader: { log: N, prefix: m }, fragmentShader: { log: F, prefix: y } });
    }
    r.deleteShader(M), r.deleteShader(b), T = new Yd(r, v), A = function(P, N) {
      const F = {}, z = P.getProgramParameter(N, P.ACTIVE_ATTRIBUTES);
      for (let q = 0; q < z; q++) {
        const re = P.getActiveAttrib(N, q), ie = re.name;
        let me = 1;
        re.type === P.FLOAT_MAT2 && (me = 2), re.type === P.FLOAT_MAT3 && (me = 3), re.type === P.FLOAT_MAT4 && (me = 4), F[ie] = { type: re.type, location: P.getAttribLocation(N, ie), locationSize: me };
      }
      return F;
    }(r, v);
  }
  let T, A;
  r.attachShader(v, M), r.attachShader(v, b), t.index0AttributeName !== void 0 ? r.bindAttribLocation(v, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(v, 0, "position"), r.linkProgram(v), this.getUniforms = function() {
    return T === void 0 && w(this), T;
  }, this.getAttributes = function() {
    return A === void 0 && w(this), A;
  };
  let L = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return L === !1 && (L = r.getProgramParameter(v, jE)), L;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), r.deleteProgram(v), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = WE++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = M, this.fragmentShader = b, this;
}
let eA = 0;
class tA {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(n), a = this._getShaderCacheForMaterial(e);
    return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new nA(e), t.set(e, n)), n;
  }
}
class nA {
  constructor(e) {
    this.id = eA++, this.code = e, this.usedTimes = 0;
  }
}
function iA(i, e, t, n, r, s, a) {
  const o = new Wp(), l = new tA(), c = /* @__PURE__ */ new Set(), h = [], u = r.logarithmicDepthBuffer, d = r.vertexTextures;
  let p = r.precision;
  const f = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  function v(m) {
    return c.add(m), m === 0 ? "uv" : `uv${m}`;
  }
  return { getParameters: function(m, y, g, _, x) {
    const M = _.fog, b = x.geometry, w = m.isMeshStandardMaterial ? _.environment : null, T = (m.isMeshStandardMaterial ? t : e).get(m.envMap || w), A = T && T.mapping === Il ? T.image.height : null, L = f[m.type];
    m.precision !== null && (p = r.getMaxPrecision(m.precision), p !== m.precision && console.warn("THREE.WebGLProgram.getParameters:", m.precision, "not supported, using", p, "instead."));
    const I = b.morphAttributes.position || b.morphAttributes.normal || b.morphAttributes.color, P = I !== void 0 ? I.length : 0;
    let N, F, z, q, re = 0;
    if (b.morphAttributes.position !== void 0 && (re = 1), b.morphAttributes.normal !== void 0 && (re = 2), b.morphAttributes.color !== void 0 && (re = 3), L) {
      const Xl = Dn[L];
      N = Xl.vertexShader, F = Xl.fragmentShader;
    } else
      N = m.vertexShader, F = m.fragmentShader, l.update(m), z = l.getVertexShaderID(m), q = l.getFragmentShaderID(m);
    const ie = i.getRenderTarget(), me = x.isInstancedMesh === !0, Se = x.isBatchedMesh === !0, te = !!m.map, se = !!m.matcap, he = !!T, ae = !!m.aoMap, D = !!m.lightMap, R = !!m.bumpMap, X = !!m.normalMap, Q = !!m.displacementMap, O = !!m.emissiveMap, k = !!m.metalnessMap, E = !!m.roughnessMap, U = m.anisotropy > 0, B = m.clearcoat > 0, ne = m.dispersion > 0, V = m.iridescence > 0, de = m.sheen > 0, xe = m.transmission > 0, ue = U && !!m.anisotropyMap, H = B && !!m.clearcoatMap, j = B && !!m.clearcoatNormalMap, $ = B && !!m.clearcoatRoughnessMap, be = V && !!m.iridescenceMap, Ne = V && !!m.iridescenceThicknessMap, Be = de && !!m.sheenColorMap, Me = de && !!m.sheenRoughnessMap, Ve = !!m.specularMap, ze = !!m.specularColorMap, Ct = !!m.specularIntensityMap, Ce = xe && !!m.transmissionMap, at = xe && !!m.thicknessMap, Le = !!m.gradientMap, mn = !!m.alphaMap, Ii = m.alphaTest > 0, G = !!m.alphaHash, jl = !!m.extensions;
    let Wl = Pr;
    m.toneMapped && (ie !== null && ie.isXRRenderTarget !== !0 || (Wl = i.toneMapping));
    const wt = { shaderID: L, shaderType: m.type, shaderName: m.name, vertexShader: N, fragmentShader: F, defines: m.defines, customVertexShaderID: z, customFragmentShaderID: q, isRawShaderMaterial: m.isRawShaderMaterial === !0, glslVersion: m.glslVersion, precision: p, batching: Se, batchingColor: Se && x._colorsTexture !== null, instancing: me, instancingColor: me && x.instanceColor !== null, instancingMorph: me && x.morphTexture !== null, supportsVertexTextures: d, outputColorSpace: ie === null ? i.outputColorSpace : ie.isXRRenderTarget === !0 ? ie.texture.colorSpace : on, alphaToCoverage: !!m.alphaToCoverage, map: te, matcap: se, envMap: he, envMapMode: he && T.mapping, envMapCubeUVHeight: A, aoMap: ae, lightMap: D, bumpMap: R, normalMap: X, displacementMap: d && Q, emissiveMap: O, normalMapObjectSpace: X && m.normalMapType === 1, normalMapTangentSpace: X && m.normalMapType === 0, metalnessMap: k, roughnessMap: E, anisotropy: U, anisotropyMap: ue, clearcoat: B, clearcoatMap: H, clearcoatNormalMap: j, clearcoatRoughnessMap: $, dispersion: ne, iridescence: V, iridescenceMap: be, iridescenceThicknessMap: Ne, sheen: de, sheenColorMap: Be, sheenRoughnessMap: Me, specularMap: Ve, specularColorMap: ze, specularIntensityMap: Ct, transmission: xe, transmissionMap: Ce, thicknessMap: at, gradientMap: Le, opaque: m.transparent === !1 && m.blending === 1 && m.alphaToCoverage === !1, alphaMap: mn, alphaTest: Ii, alphaHash: G, combine: m.combine, mapUv: te && v(m.map.channel), aoMapUv: ae && v(m.aoMap.channel), lightMapUv: D && v(m.lightMap.channel), bumpMapUv: R && v(m.bumpMap.channel), normalMapUv: X && v(m.normalMap.channel), displacementMapUv: Q && v(m.displacementMap.channel), emissiveMapUv: O && v(m.emissiveMap.channel), metalnessMapUv: k && v(m.metalnessMap.channel), roughnessMapUv: E && v(m.roughnessMap.channel), anisotropyMapUv: ue && v(m.anisotropyMap.channel), clearcoatMapUv: H && v(m.clearcoatMap.channel), clearcoatNormalMapUv: j && v(m.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: $ && v(m.clearcoatRoughnessMap.channel), iridescenceMapUv: be && v(m.iridescenceMap.channel), iridescenceThicknessMapUv: Ne && v(m.iridescenceThicknessMap.channel), sheenColorMapUv: Be && v(m.sheenColorMap.channel), sheenRoughnessMapUv: Me && v(m.sheenRoughnessMap.channel), specularMapUv: Ve && v(m.specularMap.channel), specularColorMapUv: ze && v(m.specularColorMap.channel), specularIntensityMapUv: Ct && v(m.specularIntensityMap.channel), transmissionMapUv: Ce && v(m.transmissionMap.channel), thicknessMapUv: at && v(m.thicknessMap.channel), alphaMapUv: mn && v(m.alphaMap.channel), vertexTangents: !!b.attributes.tangent && (X || U), vertexColors: m.vertexColors, vertexAlphas: m.vertexColors === !0 && !!b.attributes.color && b.attributes.color.itemSize === 4, pointsUvs: x.isPoints === !0 && !!b.attributes.uv && (te || mn), fog: !!M, useFog: m.fog === !0, fogExp2: !!M && M.isFogExp2, flatShading: m.flatShading === !0, sizeAttenuation: m.sizeAttenuation === !0, logarithmicDepthBuffer: u, skinning: x.isSkinnedMesh === !0, morphTargets: b.morphAttributes.position !== void 0, morphNormals: b.morphAttributes.normal !== void 0, morphColors: b.morphAttributes.color !== void 0, morphTargetsCount: P, morphTextureStride: re, numDirLights: y.directional.length, numPointLights: y.point.length, numSpotLights: y.spot.length, numSpotLightMaps: y.spotLightMap.length, numRectAreaLights: y.rectArea.length, numHemiLights: y.hemi.length, numDirLightShadows: y.directionalShadowMap.length, numPointLightShadows: y.pointShadowMap.length, numSpotLightShadows: y.spotShadowMap.length, numSpotLightShadowsWithMaps: y.numSpotLightShadowsWithMaps, numLightProbes: y.numLightProbes, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: m.dithering, shadowMapEnabled: i.shadowMap.enabled && g.length > 0, shadowMapType: i.shadowMap.type, toneMapping: Wl, decodeVideoTexture: te && m.map.isVideoTexture === !0 && rt.getTransfer(m.map.colorSpace) === ft, premultipliedAlpha: m.premultipliedAlpha, doubleSided: m.side === tn, flipSided: m.side === kn, useDepthPacking: m.depthPacking >= 0, depthPacking: m.depthPacking || 0, index0AttributeName: m.index0AttributeName, extensionClipCullDistance: jl && m.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"), extensionMultiDraw: jl && m.extensions.multiDraw === !0 && n.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"), customProgramCacheKey: m.customProgramCacheKey() };
    return wt.vertexUv1s = c.has(1), wt.vertexUv2s = c.has(2), wt.vertexUv3s = c.has(3), c.clear(), wt;
  }, getProgramCacheKey: function(m) {
    const y = [];
    if (m.shaderID ? y.push(m.shaderID) : (y.push(m.customVertexShaderID), y.push(m.customFragmentShaderID)), m.defines !== void 0)
      for (const g in m.defines)
        y.push(g), y.push(m.defines[g]);
    return m.isRawShaderMaterial === !1 && (function(g, _) {
      g.push(_.precision), g.push(_.outputColorSpace), g.push(_.envMapMode), g.push(_.envMapCubeUVHeight), g.push(_.mapUv), g.push(_.alphaMapUv), g.push(_.lightMapUv), g.push(_.aoMapUv), g.push(_.bumpMapUv), g.push(_.normalMapUv), g.push(_.displacementMapUv), g.push(_.emissiveMapUv), g.push(_.metalnessMapUv), g.push(_.roughnessMapUv), g.push(_.anisotropyMapUv), g.push(_.clearcoatMapUv), g.push(_.clearcoatNormalMapUv), g.push(_.clearcoatRoughnessMapUv), g.push(_.iridescenceMapUv), g.push(_.iridescenceThicknessMapUv), g.push(_.sheenColorMapUv), g.push(_.sheenRoughnessMapUv), g.push(_.specularMapUv), g.push(_.specularColorMapUv), g.push(_.specularIntensityMapUv), g.push(_.transmissionMapUv), g.push(_.thicknessMapUv), g.push(_.combine), g.push(_.fogExp2), g.push(_.sizeAttenuation), g.push(_.morphTargetsCount), g.push(_.morphAttributeCount), g.push(_.numDirLights), g.push(_.numPointLights), g.push(_.numSpotLights), g.push(_.numSpotLightMaps), g.push(_.numHemiLights), g.push(_.numRectAreaLights), g.push(_.numDirLightShadows), g.push(_.numPointLightShadows), g.push(_.numSpotLightShadows), g.push(_.numSpotLightShadowsWithMaps), g.push(_.numLightProbes), g.push(_.shadowMapType), g.push(_.toneMapping), g.push(_.numClippingPlanes), g.push(_.numClipIntersection), g.push(_.depthPacking);
    }(y, m), function(g, _) {
      o.disableAll(), _.supportsVertexTextures && o.enable(0), _.instancing && o.enable(1), _.instancingColor && o.enable(2), _.instancingMorph && o.enable(3), _.matcap && o.enable(4), _.envMap && o.enable(5), _.normalMapObjectSpace && o.enable(6), _.normalMapTangentSpace && o.enable(7), _.clearcoat && o.enable(8), _.iridescence && o.enable(9), _.alphaTest && o.enable(10), _.vertexColors && o.enable(11), _.vertexAlphas && o.enable(12), _.vertexUv1s && o.enable(13), _.vertexUv2s && o.enable(14), _.vertexUv3s && o.enable(15), _.vertexTangents && o.enable(16), _.anisotropy && o.enable(17), _.alphaHash && o.enable(18), _.batching && o.enable(19), _.dispersion && o.enable(20), _.batchingColor && o.enable(21), g.push(o.mask), o.disableAll(), _.fog && o.enable(0), _.useFog && o.enable(1), _.flatShading && o.enable(2), _.logarithmicDepthBuffer && o.enable(3), _.skinning && o.enable(4), _.morphTargets && o.enable(5), _.morphNormals && o.enable(6), _.morphColors && o.enable(7), _.premultipliedAlpha && o.enable(8), _.shadowMapEnabled && o.enable(9), _.doubleSided && o.enable(10), _.flipSided && o.enable(11), _.useDepthPacking && o.enable(12), _.dithering && o.enable(13), _.transmission && o.enable(14), _.sheen && o.enable(15), _.opaque && o.enable(16), _.pointsUvs && o.enable(17), _.decodeVideoTexture && o.enable(18), _.alphaToCoverage && o.enable(19), g.push(o.mask);
    }(y, m), y.push(i.outputColorSpace)), y.push(m.customProgramCacheKey), y.join();
  }, getUniforms: function(m) {
    const y = f[m.type];
    let g;
    if (y) {
      const _ = Dn[y];
      g = rn.clone(_.uniforms);
    } else
      g = m.uniforms;
    return g;
  }, acquireProgram: function(m, y) {
    let g;
    for (let _ = 0, x = h.length; _ < x; _++) {
      const M = h[_];
      if (M.cacheKey === y) {
        g = M, ++g.usedTimes;
        break;
      }
    }
    return g === void 0 && (g = new $E(i, y, m, s), h.push(g)), g;
  }, releaseProgram: function(m) {
    if (--m.usedTimes == 0) {
      const y = h.indexOf(m);
      h[y] = h[h.length - 1], h.pop(), m.destroy();
    }
  }, releaseShaderCache: function(m) {
    l.remove(m);
  }, programs: h, dispose: function() {
    l.dispose();
  } };
}
function rA() {
  let i = /* @__PURE__ */ new WeakMap();
  return { get: function(e) {
    let t = i.get(e);
    return t === void 0 && (t = {}, i.set(e, t)), t;
  }, remove: function(e) {
    i.delete(e);
  }, update: function(e, t, n) {
    i.get(e)[t] = n;
  }, dispose: function() {
    i = /* @__PURE__ */ new WeakMap();
  } };
}
function sA(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id;
}
function m2(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
}
function g2() {
  const i = [];
  let e = 0;
  const t = [], n = [], r = [];
  function s(a, o, l, c, h, u) {
    let d = i[e];
    return d === void 0 ? (d = { id: a.id, object: a, geometry: o, material: l, groupOrder: c, renderOrder: a.renderOrder, z: h, group: u }, i[e] = d) : (d.id = a.id, d.object = a, d.geometry = o, d.material = l, d.groupOrder = c, d.renderOrder = a.renderOrder, d.z = h, d.group = u), e++, d;
  }
  return { opaque: t, transmissive: n, transparent: r, init: function() {
    e = 0, t.length = 0, n.length = 0, r.length = 0;
  }, push: function(a, o, l, c, h, u) {
    const d = s(a, o, l, c, h, u);
    l.transmission > 0 ? n.push(d) : l.transparent === !0 ? r.push(d) : t.push(d);
  }, unshift: function(a, o, l, c, h, u) {
    const d = s(a, o, l, c, h, u);
    l.transmission > 0 ? n.unshift(d) : l.transparent === !0 ? r.unshift(d) : t.unshift(d);
  }, finish: function() {
    for (let a = e, o = i.length; a < o; a++) {
      const l = i[a];
      if (l.id === null)
        break;
      l.id = null, l.object = null, l.geometry = null, l.material = null, l.group = null;
    }
  }, sort: function(a, o) {
    t.length > 1 && t.sort(a || sA), n.length > 1 && n.sort(o || m2), r.length > 1 && r.sort(o || m2);
  } };
}
function aA() {
  let i = /* @__PURE__ */ new WeakMap();
  return { get: function(e, t) {
    const n = i.get(e);
    let r;
    return n === void 0 ? (r = new g2(), i.set(e, [r])) : t >= n.length ? (r = new g2(), n.push(r)) : r = n[t], r;
  }, dispose: function() {
    i = /* @__PURE__ */ new WeakMap();
  } };
}
function oA() {
  const i = {};
  return { get: function(e) {
    if (i[e.id] !== void 0)
      return i[e.id];
    let t;
    switch (e.type) {
      case "DirectionalLight":
        t = { direction: new S(), color: new ce() };
        break;
      case "SpotLight":
        t = { position: new S(), direction: new S(), color: new ce(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        t = { position: new S(), color: new ce(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        t = { direction: new S(), skyColor: new ce(), groundColor: new ce() };
        break;
      case "RectAreaLight":
        t = { color: new ce(), position: new S(), halfWidth: new S(), halfHeight: new S() };
    }
    return i[e.id] = t, t;
  } };
}
let lA = 0;
function cA(i, e) {
  return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0);
}
function hA(i) {
  const e = new oA(), t = /* @__PURE__ */ function() {
    const o = {};
    return { get: function(l) {
      if (o[l.id] !== void 0)
        return o[l.id];
      let c;
      switch (l.type) {
        case "DirectionalLight":
        case "SpotLight":
          c = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Y() };
          break;
        case "PointLight":
          c = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Y(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
      }
      return o[l.id] = c, c;
    } };
  }(), n = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 };
  for (let o = 0; o < 9; o++)
    n.probe.push(new S());
  const r = new S(), s = new fe(), a = new fe();
  return { setup: function(o) {
    let l = 0, c = 0, h = 0;
    for (let w = 0; w < 9; w++)
      n.probe[w].set(0, 0, 0);
    let u = 0, d = 0, p = 0, f = 0, v = 0, m = 0, y = 0, g = 0, _ = 0, x = 0, M = 0;
    o.sort(cA);
    for (let w = 0, T = o.length; w < T; w++) {
      const A = o[w], L = A.color, I = A.intensity, P = A.distance, N = A.shadow && A.shadow.map ? A.shadow.map.texture : null;
      if (A.isAmbientLight)
        l += L.r * I, c += L.g * I, h += L.b * I;
      else if (A.isLightProbe) {
        for (let F = 0; F < 9; F++)
          n.probe[F].addScaledVector(A.sh.coefficients[F], I);
        M++;
      } else if (A.isDirectionalLight) {
        const F = e.get(A);
        if (F.color.copy(A.color).multiplyScalar(A.intensity), A.castShadow) {
          const z = A.shadow, q = t.get(A);
          q.shadowBias = z.bias, q.shadowNormalBias = z.normalBias, q.shadowRadius = z.radius, q.shadowMapSize = z.mapSize, n.directionalShadow[u] = q, n.directionalShadowMap[u] = N, n.directionalShadowMatrix[u] = A.shadow.matrix, m++;
        }
        n.directional[u] = F, u++;
      } else if (A.isSpotLight) {
        const F = e.get(A);
        F.position.setFromMatrixPosition(A.matrixWorld), F.color.copy(L).multiplyScalar(I), F.distance = P, F.coneCos = Math.cos(A.angle), F.penumbraCos = Math.cos(A.angle * (1 - A.penumbra)), F.decay = A.decay, n.spot[p] = F;
        const z = A.shadow;
        if (A.map && (n.spotLightMap[_] = A.map, _++, z.updateMatrices(A), A.castShadow && x++), n.spotLightMatrix[p] = z.matrix, A.castShadow) {
          const q = t.get(A);
          q.shadowBias = z.bias, q.shadowNormalBias = z.normalBias, q.shadowRadius = z.radius, q.shadowMapSize = z.mapSize, n.spotShadow[p] = q, n.spotShadowMap[p] = N, g++;
        }
        p++;
      } else if (A.isRectAreaLight) {
        const F = e.get(A);
        F.color.copy(L).multiplyScalar(I), F.halfWidth.set(0.5 * A.width, 0, 0), F.halfHeight.set(0, 0.5 * A.height, 0), n.rectArea[f] = F, f++;
      } else if (A.isPointLight) {
        const F = e.get(A);
        if (F.color.copy(A.color).multiplyScalar(A.intensity), F.distance = A.distance, F.decay = A.decay, A.castShadow) {
          const z = A.shadow, q = t.get(A);
          q.shadowBias = z.bias, q.shadowNormalBias = z.normalBias, q.shadowRadius = z.radius, q.shadowMapSize = z.mapSize, q.shadowCameraNear = z.camera.near, q.shadowCameraFar = z.camera.far, n.pointShadow[d] = q, n.pointShadowMap[d] = N, n.pointShadowMatrix[d] = A.shadow.matrix, y++;
        }
        n.point[d] = F, d++;
      } else if (A.isHemisphereLight) {
        const F = e.get(A);
        F.skyColor.copy(A.color).multiplyScalar(I), F.groundColor.copy(A.groundColor).multiplyScalar(I), n.hemi[v] = F, v++;
      }
    }
    f > 0 && (i.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = _e.LTC_FLOAT_1, n.rectAreaLTC2 = _e.LTC_FLOAT_2) : (n.rectAreaLTC1 = _e.LTC_HALF_1, n.rectAreaLTC2 = _e.LTC_HALF_2)), n.ambient[0] = l, n.ambient[1] = c, n.ambient[2] = h;
    const b = n.hash;
    b.directionalLength === u && b.pointLength === d && b.spotLength === p && b.rectAreaLength === f && b.hemiLength === v && b.numDirectionalShadows === m && b.numPointShadows === y && b.numSpotShadows === g && b.numSpotMaps === _ && b.numLightProbes === M || (n.directional.length = u, n.spot.length = p, n.rectArea.length = f, n.point.length = d, n.hemi.length = v, n.directionalShadow.length = m, n.directionalShadowMap.length = m, n.pointShadow.length = y, n.pointShadowMap.length = y, n.spotShadow.length = g, n.spotShadowMap.length = g, n.directionalShadowMatrix.length = m, n.pointShadowMatrix.length = y, n.spotLightMatrix.length = g + _ - x, n.spotLightMap.length = _, n.numSpotLightShadowsWithMaps = x, n.numLightProbes = M, b.directionalLength = u, b.pointLength = d, b.spotLength = p, b.rectAreaLength = f, b.hemiLength = v, b.numDirectionalShadows = m, b.numPointShadows = y, b.numSpotShadows = g, b.numSpotMaps = _, b.numLightProbes = M, n.version = lA++);
  }, setupView: function(o, l) {
    let c = 0, h = 0, u = 0, d = 0, p = 0;
    const f = l.matrixWorldInverse;
    for (let v = 0, m = o.length; v < m; v++) {
      const y = o[v];
      if (y.isDirectionalLight) {
        const g = n.directional[c];
        g.direction.setFromMatrixPosition(y.matrixWorld), r.setFromMatrixPosition(y.target.matrixWorld), g.direction.sub(r), g.direction.transformDirection(f), c++;
      } else if (y.isSpotLight) {
        const g = n.spot[u];
        g.position.setFromMatrixPosition(y.matrixWorld), g.position.applyMatrix4(f), g.direction.setFromMatrixPosition(y.matrixWorld), r.setFromMatrixPosition(y.target.matrixWorld), g.direction.sub(r), g.direction.transformDirection(f), u++;
      } else if (y.isRectAreaLight) {
        const g = n.rectArea[d];
        g.position.setFromMatrixPosition(y.matrixWorld), g.position.applyMatrix4(f), a.identity(), s.copy(y.matrixWorld), s.premultiply(f), a.extractRotation(s), g.halfWidth.set(0.5 * y.width, 0, 0), g.halfHeight.set(0, 0.5 * y.height, 0), g.halfWidth.applyMatrix4(a), g.halfHeight.applyMatrix4(a), d++;
      } else if (y.isPointLight) {
        const g = n.point[h];
        g.position.setFromMatrixPosition(y.matrixWorld), g.position.applyMatrix4(f), h++;
      } else if (y.isHemisphereLight) {
        const g = n.hemi[p];
        g.direction.setFromMatrixPosition(y.matrixWorld), g.direction.transformDirection(f), p++;
      }
    }
  }, state: n };
}
function v2(i) {
  const e = new hA(i), t = [], n = [], r = { lightsArray: t, shadowsArray: n, camera: null, lights: e, transmissionRenderTarget: {} };
  return { init: function(s) {
    r.camera = s, t.length = 0, n.length = 0;
  }, state: r, setupLights: function() {
    e.setup(t);
  }, setupLightsView: function(s) {
    e.setupView(t, s);
  }, pushLight: function(s) {
    t.push(s);
  }, pushShadow: function(s) {
    n.push(s);
  } };
}
function uA(i) {
  let e = /* @__PURE__ */ new WeakMap();
  return { get: function(t, n = 0) {
    const r = e.get(t);
    let s;
    return r === void 0 ? (s = new v2(i), e.set(t, [s])) : n >= r.length ? (s = new v2(i), r.push(s)) : s = r[n], s;
  }, dispose: function() {
    e = /* @__PURE__ */ new WeakMap();
  } };
}
class Zp extends Wt {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class m1 extends Wt {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
function dA(i, e, t) {
  let n = new sh();
  const r = new Y(), s = new Y(), a = new je(), o = new Zp({ depthPacking: u1 }), l = new m1(), c = {}, h = t.maxTextureSize, u = { [Gi]: kn, [kn]: Gi, [tn]: tn }, d = new st({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Y() }, radius: { value: 4 } }, vertexShader: `void main() {
	gl_Position = vec4( position, 1.0 );
}`, fragmentShader: `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}` }), p = d.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const f = new Re();
  f.setAttribute("position", new it(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const v = new ve(f, d), m = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = J0;
  let y = this.type;
  function g(b, w) {
    const T = e.update(v);
    d.defines.VSM_SAMPLES !== b.blurSamples && (d.defines.VSM_SAMPLES = b.blurSamples, p.defines.VSM_SAMPLES = b.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), b.mapPass === null && (b.mapPass = new dt(r.x, r.y)), d.uniforms.shadow_pass.value = b.map.texture, d.uniforms.resolution.value = b.mapSize, d.uniforms.radius.value = b.radius, i.setRenderTarget(b.mapPass), i.clear(), i.renderBufferDirect(w, null, T, d, v, null), p.uniforms.shadow_pass.value = b.mapPass.texture, p.uniforms.resolution.value = b.mapSize, p.uniforms.radius.value = b.radius, i.setRenderTarget(b.map), i.clear(), i.renderBufferDirect(w, null, T, p, v, null);
  }
  function _(b, w, T, A) {
    let L = null;
    const I = T.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
    if (I !== void 0)
      L = I;
    else if (L = T.isPointLight === !0 ? l : o, i.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
      const P = L.uuid, N = w.uuid;
      let F = c[P];
      F === void 0 && (F = {}, c[P] = F);
      let z = F[N];
      z === void 0 && (z = L.clone(), F[N] = z, w.addEventListener("dispose", M)), L = z;
    }
    return L.visible = w.visible, L.wireframe = w.wireframe, L.side = A === nr ? w.shadowSide !== null ? w.shadowSide : w.side : w.shadowSide !== null ? w.shadowSide : u[w.side], L.alphaMap = w.alphaMap, L.alphaTest = w.alphaTest, L.map = w.map, L.clipShadows = w.clipShadows, L.clippingPlanes = w.clippingPlanes, L.clipIntersection = w.clipIntersection, L.displacementMap = w.displacementMap, L.displacementScale = w.displacementScale, L.displacementBias = w.displacementBias, L.wireframeLinewidth = w.wireframeLinewidth, L.linewidth = w.linewidth, T.isPointLight === !0 && L.isMeshDistanceMaterial === !0 && (i.properties.get(L).light = T), L;
  }
  function x(b, w, T, A, L) {
    if (b.visible === !1)
      return;
    if (b.layers.test(w.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && L === nr) && (!b.frustumCulled || n.intersectsObject(b))) {
      b.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, b.matrixWorld);
      const P = e.update(b), N = b.material;
      if (Array.isArray(N)) {
        const F = P.groups;
        for (let z = 0, q = F.length; z < q; z++) {
          const re = F[z], ie = N[re.materialIndex];
          if (ie && ie.visible) {
            const me = _(b, ie, A, L);
            b.onBeforeShadow(i, b, w, T, P, me, re), i.renderBufferDirect(T, null, P, me, b, re), b.onAfterShadow(i, b, w, T, P, me, re);
          }
        }
      } else if (N.visible) {
        const F = _(b, N, A, L);
        b.onBeforeShadow(i, b, w, T, P, F, null), i.renderBufferDirect(T, null, P, F, b, null), b.onAfterShadow(i, b, w, T, P, F, null);
      }
    }
    const I = b.children;
    for (let P = 0, N = I.length; P < N; P++)
      x(I[P], w, T, A, L);
  }
  function M(b) {
    b.target.removeEventListener("dispose", M);
    for (const w in c) {
      const T = c[w], A = b.target.uuid;
      A in T && (T[A].dispose(), delete T[A]);
    }
  }
  this.render = function(b, w, T) {
    if (m.enabled === !1 || m.autoUpdate === !1 && m.needsUpdate === !1 || b.length === 0)
      return;
    const A = i.getRenderTarget(), L = i.getActiveCubeFace(), I = i.getActiveMipmapLevel(), P = i.state;
    P.setBlending(0), P.buffers.color.setClear(1, 1, 1, 1), P.buffers.depth.setTest(!0), P.setScissorTest(!1);
    const N = y !== nr && this.type === nr, F = y === nr && this.type !== nr;
    for (let z = 0, q = b.length; z < q; z++) {
      const re = b[z], ie = re.shadow;
      if (ie === void 0) {
        console.warn("THREE.WebGLShadowMap:", re, "has no shadow.");
        continue;
      }
      if (ie.autoUpdate === !1 && ie.needsUpdate === !1)
        continue;
      r.copy(ie.mapSize);
      const me = ie.getFrameExtents();
      if (r.multiply(me), s.copy(ie.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / me.x), r.x = s.x * me.x, ie.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / me.y), r.y = s.y * me.y, ie.mapSize.y = s.y)), ie.map === null || N === !0 || F === !0) {
        const te = this.type !== nr ? { minFilter: lt, magFilter: lt } : {};
        ie.map !== null && ie.map.dispose(), ie.map = new dt(r.x, r.y, te), ie.map.texture.name = re.name + ".shadowMap", ie.camera.updateProjectionMatrix();
      }
      i.setRenderTarget(ie.map), i.clear();
      const Se = ie.getViewportCount();
      for (let te = 0; te < Se; te++) {
        const se = ie.getViewport(te);
        a.set(s.x * se.x, s.y * se.y, s.x * se.z, s.y * se.w), P.viewport(a), ie.updateMatrices(re, te), n = ie.getFrustum(), x(w, T, ie.camera, re, this.type);
      }
      ie.isPointLightShadow !== !0 && this.type === nr && g(ie, T), ie.needsUpdate = !1;
    }
    y = this.type, m.needsUpdate = !1, i.setRenderTarget(A, L, I);
  };
}
function pA(i) {
  const e = new function() {
    let E = !1;
    const U = new je();
    let B = null;
    const ne = new je(0, 0, 0, 0);
    return { setMask: function(V) {
      B === V || E || (i.colorMask(V, V, V, V), B = V);
    }, setLocked: function(V) {
      E = V;
    }, setClear: function(V, de, xe, ue, H) {
      H === !0 && (V *= ue, de *= ue, xe *= ue), U.set(V, de, xe, ue), ne.equals(U) === !1 && (i.clearColor(V, de, xe, ue), ne.copy(U));
    }, reset: function() {
      E = !1, B = null, ne.set(-1, 0, 0, 0);
    } };
  }(), t = new function() {
    let E = !1, U = null, B = null, ne = null;
    return { setTest: function(V) {
      V ? he(i.DEPTH_TEST) : ae(i.DEPTH_TEST);
    }, setMask: function(V) {
      U === V || E || (i.depthMask(V), U = V);
    }, setFunc: function(V) {
      if (B !== V) {
        switch (V) {
          case 0:
            i.depthFunc(i.NEVER);
            break;
          case 1:
            i.depthFunc(i.ALWAYS);
            break;
          case 2:
            i.depthFunc(i.LESS);
            break;
          case 3:
          default:
            i.depthFunc(i.LEQUAL);
            break;
          case 4:
            i.depthFunc(i.EQUAL);
            break;
          case 5:
            i.depthFunc(i.GEQUAL);
            break;
          case 6:
            i.depthFunc(i.GREATER);
            break;
          case 7:
            i.depthFunc(i.NOTEQUAL);
        }
        B = V;
      }
    }, setLocked: function(V) {
      E = V;
    }, setClear: function(V) {
      ne !== V && (i.clearDepth(V), ne = V);
    }, reset: function() {
      E = !1, U = null, B = null, ne = null;
    } };
  }(), n = new function() {
    let E = !1, U = null, B = null, ne = null, V = null, de = null, xe = null, ue = null, H = null;
    return { setTest: function(j) {
      E || (j ? he(i.STENCIL_TEST) : ae(i.STENCIL_TEST));
    }, setMask: function(j) {
      U === j || E || (i.stencilMask(j), U = j);
    }, setFunc: function(j, $, be) {
      B === j && ne === $ && V === be || (i.stencilFunc(j, $, be), B = j, ne = $, V = be);
    }, setOp: function(j, $, be) {
      de === j && xe === $ && ue === be || (i.stencilOp(j, $, be), de = j, xe = $, ue = be);
    }, setLocked: function(j) {
      E = j;
    }, setClear: function(j) {
      H !== j && (i.clearStencil(j), H = j);
    }, reset: function() {
      E = !1, U = null, B = null, ne = null, V = null, de = null, xe = null, ue = null, H = null;
    } };
  }(), r = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap();
  let a = {}, o = {}, l = /* @__PURE__ */ new WeakMap(), c = [], h = null, u = !1, d = null, p = null, f = null, v = null, m = null, y = null, g = null, _ = new ce(0, 0, 0), x = 0, M = !1, b = null, w = null, T = null, A = null, L = null;
  const I = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let P = !1, N = 0;
  const F = i.getParameter(i.VERSION);
  F.indexOf("WebGL") !== -1 ? (N = parseFloat(/^WebGL (\d)/.exec(F)[1]), P = N >= 1) : F.indexOf("OpenGL ES") !== -1 && (N = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]), P = N >= 2);
  let z = null, q = {};
  const re = i.getParameter(i.SCISSOR_BOX), ie = i.getParameter(i.VIEWPORT), me = new je().fromArray(re), Se = new je().fromArray(ie);
  function te(E, U, B, ne) {
    const V = new Uint8Array(4), de = i.createTexture();
    i.bindTexture(E, de), i.texParameteri(E, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(E, i.TEXTURE_MAG_FILTER, i.NEAREST);
    for (let xe = 0; xe < B; xe++)
      E === i.TEXTURE_3D || E === i.TEXTURE_2D_ARRAY ? i.texImage3D(U, 0, i.RGBA, 1, 1, ne, 0, i.RGBA, i.UNSIGNED_BYTE, V) : i.texImage2D(U + xe, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, V);
    return de;
  }
  const se = {};
  function he(E) {
    a[E] !== !0 && (i.enable(E), a[E] = !0);
  }
  function ae(E) {
    a[E] !== !1 && (i.disable(E), a[E] = !1);
  }
  se[i.TEXTURE_2D] = te(i.TEXTURE_2D, i.TEXTURE_2D, 1), se[i.TEXTURE_CUBE_MAP] = te(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), se[i.TEXTURE_2D_ARRAY] = te(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), se[i.TEXTURE_3D] = te(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1), e.setClear(0, 0, 0, 1), t.setClear(1), n.setClear(0), he(i.DEPTH_TEST), t.setFunc(3), Q(!1), O(1), he(i.CULL_FACE), X(0);
  const D = { [Mi]: i.FUNC_ADD, [iT]: i.FUNC_SUBTRACT, [rT]: i.FUNC_REVERSE_SUBTRACT };
  D[103] = i.MIN, D[104] = i.MAX;
  const R = { [ap]: i.ZERO, [e1]: i.ONE, [sT]: i.SRC_COLOR, [Ua]: i.SRC_ALPHA, [uT]: i.SRC_ALPHA_SATURATE, [cT]: i.DST_COLOR, [oT]: i.DST_ALPHA, [aT]: i.ONE_MINUS_SRC_COLOR, [ka]: i.ONE_MINUS_SRC_ALPHA, [hT]: i.ONE_MINUS_DST_COLOR, [lT]: i.ONE_MINUS_DST_ALPHA, [dT]: i.CONSTANT_COLOR, [pT]: i.ONE_MINUS_CONSTANT_COLOR, [fT]: i.CONSTANT_ALPHA, [mT]: i.ONE_MINUS_CONSTANT_ALPHA };
  function X(E, U, B, ne, V, de, xe, ue, H, j) {
    if (E !== 0) {
      if (u === !1 && (he(i.BLEND), u = !0), E === 5)
        V = V || U, de = de || B, xe = xe || ne, U === p && V === m || (i.blendEquationSeparate(D[U], D[V]), p = U, m = V), B === f && ne === v && de === y && xe === g || (i.blendFuncSeparate(R[B], R[ne], R[de], R[xe]), f = B, v = ne, y = de, g = xe), ue.equals(_) !== !1 && H === x || (i.blendColor(ue.r, ue.g, ue.b, H), _.copy(ue), x = H), d = E, M = !1;
      else if (E !== d || j !== M) {
        if (p === Mi && m === Mi || (i.blendEquation(i.FUNC_ADD), p = Mi, m = Mi), j)
          switch (E) {
            case 1:
              i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case al:
              i.blendFunc(i.ONE, i.ONE);
              break;
            case 3:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case 4:
              i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", E);
          }
        else
          switch (E) {
            case 1:
              i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case al:
              i.blendFunc(i.SRC_ALPHA, i.ONE);
              break;
            case 3:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case 4:
              i.blendFunc(i.ZERO, i.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", E);
          }
        f = null, v = null, y = null, g = null, _.set(0, 0, 0), x = 0, d = E, M = j;
      }
    } else
      u === !0 && (ae(i.BLEND), u = !1);
  }
  function Q(E) {
    b !== E && (E ? i.frontFace(i.CW) : i.frontFace(i.CCW), b = E);
  }
  function O(E) {
    E !== 0 ? (he(i.CULL_FACE), E !== w && (E === 1 ? i.cullFace(i.BACK) : E === 2 ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : ae(i.CULL_FACE), w = E;
  }
  function k(E, U, B) {
    E ? (he(i.POLYGON_OFFSET_FILL), A === U && L === B || (i.polygonOffset(U, B), A = U, L = B)) : ae(i.POLYGON_OFFSET_FILL);
  }
  return { buffers: { color: e, depth: t, stencil: n }, enable: he, disable: ae, bindFramebuffer: function(E, U) {
    return o[E] !== U && (i.bindFramebuffer(E, U), o[E] = U, E === i.DRAW_FRAMEBUFFER && (o[i.FRAMEBUFFER] = U), E === i.FRAMEBUFFER && (o[i.DRAW_FRAMEBUFFER] = U), !0);
  }, drawBuffers: function(E, U) {
    let B = c, ne = !1;
    if (E) {
      B = l.get(U), B === void 0 && (B = [], l.set(U, B));
      const V = E.textures;
      if (B.length !== V.length || B[0] !== i.COLOR_ATTACHMENT0) {
        for (let de = 0, xe = V.length; de < xe; de++)
          B[de] = i.COLOR_ATTACHMENT0 + de;
        B.length = V.length, ne = !0;
      }
    } else
      B[0] !== i.BACK && (B[0] = i.BACK, ne = !0);
    ne && i.drawBuffers(B);
  }, useProgram: function(E) {
    return h !== E && (i.useProgram(E), h = E, !0);
  }, setBlending: X, setMaterial: function(E, U) {
    E.side === tn ? ae(i.CULL_FACE) : he(i.CULL_FACE);
    let B = E.side === kn;
    U && (B = !B), Q(B), E.blending === 1 && E.transparent === !1 ? X(0) : X(E.blending, E.blendEquation, E.blendSrc, E.blendDst, E.blendEquationAlpha, E.blendSrcAlpha, E.blendDstAlpha, E.blendColor, E.blendAlpha, E.premultipliedAlpha), t.setFunc(E.depthFunc), t.setTest(E.depthTest), t.setMask(E.depthWrite), e.setMask(E.colorWrite);
    const ne = E.stencilWrite;
    n.setTest(ne), ne && (n.setMask(E.stencilWriteMask), n.setFunc(E.stencilFunc, E.stencilRef, E.stencilFuncMask), n.setOp(E.stencilFail, E.stencilZFail, E.stencilZPass)), k(E.polygonOffset, E.polygonOffsetFactor, E.polygonOffsetUnits), E.alphaToCoverage === !0 ? he(i.SAMPLE_ALPHA_TO_COVERAGE) : ae(i.SAMPLE_ALPHA_TO_COVERAGE);
  }, setFlipSided: Q, setCullFace: O, setLineWidth: function(E) {
    E !== T && (P && i.lineWidth(E), T = E);
  }, setPolygonOffset: k, setScissorTest: function(E) {
    E ? he(i.SCISSOR_TEST) : ae(i.SCISSOR_TEST);
  }, activeTexture: function(E) {
    E === void 0 && (E = i.TEXTURE0 + I - 1), z !== E && (i.activeTexture(E), z = E);
  }, bindTexture: function(E, U, B) {
    B === void 0 && (B = z === null ? i.TEXTURE0 + I - 1 : z);
    let ne = q[B];
    ne === void 0 && (ne = { type: void 0, texture: void 0 }, q[B] = ne), ne.type === E && ne.texture === U || (z !== B && (i.activeTexture(B), z = B), i.bindTexture(E, U || se[E]), ne.type = E, ne.texture = U);
  }, unbindTexture: function() {
    const E = q[z];
    E !== void 0 && E.type !== void 0 && (i.bindTexture(E.type, null), E.type = void 0, E.texture = void 0);
  }, compressedTexImage2D: function() {
    try {
      i.compressedTexImage2D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, compressedTexImage3D: function() {
    try {
      i.compressedTexImage3D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, texImage2D: function() {
    try {
      i.texImage2D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, texImage3D: function() {
    try {
      i.texImage3D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, updateUBOMapping: function(E, U) {
    let B = s.get(U);
    B === void 0 && (B = /* @__PURE__ */ new WeakMap(), s.set(U, B));
    let ne = B.get(E);
    ne === void 0 && (ne = i.getUniformBlockIndex(U, E.name), B.set(E, ne));
  }, uniformBlockBinding: function(E, U) {
    const B = s.get(U).get(E);
    r.get(U) !== B && (i.uniformBlockBinding(U, B, E.__bindingPointIndex), r.set(U, B));
  }, texStorage2D: function() {
    try {
      i.texStorage2D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, texStorage3D: function() {
    try {
      i.texStorage3D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, texSubImage2D: function() {
    try {
      i.texSubImage2D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, texSubImage3D: function() {
    try {
      i.texSubImage3D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, compressedTexSubImage2D: function() {
    try {
      i.compressedTexSubImage2D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, compressedTexSubImage3D: function() {
    try {
      i.compressedTexSubImage3D.apply(i, arguments);
    } catch (E) {
      console.error("THREE.WebGLState:", E);
    }
  }, scissor: function(E) {
    me.equals(E) === !1 && (i.scissor(E.x, E.y, E.z, E.w), me.copy(E));
  }, viewport: function(E) {
    Se.equals(E) === !1 && (i.viewport(E.x, E.y, E.z, E.w), Se.copy(E));
  }, reset: function() {
    i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.blendColor(0, 0, 0, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), a = {}, z = null, q = {}, o = {}, l = /* @__PURE__ */ new WeakMap(), c = [], h = null, u = !1, d = null, p = null, f = null, v = null, m = null, y = null, g = null, _ = new ce(0, 0, 0), x = 0, M = !1, b = null, w = null, T = null, A = null, L = null, me.set(0, 0, i.canvas.width, i.canvas.height), Se.set(0, 0, i.canvas.width, i.canvas.height), e.reset(), t.reset(), n.reset();
  } };
}
function fA(i, e, t, n, r, s, a) {
  const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator != "undefined" && /OculusBrowser/g.test(navigator.userAgent), c = new Y(), h = /* @__PURE__ */ new WeakMap();
  let u;
  const d = /* @__PURE__ */ new WeakMap();
  let p = !1;
  try {
    p = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (D) {
  }
  function f(D, R) {
    return p ? new OffscreenCanvas(D, R) : rh("canvas");
  }
  function v(D, R, X) {
    let Q = 1;
    const O = ae(D);
    if ((O.width > X || O.height > X) && (Q = X / Math.max(O.width, O.height)), Q < 1) {
      if (typeof HTMLImageElement != "undefined" && D instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && D instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && D instanceof ImageBitmap || typeof VideoFrame != "undefined" && D instanceof VideoFrame) {
        const k = Math.floor(Q * O.width), E = Math.floor(Q * O.height);
        u === void 0 && (u = f(k, E));
        const U = R ? f(k, E) : u;
        return U.width = k, U.height = E, U.getContext("2d").drawImage(D, 0, 0, k, E), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + O.width + "x" + O.height + ") to (" + k + "x" + E + ")."), U;
      }
      return "data" in D && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + O.width + "x" + O.height + ")."), D;
    }
    return D;
  }
  function m(D) {
    return D.generateMipmaps && D.minFilter !== lt && D.minFilter !== Gt;
  }
  function y(D) {
    i.generateMipmap(D);
  }
  function g(D, R, X, Q, O = !1) {
    if (D !== null) {
      if (i[D] !== void 0)
        return i[D];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + D + "'");
    }
    let k = R;
    if (R === i.RED && (X === i.FLOAT && (k = i.R32F), X === i.HALF_FLOAT && (k = i.R16F), X === i.UNSIGNED_BYTE && (k = i.R8)), R === i.RED_INTEGER && (X === i.UNSIGNED_BYTE && (k = i.R8UI), X === i.UNSIGNED_SHORT && (k = i.R16UI), X === i.UNSIGNED_INT && (k = i.R32UI), X === i.BYTE && (k = i.R8I), X === i.SHORT && (k = i.R16I), X === i.INT && (k = i.R32I)), R === i.RG && (X === i.FLOAT && (k = i.RG32F), X === i.HALF_FLOAT && (k = i.RG16F), X === i.UNSIGNED_BYTE && (k = i.RG8)), R === i.RG_INTEGER && (X === i.UNSIGNED_BYTE && (k = i.RG8UI), X === i.UNSIGNED_SHORT && (k = i.RG16UI), X === i.UNSIGNED_INT && (k = i.RG32UI), X === i.BYTE && (k = i.RG8I), X === i.SHORT && (k = i.RG16I), X === i.INT && (k = i.RG32I)), R === i.RGB && X === i.UNSIGNED_INT_5_9_9_9_REV && (k = i.RGB9_E5), R === i.RGBA) {
      const E = O ? $c : rt.getTransfer(Q);
      X === i.FLOAT && (k = i.RGBA32F), X === i.HALF_FLOAT && (k = i.RGBA16F), X === i.UNSIGNED_BYTE && (k = E === ft ? i.SRGB8_ALPHA8 : i.RGBA8), X === i.UNSIGNED_SHORT_4_4_4_4 && (k = i.RGBA4), X === i.UNSIGNED_SHORT_5_5_5_1 && (k = i.RGB5_A1);
    }
    return k !== i.R16F && k !== i.R32F && k !== i.RG16F && k !== i.RG32F && k !== i.RGBA16F && k !== i.RGBA32F || e.get("EXT_color_buffer_float"), k;
  }
  function _(D, R) {
    let X;
    return D ? R === null || R === Ba || R === _s ? X = i.DEPTH24_STENCIL8 : R === si ? X = i.DEPTH32F_STENCIL8 : R === ll && (X = i.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : R === null || R === Ba || R === _s ? X = i.DEPTH_COMPONENT24 : R === si ? X = i.DEPTH_COMPONENT32F : R === ll && (X = i.DEPTH_COMPONENT16), X;
  }
  function x(D, R) {
    return m(D) === !0 || D.isFramebufferTexture && D.minFilter !== lt && D.minFilter !== Gt ? Math.log2(Math.max(R.width, R.height)) + 1 : D.mipmaps !== void 0 && D.mipmaps.length > 0 ? D.mipmaps.length : D.isCompressedTexture && Array.isArray(D.image) ? R.mipmaps.length : 1;
  }
  function M(D) {
    const R = D.target;
    R.removeEventListener("dispose", M), function(X) {
      const Q = n.get(X);
      if (Q.__webglInit === void 0)
        return;
      const O = X.source, k = d.get(O);
      if (k) {
        const E = k[Q.__cacheKey];
        E.usedTimes--, E.usedTimes === 0 && w(X), Object.keys(k).length === 0 && d.delete(O);
      }
      n.remove(X);
    }(R), R.isVideoTexture && h.delete(R);
  }
  function b(D) {
    const R = D.target;
    R.removeEventListener("dispose", b), function(X) {
      const Q = n.get(X);
      if (X.depthTexture && X.depthTexture.dispose(), X.isWebGLCubeRenderTarget)
        for (let k = 0; k < 6; k++) {
          if (Array.isArray(Q.__webglFramebuffer[k]))
            for (let E = 0; E < Q.__webglFramebuffer[k].length; E++)
              i.deleteFramebuffer(Q.__webglFramebuffer[k][E]);
          else
            i.deleteFramebuffer(Q.__webglFramebuffer[k]);
          Q.__webglDepthbuffer && i.deleteRenderbuffer(Q.__webglDepthbuffer[k]);
        }
      else {
        if (Array.isArray(Q.__webglFramebuffer))
          for (let k = 0; k < Q.__webglFramebuffer.length; k++)
            i.deleteFramebuffer(Q.__webglFramebuffer[k]);
        else
          i.deleteFramebuffer(Q.__webglFramebuffer);
        if (Q.__webglDepthbuffer && i.deleteRenderbuffer(Q.__webglDepthbuffer), Q.__webglMultisampledFramebuffer && i.deleteFramebuffer(Q.__webglMultisampledFramebuffer), Q.__webglColorRenderbuffer)
          for (let k = 0; k < Q.__webglColorRenderbuffer.length; k++)
            Q.__webglColorRenderbuffer[k] && i.deleteRenderbuffer(Q.__webglColorRenderbuffer[k]);
        Q.__webglDepthRenderbuffer && i.deleteRenderbuffer(Q.__webglDepthRenderbuffer);
      }
      const O = X.textures;
      for (let k = 0, E = O.length; k < E; k++) {
        const U = n.get(O[k]);
        U.__webglTexture && (i.deleteTexture(U.__webglTexture), a.memory.textures--), n.remove(O[k]);
      }
      n.remove(X);
    }(R);
  }
  function w(D) {
    const R = n.get(D);
    i.deleteTexture(R.__webglTexture);
    const X = D.source;
    delete d.get(X)[R.__cacheKey], a.memory.textures--;
  }
  let T = 0;
  function A(D, R) {
    const X = n.get(D);
    if (D.isVideoTexture && function(Q) {
      const O = a.render.frame;
      h.get(Q) !== O && (h.set(Q, O), Q.update());
    }(D), D.isRenderTargetTexture === !1 && D.version > 0 && X.__version !== D.version) {
      const Q = D.image;
      if (Q === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else {
        if (Q.complete !== !1)
          return void z(X, D, R);
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }
    t.bindTexture(i.TEXTURE_2D, X.__webglTexture, i.TEXTURE0 + R);
  }
  const L = { [In]: i.REPEAT, [ri]: i.CLAMP_TO_EDGE, [Fa]: i.MIRRORED_REPEAT }, I = { [lt]: i.NEAREST, [jp]: i.NEAREST_MIPMAP_NEAREST, [ma]: i.NEAREST_MIPMAP_LINEAR, [Gt]: i.LINEAR, [Zo]: i.LINEAR_MIPMAP_NEAREST, [zi]: i.LINEAR_MIPMAP_LINEAR }, P = { [gT]: i.NEVER, [wT]: i.ALWAYS, [vT]: i.LESS, [_T]: i.LEQUAL, [yT]: i.EQUAL, [MT]: i.GEQUAL, [xT]: i.GREATER, [bT]: i.NOTEQUAL };
  function N(D, R) {
    if (R.type !== si || e.has("OES_texture_float_linear") !== !1 || R.magFilter !== Gt && R.magFilter !== Zo && R.magFilter !== ma && R.magFilter !== zi && R.minFilter !== Gt && R.minFilter !== Zo && R.minFilter !== ma && R.minFilter !== zi || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), i.texParameteri(D, i.TEXTURE_WRAP_S, L[R.wrapS]), i.texParameteri(D, i.TEXTURE_WRAP_T, L[R.wrapT]), D !== i.TEXTURE_3D && D !== i.TEXTURE_2D_ARRAY || i.texParameteri(D, i.TEXTURE_WRAP_R, L[R.wrapR]), i.texParameteri(D, i.TEXTURE_MAG_FILTER, I[R.magFilter]), i.texParameteri(D, i.TEXTURE_MIN_FILTER, I[R.minFilter]), R.compareFunction && (i.texParameteri(D, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(D, i.TEXTURE_COMPARE_FUNC, P[R.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (R.magFilter === lt || R.minFilter !== ma && R.minFilter !== zi || R.type === si && e.has("OES_texture_float_linear") === !1)
        return;
      if (R.anisotropy > 1 || n.get(R).__currentAnisotropy) {
        const X = e.get("EXT_texture_filter_anisotropic");
        i.texParameterf(D, X.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(R.anisotropy, r.getMaxAnisotropy())), n.get(R).__currentAnisotropy = R.anisotropy;
      }
    }
  }
  function F(D, R) {
    let X = !1;
    D.__webglInit === void 0 && (D.__webglInit = !0, R.addEventListener("dispose", M));
    const Q = R.source;
    let O = d.get(Q);
    O === void 0 && (O = {}, d.set(Q, O));
    const k = function(E) {
      const U = [];
      return U.push(E.wrapS), U.push(E.wrapT), U.push(E.wrapR || 0), U.push(E.magFilter), U.push(E.minFilter), U.push(E.anisotropy), U.push(E.internalFormat), U.push(E.format), U.push(E.type), U.push(E.generateMipmaps), U.push(E.premultiplyAlpha), U.push(E.flipY), U.push(E.unpackAlignment), U.push(E.colorSpace), U.join();
    }(R);
    if (k !== D.__cacheKey) {
      O[k] === void 0 && (O[k] = { texture: i.createTexture(), usedTimes: 0 }, a.memory.textures++, X = !0), O[k].usedTimes++;
      const E = O[D.__cacheKey];
      E !== void 0 && (O[D.__cacheKey].usedTimes--, E.usedTimes === 0 && w(R)), D.__cacheKey = k, D.__webglTexture = O[k].texture;
    }
    return X;
  }
  function z(D, R, X) {
    let Q = i.TEXTURE_2D;
    (R.isDataArrayTexture || R.isCompressedArrayTexture) && (Q = i.TEXTURE_2D_ARRAY), R.isData3DTexture && (Q = i.TEXTURE_3D);
    const O = F(D, R), k = R.source;
    t.bindTexture(Q, D.__webglTexture, i.TEXTURE0 + X);
    const E = n.get(k);
    if (k.version !== E.__version || O === !0) {
      t.activeTexture(i.TEXTURE0 + X);
      const U = rt.getPrimaries(rt.workingColorSpace), B = R.colorSpace === la ? null : rt.getPrimaries(R.colorSpace), ne = R.colorSpace === la || U === B ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, R.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, R.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, ne);
      let V = v(R.image, !1, r.maxTextureSize);
      V = he(R, V);
      const de = s.convert(R.format, R.colorSpace), xe = s.convert(R.type);
      let ue, H = g(R.internalFormat, de, xe, R.colorSpace, R.isVideoTexture);
      N(Q, R);
      const j = R.mipmaps, $ = R.isVideoTexture !== !0, be = E.__version === void 0 || O === !0, Ne = k.dataReady, Be = x(R, V);
      if (R.isDepthTexture)
        H = _(R.format === xs, R.type), be && ($ ? t.texStorage2D(i.TEXTURE_2D, 1, H, V.width, V.height) : t.texImage2D(i.TEXTURE_2D, 0, H, V.width, V.height, 0, de, xe, null));
      else if (R.isDataTexture)
        if (j.length > 0) {
          $ && be && t.texStorage2D(i.TEXTURE_2D, Be, H, j[0].width, j[0].height);
          for (let Me = 0, Ve = j.length; Me < Ve; Me++)
            ue = j[Me], $ ? Ne && t.texSubImage2D(i.TEXTURE_2D, Me, 0, 0, ue.width, ue.height, de, xe, ue.data) : t.texImage2D(i.TEXTURE_2D, Me, H, ue.width, ue.height, 0, de, xe, ue.data);
          R.generateMipmaps = !1;
        } else
          $ ? (be && t.texStorage2D(i.TEXTURE_2D, Be, H, V.width, V.height), Ne && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, V.width, V.height, de, xe, V.data)) : t.texImage2D(i.TEXTURE_2D, 0, H, V.width, V.height, 0, de, xe, V.data);
      else if (R.isCompressedTexture)
        if (R.isCompressedArrayTexture) {
          $ && be && t.texStorage3D(i.TEXTURE_2D_ARRAY, Be, H, j[0].width, j[0].height, V.depth);
          for (let Me = 0, Ve = j.length; Me < Ve; Me++)
            if (ue = j[Me], R.format !== ai)
              if (de !== null)
                if ($) {
                  if (Ne)
                    if (R.layerUpdates.size > 0) {
                      for (const ze of R.layerUpdates) {
                        const Ct = ue.width * ue.height;
                        t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, Me, 0, 0, ze, ue.width, ue.height, 1, de, ue.data.slice(Ct * ze, Ct * (ze + 1)), 0, 0);
                      }
                      R.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, Me, 0, 0, 0, ue.width, ue.height, V.depth, de, ue.data, 0, 0);
                } else
                  t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, Me, H, ue.width, ue.height, V.depth, 0, ue.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              $ ? Ne && t.texSubImage3D(i.TEXTURE_2D_ARRAY, Me, 0, 0, 0, ue.width, ue.height, V.depth, de, xe, ue.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, Me, H, ue.width, ue.height, V.depth, 0, de, xe, ue.data);
        } else {
          $ && be && t.texStorage2D(i.TEXTURE_2D, Be, H, j[0].width, j[0].height);
          for (let Me = 0, Ve = j.length; Me < Ve; Me++)
            ue = j[Me], R.format !== ai ? de !== null ? $ ? Ne && t.compressedTexSubImage2D(i.TEXTURE_2D, Me, 0, 0, ue.width, ue.height, de, ue.data) : t.compressedTexImage2D(i.TEXTURE_2D, Me, H, ue.width, ue.height, 0, ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : $ ? Ne && t.texSubImage2D(i.TEXTURE_2D, Me, 0, 0, ue.width, ue.height, de, xe, ue.data) : t.texImage2D(i.TEXTURE_2D, Me, H, ue.width, ue.height, 0, de, xe, ue.data);
        }
      else if (R.isDataArrayTexture)
        if ($) {
          if (be && t.texStorage3D(i.TEXTURE_2D_ARRAY, Be, H, V.width, V.height, V.depth), Ne)
            if (R.layerUpdates.size > 0) {
              let Me;
              switch (xe) {
                case i.UNSIGNED_BYTE:
                  switch (de) {
                    case i.ALPHA:
                    case i.LUMINANCE:
                      Me = 1;
                      break;
                    case i.LUMINANCE_ALPHA:
                      Me = 2;
                      break;
                    case i.RGB:
                      Me = 3;
                      break;
                    case i.RGBA:
                      Me = 4;
                      break;
                    default:
                      throw new Error(`Unknown texel size for format ${de}.`);
                  }
                  break;
                case i.UNSIGNED_SHORT_4_4_4_4:
                case i.UNSIGNED_SHORT_5_5_5_1:
                case i.UNSIGNED_SHORT_5_6_5:
                  Me = 1;
                  break;
                default:
                  throw new Error(`Unknown texel size for type ${xe}.`);
              }
              const Ve = V.width * V.height * Me;
              for (const ze of R.layerUpdates)
                t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, ze, V.width, V.height, 1, de, xe, V.data.slice(Ve * ze, Ve * (ze + 1)));
              R.clearLayerUpdates();
            } else
              t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, V.width, V.height, V.depth, de, xe, V.data);
        } else
          t.texImage3D(i.TEXTURE_2D_ARRAY, 0, H, V.width, V.height, V.depth, 0, de, xe, V.data);
      else if (R.isData3DTexture)
        $ ? (be && t.texStorage3D(i.TEXTURE_3D, Be, H, V.width, V.height, V.depth), Ne && t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, V.width, V.height, V.depth, de, xe, V.data)) : t.texImage3D(i.TEXTURE_3D, 0, H, V.width, V.height, V.depth, 0, de, xe, V.data);
      else if (R.isFramebufferTexture) {
        if (be)
          if ($)
            t.texStorage2D(i.TEXTURE_2D, Be, H, V.width, V.height);
          else {
            let Me = V.width, Ve = V.height;
            for (let ze = 0; ze < Be; ze++)
              t.texImage2D(i.TEXTURE_2D, ze, H, Me, Ve, 0, de, xe, null), Me >>= 1, Ve >>= 1;
          }
      } else if (j.length > 0) {
        if ($ && be) {
          const Me = ae(j[0]);
          t.texStorage2D(i.TEXTURE_2D, Be, H, Me.width, Me.height);
        }
        for (let Me = 0, Ve = j.length; Me < Ve; Me++)
          ue = j[Me], $ ? Ne && t.texSubImage2D(i.TEXTURE_2D, Me, 0, 0, de, xe, ue) : t.texImage2D(i.TEXTURE_2D, Me, H, de, xe, ue);
        R.generateMipmaps = !1;
      } else if ($) {
        if (be) {
          const Me = ae(V);
          t.texStorage2D(i.TEXTURE_2D, Be, H, Me.width, Me.height);
        }
        Ne && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, de, xe, V);
      } else
        t.texImage2D(i.TEXTURE_2D, 0, H, de, xe, V);
      m(R) && y(Q), E.__version = k.version, R.onUpdate && R.onUpdate(R);
    }
    D.__version = R.version;
  }
  function q(D, R, X, Q, O, k) {
    const E = s.convert(X.format, X.colorSpace), U = s.convert(X.type), B = g(X.internalFormat, E, U, X.colorSpace);
    if (!n.get(R).__hasExternalTextures) {
      const ne = Math.max(1, R.width >> k), V = Math.max(1, R.height >> k);
      O === i.TEXTURE_3D || O === i.TEXTURE_2D_ARRAY ? t.texImage3D(O, k, B, ne, V, R.depth, 0, E, U, null) : t.texImage2D(O, k, B, ne, V, 0, E, U, null);
    }
    t.bindFramebuffer(i.FRAMEBUFFER, D), se(R) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, Q, O, n.get(X).__webglTexture, 0, te(R)) : (O === i.TEXTURE_2D || O >= i.TEXTURE_CUBE_MAP_POSITIVE_X && O <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, Q, O, n.get(X).__webglTexture, k), t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function re(D, R, X) {
    if (i.bindRenderbuffer(i.RENDERBUFFER, D), R.depthBuffer) {
      const Q = R.depthTexture, O = Q && Q.isDepthTexture ? Q.type : null, k = _(R.stencilBuffer, O), E = R.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, U = te(R);
      se(R) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, U, k, R.width, R.height) : X ? i.renderbufferStorageMultisample(i.RENDERBUFFER, U, k, R.width, R.height) : i.renderbufferStorage(i.RENDERBUFFER, k, R.width, R.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, E, i.RENDERBUFFER, D);
    } else {
      const Q = R.textures;
      for (let O = 0; O < Q.length; O++) {
        const k = Q[O], E = s.convert(k.format, k.colorSpace), U = s.convert(k.type), B = g(k.internalFormat, E, U, k.colorSpace), ne = te(R);
        X && se(R) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, ne, B, R.width, R.height) : se(R) ? o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, ne, B, R.width, R.height) : i.renderbufferStorage(i.RENDERBUFFER, B, R.width, R.height);
      }
    }
    i.bindRenderbuffer(i.RENDERBUFFER, null);
  }
  function ie(D) {
    const R = n.get(D), X = D.isWebGLCubeRenderTarget === !0;
    if (D.depthTexture && !R.__autoAllocateDepthBuffer) {
      if (X)
        throw new Error("target.depthTexture not supported in Cube render targets");
      (function(Q, O) {
        if (O && O.isWebGLCubeRenderTarget)
          throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(i.FRAMEBUFFER, Q), !O.depthTexture || !O.depthTexture.isDepthTexture)
          throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        n.get(O.depthTexture).__webglTexture && O.depthTexture.image.width === O.width && O.depthTexture.image.height === O.height || (O.depthTexture.image.width = O.width, O.depthTexture.image.height = O.height, O.depthTexture.needsUpdate = !0), A(O.depthTexture, 0);
        const k = n.get(O.depthTexture).__webglTexture, E = te(O);
        if (O.depthTexture.format === cl)
          se(O) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, k, 0, E) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, k, 0);
        else {
          if (O.depthTexture.format !== xs)
            throw new Error("Unknown depthTexture format");
          se(O) ? o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, k, 0, E) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, k, 0);
        }
      })(R.__webglFramebuffer, D);
    } else if (X) {
      R.__webglDepthbuffer = [];
      for (let Q = 0; Q < 6; Q++)
        t.bindFramebuffer(i.FRAMEBUFFER, R.__webglFramebuffer[Q]), R.__webglDepthbuffer[Q] = i.createRenderbuffer(), re(R.__webglDepthbuffer[Q], D, !1);
    } else
      t.bindFramebuffer(i.FRAMEBUFFER, R.__webglFramebuffer), R.__webglDepthbuffer = i.createRenderbuffer(), re(R.__webglDepthbuffer, D, !1);
    t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  const me = [], Se = [];
  function te(D) {
    return Math.min(r.maxSamples, D.samples);
  }
  function se(D) {
    const R = n.get(D);
    return D.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && R.__useRenderToTexture !== !1;
  }
  function he(D, R) {
    const X = D.colorSpace, Q = D.format, O = D.type;
    return D.isCompressedTexture === !0 || D.isVideoTexture === !0 || X !== on && X !== la && (rt.getTransfer(X) === ft ? Q === ai && O === fs || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", X)), R;
  }
  function ae(D) {
    return typeof HTMLImageElement != "undefined" && D instanceof HTMLImageElement ? (c.width = D.naturalWidth || D.width, c.height = D.naturalHeight || D.height) : typeof VideoFrame != "undefined" && D instanceof VideoFrame ? (c.width = D.displayWidth, c.height = D.displayHeight) : (c.width = D.width, c.height = D.height), c;
  }
  this.allocateTextureUnit = function() {
    const D = T;
    return D >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + D + " texture units while this GPU supports only " + r.maxTextures), T += 1, D;
  }, this.resetTextureUnits = function() {
    T = 0;
  }, this.setTexture2D = A, this.setTexture2DArray = function(D, R) {
    const X = n.get(D);
    D.version > 0 && X.__version !== D.version ? z(X, D, R) : t.bindTexture(i.TEXTURE_2D_ARRAY, X.__webglTexture, i.TEXTURE0 + R);
  }, this.setTexture3D = function(D, R) {
    const X = n.get(D);
    D.version > 0 && X.__version !== D.version ? z(X, D, R) : t.bindTexture(i.TEXTURE_3D, X.__webglTexture, i.TEXTURE0 + R);
  }, this.setTextureCube = function(D, R) {
    const X = n.get(D);
    D.version > 0 && X.__version !== D.version ? function(Q, O, k) {
      if (O.image.length !== 6)
        return;
      const E = F(Q, O), U = O.source;
      t.bindTexture(i.TEXTURE_CUBE_MAP, Q.__webglTexture, i.TEXTURE0 + k);
      const B = n.get(U);
      if (U.version !== B.__version || E === !0) {
        t.activeTexture(i.TEXTURE0 + k);
        const ne = rt.getPrimaries(rt.workingColorSpace), V = O.colorSpace === la ? null : rt.getPrimaries(O.colorSpace), de = O.colorSpace === la || ne === V ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
        i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, O.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, O.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, de);
        const xe = O.isCompressedTexture || O.image[0].isCompressedTexture, ue = O.image[0] && O.image[0].isDataTexture, H = [];
        for (let Ce = 0; Ce < 6; Ce++)
          H[Ce] = xe || ue ? ue ? O.image[Ce].image : O.image[Ce] : v(O.image[Ce], !0, r.maxCubemapSize), H[Ce] = he(O, H[Ce]);
        const j = H[0], $ = s.convert(O.format, O.colorSpace), be = s.convert(O.type), Ne = g(O.internalFormat, $, be, O.colorSpace), Be = O.isVideoTexture !== !0, Me = B.__version === void 0 || E === !0, Ve = U.dataReady;
        let ze, Ct = x(O, j);
        if (N(i.TEXTURE_CUBE_MAP, O), xe) {
          Be && Me && t.texStorage2D(i.TEXTURE_CUBE_MAP, Ct, Ne, j.width, j.height);
          for (let Ce = 0; Ce < 6; Ce++) {
            ze = H[Ce].mipmaps;
            for (let at = 0; at < ze.length; at++) {
              const Le = ze[at];
              O.format !== ai ? $ !== null ? Be ? Ve && t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, at, 0, 0, Le.width, Le.height, $, Le.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, at, Ne, Le.width, Le.height, 0, Le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Be ? Ve && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, at, 0, 0, Le.width, Le.height, $, be, Le.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, at, Ne, Le.width, Le.height, 0, $, be, Le.data);
            }
          }
        } else {
          if (ze = O.mipmaps, Be && Me) {
            ze.length > 0 && Ct++;
            const Ce = ae(H[0]);
            t.texStorage2D(i.TEXTURE_CUBE_MAP, Ct, Ne, Ce.width, Ce.height);
          }
          for (let Ce = 0; Ce < 6; Ce++)
            if (ue) {
              Be ? Ve && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, 0, 0, 0, H[Ce].width, H[Ce].height, $, be, H[Ce].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, 0, Ne, H[Ce].width, H[Ce].height, 0, $, be, H[Ce].data);
              for (let at = 0; at < ze.length; at++) {
                const Le = ze[at].image[Ce].image;
                Be ? Ve && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, at + 1, 0, 0, Le.width, Le.height, $, be, Le.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, at + 1, Ne, Le.width, Le.height, 0, $, be, Le.data);
              }
            } else {
              Be ? Ve && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, 0, 0, 0, $, be, H[Ce]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, 0, Ne, $, be, H[Ce]);
              for (let at = 0; at < ze.length; at++) {
                const Le = ze[at];
                Be ? Ve && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, at + 1, 0, 0, $, be, Le.image[Ce]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, at + 1, Ne, $, be, Le.image[Ce]);
              }
            }
        }
        m(O) && y(i.TEXTURE_CUBE_MAP), B.__version = U.version, O.onUpdate && O.onUpdate(O);
      }
      Q.__version = O.version;
    }(X, D, R) : t.bindTexture(i.TEXTURE_CUBE_MAP, X.__webglTexture, i.TEXTURE0 + R);
  }, this.rebindTextures = function(D, R, X) {
    const Q = n.get(D);
    R !== void 0 && q(Q.__webglFramebuffer, D, D.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), X !== void 0 && ie(D);
  }, this.setupRenderTarget = function(D) {
    const R = D.texture, X = n.get(D), Q = n.get(R);
    D.addEventListener("dispose", b);
    const O = D.textures, k = D.isWebGLCubeRenderTarget === !0, E = O.length > 1;
    if (E || (Q.__webglTexture === void 0 && (Q.__webglTexture = i.createTexture()), Q.__version = R.version, a.memory.textures++), k) {
      X.__webglFramebuffer = [];
      for (let U = 0; U < 6; U++)
        if (R.mipmaps && R.mipmaps.length > 0) {
          X.__webglFramebuffer[U] = [];
          for (let B = 0; B < R.mipmaps.length; B++)
            X.__webglFramebuffer[U][B] = i.createFramebuffer();
        } else
          X.__webglFramebuffer[U] = i.createFramebuffer();
    } else {
      if (R.mipmaps && R.mipmaps.length > 0) {
        X.__webglFramebuffer = [];
        for (let U = 0; U < R.mipmaps.length; U++)
          X.__webglFramebuffer[U] = i.createFramebuffer();
      } else
        X.__webglFramebuffer = i.createFramebuffer();
      if (E)
        for (let U = 0, B = O.length; U < B; U++) {
          const ne = n.get(O[U]);
          ne.__webglTexture === void 0 && (ne.__webglTexture = i.createTexture(), a.memory.textures++);
        }
      if (D.samples > 0 && se(D) === !1) {
        X.__webglMultisampledFramebuffer = i.createFramebuffer(), X.__webglColorRenderbuffer = [], t.bindFramebuffer(i.FRAMEBUFFER, X.__webglMultisampledFramebuffer);
        for (let U = 0; U < O.length; U++) {
          const B = O[U];
          X.__webglColorRenderbuffer[U] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, X.__webglColorRenderbuffer[U]);
          const ne = s.convert(B.format, B.colorSpace), V = s.convert(B.type), de = g(B.internalFormat, ne, V, B.colorSpace, D.isXRRenderTarget === !0), xe = te(D);
          i.renderbufferStorageMultisample(i.RENDERBUFFER, xe, de, D.width, D.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + U, i.RENDERBUFFER, X.__webglColorRenderbuffer[U]);
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null), D.depthBuffer && (X.__webglDepthRenderbuffer = i.createRenderbuffer(), re(X.__webglDepthRenderbuffer, D, !0)), t.bindFramebuffer(i.FRAMEBUFFER, null);
      }
    }
    if (k) {
      t.bindTexture(i.TEXTURE_CUBE_MAP, Q.__webglTexture), N(i.TEXTURE_CUBE_MAP, R);
      for (let U = 0; U < 6; U++)
        if (R.mipmaps && R.mipmaps.length > 0)
          for (let B = 0; B < R.mipmaps.length; B++)
            q(X.__webglFramebuffer[U][B], D, R, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + U, B);
        else
          q(X.__webglFramebuffer[U], D, R, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + U, 0);
      m(R) && y(i.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (E) {
      for (let U = 0, B = O.length; U < B; U++) {
        const ne = O[U], V = n.get(ne);
        t.bindTexture(i.TEXTURE_2D, V.__webglTexture), N(i.TEXTURE_2D, ne), q(X.__webglFramebuffer, D, ne, i.COLOR_ATTACHMENT0 + U, i.TEXTURE_2D, 0), m(ne) && y(i.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let U = i.TEXTURE_2D;
      if ((D.isWebGL3DRenderTarget || D.isWebGLArrayRenderTarget) && (U = D.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY), t.bindTexture(U, Q.__webglTexture), N(U, R), R.mipmaps && R.mipmaps.length > 0)
        for (let B = 0; B < R.mipmaps.length; B++)
          q(X.__webglFramebuffer[B], D, R, i.COLOR_ATTACHMENT0, U, B);
      else
        q(X.__webglFramebuffer, D, R, i.COLOR_ATTACHMENT0, U, 0);
      m(R) && y(U), t.unbindTexture();
    }
    D.depthBuffer && ie(D);
  }, this.updateRenderTargetMipmap = function(D) {
    const R = D.textures;
    for (let X = 0, Q = R.length; X < Q; X++) {
      const O = R[X];
      if (m(O)) {
        const k = D.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : i.TEXTURE_2D, E = n.get(O).__webglTexture;
        t.bindTexture(k, E), y(k), t.unbindTexture();
      }
    }
  }, this.updateMultisampleRenderTarget = function(D) {
    if (D.samples > 0) {
      if (se(D) === !1) {
        const R = D.textures, X = D.width, Q = D.height;
        let O = i.COLOR_BUFFER_BIT;
        const k = D.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, E = n.get(D), U = R.length > 1;
        if (U)
          for (let B = 0; B < R.length; B++)
            t.bindFramebuffer(i.FRAMEBUFFER, E.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + B, i.RENDERBUFFER, null), t.bindFramebuffer(i.FRAMEBUFFER, E.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + B, i.TEXTURE_2D, null, 0);
        t.bindFramebuffer(i.READ_FRAMEBUFFER, E.__webglMultisampledFramebuffer), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, E.__webglFramebuffer);
        for (let B = 0; B < R.length; B++) {
          if (D.resolveDepthBuffer && (D.depthBuffer && (O |= i.DEPTH_BUFFER_BIT), D.stencilBuffer && D.resolveStencilBuffer && (O |= i.STENCIL_BUFFER_BIT)), U) {
            i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, E.__webglColorRenderbuffer[B]);
            const ne = n.get(R[B]).__webglTexture;
            i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, ne, 0);
          }
          i.blitFramebuffer(0, 0, X, Q, 0, 0, X, Q, O, i.NEAREST), l === !0 && (me.length = 0, Se.length = 0, me.push(i.COLOR_ATTACHMENT0 + B), D.depthBuffer && D.resolveDepthBuffer === !1 && (me.push(k), Se.push(k), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, Se)), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, me));
        }
        if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), U)
          for (let B = 0; B < R.length; B++) {
            t.bindFramebuffer(i.FRAMEBUFFER, E.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + B, i.RENDERBUFFER, E.__webglColorRenderbuffer[B]);
            const ne = n.get(R[B]).__webglTexture;
            t.bindFramebuffer(i.FRAMEBUFFER, E.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + B, i.TEXTURE_2D, ne, 0);
          }
        t.bindFramebuffer(i.DRAW_FRAMEBUFFER, E.__webglMultisampledFramebuffer);
      } else if (D.depthBuffer && D.resolveDepthBuffer === !1 && l) {
        const R = D.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
        i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [R]);
      }
    }
  }, this.setupDepthRenderbuffer = ie, this.setupFrameBufferTexture = q, this.useMultisampledRTT = se;
}
function y2(i, e) {
  return { convert: function(t, n = "") {
    let r;
    const s = rt.getTransfer(n);
    if (t === fs)
      return i.UNSIGNED_BYTE;
    if (t === Cg)
      return i.UNSIGNED_SHORT_4_4_4_4;
    if (t === Rg)
      return i.UNSIGNED_SHORT_5_5_5_1;
    if (t === 35902)
      return i.UNSIGNED_INT_5_9_9_9_REV;
    if (t === 1010)
      return i.BYTE;
    if (t === 1011)
      return i.SHORT;
    if (t === ll)
      return i.UNSIGNED_SHORT;
    if (t === o1)
      return i.INT;
    if (t === Ba)
      return i.UNSIGNED_INT;
    if (t === si)
      return i.FLOAT;
    if (t === Vt)
      return i.HALF_FLOAT;
    if (t === 1021)
      return i.ALPHA;
    if (t === 1022)
      return i.RGB;
    if (t === ai)
      return i.RGBA;
    if (t === 1024)
      return i.LUMINANCE;
    if (t === 1025)
      return i.LUMINANCE_ALPHA;
    if (t === cl)
      return i.DEPTH_COMPONENT;
    if (t === xs)
      return i.DEPTH_STENCIL;
    if (t === l1)
      return i.RED;
    if (t === Pg)
      return i.RED_INTEGER;
    if (t === 1030)
      return i.RG;
    if (t === Lg)
      return i.RG_INTEGER;
    if (t === Dg)
      return i.RGBA_INTEGER;
    if (t === Gd || t === Vd || t === jd || t === Wd)
      if (s === ft) {
        if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r === null)
          return null;
        if (t === Gd)
          return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (t === Vd)
          return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (t === jd)
          return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (t === Wd)
          return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else {
        if (r = e.get("WEBGL_compressed_texture_s3tc"), r === null)
          return null;
        if (t === Gd)
          return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (t === Vd)
          return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (t === jd)
          return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (t === Wd)
          return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    if (t === Ng || t === Og || t === Ug || t === kg) {
      if (r = e.get("WEBGL_compressed_texture_pvrtc"), r === null)
        return null;
      if (t === Ng)
        return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (t === Og)
        return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (t === Ug)
        return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (t === kg)
        return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (t === Fg || t === Bg || t === zg) {
      if (r = e.get("WEBGL_compressed_texture_etc"), r === null)
        return null;
      if (t === Fg || t === Bg)
        return s === ft ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
      if (t === zg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (t === Hg || t === Gg || t === Vg || t === jg || t === Wg || t === Xg || t === qg || t === Yg || t === Zg || t === Kg || t === Qg || t === Jg || t === $g || t === e0) {
      if (r = e.get("WEBGL_compressed_texture_astc"), r === null)
        return null;
      if (t === Hg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (t === Gg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (t === Vg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (t === jg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (t === Wg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (t === Xg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (t === qg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (t === Yg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (t === Zg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (t === Kg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (t === Qg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (t === Jg)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (t === $g)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (t === e0)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
    }
    if (t === Xd || t === t0 || t === n0) {
      if (r = e.get("EXT_texture_compression_bptc"), r === null)
        return null;
      if (t === Xd)
        return s === ft ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      if (t === t0)
        return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
      if (t === n0)
        return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
    }
    if (t === 36283 || t === i0 || t === r0 || t === s0) {
      if (r = e.get("EXT_texture_compression_rgtc"), r === null)
        return null;
      if (t === Xd)
        return r.COMPRESSED_RED_RGTC1_EXT;
      if (t === i0)
        return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
      if (t === r0)
        return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
      if (t === s0)
        return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
    }
    return t === _s ? i.UNSIGNED_INT_24_8 : i[t] !== void 0 ? i[t] : null;
  } };
}
class KM extends jt {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class oi extends Fe {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const mA = { type: "move" };
class gm {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new oi(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new oi(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new S(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new S()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new oi(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new S(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new S()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let r = null, s = null, a = null;
    const o = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const v of e.hand.values()) {
          const m = t.getJointPose(v, n), y = this._getHandJoint(c, v);
          m !== null && (y.matrix.fromArray(m.transform.matrix), y.matrix.decompose(y.position, y.rotation, y.scale), y.matrixWorldNeedsUpdate = !0, y.jointRadius = m.radius), y.visible = m !== null;
        }
        const h = c.joints["index-finger-tip"], u = c.joints["thumb-tip"], d = h.position.distanceTo(u.position), p = 0.02, f = 5e-3;
        c.inputState.pinching && d > p + f ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !c.inputState.pinching && d <= p - f && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
      } else
        l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
      o !== null && (r = t.getPose(e.targetRaySpace, n), r === null && s !== null && (r = s), r !== null && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(mA)));
    }
    return o !== null && (o.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = a !== null), this;
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new oi();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class gA {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, n) {
    if (this.texture === null) {
      const r = new vt();
      e.properties.get(r).__webglTexture = t.texture, t.depthNear == n.depthNear && t.depthFar == n.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, n = new st({ vertexShader: `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, fragmentShader: `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: t.z }, depthHeight: { value: t.w } } });
      this.mesh = new ve(new Qa(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
}
class vA extends lr {
  constructor(e, t) {
    super();
    const n = this;
    let r = null, s = 1, a = null, o = "local-floor", l = 1, c = null, h = null, u = null, d = null, p = null, f = null;
    const v = new gA(), m = t.getContextAttributes();
    let y = null, g = null;
    const _ = [], x = [], M = new Y();
    let b = null;
    const w = new jt();
    w.layers.enable(1), w.viewport = new je();
    const T = new jt();
    T.layers.enable(2), T.viewport = new je();
    const A = [w, T], L = new KM();
    L.layers.enable(1), L.layers.enable(2);
    let I = null, P = null;
    function N(te) {
      const se = x.indexOf(te.inputSource);
      if (se === -1)
        return;
      const he = _[se];
      he !== void 0 && (he.update(te.inputSource, te.frame, c || a), he.dispatchEvent({ type: te.type, data: te.inputSource }));
    }
    function F() {
      r.removeEventListener("select", N), r.removeEventListener("selectstart", N), r.removeEventListener("selectend", N), r.removeEventListener("squeeze", N), r.removeEventListener("squeezestart", N), r.removeEventListener("squeezeend", N), r.removeEventListener("end", F), r.removeEventListener("inputsourceschange", z);
      for (let te = 0; te < _.length; te++) {
        const se = x[te];
        se !== null && (x[te] = null, _[te].disconnect(se));
      }
      I = null, P = null, v.reset(), e.setRenderTarget(y), p = null, d = null, u = null, r = null, g = null, Se.stop(), n.isPresenting = !1, e.setPixelRatio(b), e.setSize(M.width, M.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    function z(te) {
      for (let se = 0; se < te.removed.length; se++) {
        const he = te.removed[se], ae = x.indexOf(he);
        ae >= 0 && (x[ae] = null, _[ae].disconnect(he));
      }
      for (let se = 0; se < te.added.length; se++) {
        const he = te.added[se];
        let ae = x.indexOf(he);
        if (ae === -1) {
          for (let R = 0; R < _.length; R++) {
            if (R >= x.length) {
              x.push(he), ae = R;
              break;
            }
            if (x[R] === null) {
              x[R] = he, ae = R;
              break;
            }
          }
          if (ae === -1)
            break;
        }
        const D = _[ae];
        D && D.connect(he);
      }
    }
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(te) {
      let se = _[te];
      return se === void 0 && (se = new gm(), _[te] = se), se.getTargetRaySpace();
    }, this.getControllerGrip = function(te) {
      let se = _[te];
      return se === void 0 && (se = new gm(), _[te] = se), se.getGripSpace();
    }, this.getHand = function(te) {
      let se = _[te];
      return se === void 0 && (se = new gm(), _[te] = se), se.getHandSpace();
    }, this.setFramebufferScaleFactor = function(te) {
      s = te, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(te) {
      o = te, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || a;
    }, this.setReferenceSpace = function(te) {
      c = te;
    }, this.getBaseLayer = function() {
      return d !== null ? d : p;
    }, this.getBinding = function() {
      return u;
    }, this.getFrame = function() {
      return f;
    }, this.getSession = function() {
      return r;
    }, this.setSession = function(te) {
      return di(this, null, function* () {
        if (r = te, r !== null) {
          if (y = e.getRenderTarget(), r.addEventListener("select", N), r.addEventListener("selectstart", N), r.addEventListener("selectend", N), r.addEventListener("squeeze", N), r.addEventListener("squeezestart", N), r.addEventListener("squeezeend", N), r.addEventListener("end", F), r.addEventListener("inputsourceschange", z), m.xrCompatible !== !0 && (yield t.makeXRCompatible()), b = e.getPixelRatio(), e.getSize(M), r.renderState.layers === void 0) {
            const se = { antialias: m.antialias, alpha: !0, depth: m.depth, stencil: m.stencil, framebufferScaleFactor: s };
            p = new XRWebGLLayer(r, t, se), r.updateRenderState({ baseLayer: p }), e.setPixelRatio(1), e.setSize(p.framebufferWidth, p.framebufferHeight, !1), g = new dt(p.framebufferWidth, p.framebufferHeight, { format: ai, type: fs, colorSpace: e.outputColorSpace, stencilBuffer: m.stencil });
          } else {
            let se = null, he = null, ae = null;
            m.depth && (ae = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, se = m.stencil ? xs : cl, he = m.stencil ? _s : Ba);
            const D = { colorFormat: t.RGBA8, depthFormat: ae, scaleFactor: s };
            u = new XRWebGLBinding(r, t), d = u.createProjectionLayer(D), r.updateRenderState({ layers: [d] }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), g = new dt(d.textureWidth, d.textureHeight, { format: ai, type: fs, depthTexture: new Bh(d.textureWidth, d.textureHeight, he, void 0, void 0, void 0, void 0, void 0, void 0, se), stencilBuffer: m.stencil, colorSpace: e.outputColorSpace, samples: m.antialias ? 4 : 0, resolveDepthBuffer: d.ignoreDepthValues === !1 });
          }
          g.isXRRenderTarget = !0, this.setFoveation(l), c = null, a = yield r.requestReferenceSpace(o), Se.setContext(r), Se.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
        }
      });
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    };
    const q = new S(), re = new S();
    function ie(te, se) {
      se === null ? te.matrixWorld.copy(te.matrix) : te.matrixWorld.multiplyMatrices(se.matrixWorld, te.matrix), te.matrixWorldInverse.copy(te.matrixWorld).invert();
    }
    this.updateCamera = function(te) {
      if (r === null)
        return;
      v.texture !== null && (te.near = v.depthNear, te.far = v.depthFar), L.near = T.near = w.near = te.near, L.far = T.far = w.far = te.far, I === L.near && P === L.far || (r.updateRenderState({ depthNear: L.near, depthFar: L.far }), I = L.near, P = L.far, w.near = I, w.far = P, T.near = I, T.far = P, w.updateProjectionMatrix(), T.updateProjectionMatrix(), te.updateProjectionMatrix());
      const se = te.parent, he = L.cameras;
      ie(L, se);
      for (let ae = 0; ae < he.length; ae++)
        ie(he[ae], se);
      he.length === 2 ? function(ae, D, R) {
        q.setFromMatrixPosition(D.matrixWorld), re.setFromMatrixPosition(R.matrixWorld);
        const X = q.distanceTo(re), Q = D.projectionMatrix.elements, O = R.projectionMatrix.elements, k = Q[14] / (Q[10] - 1), E = Q[14] / (Q[10] + 1), U = (Q[9] + 1) / Q[5], B = (Q[9] - 1) / Q[5], ne = (Q[8] - 1) / Q[0], V = (O[8] + 1) / O[0], de = k * ne, xe = k * V, ue = X / (-ne + V), H = ue * -ne;
        D.matrixWorld.decompose(ae.position, ae.quaternion, ae.scale), ae.translateX(H), ae.translateZ(ue), ae.matrixWorld.compose(ae.position, ae.quaternion, ae.scale), ae.matrixWorldInverse.copy(ae.matrixWorld).invert();
        const j = k + ue, $ = E + ue, be = de - H, Ne = xe + (X - H), Be = U * E / $ * j, Me = B * E / $ * j;
        ae.projectionMatrix.makePerspective(be, Ne, Be, Me, j, $), ae.projectionMatrixInverse.copy(ae.projectionMatrix).invert();
      }(L, w, T) : L.projectionMatrix.copy(w.projectionMatrix), function(ae, D, R) {
        R === null ? ae.matrix.copy(D.matrixWorld) : (ae.matrix.copy(R.matrixWorld), ae.matrix.invert(), ae.matrix.multiply(D.matrixWorld)), ae.matrix.decompose(ae.position, ae.quaternion, ae.scale), ae.updateMatrixWorld(!0), ae.projectionMatrix.copy(D.projectionMatrix), ae.projectionMatrixInverse.copy(D.projectionMatrixInverse), ae.isPerspectiveCamera && (ae.fov = 2 * dl * Math.atan(1 / ae.projectionMatrix.elements[5]), ae.zoom = 1);
      }(te, L, se);
    }, this.getCamera = function() {
      return L;
    }, this.getFoveation = function() {
      return d === null && p === null ? void 0 : l;
    }, this.setFoveation = function(te) {
      l = te, d !== null && (d.fixedFoveation = te), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = te);
    }, this.hasDepthSensing = function() {
      return v.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return v.getMesh(L);
    };
    let me = null;
    const Se = new jM();
    Se.setAnimationLoop(function(te, se) {
      if (h = se.getViewerPose(c || a), f = se, h !== null) {
        const he = h.views;
        p !== null && (e.setRenderTargetFramebuffer(g, p.framebuffer), e.setRenderTarget(g));
        let ae = !1;
        he.length !== L.cameras.length && (L.cameras.length = 0, ae = !0);
        for (let R = 0; R < he.length; R++) {
          const X = he[R];
          let Q = null;
          if (p !== null)
            Q = p.getViewport(X);
          else {
            const k = u.getViewSubImage(d, X);
            Q = k.viewport, R === 0 && (e.setRenderTargetTextures(g, k.colorTexture, d.ignoreDepthValues ? void 0 : k.depthStencilTexture), e.setRenderTarget(g));
          }
          let O = A[R];
          O === void 0 && (O = new jt(), O.layers.enable(R), O.viewport = new je(), A[R] = O), O.matrix.fromArray(X.transform.matrix), O.matrix.decompose(O.position, O.quaternion, O.scale), O.projectionMatrix.fromArray(X.projectionMatrix), O.projectionMatrixInverse.copy(O.projectionMatrix).invert(), O.viewport.set(Q.x, Q.y, Q.width, Q.height), R === 0 && (L.matrix.copy(O.matrix), L.matrix.decompose(L.position, L.quaternion, L.scale)), ae === !0 && L.cameras.push(O);
        }
        const D = r.enabledFeatures;
        if (D && D.includes("depth-sensing")) {
          const R = u.getDepthInformation(he[0]);
          R && R.isValid && R.texture && v.init(e, R, r.renderState);
        }
      }
      for (let he = 0; he < _.length; he++) {
        const ae = x[he], D = _[he];
        ae !== null && D !== void 0 && D.update(ae, se, c || a);
      }
      me && me(te, se), se.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: se }), f = null;
    }), this.setAnimationLoop = function(te) {
      me = te;
    }, this.dispose = function() {
    };
  }
}
const Vs = new bt(), yA = new fe();
function _A(i, e) {
  function t(r, s) {
    r.matrixAutoUpdate === !0 && r.updateMatrix(), s.value.copy(r.matrix);
  }
  function n(r, s) {
    r.opacity.value = s.opacity, s.color && r.diffuse.value.copy(s.color), s.emissive && r.emissive.value.copy(s.emissive).multiplyScalar(s.emissiveIntensity), s.map && (r.map.value = s.map, t(s.map, r.mapTransform)), s.alphaMap && (r.alphaMap.value = s.alphaMap, t(s.alphaMap, r.alphaMapTransform)), s.bumpMap && (r.bumpMap.value = s.bumpMap, t(s.bumpMap, r.bumpMapTransform), r.bumpScale.value = s.bumpScale, s.side === kn && (r.bumpScale.value *= -1)), s.normalMap && (r.normalMap.value = s.normalMap, t(s.normalMap, r.normalMapTransform), r.normalScale.value.copy(s.normalScale), s.side === kn && r.normalScale.value.negate()), s.displacementMap && (r.displacementMap.value = s.displacementMap, t(s.displacementMap, r.displacementMapTransform), r.displacementScale.value = s.displacementScale, r.displacementBias.value = s.displacementBias), s.emissiveMap && (r.emissiveMap.value = s.emissiveMap, t(s.emissiveMap, r.emissiveMapTransform)), s.specularMap && (r.specularMap.value = s.specularMap, t(s.specularMap, r.specularMapTransform)), s.alphaTest > 0 && (r.alphaTest.value = s.alphaTest);
    const a = e.get(s), o = a.envMap, l = a.envMapRotation;
    o && (r.envMap.value = o, Vs.copy(l), Vs.x *= -1, Vs.y *= -1, Vs.z *= -1, o.isCubeTexture && o.isRenderTargetTexture === !1 && (Vs.y *= -1, Vs.z *= -1), r.envMapRotation.value.setFromMatrix4(yA.makeRotationFromEuler(Vs)), r.flipEnvMap.value = o.isCubeTexture && o.isRenderTargetTexture === !1 ? -1 : 1, r.reflectivity.value = s.reflectivity, r.ior.value = s.ior, r.refractionRatio.value = s.refractionRatio), s.lightMap && (r.lightMap.value = s.lightMap, r.lightMapIntensity.value = s.lightMapIntensity, t(s.lightMap, r.lightMapTransform)), s.aoMap && (r.aoMap.value = s.aoMap, r.aoMapIntensity.value = s.aoMapIntensity, t(s.aoMap, r.aoMapTransform));
  }
  return { refreshFogUniforms: function(r, s) {
    s.color.getRGB(r.fogColor.value, HM(i)), s.isFog ? (r.fogNear.value = s.near, r.fogFar.value = s.far) : s.isFogExp2 && (r.fogDensity.value = s.density);
  }, refreshMaterialUniforms: function(r, s, a, o, l) {
    s.isMeshBasicMaterial || s.isMeshLambertMaterial ? n(r, s) : s.isMeshToonMaterial ? (n(r, s), function(c, h) {
      h.gradientMap && (c.gradientMap.value = h.gradientMap);
    }(r, s)) : s.isMeshPhongMaterial ? (n(r, s), function(c, h) {
      c.specular.value.copy(h.specular), c.shininess.value = Math.max(h.shininess, 1e-4);
    }(r, s)) : s.isMeshStandardMaterial ? (n(r, s), function(c, h) {
      c.metalness.value = h.metalness, h.metalnessMap && (c.metalnessMap.value = h.metalnessMap, t(h.metalnessMap, c.metalnessMapTransform)), c.roughness.value = h.roughness, h.roughnessMap && (c.roughnessMap.value = h.roughnessMap, t(h.roughnessMap, c.roughnessMapTransform)), h.envMap && (c.envMapIntensity.value = h.envMapIntensity);
    }(r, s), s.isMeshPhysicalMaterial && function(c, h, u) {
      c.ior.value = h.ior, h.sheen > 0 && (c.sheenColor.value.copy(h.sheenColor).multiplyScalar(h.sheen), c.sheenRoughness.value = h.sheenRoughness, h.sheenColorMap && (c.sheenColorMap.value = h.sheenColorMap, t(h.sheenColorMap, c.sheenColorMapTransform)), h.sheenRoughnessMap && (c.sheenRoughnessMap.value = h.sheenRoughnessMap, t(h.sheenRoughnessMap, c.sheenRoughnessMapTransform))), h.clearcoat > 0 && (c.clearcoat.value = h.clearcoat, c.clearcoatRoughness.value = h.clearcoatRoughness, h.clearcoatMap && (c.clearcoatMap.value = h.clearcoatMap, t(h.clearcoatMap, c.clearcoatMapTransform)), h.clearcoatRoughnessMap && (c.clearcoatRoughnessMap.value = h.clearcoatRoughnessMap, t(h.clearcoatRoughnessMap, c.clearcoatRoughnessMapTransform)), h.clearcoatNormalMap && (c.clearcoatNormalMap.value = h.clearcoatNormalMap, t(h.clearcoatNormalMap, c.clearcoatNormalMapTransform), c.clearcoatNormalScale.value.copy(h.clearcoatNormalScale), h.side === kn && c.clearcoatNormalScale.value.negate())), h.dispersion > 0 && (c.dispersion.value = h.dispersion), h.iridescence > 0 && (c.iridescence.value = h.iridescence, c.iridescenceIOR.value = h.iridescenceIOR, c.iridescenceThicknessMinimum.value = h.iridescenceThicknessRange[0], c.iridescenceThicknessMaximum.value = h.iridescenceThicknessRange[1], h.iridescenceMap && (c.iridescenceMap.value = h.iridescenceMap, t(h.iridescenceMap, c.iridescenceMapTransform)), h.iridescenceThicknessMap && (c.iridescenceThicknessMap.value = h.iridescenceThicknessMap, t(h.iridescenceThicknessMap, c.iridescenceThicknessMapTransform))), h.transmission > 0 && (c.transmission.value = h.transmission, c.transmissionSamplerMap.value = u.texture, c.transmissionSamplerSize.value.set(u.width, u.height), h.transmissionMap && (c.transmissionMap.value = h.transmissionMap, t(h.transmissionMap, c.transmissionMapTransform)), c.thickness.value = h.thickness, h.thicknessMap && (c.thicknessMap.value = h.thicknessMap, t(h.thicknessMap, c.thicknessMapTransform)), c.attenuationDistance.value = h.attenuationDistance, c.attenuationColor.value.copy(h.attenuationColor)), h.anisotropy > 0 && (c.anisotropyVector.value.set(h.anisotropy * Math.cos(h.anisotropyRotation), h.anisotropy * Math.sin(h.anisotropyRotation)), h.anisotropyMap && (c.anisotropyMap.value = h.anisotropyMap, t(h.anisotropyMap, c.anisotropyMapTransform))), c.specularIntensity.value = h.specularIntensity, c.specularColor.value.copy(h.specularColor), h.specularColorMap && (c.specularColorMap.value = h.specularColorMap, t(h.specularColorMap, c.specularColorMapTransform)), h.specularIntensityMap && (c.specularIntensityMap.value = h.specularIntensityMap, t(h.specularIntensityMap, c.specularIntensityMapTransform));
    }(r, s, l)) : s.isMeshMatcapMaterial ? (n(r, s), function(c, h) {
      h.matcap && (c.matcap.value = h.matcap);
    }(r, s)) : s.isMeshDepthMaterial ? n(r, s) : s.isMeshDistanceMaterial ? (n(r, s), function(c, h) {
      const u = e.get(h).light;
      c.referencePosition.value.setFromMatrixPosition(u.matrixWorld), c.nearDistance.value = u.shadow.camera.near, c.farDistance.value = u.shadow.camera.far;
    }(r, s)) : s.isMeshNormalMaterial ? n(r, s) : s.isLineBasicMaterial ? (function(c, h) {
      c.diffuse.value.copy(h.color), c.opacity.value = h.opacity, h.map && (c.map.value = h.map, t(h.map, c.mapTransform));
    }(r, s), s.isLineDashedMaterial && function(c, h) {
      c.dashSize.value = h.dashSize, c.totalSize.value = h.dashSize + h.gapSize, c.scale.value = h.scale;
    }(r, s)) : s.isPointsMaterial ? function(c, h, u, d) {
      c.diffuse.value.copy(h.color), c.opacity.value = h.opacity, c.size.value = h.size * u, c.scale.value = 0.5 * d, h.map && (c.map.value = h.map, t(h.map, c.uvTransform)), h.alphaMap && (c.alphaMap.value = h.alphaMap, t(h.alphaMap, c.alphaMapTransform)), h.alphaTest > 0 && (c.alphaTest.value = h.alphaTest);
    }(r, s, a, o) : s.isSpriteMaterial ? function(c, h) {
      c.diffuse.value.copy(h.color), c.opacity.value = h.opacity, c.rotation.value = h.rotation, h.map && (c.map.value = h.map, t(h.map, c.mapTransform)), h.alphaMap && (c.alphaMap.value = h.alphaMap, t(h.alphaMap, c.alphaMapTransform)), h.alphaTest > 0 && (c.alphaTest.value = h.alphaTest);
    }(r, s) : s.isShadowMaterial ? (r.color.value.copy(s.color), r.opacity.value = s.opacity) : s.isShaderMaterial && (s.uniformsNeedUpdate = !1);
  } };
}
function xA(i, e, t, n) {
  let r = {}, s = {}, a = [];
  const o = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(u, d, p, f) {
    const v = u.value, m = d + "_" + p;
    if (f[m] === void 0)
      return f[m] = typeof v == "number" || typeof v == "boolean" ? v : v.clone(), !0;
    {
      const y = f[m];
      if (typeof v == "number" || typeof v == "boolean") {
        if (y !== v)
          return f[m] = v, !0;
      } else if (y.equals(v) === !1)
        return y.copy(v), !0;
    }
    return !1;
  }
  function c(u) {
    const d = { boundary: 0, storage: 0 };
    return typeof u == "number" || typeof u == "boolean" ? (d.boundary = 4, d.storage = 4) : u.isVector2 ? (d.boundary = 8, d.storage = 8) : u.isVector3 || u.isColor ? (d.boundary = 16, d.storage = 12) : u.isVector4 ? (d.boundary = 16, d.storage = 16) : u.isMatrix3 ? (d.boundary = 48, d.storage = 48) : u.isMatrix4 ? (d.boundary = 64, d.storage = 64) : u.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", u), d;
  }
  function h(u) {
    const d = u.target;
    d.removeEventListener("dispose", h);
    const p = a.indexOf(d.__bindingPointIndex);
    a.splice(p, 1), i.deleteBuffer(r[d.id]), delete r[d.id], delete s[d.id];
  }
  return { bind: function(u, d) {
    const p = d.program;
    n.uniformBlockBinding(u, p);
  }, update: function(u, d) {
    let p = r[u.id];
    p === void 0 && (function(m) {
      const y = m.uniforms;
      let g = 0;
      const _ = 16;
      for (let M = 0, b = y.length; M < b; M++) {
        const w = Array.isArray(y[M]) ? y[M] : [y[M]];
        for (let T = 0, A = w.length; T < A; T++) {
          const L = w[T], I = Array.isArray(L.value) ? L.value : [L.value];
          for (let P = 0, N = I.length; P < N; P++) {
            const F = c(I[P]), z = g % _;
            z !== 0 && _ - z < F.boundary && (g += _ - z), L.__data = new Float32Array(F.storage / Float32Array.BYTES_PER_ELEMENT), L.__offset = g, g += F.storage;
          }
        }
      }
      const x = g % _;
      x > 0 && (g += _ - x), m.__size = g, m.__cache = {};
    }(u), p = function(m) {
      const y = function() {
        for (let M = 0; M < o; M++)
          if (a.indexOf(M) === -1)
            return a.push(M), M;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
      }();
      m.__bindingPointIndex = y;
      const g = i.createBuffer(), _ = m.__size, x = m.usage;
      return i.bindBuffer(i.UNIFORM_BUFFER, g), i.bufferData(i.UNIFORM_BUFFER, _, x), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, y, g), g;
    }(u), r[u.id] = p, u.addEventListener("dispose", h));
    const f = d.program;
    n.updateUBOMapping(u, f);
    const v = e.render.frame;
    s[u.id] !== v && (function(m) {
      const y = r[m.id], g = m.uniforms, _ = m.__cache;
      i.bindBuffer(i.UNIFORM_BUFFER, y);
      for (let x = 0, M = g.length; x < M; x++) {
        const b = Array.isArray(g[x]) ? g[x] : [g[x]];
        for (let w = 0, T = b.length; w < T; w++) {
          const A = b[w];
          if (l(A, x, w, _) === !0) {
            const L = A.__offset, I = Array.isArray(A.value) ? A.value : [A.value];
            let P = 0;
            for (let N = 0; N < I.length; N++) {
              const F = I[N], z = c(F);
              typeof F == "number" || typeof F == "boolean" ? (A.__data[0] = F, i.bufferSubData(i.UNIFORM_BUFFER, L + P, A.__data)) : F.isMatrix3 ? (A.__data[0] = F.elements[0], A.__data[1] = F.elements[1], A.__data[2] = F.elements[2], A.__data[3] = 0, A.__data[4] = F.elements[3], A.__data[5] = F.elements[4], A.__data[6] = F.elements[5], A.__data[7] = 0, A.__data[8] = F.elements[6], A.__data[9] = F.elements[7], A.__data[10] = F.elements[8], A.__data[11] = 0) : (F.toArray(A.__data, P), P += z.storage / Float32Array.BYTES_PER_ELEMENT);
            }
            i.bufferSubData(i.UNIFORM_BUFFER, L, A.__data);
          }
        }
      }
      i.bindBuffer(i.UNIFORM_BUFFER, null);
    }(u), s[u.id] = v);
  }, dispose: function() {
    for (const u in r)
      i.deleteBuffer(r[u]);
    a = [], r = {}, s = {};
  } };
}
class cp {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new ce(e), this.density = t;
  }
  clone() {
    return new cp(this.color, this.density);
  }
  toJSON() {
    return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density };
  }
}
class ah {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new ce(e), this.near = t, this.far = n;
  }
  clone() {
    return new ah(this.color, this.near, this.far);
  }
  toJSON() {
    return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far };
  }
}
class _2 extends Fe {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new bt(), this.environmentIntensity = 1, this.environmentRotation = new bt(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
}
class zh {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = nh, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = ci();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return d1("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ci()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ci()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
  }
}
const Cn = new S();
class Gn {
  constructor(e, t, n, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = r;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Cn.fromBufferAttribute(this, t), Cn.applyMatrix4(e), this.setXYZ(t, Cn.x, Cn.y, Cn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Cn.fromBufferAttribute(this, t), Cn.applyNormalMatrix(e), this.setXYZ(t, Cn.x, Cn.y, Cn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Cn.fromBufferAttribute(this, t), Cn.transformDirection(e), this.setXYZ(t, Cn.x, Cn.y, Cn.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = On(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = ke(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
  }
  setX(e, t) {
    return this.normalized && (t = ke(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = ke(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = ke(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = ke(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = On(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = On(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = On(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = On(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ke(t, this.array), n = ke(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ke(t, this.array), n = ke(n, this.array), r = ke(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this;
  }
  setXYZW(e, t, n, r, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ke(t, this.array), n = ke(n, this.array), r = ke(r, this.array), s = ke(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return new it(new this.array.constructor(t), this.itemSize, this.normalized);
    }
    return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Gn(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
    }
    return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
}
class Kp extends Wt {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new ce(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let yo;
const tc = new S(), _o = new S(), xo = new S(), bo = new Y(), nc = new Y(), QM = new fe(), ju = new S(), ic = new S(), Wu = new S(), x2 = new Y(), vm = new Y(), b2 = new Y();
class M2 extends Fe {
  constructor(e = new Kp()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", yo === void 0) {
      yo = new Re();
      const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), n = new zh(t, 5);
      yo.setIndex([0, 1, 2, 0, 2, 3]), yo.setAttribute("position", new Gn(n, 3, 0, !1)), yo.setAttribute("uv", new Gn(n, 2, 3, !1));
    }
    this.geometry = yo, this.material = e, this.center = new Y(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _o.setFromMatrixScale(this.matrixWorld), QM.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), xo.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && _o.multiplyScalar(-xo.z);
    const n = this.material.rotation;
    let r, s;
    n !== 0 && (s = Math.cos(n), r = Math.sin(n));
    const a = this.center;
    Xu(ju.set(-0.5, -0.5, 0), xo, a, _o, r, s), Xu(ic.set(0.5, -0.5, 0), xo, a, _o, r, s), Xu(Wu.set(0.5, 0.5, 0), xo, a, _o, r, s), x2.set(0, 0), vm.set(1, 0), b2.set(1, 1);
    let o = e.ray.intersectTriangle(ju, ic, Wu, !1, tc);
    if (o === null && (Xu(ic.set(-0.5, 0.5, 0), xo, a, _o, r, s), vm.set(0, 1), o = e.ray.intersectTriangle(ju, Wu, ic, !1, tc), o === null))
      return;
    const l = e.ray.origin.distanceTo(tc);
    l < e.near || l > e.far || t.push({ distance: l, point: tc.clone(), uv: ni.getInterpolation(tc, ju, ic, Wu, x2, vm, b2, new Y()), face: null, object: this });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Xu(i, e, t, n, r, s) {
  bo.subVectors(i, t).addScalar(0.5).multiply(n), r !== void 0 ? (nc.x = s * bo.x - r * bo.y, nc.y = r * bo.x + s * bo.y) : nc.copy(bo), i.copy(e), i.x += nc.x, i.y += nc.y, i.applyMatrix4(QM);
}
const qu = new S(), w2 = new S();
class S2 extends Fe {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++)
      ;
    return r.splice(s, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, r;
      for (n = 1, r = t.length; n < r; n++) {
        let s = t[n].distance;
        if (t[n].object.visible && (s -= s * t[n].hysteresis), e < s)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      qu.setFromMatrixPosition(this.matrixWorld);
      const n = e.ray.origin.distanceTo(qu);
      this.getObjectForDistance(n).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      qu.setFromMatrixPosition(e.matrixWorld), w2.setFromMatrixPosition(this.matrixWorld);
      const n = qu.distanceTo(w2) / e.zoom;
      let r, s;
      for (t[0].object.visible = !0, r = 1, s = t.length; r < s; r++) {
        let a = t[r].distance;
        if (t[r].object.visible && (a -= a * t[r].hysteresis), !(n >= a))
          break;
        t[r - 1].object.visible = !1, t[r].object.visible = !0;
      }
      for (this._currentLevel = r - 1; r < s; r++)
        t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let r = 0, s = n.length; r < s; r++) {
      const a = n[r];
      t.object.levels.push({ object: a.object.uuid, distance: a.distance, hysteresis: a.hysteresis });
    }
    return t;
  }
}
const T2 = new S(), E2 = new je(), A2 = new je(), bA = new S(), I2 = new fe(), Yu = new S(), ym = new an(), C2 = new fe(), _m = new Ka();
class hp extends ve {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Ig, this.bindMatrix = new fe(), this.bindMatrixInverse = new fe(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new sn()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Yu), this.boundingBox.expandByPoint(Yu);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new an()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Yu), this.boundingSphere.expandByPoint(Yu);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, r = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), ym.copy(this.boundingSphere), ym.applyMatrix4(r), e.ray.intersectsSphere(ym) !== !1 && (C2.copy(r).invert(), _m.copy(e.ray).applyMatrix4(C2), this.boundingBox !== null && _m.intersectsBox(this.boundingBox) === !1 || this._computeIntersections(e, t, _m)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new je(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, r = t.count; n < r; n++) {
      e.fromBufferAttribute(t, n);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === Ig ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === UM ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, r = this.geometry;
    E2.fromBufferAttribute(r.attributes.skinIndex, e), A2.fromBufferAttribute(r.attributes.skinWeight, e), T2.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const a = A2.getComponent(s);
      if (a !== 0) {
        const o = E2.getComponent(s);
        I2.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(bA.copy(T2).applyMatrix4(I2), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class fl extends Fe {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Cr extends vt {
  constructor(e = null, t = 1, n = 1, r, s, a, o, l, c = 1003, h = 1003, u, d) {
    super(null, a, o, l, c, h, r, s, u, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const R2 = new fe(), MA = new fe();
class ml {
  constructor(e = [], t = []) {
    this.uuid = ci(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(16 * e.length), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, r = this.bones.length; n < r; n++)
        this.boneInverses.push(new fe());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new fe();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s] ? e[s].matrixWorld : MA;
      R2.multiplyMatrices(o, t[s]), R2.toArray(n, 16 * s);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new ml(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(4 * this.bones.length);
    e = 4 * Math.ceil(e / 4), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Cr(t, e, e, ai, si);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const r = this.bones[t];
      if (r.name === e)
        return r;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, r = e.bones.length; n < r; n++) {
      const s = e.bones[n];
      let a = t[s];
      a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), a = new fl()), this.bones.push(a), this.boneInverses.push(new fe().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const a = t[r];
      e.bones.push(a.uuid);
      const o = n[r];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class Sa extends it {
  constructor(e, t, n, r = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const Mo = new fe(), P2 = new fe(), Zu = [], L2 = new sn(), wA = new fe(), rc = new ve(), sc = new an();
class u0 extends ve {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Sa(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let r = 0; r < n; r++)
      this.setMatrixAt(r, wA);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new sn()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Mo), L2.copy(e.boundingBox).applyMatrix4(Mo), this.boundingBox.union(L2);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new an()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Mo), sc.copy(e.boundingSphere).applyMatrix4(Mo), this.boundingSphere.union(sc);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, 3 * e);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, 16 * e);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences, r = this.morphTexture.source.data.data, s = e * (n.length + 1) + 1;
    for (let a = 0; a < n.length; a++)
      n[a] = r[s + a];
  }
  raycast(e, t) {
    const n = this.matrixWorld, r = this.count;
    if (rc.geometry = this.geometry, rc.material = this.material, rc.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), sc.copy(this.boundingSphere), sc.applyMatrix4(n), e.ray.intersectsSphere(sc) !== !1))
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, Mo), P2.multiplyMatrices(n, Mo), rc.matrixWorld = P2, rc.raycast(e, Zu);
        for (let a = 0, o = Zu.length; a < o; a++) {
          const l = Zu[a];
          l.instanceId = s, l.object = this, t.push(l);
        }
        Zu.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Sa(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, 16 * e);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences, r = n.length + 1;
    this.morphTexture === null && (this.morphTexture = new Cr(new Float32Array(r * this.count), r, this.count, l1, si));
    const s = this.morphTexture.source.data.data;
    let a = 0;
    for (let c = 0; c < n.length; c++)
      a += n[c];
    const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, l = r * e;
    s[l] = o, s.set(n, l + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
}
function SA(i, e) {
  return i.z - e.z;
}
function TA(i, e) {
  return e.z - i.z;
}
class EA {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t) {
    const n = this.pool, r = this.list;
    this.index >= n.length && n.push({ start: -1, count: -1, z: -1 });
    const s = n[this.index];
    r.push(s), this.index++, s.start = e.start, s.count = e.count, s.z = t;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const wo = "batchId", Qr = new fe(), xm = new fe(), AA = new fe(), IA = new ce(1, 1, 1), D2 = new fe(), bm = new sh(), Ku = new sn(), js = new an(), ac = new S(), N2 = new S(), CA = new S(), Mm = new EA(), wn = new ve(), Qu = [];
function RA(i, e, t = 0) {
  const n = e.itemSize;
  if (i.isInterleavedBufferAttribute || i.array.constructor !== e.array.constructor) {
    const r = i.count;
    for (let s = 0; s < r; s++)
      for (let a = 0; a < n; a++)
        e.setComponent(s + t, a, i.getComponent(s, a));
  } else
    e.array.set(i.array, t * n);
  e.needsUpdate = !0;
}
class O2 extends ve {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, n = 2 * t, r) {
    super(new Re(), r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture(), this._colorsTexture = null;
  }
  _initMatricesTexture() {
    let e = Math.sqrt(4 * this._maxGeometryCount);
    e = 4 * Math.ceil(e / 4), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), n = new Cr(t, e, e, ai, si);
    this._matricesTexture = n;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxGeometryCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1), n = new Cr(t, e, e, ai, si);
    n.colorSpace = rt.workingColorSpace, this._colorsTexture = n;
  }
  _initializeGeometry(e) {
    const t = this.geometry, n = this._maxVertexCount, r = this._maxGeometryCount, s = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const l = e.getAttribute(o), { array: c, itemSize: h, normalized: u } = l, d = new c.constructor(n * h), p = new it(d, h, u);
        t.setAttribute(o, p);
      }
      if (e.getIndex() !== null) {
        const o = n > 65536 ? new Uint32Array(s) : new Uint16Array(s);
        t.setIndex(new it(o, 1));
      }
      const a = r > 65536 ? new Uint32Array(n) : new Uint16Array(n);
      t.setAttribute(wo, new it(a, 1)), this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    if (e.getAttribute(wo))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${wo}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (n === wo)
        continue;
      if (!e.hasAttribute(n))
        throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
      const r = e.getAttribute(n), s = t.getAttribute(n);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new sn());
    const e = this._geometryCount, t = this.boundingBox, n = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      n[r] !== !1 && (this.getMatrixAt(r, Qr), this.getBoundingBoxAt(r, Ku).applyMatrix4(Qr), t.union(Ku));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new an());
    const e = this._geometryCount, t = this.boundingSphere, n = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      n[r] !== !1 && (this.getMatrixAt(r, Qr), this.getBoundingSphereAt(r, js).applyMatrix4(Qr), t.union(js));
  }
  addGeometry(e, t = -1, n = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const r = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 };
    let s = null;
    const a = this._reservedRanges, o = this._drawRanges, l = this._bounds;
    this._geometryCount !== 0 && (s = a[a.length - 1]), r.vertexCount = t === -1 ? e.getAttribute("position").count : t, r.vertexStart = s === null ? 0 : s.vertexStart + s.vertexCount;
    const c = e.getIndex(), h = c !== null;
    if (h && (r.indexCount = n === -1 ? c.count : n, r.indexStart = s === null ? 0 : s.indexStart + s.indexCount), r.indexStart !== -1 && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const u = this._visibility, d = this._active, p = this._matricesTexture, f = this._matricesTexture.image.data, v = this._colorsTexture;
    u.push(!0), d.push(!0);
    const m = this._geometryCount;
    this._geometryCount++, AA.toArray(f, 16 * m), p.needsUpdate = !0, v !== null && (IA.toArray(v.image.data, 4 * m), v.needsUpdate = !0), a.push(r), o.push({ start: h ? r.indexStart : r.vertexStart, count: -1 }), l.push({ boxInitialized: !1, box: new sn(), sphereInitialized: !1, sphere: new an() });
    const y = this.geometry.getAttribute(wo);
    for (let g = 0; g < r.vertexCount; g++)
      y.setX(r.vertexStart + g, m);
    return y.needsUpdate = !0, this.setGeometryAt(m, e), m;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry, r = n.getIndex() !== null, s = n.getIndex(), a = t.getIndex(), o = this._reservedRanges[e];
    if (r && a.count > o.indexCount || t.attributes.position.count > o.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const l = o.vertexStart, c = o.vertexCount;
    for (const p in n.attributes) {
      if (p === wo)
        continue;
      const f = t.getAttribute(p), v = n.getAttribute(p);
      RA(f, v, l);
      const m = f.itemSize;
      for (let y = f.count, g = c; y < g; y++) {
        const _ = l + y;
        for (let x = 0; x < m; x++)
          v.setComponent(_, x, 0);
      }
      v.needsUpdate = !0, v.addUpdateRange(l * m, c * m);
    }
    if (r) {
      const p = o.indexStart;
      for (let f = 0; f < a.count; f++)
        s.setX(p + f, l + a.getX(f));
      for (let f = a.count, v = o.indexCount; f < v; f++)
        s.setX(p + f, l);
      s.needsUpdate = !0, s.addUpdateRange(p, o.indexCount);
    }
    const h = this._bounds[e];
    t.boundingBox !== null ? (h.box.copy(t.boundingBox), h.boxInitialized = !0) : h.boxInitialized = !1, t.boundingSphere !== null ? (h.sphere.copy(t.boundingSphere), h.sphereInitialized = !0) : h.sphereInitialized = !1;
    const u = this._drawRanges[e], d = t.getAttribute("position");
    return u.count = r ? a.count : d.count, this._visibilityChanged = !0, e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === !1 || (t[e] = !1, this._visibilityChanged = !0), this;
  }
  getInstanceCountAt(e) {
    return this._multiDrawInstances === null ? null : this._multiDrawInstances[e];
  }
  setInstanceCountAt(e, t) {
    return this._multiDrawInstances === null && (this._multiDrawInstances = new Int32Array(this._maxGeometryCount).fill(1)), this._multiDrawInstances[e] = t, e;
  }
  getBoundingBoxAt(e, t) {
    if (this._active[e] === !1)
      return null;
    const n = this._bounds[e], r = n.box, s = this.geometry;
    if (n.boxInitialized === !1) {
      r.makeEmpty();
      const a = s.index, o = s.attributes.position, l = this._drawRanges[e];
      for (let c = l.start, h = l.start + l.count; c < h; c++) {
        let u = c;
        a && (u = a.getX(u)), r.expandByPoint(ac.fromBufferAttribute(o, u));
      }
      n.boxInitialized = !0;
    }
    return t.copy(r), t;
  }
  getBoundingSphereAt(e, t) {
    if (this._active[e] === !1)
      return null;
    const n = this._bounds[e], r = n.sphere, s = this.geometry;
    if (n.sphereInitialized === !1) {
      r.makeEmpty(), this.getBoundingBoxAt(e, Ku), Ku.getCenter(r.center);
      const a = s.index, o = s.attributes.position, l = this._drawRanges[e];
      let c = 0;
      for (let h = l.start, u = l.start + l.count; h < u; h++) {
        let d = h;
        a && (d = a.getX(d)), ac.fromBufferAttribute(o, d), c = Math.max(c, r.center.distanceToSquared(ac));
      }
      r.radius = Math.sqrt(c), n.sphereInitialized = !0;
    }
    return t.copy(r), t;
  }
  setMatrixAt(e, t) {
    const n = this._active, r = this._matricesTexture, s = this._matricesTexture.image.data;
    return e >= this._geometryCount || n[e] === !1 || (t.toArray(s, 16 * e), r.needsUpdate = !0), this;
  }
  getMatrixAt(e, t) {
    const n = this._active, r = this._matricesTexture.image.data;
    return e >= this._geometryCount || n[e] === !1 ? null : t.fromArray(r, 16 * e);
  }
  setColorAt(e, t) {
    this._colorsTexture === null && this._initColorsTexture();
    const n = this._active, r = this._colorsTexture, s = this._colorsTexture.image.data;
    return e >= this._geometryCount || n[e] === !1 || (t.toArray(s, 4 * e), r.needsUpdate = !0), this;
  }
  getColorAt(e, t) {
    const n = this._active, r = this._colorsTexture.image.data;
    return e >= this._geometryCount || n[e] === !1 ? null : t.fromArray(r, 4 * e);
  }
  setVisibleAt(e, t) {
    const n = this._visibility, r = this._active;
    return e >= this._geometryCount || r[e] === !1 || n[e] === t || (n[e] = t, this._visibilityChanged = !0), this;
  }
  getVisibleAt(e) {
    const t = this._visibility, n = this._active;
    return !(e >= this._geometryCount || n[e] === !1) && t[e];
  }
  raycast(e, t) {
    const n = this._visibility, r = this._active, s = this._drawRanges, a = this._geometryCount, o = this.matrixWorld, l = this.geometry;
    wn.material = this.material, wn.geometry.index = l.index, wn.geometry.attributes = l.attributes, wn.geometry.boundingBox === null && (wn.geometry.boundingBox = new sn()), wn.geometry.boundingSphere === null && (wn.geometry.boundingSphere = new an());
    for (let c = 0; c < a; c++) {
      if (!n[c] || !r[c])
        continue;
      const h = s[c];
      wn.geometry.setDrawRange(h.start, h.count), this.getMatrixAt(c, wn.matrixWorld).premultiply(o), this.getBoundingBoxAt(c, wn.geometry.boundingBox), this.getBoundingSphereAt(c, wn.geometry.boundingSphere), wn.raycast(e, Qu);
      for (let u = 0, d = Qu.length; u < d; u++) {
        const p = Qu[u];
        p.object = this, p.batchId = c, t.push(p);
      }
      Qu.length = 0;
    }
    wn.material = null, wn.geometry.index = null, wn.geometry.attributes = {}, wn.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => Ee({}, t)), this._reservedRanges = e._reservedRanges.map((t) => Ee({}, t)), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({ boxInitialized: t.boxInitialized, box: t.box.clone(), sphereInitialized: t.sphereInitialized, sphere: t.sphere.clone() })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.slice()), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null), this;
  }
  onBeforeRender(e, t, n, r, s) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const a = r.getIndex(), o = a === null ? 1 : a.array.BYTES_PER_ELEMENT, l = this._active, c = this._visibility, h = this._multiDrawStarts, u = this._multiDrawCounts, d = this._drawRanges, p = this.perObjectFrustumCulled;
    p && (D2.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), bm.setFromProjectionMatrix(D2, e.coordinateSystem));
    let f = 0;
    if (this.sortObjects) {
      xm.copy(this.matrixWorld).invert(), ac.setFromMatrixPosition(n.matrixWorld).applyMatrix4(xm), N2.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(xm);
      for (let y = 0, g = c.length; y < g; y++)
        if (c[y] && l[y]) {
          this.getMatrixAt(y, Qr), this.getBoundingSphereAt(y, js).applyMatrix4(Qr);
          let _ = !1;
          if (p && (_ = !bm.intersectsSphere(js)), !_) {
            const x = CA.subVectors(js.center, ac).dot(N2);
            Mm.push(d[y], x);
          }
        }
      const v = Mm.list, m = this.customSort;
      m === null ? v.sort(s.transparent ? TA : SA) : m.call(this, v, n);
      for (let y = 0, g = v.length; y < g; y++) {
        const _ = v[y];
        h[f] = _.start * o, u[f] = _.count, f++;
      }
      Mm.reset();
    } else
      for (let v = 0, m = c.length; v < m; v++)
        if (c[v] && l[v]) {
          let y = !1;
          if (p && (this.getMatrixAt(v, Qr), this.getBoundingSphereAt(v, js).applyMatrix4(Qr), y = !bm.intersectsSphere(js)), !y) {
            const g = d[v];
            h[f] = g.start * o, u[f] = g.count, f++;
          }
        }
    this._multiDrawCount = f, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, n, r, s, a) {
    this.onBeforeRender(e, null, r, s, a);
  }
}
class zt extends Wt {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new ce(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const up = new S(), dp = new S(), U2 = new fe(), oc = new Ka(), Ju = new an(), wm = new S(), k2 = new S();
class dn extends Fe {
  constructor(e = new Re(), t = new zt()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let r = 1, s = t.count; r < s; r++)
        up.fromBufferAttribute(t, r - 1), dp.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += up.distanceTo(dp);
      e.setAttribute("lineDistance", new ye(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Ju.copy(n.boundingSphere), Ju.applyMatrix4(r), Ju.radius += s, e.ray.intersectsSphere(Ju) === !1)
      return;
    U2.copy(r).invert(), oc.copy(e.ray).applyMatrix4(U2);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = this.isLineSegments ? 2 : 1, h = n.index, u = n.attributes.position;
    if (h !== null) {
      const d = Math.max(0, a.start), p = Math.min(h.count, a.start + a.count);
      for (let f = d, v = p - 1; f < v; f += c) {
        const m = h.getX(f), y = h.getX(f + 1), g = $u(this, e, oc, l, m, y);
        g && t.push(g);
      }
      if (this.isLineLoop) {
        const f = h.getX(p - 1), v = h.getX(d), m = $u(this, e, oc, l, f, v);
        m && t.push(m);
      }
    } else {
      const d = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count);
      for (let f = d, v = p - 1; f < v; f += c) {
        const m = $u(this, e, oc, l, f, f + 1);
        m && t.push(m);
      }
      if (this.isLineLoop) {
        const f = $u(this, e, oc, l, p - 1, d);
        f && t.push(f);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const n = e[t[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, s = n.length; r < s; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function $u(i, e, t, n, r, s) {
  const a = i.geometry.attributes.position;
  if (up.fromBufferAttribute(a, r), dp.fromBufferAttribute(a, s), t.distanceSqToSegment(up, dp, wm, k2) > n)
    return;
  wm.applyMatrix4(i.matrixWorld);
  const o = e.ray.origin.distanceTo(wm);
  return o < e.near || o > e.far ? void 0 : { distance: o, point: k2.clone().applyMatrix4(i.matrixWorld), index: r, face: null, faceIndex: null, object: i };
}
const F2 = new S(), B2 = new S();
class Qn extends dn {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        F2.fromBufferAttribute(t, r), B2.fromBufferAttribute(t, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + F2.distanceTo(B2);
      e.setAttribute("lineDistance", new ye(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class d0 extends dn {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class ss extends Wt {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new ce(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const z2 = new fe(), p0 = new Ka(), ed = new an(), td = new S();
class Qo extends Fe {
  constructor(e = new Re(), t = new ss()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), ed.copy(n.boundingSphere), ed.applyMatrix4(r), ed.radius += s, e.ray.intersectsSphere(ed) === !1)
      return;
    z2.copy(r).invert(), p0.copy(e.ray).applyMatrix4(z2);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = n.index, h = n.attributes.position;
    if (c !== null)
      for (let u = Math.max(0, a.start), d = Math.min(c.count, a.start + a.count); u < d; u++) {
        const p = c.getX(u);
        td.fromBufferAttribute(h, p), H2(td, p, l, r, e, t, this);
      }
    else
      for (let u = Math.max(0, a.start), d = Math.min(h.count, a.start + a.count); u < d; u++)
        td.fromBufferAttribute(h, u), H2(td, u, l, r, e, t, this);
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const n = e[t[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, s = n.length; r < s; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function H2(i, e, t, n, r, s, a) {
  const o = p0.distanceSqToPoint(i);
  if (o < t) {
    const l = new S();
    p0.closestPointToPoint(i, l), l.applyMatrix4(n);
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far)
      return;
    s.push({ distance: c, distanceToRay: Math.sqrt(o), point: l, index: e, face: null, object: a });
  }
}
class JM extends vt {
  constructor(e, t, n, r, s, a, o, l, c) {
    super(e, t, n, r, s, a, o, l, c), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : Gt, this.magFilter = s !== void 0 ? s : Gt, this.generateMipmaps = !1;
    const h = this;
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function u() {
      h.needsUpdate = !0, e.requestVideoFrameCallback(u);
    });
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    !("requestVideoFrameCallback" in e) && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class nd extends vt {
  constructor(e, t, n, r, s, a, o, l, c, h, u, d) {
    super(null, a, o, l, c, h, r, s, u, d), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Ei {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, r = this.getPoint(0), s = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      n = this.getPoint(a / e), s += n.distanceTo(r), t.push(s), r = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let r = 0;
    const s = n.length;
    let a;
    a = t || e * n[s - 1];
    let o, l = 0, c = s - 1;
    for (; l <= c; )
      if (r = Math.floor(l + (c - l) / 2), o = n[r] - a, o < 0)
        l = r + 1;
      else {
        if (!(o > 0)) {
          c = r;
          break;
        }
        c = r - 1;
      }
    if (r = c, n[r] === a)
      return r / (s - 1);
    const h = n[r];
    return (r + (a - h) / (n[r + 1] - h)) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4, s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const a = this.getPoint(r), o = this.getPoint(s), l = t || (a.isVector2 ? new Y() : new S());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new S(), r = [], s = [], a = [], o = new S(), l = new fe();
    for (let p = 0; p <= e; p++) {
      const f = p / e;
      r[p] = this.getTangentAt(f, new S());
    }
    s[0] = new S(), a[0] = new S();
    let c = Number.MAX_VALUE;
    const h = Math.abs(r[0].x), u = Math.abs(r[0].y), d = Math.abs(r[0].z);
    h <= c && (c = h, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), d <= c && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), s[0].crossVectors(r[0], o), a[0].crossVectors(r[0], s[0]);
    for (let p = 1; p <= e; p++) {
      if (s[p] = s[p - 1].clone(), a[p] = a[p - 1].clone(), o.crossVectors(r[p - 1], r[p]), o.length() > Number.EPSILON) {
        o.normalize();
        const f = Math.acos(Dt(r[p - 1].dot(r[p]), -1, 1));
        s[p].applyMatrix4(l.makeRotationAxis(o, f));
      }
      a[p].crossVectors(r[p], s[p]);
    }
    if (t === !0) {
      let p = Math.acos(Dt(s[0].dot(s[e]), -1, 1));
      p /= e, r[0].dot(o.crossVectors(s[0], s[e])) > 0 && (p = -p);
      for (let f = 1; f <= e; f++)
        s[f].applyMatrix4(l.makeRotationAxis(r[f], p * f)), a[f].crossVectors(r[f], s[f]);
    }
    return { tangents: r, normals: s, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Qp extends Ei {
  constructor(e = 0, t = 0, n = 1, r = 1, s = 0, a = 2 * Math.PI, o = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = a, this.aClockwise = o, this.aRotation = l;
  }
  getPoint(e, t = new Y()) {
    const n = t, r = 2 * Math.PI;
    let s = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += r;
    for (; s > r; )
      s -= r;
    s < Number.EPSILON && (s = a ? 0 : r), this.aClockwise !== !0 || a || (s === r ? s = -r : s -= r);
    const o = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(o), c = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), u = Math.sin(this.aRotation), d = l - this.aX, p = c - this.aY;
      l = d * h - p * u + this.aX, c = d * u + p * h + this.aY;
    }
    return n.set(l, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class $M extends Qp {
  constructor(e, t, n, r, s, a) {
    super(e, t, n, n, r, s, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function g1() {
  let i = 0, e = 0, t = 0, n = 0;
  function r(s, a, o, l) {
    i = s, e = o, t = -3 * s + 3 * a - 2 * o - l, n = 2 * s - 2 * a + o + l;
  }
  return { initCatmullRom: function(s, a, o, l, c) {
    r(a, o, c * (o - s), c * (l - a));
  }, initNonuniformCatmullRom: function(s, a, o, l, c, h, u) {
    let d = (a - s) / c - (o - s) / (c + h) + (o - a) / h, p = (o - a) / h - (l - a) / (h + u) + (l - o) / u;
    d *= h, p *= h, r(a, o, d, p);
  }, calc: function(s) {
    const a = s * s;
    return i + e * s + t * a + n * (a * s);
  } };
}
const id = new S(), Sm = new g1(), Tm = new g1(), Em = new g1();
class ew extends Ei {
  constructor(e = [], t = !1, n = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r;
  }
  getPoint(e, t = new S()) {
    const n = t, r = this.points, s = r.length, a = (s - (this.closed ? 0 : 1)) * e;
    let o, l, c = Math.floor(a), h = a - c;
    this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / s) + 1) * s : h === 0 && c === s - 1 && (c = s - 2, h = 1), this.closed || c > 0 ? o = r[(c - 1) % s] : (id.subVectors(r[0], r[1]).add(r[0]), o = id);
    const u = r[c % s], d = r[(c + 1) % s];
    if (this.closed || c + 2 < s ? l = r[(c + 2) % s] : (id.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), l = id), this.curveType === "centripetal" || this.curveType === "chordal") {
      const p = this.curveType === "chordal" ? 0.5 : 0.25;
      let f = Math.pow(o.distanceToSquared(u), p), v = Math.pow(u.distanceToSquared(d), p), m = Math.pow(d.distanceToSquared(l), p);
      v < 1e-4 && (v = 1), f < 1e-4 && (f = v), m < 1e-4 && (m = v), Sm.initNonuniformCatmullRom(o.x, u.x, d.x, l.x, f, v, m), Tm.initNonuniformCatmullRom(o.y, u.y, d.y, l.y, f, v, m), Em.initNonuniformCatmullRom(o.z, u.z, d.z, l.z, f, v, m);
    } else
      this.curveType === "catmullrom" && (Sm.initCatmullRom(o.x, u.x, d.x, l.x, this.tension), Tm.initCatmullRom(o.y, u.y, d.y, l.y, this.tension), Em.initCatmullRom(o.z, u.z, d.z, l.z, this.tension));
    return n.set(Sm.calc(h), Tm.calc(h), Em.calc(h)), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new S().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function G2(i, e, t, n, r) {
  const s = 0.5 * (n - e), a = 0.5 * (r - t), o = i * i;
  return (2 * t - 2 * n + s + a) * (i * o) + (-3 * t + 3 * n - 2 * s - a) * o + s * i + t;
}
function Fc(i, e, t, n) {
  return function(r, s) {
    const a = 1 - r;
    return a * a * s;
  }(i, e) + function(r, s) {
    return 2 * (1 - r) * r * s;
  }(i, t) + function(r, s) {
    return r * r * s;
  }(i, n);
}
function Bc(i, e, t, n, r) {
  return function(s, a) {
    const o = 1 - s;
    return o * o * o * a;
  }(i, e) + function(s, a) {
    const o = 1 - s;
    return 3 * o * o * s * a;
  }(i, t) + function(s, a) {
    return 3 * (1 - s) * s * s * a;
  }(i, n) + function(s, a) {
    return s * s * s * a;
  }(i, r);
}
class v1 extends Ei {
  constructor(e = new Y(), t = new Y(), n = new Y(), r = new Y()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
  }
  getPoint(e, t = new Y()) {
    const n = t, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
    return n.set(Bc(e, r.x, s.x, a.x, o.x), Bc(e, r.y, s.y, a.y, o.y)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class tw extends Ei {
  constructor(e = new S(), t = new S(), n = new S(), r = new S()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
  }
  getPoint(e, t = new S()) {
    const n = t, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
    return n.set(Bc(e, r.x, s.x, a.x, o.x), Bc(e, r.y, s.y, a.y, o.y), Bc(e, r.z, s.z, a.z, o.z)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class y1 extends Ei {
  constructor(e = new Y(), t = new Y()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Y()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Y()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class nw extends Ei {
  constructor(e = new S(), t = new S()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new S()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new S()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class _1 extends Ei {
  constructor(e = new Y(), t = new Y(), n = new Y()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new Y()) {
    const n = t, r = this.v0, s = this.v1, a = this.v2;
    return n.set(Fc(e, r.x, s.x, a.x), Fc(e, r.y, s.y, a.y)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class x1 extends Ei {
  constructor(e = new S(), t = new S(), n = new S()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new S()) {
    const n = t, r = this.v0, s = this.v1, a = this.v2;
    return n.set(Fc(e, r.x, s.x, a.x), Fc(e, r.y, s.y, a.y), Fc(e, r.z, s.z, a.z)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class b1 extends Ei {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Y()) {
    const n = t, r = this.points, s = (r.length - 1) * e, a = Math.floor(s), o = s - a, l = r[a === 0 ? a : a - 1], c = r[a], h = r[a > r.length - 2 ? r.length - 1 : a + 1], u = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return n.set(G2(o, l.x, c.x, h.x, u.x), G2(o, l.y, c.y, h.y, u.y)), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new Y().fromArray(r));
    }
    return this;
  }
}
var pp = Object.freeze({ __proto__: null, ArcCurve: $M, CatmullRomCurve3: ew, CubicBezierCurve: v1, CubicBezierCurve3: tw, EllipseCurve: Qp, LineCurve: y1, LineCurve3: nw, QuadraticBezierCurve: _1, QuadraticBezierCurve3: x1, SplineCurve: b1 });
class iw extends Ei {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new pp[n](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const n = e * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= n) {
        const a = r[s] - n, o = this.curves[s], l = o.getLength(), c = l === 0 ? 0 : 1 - a / l;
        return o.getPointAt(c, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, r = this.curves.length; n < r; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const a = s[r], o = a.isEllipseCurve ? 2 * e : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, l = a.getPoints(o);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        n && n.equals(h) || (t.push(h), n = h);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(new pp[r.type]().fromJSON(r));
    }
    return this;
  }
}
class oh extends iw {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Y(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new y1(this.currentPoint.clone(), new Y(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, r) {
    const s = new _1(this.currentPoint.clone(), new Y(e, t), new Y(n, r));
    return this.curves.push(s), this.currentPoint.set(n, r), this;
  }
  bezierCurveTo(e, t, n, r, s, a) {
    const o = new v1(this.currentPoint.clone(), new Y(e, t), new Y(n, r), new Y(s, a));
    return this.curves.push(o), this.currentPoint.set(s, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new b1(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, r, s, a) {
    const o = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(e + o, t + l, n, r, s, a), this;
  }
  absarc(e, t, n, r, s, a) {
    return this.absellipse(e, t, n, n, r, s, a), this;
  }
  ellipse(e, t, n, r, s, a, o, l) {
    const c = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + c, t + h, n, r, s, a, o, l), this;
  }
  absellipse(e, t, n, r, s, a, o, l) {
    const c = new Qp(e, t, n, r, s, a, o, l);
    if (this.curves.length > 0) {
      const u = c.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Hh extends Re {
  constructor(e = [new Y(0, -0.5), new Y(0.5, 0), new Y(0, 0.5)], t = 12, n = 0, r = 2 * Math.PI) {
    super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: n, phiLength: r }, t = Math.floor(t), r = Dt(r, 0, 2 * Math.PI);
    const s = [], a = [], o = [], l = [], c = [], h = 1 / t, u = new S(), d = new Y(), p = new S(), f = new S(), v = new S();
    let m = 0, y = 0;
    for (let g = 0; g <= e.length - 1; g++)
      switch (g) {
        case 0:
          m = e[g + 1].x - e[g].x, y = e[g + 1].y - e[g].y, p.x = 1 * y, p.y = -m, p.z = 0 * y, v.copy(p), p.normalize(), l.push(p.x, p.y, p.z);
          break;
        case e.length - 1:
          l.push(v.x, v.y, v.z);
          break;
        default:
          m = e[g + 1].x - e[g].x, y = e[g + 1].y - e[g].y, p.x = 1 * y, p.y = -m, p.z = 0 * y, f.copy(p), p.x += v.x, p.y += v.y, p.z += v.z, p.normalize(), l.push(p.x, p.y, p.z), v.copy(f);
      }
    for (let g = 0; g <= t; g++) {
      const _ = n + g * h * r, x = Math.sin(_), M = Math.cos(_);
      for (let b = 0; b <= e.length - 1; b++) {
        u.x = e[b].x * x, u.y = e[b].y, u.z = e[b].x * M, a.push(u.x, u.y, u.z), d.x = g / t, d.y = b / (e.length - 1), o.push(d.x, d.y);
        const w = l[3 * b + 0] * x, T = l[3 * b + 1], A = l[3 * b + 0] * M;
        c.push(w, T, A);
      }
    }
    for (let g = 0; g < t; g++)
      for (let _ = 0; _ < e.length - 1; _++) {
        const x = _ + g * e.length, M = x, b = x + e.length, w = x + e.length + 1, T = x + 1;
        s.push(M, b, T), s.push(w, T, b);
      }
    this.setIndex(s), this.setAttribute("position", new ye(a, 3)), this.setAttribute("uv", new ye(o, 2)), this.setAttribute("normal", new ye(c, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Hh(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Jp extends Hh {
  constructor(e = 1, t = 1, n = 4, r = 8) {
    const s = new oh();
    s.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), s.absarc(0, t / 2, e, 0, 0.5 * Math.PI), super(s.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: n, radialSegments: r };
  }
  static fromJSON(e) {
    return new Jp(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class $p extends Re {
  constructor(e = 1, t = 32, n = 0, r = 2 * Math.PI) {
    super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: r }, t = Math.max(3, t);
    const s = [], a = [], o = [], l = [], c = new S(), h = new Y();
    a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5);
    for (let u = 0, d = 3; u <= t; u++, d += 3) {
      const p = n + u / t * r;
      c.x = e * Math.cos(p), c.y = e * Math.sin(p), a.push(c.x, c.y, c.z), o.push(0, 0, 1), h.x = (a[d] / e + 1) / 2, h.y = (a[d + 1] / e + 1) / 2, l.push(h.x, h.y);
    }
    for (let u = 1; u <= t; u++)
      s.push(u, u + 1, 0);
    this.setIndex(s), this.setAttribute("position", new ye(a, 3)), this.setAttribute("normal", new ye(o, 3)), this.setAttribute("uv", new ye(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new $p(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Ft extends Re {
  constructor(e = 1, t = 1, n = 1, r = 32, s = 1, a = !1, o = 0, l = 2 * Math.PI) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: r, heightSegments: s, openEnded: a, thetaStart: o, thetaLength: l };
    const c = this;
    r = Math.floor(r), s = Math.floor(s);
    const h = [], u = [], d = [], p = [];
    let f = 0;
    const v = [], m = n / 2;
    let y = 0;
    function g(_) {
      const x = f, M = new Y(), b = new S();
      let w = 0;
      const T = _ === !0 ? e : t, A = _ === !0 ? 1 : -1;
      for (let I = 1; I <= r; I++)
        u.push(0, m * A, 0), d.push(0, A, 0), p.push(0.5, 0.5), f++;
      const L = f;
      for (let I = 0; I <= r; I++) {
        const P = I / r * l + o, N = Math.cos(P), F = Math.sin(P);
        b.x = T * F, b.y = m * A, b.z = T * N, u.push(b.x, b.y, b.z), d.push(0, A, 0), M.x = 0.5 * N + 0.5, M.y = 0.5 * F * A + 0.5, p.push(M.x, M.y), f++;
      }
      for (let I = 0; I < r; I++) {
        const P = x + I, N = L + I;
        _ === !0 ? h.push(N, N + 1, P) : h.push(N + 1, N, P), w += 3;
      }
      c.addGroup(y, w, _ === !0 ? 1 : 2), y += w;
    }
    (function() {
      const _ = new S(), x = new S();
      let M = 0;
      const b = (t - e) / n;
      for (let w = 0; w <= s; w++) {
        const T = [], A = w / s, L = A * (t - e) + e;
        for (let I = 0; I <= r; I++) {
          const P = I / r, N = P * l + o, F = Math.sin(N), z = Math.cos(N);
          x.x = L * F, x.y = -A * n + m, x.z = L * z, u.push(x.x, x.y, x.z), _.set(F, b, z).normalize(), d.push(_.x, _.y, _.z), p.push(P, 1 - A), T.push(f++);
        }
        v.push(T);
      }
      for (let w = 0; w < r; w++)
        for (let T = 0; T < s; T++) {
          const A = v[T][w], L = v[T + 1][w], I = v[T + 1][w + 1], P = v[T][w + 1];
          h.push(A, L, P), h.push(L, I, P), M += 6;
        }
      c.addGroup(y, M, 0), y += M;
    })(), a === !1 && (e > 0 && g(!0), t > 0 && g(!1)), this.setIndex(h), this.setAttribute("position", new ye(u, 3)), this.setAttribute("normal", new ye(d, 3)), this.setAttribute("uv", new ye(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ft(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class ef extends Ft {
  constructor(e = 1, t = 1, n = 32, r = 1, s = !1, a = 0, o = 2 * Math.PI) {
    super(0, e, t, n, r, s, a, o), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: r, openEnded: s, thetaStart: a, thetaLength: o };
  }
  static fromJSON(e) {
    return new ef(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Rs extends Re {
  constructor(e = [], t = [], n = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: n, detail: r };
    const s = [], a = [];
    function o(d, p, f, v) {
      const m = v + 1, y = [];
      for (let g = 0; g <= m; g++) {
        y[g] = [];
        const _ = d.clone().lerp(f, g / m), x = p.clone().lerp(f, g / m), M = m - g;
        for (let b = 0; b <= M; b++)
          y[g][b] = b === 0 && g === m ? _ : _.clone().lerp(x, b / M);
      }
      for (let g = 0; g < m; g++)
        for (let _ = 0; _ < 2 * (m - g) - 1; _++) {
          const x = Math.floor(_ / 2);
          _ % 2 == 0 ? (l(y[g][x + 1]), l(y[g + 1][x]), l(y[g][x])) : (l(y[g][x + 1]), l(y[g + 1][x + 1]), l(y[g + 1][x]));
        }
    }
    function l(d) {
      s.push(d.x, d.y, d.z);
    }
    function c(d, p) {
      const f = 3 * d;
      p.x = e[f + 0], p.y = e[f + 1], p.z = e[f + 2];
    }
    function h(d, p, f, v) {
      v < 0 && d.x === 1 && (a[p] = d.x - 1), f.x === 0 && f.z === 0 && (a[p] = v / 2 / Math.PI + 0.5);
    }
    function u(d) {
      return Math.atan2(d.z, -d.x);
    }
    (function(d) {
      const p = new S(), f = new S(), v = new S();
      for (let m = 0; m < t.length; m += 3)
        c(t[m + 0], p), c(t[m + 1], f), c(t[m + 2], v), o(p, f, v, d);
    })(r), function(d) {
      const p = new S();
      for (let f = 0; f < s.length; f += 3)
        p.x = s[f + 0], p.y = s[f + 1], p.z = s[f + 2], p.normalize().multiplyScalar(d), s[f + 0] = p.x, s[f + 1] = p.y, s[f + 2] = p.z;
    }(n), function() {
      const d = new S();
      for (let f = 0; f < s.length; f += 3) {
        d.x = s[f + 0], d.y = s[f + 1], d.z = s[f + 2];
        const v = u(d) / 2 / Math.PI + 0.5, m = (p = d, Math.atan2(-p.y, Math.sqrt(p.x * p.x + p.z * p.z)) / Math.PI + 0.5);
        a.push(v, 1 - m);
      }
      var p;
      (function() {
        const f = new S(), v = new S(), m = new S(), y = new S(), g = new Y(), _ = new Y(), x = new Y();
        for (let M = 0, b = 0; M < s.length; M += 9, b += 6) {
          f.set(s[M + 0], s[M + 1], s[M + 2]), v.set(s[M + 3], s[M + 4], s[M + 5]), m.set(s[M + 6], s[M + 7], s[M + 8]), g.set(a[b + 0], a[b + 1]), _.set(a[b + 2], a[b + 3]), x.set(a[b + 4], a[b + 5]), y.copy(f).add(v).add(m).divideScalar(3);
          const w = u(y);
          h(g, b + 0, f, w), h(_, b + 2, v, w), h(x, b + 4, m, w);
        }
      })(), function() {
        for (let f = 0; f < a.length; f += 6) {
          const v = a[f + 0], m = a[f + 2], y = a[f + 4], g = Math.max(v, m, y), _ = Math.min(v, m, y);
          g > 0.9 && _ < 0.1 && (v < 0.2 && (a[f + 0] += 1), m < 0.2 && (a[f + 2] += 1), y < 0.2 && (a[f + 4] += 1));
        }
      }();
    }(), this.setAttribute("position", new ye(s, 3)), this.setAttribute("normal", new ye(s.slice(), 3)), this.setAttribute("uv", new ye(a, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Rs(e.vertices, e.indices, e.radius, e.details);
  }
}
class tf extends Rs {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, r = 1 / n;
    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new tf(e.radius, e.detail);
  }
}
const rd = new S(), sd = new S(), Am = new S(), ad = new ni();
class rw extends Re {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) {
      const r = Math.pow(10, 4), s = Math.cos(wa * t), a = e.getIndex(), o = e.getAttribute("position"), l = a ? a.count : o.count, c = [0, 0, 0], h = ["a", "b", "c"], u = new Array(3), d = {}, p = [];
      for (let f = 0; f < l; f += 3) {
        a ? (c[0] = a.getX(f), c[1] = a.getX(f + 1), c[2] = a.getX(f + 2)) : (c[0] = f, c[1] = f + 1, c[2] = f + 2);
        const { a: v, b: m, c: y } = ad;
        if (v.fromBufferAttribute(o, c[0]), m.fromBufferAttribute(o, c[1]), y.fromBufferAttribute(o, c[2]), ad.getNormal(Am), u[0] = `${Math.round(v.x * r)},${Math.round(v.y * r)},${Math.round(v.z * r)}`, u[1] = `${Math.round(m.x * r)},${Math.round(m.y * r)},${Math.round(m.z * r)}`, u[2] = `${Math.round(y.x * r)},${Math.round(y.y * r)},${Math.round(y.z * r)}`, u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0])
          for (let g = 0; g < 3; g++) {
            const _ = (g + 1) % 3, x = u[g], M = u[_], b = ad[h[g]], w = ad[h[_]], T = `${x}_${M}`, A = `${M}_${x}`;
            A in d && d[A] ? (Am.dot(d[A].normal) <= s && (p.push(b.x, b.y, b.z), p.push(w.x, w.y, w.z)), d[A] = null) : T in d || (d[T] = { index0: c[g], index1: c[_], normal: Am.clone() });
          }
      }
      for (const f in d)
        if (d[f]) {
          const { index0: v, index1: m } = d[f];
          rd.fromBufferAttribute(o, v), sd.fromBufferAttribute(o, m), p.push(rd.x, rd.y, rd.z), p.push(sd.x, sd.y, sd.z);
        }
      this.setAttribute("position", new ye(p, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class Ta extends oh {
  constructor(e) {
    super(e), this.uuid = ci(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, r = this.holes.length; n < r; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(new oh().fromJSON(r));
    }
    return this;
  }
}
const PA = function(i, e, t = 2) {
  const n = e && e.length, r = n ? e[0] * t : i.length;
  let s = V2(i, 0, r, t, !0);
  const a = [];
  if (!s || s.next === s.prev)
    return a;
  let o, l, c, h, u, d, p;
  if (n && (s = function(f, v, m, y) {
    const g = [];
    let _, x, M, b, w;
    for (_ = 0, x = v.length; _ < x; _++)
      M = v[_] * y, b = _ < x - 1 ? v[_ + 1] * y : f.length, w = V2(f, M, b, y, !1), w === w.next && (w.steiner = !0), g.push(BA(w));
    for (g.sort(UA), _ = 0; _ < g.length; _++)
      m = kA(g[_], m);
    return m;
  }(i, e, s, t)), i.length > 80 * t) {
    o = c = i[0], l = h = i[1];
    for (let f = t; f < r; f += t)
      u = i[f], d = i[f + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
    p = Math.max(c - o, h - l), p = p !== 0 ? 32767 / p : 0;
  }
  return lh(s, a, t, o, l, p, 0), a;
};
function V2(i, e, t, n, r) {
  let s, a;
  if (r === function(o, l, c, h) {
    let u = 0;
    for (let d = l, p = c - h; d < c; d += h)
      u += (o[p] - o[d]) * (o[d + 1] + o[p + 1]), p = d;
    return u;
  }(i, e, t, n) > 0)
    for (s = e; s < t; s += n)
      a = j2(s, i[s], i[s + 1], a);
  else
    for (s = t - n; s >= e; s -= n)
      a = j2(s, i[s], i[s + 1], a);
  return a && nf(a, a.next) && (hh(a), a = a.next), a;
}
function Ga(i, e) {
  if (!i)
    return i;
  e || (e = i);
  let t, n = i;
  do
    if (t = !1, n.steiner || !nf(n, n.next) && At(n.prev, n, n.next) !== 0)
      n = n.next;
    else {
      if (hh(n), n = e = n.prev, n === n.next)
        break;
      t = !0;
    }
  while (t || n !== e);
  return e;
}
function lh(i, e, t, n, r, s, a) {
  if (!i)
    return;
  !a && s && function(h, u, d, p) {
    let f = h;
    do
      f.z === 0 && (f.z = f0(f.x, f.y, u, d, p)), f.prevZ = f.prev, f.nextZ = f.next, f = f.next;
    while (f !== h);
    f.prevZ.nextZ = null, f.prevZ = null, function(v) {
      let m, y, g, _, x, M, b, w, T = 1;
      do {
        for (y = v, v = null, x = null, M = 0; y; ) {
          for (M++, g = y, b = 0, m = 0; m < T && (b++, g = g.nextZ, g); m++)
            ;
          for (w = T; b > 0 || w > 0 && g; )
            b !== 0 && (w === 0 || !g || y.z <= g.z) ? (_ = y, y = y.nextZ, b--) : (_ = g, g = g.nextZ, w--), x ? x.nextZ = _ : v = _, _.prevZ = x, x = _;
          y = g;
        }
        x.nextZ = null, T *= 2;
      } while (M > 1);
    }(f);
  }(i, n, r, s);
  let o, l, c = i;
  for (; i.prev !== i.next; )
    if (o = i.prev, l = i.next, s ? DA(i, n, r, s) : LA(i))
      e.push(o.i / t | 0), e.push(i.i / t | 0), e.push(l.i / t | 0), hh(i), i = l.next, c = l.next;
    else if ((i = l) === c) {
      a ? a === 1 ? lh(i = NA(Ga(i), e, t), e, t, n, r, s, 2) : a === 2 && OA(i, e, t, n, r, s) : lh(Ga(i), e, t, n, r, s, 1);
      break;
    }
}
function LA(i) {
  const e = i.prev, t = i, n = i.next;
  if (At(e, t, n) >= 0)
    return !1;
  const r = e.x, s = t.x, a = n.x, o = e.y, l = t.y, c = n.y, h = r < s ? r < a ? r : a : s < a ? s : a, u = o < l ? o < c ? o : c : l < c ? l : c, d = r > s ? r > a ? r : a : s > a ? s : a, p = o > l ? o > c ? o : c : l > c ? l : c;
  let f = n.next;
  for (; f !== e; ) {
    if (f.x >= h && f.x <= d && f.y >= u && f.y <= p && Fo(r, o, s, l, a, c, f.x, f.y) && At(f.prev, f, f.next) >= 0)
      return !1;
    f = f.next;
  }
  return !0;
}
function DA(i, e, t, n) {
  const r = i.prev, s = i, a = i.next;
  if (At(r, s, a) >= 0)
    return !1;
  const o = r.x, l = s.x, c = a.x, h = r.y, u = s.y, d = a.y, p = o < l ? o < c ? o : c : l < c ? l : c, f = h < u ? h < d ? h : d : u < d ? u : d, v = o > l ? o > c ? o : c : l > c ? l : c, m = h > u ? h > d ? h : d : u > d ? u : d, y = f0(p, f, e, t, n), g = f0(v, m, e, t, n);
  let _ = i.prevZ, x = i.nextZ;
  for (; _ && _.z >= y && x && x.z <= g; ) {
    if (_.x >= p && _.x <= v && _.y >= f && _.y <= m && _ !== r && _ !== a && Fo(o, h, l, u, c, d, _.x, _.y) && At(_.prev, _, _.next) >= 0 || (_ = _.prevZ, x.x >= p && x.x <= v && x.y >= f && x.y <= m && x !== r && x !== a && Fo(o, h, l, u, c, d, x.x, x.y) && At(x.prev, x, x.next) >= 0))
      return !1;
    x = x.nextZ;
  }
  for (; _ && _.z >= y; ) {
    if (_.x >= p && _.x <= v && _.y >= f && _.y <= m && _ !== r && _ !== a && Fo(o, h, l, u, c, d, _.x, _.y) && At(_.prev, _, _.next) >= 0)
      return !1;
    _ = _.prevZ;
  }
  for (; x && x.z <= g; ) {
    if (x.x >= p && x.x <= v && x.y >= f && x.y <= m && x !== r && x !== a && Fo(o, h, l, u, c, d, x.x, x.y) && At(x.prev, x, x.next) >= 0)
      return !1;
    x = x.nextZ;
  }
  return !0;
}
function NA(i, e, t) {
  let n = i;
  do {
    const r = n.prev, s = n.next.next;
    !nf(r, s) && sw(r, n, n.next, s) && ch(r, s) && ch(s, r) && (e.push(r.i / t | 0), e.push(n.i / t | 0), e.push(s.i / t | 0), hh(n), hh(n.next), n = i = s), n = n.next;
  } while (n !== i);
  return Ga(n);
}
function OA(i, e, t, n, r, s) {
  let a = i;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && zA(a, o)) {
        let l = aw(a, o);
        return a = Ga(a, a.next), l = Ga(l, l.next), lh(a, e, t, n, r, s, 0), void lh(l, e, t, n, r, s, 0);
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== i);
}
function UA(i, e) {
  return i.x - e.x;
}
function kA(i, e) {
  const t = function(r, s) {
    let a, o = s, l = -1 / 0;
    const c = r.x, h = r.y;
    do {
      if (h <= o.y && h >= o.next.y && o.next.y !== o.y) {
        const m = o.x + (h - o.y) * (o.next.x - o.x) / (o.next.y - o.y);
        if (m <= c && m > l && (l = m, a = o.x < o.next.x ? o : o.next, m === c))
          return a;
      }
      o = o.next;
    } while (o !== s);
    if (!a)
      return null;
    const u = a, d = a.x, p = a.y;
    let f, v = 1 / 0;
    o = a;
    do
      c >= o.x && o.x >= d && c !== o.x && Fo(h < p ? c : l, h, d, p, h < p ? l : c, h, o.x, o.y) && (f = Math.abs(h - o.y) / (c - o.x), ch(o, r) && (f < v || f === v && (o.x > a.x || o.x === a.x && FA(a, o))) && (a = o, v = f)), o = o.next;
    while (o !== u);
    return a;
  }(i, e);
  if (!t)
    return e;
  const n = aw(t, i);
  return Ga(n, n.next), Ga(t, t.next);
}
function FA(i, e) {
  return At(i.prev, i, e.prev) < 0 && At(e.next, i, i.next) < 0;
}
function f0(i, e, t, n, r) {
  return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - t) * r | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
}
function BA(i) {
  let e = i, t = i;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== i);
  return t;
}
function Fo(i, e, t, n, r, s, a, o) {
  return (r - a) * (e - o) >= (i - a) * (s - o) && (i - a) * (n - o) >= (t - a) * (e - o) && (t - a) * (s - o) >= (r - a) * (n - o);
}
function zA(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !function(t, n) {
    let r = t;
    do {
      if (r.i !== t.i && r.next.i !== t.i && r.i !== n.i && r.next.i !== n.i && sw(r, r.next, t, n))
        return !0;
      r = r.next;
    } while (r !== t);
    return !1;
  }(i, e) && (ch(i, e) && ch(e, i) && function(t, n) {
    let r = t, s = !1;
    const a = (t.x + n.x) / 2, o = (t.y + n.y) / 2;
    do
      r.y > o != r.next.y > o && r.next.y !== r.y && a < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (s = !s), r = r.next;
    while (r !== t);
    return s;
  }(i, e) && (At(i.prev, i, e.prev) || At(i, e.prev, e)) || nf(i, e) && At(i.prev, i, i.next) > 0 && At(e.prev, e, e.next) > 0);
}
function At(i, e, t) {
  return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function nf(i, e) {
  return i.x === e.x && i.y === e.y;
}
function sw(i, e, t, n) {
  const r = ld(At(i, e, t)), s = ld(At(i, e, n)), a = ld(At(t, n, i)), o = ld(At(t, n, e));
  return r !== s && a !== o || !(r !== 0 || !od(i, t, e)) || !(s !== 0 || !od(i, n, e)) || !(a !== 0 || !od(t, i, n)) || !(o !== 0 || !od(t, e, n));
}
function od(i, e, t) {
  return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
}
function ld(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function ch(i, e) {
  return At(i.prev, i, i.next) < 0 ? At(i, e, i.next) >= 0 && At(i, i.prev, e) >= 0 : At(i, e, i.prev) < 0 || At(i, i.next, e) < 0;
}
function aw(i, e) {
  const t = new m0(i.i, i.x, i.y), n = new m0(e.i, e.x, e.y), r = i.next, s = e.prev;
  return i.next = e, e.prev = i, t.next = r, r.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n;
}
function j2(i, e, t, n) {
  const r = new m0(i, e, t);
  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
}
function hh(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function m0(i, e, t) {
  this.i = i, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
class Vi {
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      n += e[r].x * e[s].y - e[s].x * e[r].y;
    return 0.5 * n;
  }
  static isClockWise(e) {
    return Vi.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], r = [], s = [];
    W2(e), X2(n, e);
    let a = e.length;
    t.forEach(W2);
    for (let l = 0; l < t.length; l++)
      r.push(a), a += t[l].length, X2(n, t[l]);
    const o = PA(n, r);
    for (let l = 0; l < o.length; l += 3)
      s.push(o.slice(l, l + 3));
    return s;
  }
}
function W2(i) {
  const e = i.length;
  e > 2 && i[e - 1].equals(i[0]) && i.pop();
}
function X2(i, e) {
  for (let t = 0; t < e.length; t++)
    i.push(e[t].x), i.push(e[t].y);
}
class Gh extends Re {
  constructor(e = new Ta([new Y(0.5, 0.5), new Y(-0.5, 0.5), new Y(-0.5, -0.5), new Y(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e];
    const n = this, r = [], s = [];
    for (let o = 0, l = e.length; o < l; o++)
      a(e[o]);
    function a(o) {
      const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, u = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled === void 0 || t.bevelEnabled, p = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, f = t.bevelSize !== void 0 ? t.bevelSize : p - 0.1, v = t.bevelOffset !== void 0 ? t.bevelOffset : 0, m = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const y = t.extrudePath, g = t.UVGenerator !== void 0 ? t.UVGenerator : HA;
      let _, x, M, b, w, T = !1;
      y && (_ = y.getSpacedPoints(h), T = !0, d = !1, x = y.computeFrenetFrames(h, !1), M = new S(), b = new S(), w = new S()), d || (m = 0, p = 0, f = 0, v = 0);
      const A = o.extractPoints(c);
      let L = A.shape;
      const I = A.holes;
      if (!Vi.isClockWise(L)) {
        L = L.reverse();
        for (let O = 0, k = I.length; O < k; O++) {
          const E = I[O];
          Vi.isClockWise(E) && (I[O] = E.reverse());
        }
      }
      const P = Vi.triangulateShape(L, I), N = L;
      for (let O = 0, k = I.length; O < k; O++) {
        const E = I[O];
        L = L.concat(E);
      }
      function F(O, k, E) {
        return k || console.error("THREE.ExtrudeGeometry: vec does not exist"), O.clone().addScaledVector(k, E);
      }
      const z = L.length, q = P.length;
      function re(O, k, E) {
        let U, B, ne;
        const V = O.x - k.x, de = O.y - k.y, xe = E.x - O.x, ue = E.y - O.y, H = V * V + de * de, j = V * ue - de * xe;
        if (Math.abs(j) > Number.EPSILON) {
          const $ = Math.sqrt(H), be = Math.sqrt(xe * xe + ue * ue), Ne = k.x - de / $, Be = k.y + V / $, Me = ((E.x - ue / be - Ne) * ue - (E.y + xe / be - Be) * xe) / (V * ue - de * xe);
          U = Ne + V * Me - O.x, B = Be + de * Me - O.y;
          const Ve = U * U + B * B;
          if (Ve <= 2)
            return new Y(U, B);
          ne = Math.sqrt(Ve / 2);
        } else {
          let $ = !1;
          V > Number.EPSILON ? xe > Number.EPSILON && ($ = !0) : V < -Number.EPSILON ? xe < -Number.EPSILON && ($ = !0) : Math.sign(de) === Math.sign(ue) && ($ = !0), $ ? (U = -de, B = V, ne = Math.sqrt(H)) : (U = V, B = de, ne = Math.sqrt(H / 2));
        }
        return new Y(U / ne, B / ne);
      }
      const ie = [];
      for (let O = 0, k = N.length, E = k - 1, U = O + 1; O < k; O++, E++, U++)
        E === k && (E = 0), U === k && (U = 0), ie[O] = re(N[O], N[E], N[U]);
      const me = [];
      let Se, te = ie.concat();
      for (let O = 0, k = I.length; O < k; O++) {
        const E = I[O];
        Se = [];
        for (let U = 0, B = E.length, ne = B - 1, V = U + 1; U < B; U++, ne++, V++)
          ne === B && (ne = 0), V === B && (V = 0), Se[U] = re(E[U], E[ne], E[V]);
        me.push(Se), te = te.concat(Se);
      }
      for (let O = 0; O < m; O++) {
        const k = O / m, E = p * Math.cos(k * Math.PI / 2), U = f * Math.sin(k * Math.PI / 2) + v;
        for (let B = 0, ne = N.length; B < ne; B++) {
          const V = F(N[B], ie[B], U);
          ae(V.x, V.y, -E);
        }
        for (let B = 0, ne = I.length; B < ne; B++) {
          const V = I[B];
          Se = me[B];
          for (let de = 0, xe = V.length; de < xe; de++) {
            const ue = F(V[de], Se[de], U);
            ae(ue.x, ue.y, -E);
          }
        }
      }
      const se = f + v;
      for (let O = 0; O < z; O++) {
        const k = d ? F(L[O], te[O], se) : L[O];
        T ? (b.copy(x.normals[0]).multiplyScalar(k.x), M.copy(x.binormals[0]).multiplyScalar(k.y), w.copy(_[0]).add(b).add(M), ae(w.x, w.y, w.z)) : ae(k.x, k.y, 0);
      }
      for (let O = 1; O <= h; O++)
        for (let k = 0; k < z; k++) {
          const E = d ? F(L[k], te[k], se) : L[k];
          T ? (b.copy(x.normals[O]).multiplyScalar(E.x), M.copy(x.binormals[O]).multiplyScalar(E.y), w.copy(_[O]).add(b).add(M), ae(w.x, w.y, w.z)) : ae(E.x, E.y, u / h * O);
        }
      for (let O = m - 1; O >= 0; O--) {
        const k = O / m, E = p * Math.cos(k * Math.PI / 2), U = f * Math.sin(k * Math.PI / 2) + v;
        for (let B = 0, ne = N.length; B < ne; B++) {
          const V = F(N[B], ie[B], U);
          ae(V.x, V.y, u + E);
        }
        for (let B = 0, ne = I.length; B < ne; B++) {
          const V = I[B];
          Se = me[B];
          for (let de = 0, xe = V.length; de < xe; de++) {
            const ue = F(V[de], Se[de], U);
            T ? ae(ue.x, ue.y + _[h - 1].y, _[h - 1].x + E) : ae(ue.x, ue.y, u + E);
          }
        }
      }
      function he(O, k) {
        let E = O.length;
        for (; --E >= 0; ) {
          const U = E;
          let B = E - 1;
          B < 0 && (B = O.length - 1);
          for (let ne = 0, V = h + 2 * m; ne < V; ne++) {
            const de = z * ne, xe = z * (ne + 1);
            R(k + U + de, k + B + de, k + B + xe, k + U + xe);
          }
        }
      }
      function ae(O, k, E) {
        l.push(O), l.push(k), l.push(E);
      }
      function D(O, k, E) {
        X(O), X(k), X(E);
        const U = r.length / 3, B = g.generateTopUV(n, r, U - 3, U - 2, U - 1);
        Q(B[0]), Q(B[1]), Q(B[2]);
      }
      function R(O, k, E, U) {
        X(O), X(k), X(U), X(k), X(E), X(U);
        const B = r.length / 3, ne = g.generateSideWallUV(n, r, B - 6, B - 3, B - 2, B - 1);
        Q(ne[0]), Q(ne[1]), Q(ne[3]), Q(ne[1]), Q(ne[2]), Q(ne[3]);
      }
      function X(O) {
        r.push(l[3 * O + 0]), r.push(l[3 * O + 1]), r.push(l[3 * O + 2]);
      }
      function Q(O) {
        s.push(O.x), s.push(O.y);
      }
      (function() {
        const O = r.length / 3;
        if (d) {
          let k = 0, E = z * k;
          for (let U = 0; U < q; U++) {
            const B = P[U];
            D(B[2] + E, B[1] + E, B[0] + E);
          }
          k = h + 2 * m, E = z * k;
          for (let U = 0; U < q; U++) {
            const B = P[U];
            D(B[0] + E, B[1] + E, B[2] + E);
          }
        } else {
          for (let k = 0; k < q; k++) {
            const E = P[k];
            D(E[2], E[1], E[0]);
          }
          for (let k = 0; k < q; k++) {
            const E = P[k];
            D(E[0] + z * h, E[1] + z * h, E[2] + z * h);
          }
        }
        n.addGroup(O, r.length / 3 - O, 0);
      })(), function() {
        const O = r.length / 3;
        let k = 0;
        he(N, k), k += N.length;
        for (let E = 0, U = I.length; E < U; E++) {
          const B = I[E];
          he(B, k), k += B.length;
        }
        n.addGroup(O, r.length / 3 - O, 1);
      }();
    }
    this.setAttribute("position", new ye(r, 3)), this.setAttribute("uv", new ye(s, 2)), this.computeVertexNormals();
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return function(t, n, r) {
      if (r.shapes = [], Array.isArray(t))
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s];
          r.shapes.push(o.uuid);
        }
      else
        r.shapes.push(t.uuid);
      return r.options = Object.assign({}, n), n.extrudePath !== void 0 && (r.options.extrudePath = n.extrudePath.toJSON()), r;
    }(this.parameters.shapes, this.parameters.options, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let s = 0, a = e.shapes.length; s < a; s++) {
      const o = t[e.shapes[s]];
      n.push(o);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new pp[r.type]().fromJSON(r)), new Gh(n, e.options);
  }
}
const HA = { generateTopUV: function(i, e, t, n, r) {
  const s = e[3 * t], a = e[3 * t + 1], o = e[3 * n], l = e[3 * n + 1], c = e[3 * r], h = e[3 * r + 1];
  return [new Y(s, a), new Y(o, l), new Y(c, h)];
}, generateSideWallUV: function(i, e, t, n, r, s) {
  const a = e[3 * t], o = e[3 * t + 1], l = e[3 * t + 2], c = e[3 * n], h = e[3 * n + 1], u = e[3 * n + 2], d = e[3 * r], p = e[3 * r + 1], f = e[3 * r + 2], v = e[3 * s], m = e[3 * s + 1], y = e[3 * s + 2];
  return Math.abs(o - h) < Math.abs(a - c) ? [new Y(a, 1 - l), new Y(c, 1 - u), new Y(d, 1 - f), new Y(v, 1 - y)] : [new Y(o, 1 - l), new Y(h, 1 - u), new Y(p, 1 - f), new Y(m, 1 - y)];
} };
class rf extends Rs {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2;
    super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new rf(e.radius, e.detail);
  }
}
class Lr extends Rs {
  constructor(e = 1, t = 0) {
    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new Lr(e.radius, e.detail);
  }
}
class sf extends Re {
  constructor(e = 0.5, t = 1, n = 32, r = 1, s = 0, a = 2 * Math.PI) {
    super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: r, thetaStart: s, thetaLength: a }, n = Math.max(3, n);
    const o = [], l = [], c = [], h = [];
    let u = e;
    const d = (t - e) / (r = Math.max(1, r)), p = new S(), f = new Y();
    for (let v = 0; v <= r; v++) {
      for (let m = 0; m <= n; m++) {
        const y = s + m / n * a;
        p.x = u * Math.cos(y), p.y = u * Math.sin(y), l.push(p.x, p.y, p.z), c.push(0, 0, 1), f.x = (p.x / t + 1) / 2, f.y = (p.y / t + 1) / 2, h.push(f.x, f.y);
      }
      u += d;
    }
    for (let v = 0; v < r; v++) {
      const m = v * (n + 1);
      for (let y = 0; y < n; y++) {
        const g = y + m, _ = g, x = g + n + 1, M = g + n + 2, b = g + 1;
        o.push(_, x, b), o.push(x, M, b);
      }
    }
    this.setIndex(o), this.setAttribute("position", new ye(l, 3)), this.setAttribute("normal", new ye(c, 3)), this.setAttribute("uv", new ye(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new sf(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class af extends Re {
  constructor(e = new Ta([new Y(0, 0.5), new Y(-0.5, -0.5), new Y(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t };
    const n = [], r = [], s = [], a = [];
    let o = 0, l = 0;
    if (Array.isArray(e) === !1)
      c(e);
    else
      for (let h = 0; h < e.length; h++)
        c(e[h]), this.addGroup(o, l, h), o += l, l = 0;
    function c(h) {
      const u = r.length / 3, d = h.extractPoints(t);
      let p = d.shape;
      const f = d.holes;
      Vi.isClockWise(p) === !1 && (p = p.reverse());
      for (let m = 0, y = f.length; m < y; m++) {
        const g = f[m];
        Vi.isClockWise(g) === !0 && (f[m] = g.reverse());
      }
      const v = Vi.triangulateShape(p, f);
      for (let m = 0, y = f.length; m < y; m++) {
        const g = f[m];
        p = p.concat(g);
      }
      for (let m = 0, y = p.length; m < y; m++) {
        const g = p[m];
        r.push(g.x, g.y, 0), s.push(0, 0, 1), a.push(g.x, g.y);
      }
      for (let m = 0, y = v.length; m < y; m++) {
        const g = v[m], _ = g[0] + u, x = g[1] + u, M = g[2] + u;
        n.push(_, x, M), l += 3;
      }
    }
    this.setIndex(n), this.setAttribute("position", new ye(r, 3)), this.setAttribute("normal", new ye(s, 3)), this.setAttribute("uv", new ye(a, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return function(t, n) {
      if (n.shapes = [], Array.isArray(t))
        for (let r = 0, s = t.length; r < s; r++) {
          const a = t[r];
          n.shapes.push(a.uuid);
        }
      else
        n.shapes.push(t.uuid);
      return n;
    }(this.parameters.shapes, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const a = t[e.shapes[r]];
      n.push(a);
    }
    return new af(n, e.curveSegments);
  }
}
class gl extends Re {
  constructor(e = 1, t = 32, n = 16, r = 0, s = 2 * Math.PI, a = 0, o = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: r, phiLength: s, thetaStart: a, thetaLength: o }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const h = [], u = new S(), d = new S(), p = [], f = [], v = [], m = [];
    for (let y = 0; y <= n; y++) {
      const g = [], _ = y / n;
      let x = 0;
      y === 0 && a === 0 ? x = 0.5 / t : y === n && l === Math.PI && (x = -0.5 / t);
      for (let M = 0; M <= t; M++) {
        const b = M / t;
        u.x = -e * Math.cos(r + b * s) * Math.sin(a + _ * o), u.y = e * Math.cos(a + _ * o), u.z = e * Math.sin(r + b * s) * Math.sin(a + _ * o), f.push(u.x, u.y, u.z), d.copy(u).normalize(), v.push(d.x, d.y, d.z), m.push(b + x, 1 - _), g.push(c++);
      }
      h.push(g);
    }
    for (let y = 0; y < n; y++)
      for (let g = 0; g < t; g++) {
        const _ = h[y][g + 1], x = h[y][g], M = h[y + 1][g], b = h[y + 1][g + 1];
        (y !== 0 || a > 0) && p.push(_, x, b), (y !== n - 1 || l < Math.PI) && p.push(x, M, b);
      }
    this.setIndex(p), this.setAttribute("position", new ye(f, 3)), this.setAttribute("normal", new ye(v, 3)), this.setAttribute("uv", new ye(m, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new gl(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class of extends Rs {
  constructor(e = 1, t = 0) {
    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new of(e.radius, e.detail);
  }
}
class Rr extends Re {
  constructor(e = 1, t = 0.4, n = 12, r = 48, s = 2 * Math.PI) {
    super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: r, arc: s }, n = Math.floor(n), r = Math.floor(r);
    const a = [], o = [], l = [], c = [], h = new S(), u = new S(), d = new S();
    for (let p = 0; p <= n; p++)
      for (let f = 0; f <= r; f++) {
        const v = f / r * s, m = p / n * Math.PI * 2;
        u.x = (e + t * Math.cos(m)) * Math.cos(v), u.y = (e + t * Math.cos(m)) * Math.sin(v), u.z = t * Math.sin(m), o.push(u.x, u.y, u.z), h.x = e * Math.cos(v), h.y = e * Math.sin(v), d.subVectors(u, h).normalize(), l.push(d.x, d.y, d.z), c.push(f / r), c.push(p / n);
      }
    for (let p = 1; p <= n; p++)
      for (let f = 1; f <= r; f++) {
        const v = (r + 1) * p + f - 1, m = (r + 1) * (p - 1) + f - 1, y = (r + 1) * (p - 1) + f, g = (r + 1) * p + f;
        a.push(v, m, g), a.push(m, y, g);
      }
    this.setIndex(a), this.setAttribute("position", new ye(o, 3)), this.setAttribute("normal", new ye(l, 3)), this.setAttribute("uv", new ye(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Rr(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class lf extends Re {
  constructor(e = 1, t = 0.4, n = 64, r = 8, s = 2, a = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: r, p: s, q: a }, n = Math.floor(n), r = Math.floor(r);
    const o = [], l = [], c = [], h = [], u = new S(), d = new S(), p = new S(), f = new S(), v = new S(), m = new S(), y = new S();
    for (let _ = 0; _ <= n; ++_) {
      const x = _ / n * s * Math.PI * 2;
      g(x, s, a, e, p), g(x + 0.01, s, a, e, f), m.subVectors(f, p), y.addVectors(f, p), v.crossVectors(m, y), y.crossVectors(v, m), v.normalize(), y.normalize();
      for (let M = 0; M <= r; ++M) {
        const b = M / r * Math.PI * 2, w = -t * Math.cos(b), T = t * Math.sin(b);
        u.x = p.x + (w * y.x + T * v.x), u.y = p.y + (w * y.y + T * v.y), u.z = p.z + (w * y.z + T * v.z), l.push(u.x, u.y, u.z), d.subVectors(u, p).normalize(), c.push(d.x, d.y, d.z), h.push(_ / n), h.push(M / r);
      }
    }
    for (let _ = 1; _ <= n; _++)
      for (let x = 1; x <= r; x++) {
        const M = (r + 1) * (_ - 1) + (x - 1), b = (r + 1) * _ + (x - 1), w = (r + 1) * _ + x, T = (r + 1) * (_ - 1) + x;
        o.push(M, b, T), o.push(b, w, T);
      }
    function g(_, x, M, b, w) {
      const T = Math.cos(_), A = Math.sin(_), L = M / x * _, I = Math.cos(L);
      w.x = b * (2 + I) * 0.5 * T, w.y = b * (2 + I) * A * 0.5, w.z = b * Math.sin(L) * 0.5;
    }
    this.setIndex(o), this.setAttribute("position", new ye(l, 3)), this.setAttribute("normal", new ye(c, 3)), this.setAttribute("uv", new ye(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new lf(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Ps extends Re {
  constructor(e = new x1(new S(-1, -1, 0), new S(-1, 1, 0), new S(1, 1, 0)), t = 64, n = 1, r = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: r, closed: s };
    const a = e.computeFrenetFrames(t, s);
    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
    const o = new S(), l = new S(), c = new Y();
    let h = new S();
    const u = [], d = [], p = [], f = [];
    function v(m) {
      h = e.getPointAt(m / t, h);
      const y = a.normals[m], g = a.binormals[m];
      for (let _ = 0; _ <= r; _++) {
        const x = _ / r * Math.PI * 2, M = Math.sin(x), b = -Math.cos(x);
        l.x = b * y.x + M * g.x, l.y = b * y.y + M * g.y, l.z = b * y.z + M * g.z, l.normalize(), d.push(l.x, l.y, l.z), o.x = h.x + n * l.x, o.y = h.y + n * l.y, o.z = h.z + n * l.z, u.push(o.x, o.y, o.z);
      }
    }
    (function() {
      for (let m = 0; m < t; m++)
        v(m);
      v(s === !1 ? t : 0), function() {
        for (let m = 0; m <= t; m++)
          for (let y = 0; y <= r; y++)
            c.x = m / t, c.y = y / r, p.push(c.x, c.y);
      }(), function() {
        for (let m = 1; m <= t; m++)
          for (let y = 1; y <= r; y++) {
            const g = (r + 1) * (m - 1) + (y - 1), _ = (r + 1) * m + (y - 1), x = (r + 1) * m + y, M = (r + 1) * (m - 1) + y;
            f.push(g, _, M), f.push(_, x, M);
          }
      }();
    })(), this.setIndex(f), this.setAttribute("position", new ye(u, 3)), this.setAttribute("normal", new ye(d, 3)), this.setAttribute("uv", new ye(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new Ps(new pp[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
  }
}
class M1 extends Re {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), r = new S(), s = new S();
      if (e.index !== null) {
        const a = e.attributes.position, o = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let c = 0, h = l.length; c < h; ++c) {
          const u = l[c], d = u.start;
          for (let p = d, f = d + u.count; p < f; p += 3)
            for (let v = 0; v < 3; v++) {
              const m = o.getX(p + v), y = o.getX(p + (v + 1) % 3);
              r.fromBufferAttribute(a, m), s.fromBufferAttribute(a, y), q2(r, s, n) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let o = 0, l = a.count / 3; o < l; o++)
          for (let c = 0; c < 3; c++) {
            const h = 3 * o + c, u = 3 * o + (c + 1) % 3;
            r.fromBufferAttribute(a, h), s.fromBufferAttribute(a, u), q2(r, s, n) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new ye(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function q2(i, e, t) {
  const n = `${i.x},${i.y},${i.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${i.x},${i.y},${i.z}`;
  return t.has(n) !== !0 && t.has(r) !== !0 && (t.add(n), t.add(r), !0);
}
var Y2 = Object.freeze({ __proto__: null, BoxGeometry: Pt, CapsuleGeometry: Jp, CircleGeometry: $p, ConeGeometry: ef, CylinderGeometry: Ft, DodecahedronGeometry: tf, EdgesGeometry: rw, ExtrudeGeometry: Gh, IcosahedronGeometry: rf, LatheGeometry: Hh, OctahedronGeometry: Lr, PlaneGeometry: Qa, PolyhedronGeometry: Rs, RingGeometry: sf, ShapeGeometry: af, SphereGeometry: gl, TetrahedronGeometry: of, TorusGeometry: Rr, TorusKnotGeometry: lf, TubeGeometry: Ps, WireframeGeometry: M1 });
class ow extends Wt {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new ce(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class w1 extends st {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class uh extends Wt {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new ce(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ce(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bt(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Ai extends uh {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Y(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      return Dt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, set: function(t) {
      this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
    } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new ce(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ce(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ce(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class Ea extends Wt {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new ce(16777215), this.specular = new ce(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ce(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bt(), this.combine = Fh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class S1 extends Wt {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new ce(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ce(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class cf extends Wt {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class T1 extends Wt {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new ce(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ce(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bt(), this.combine = Fh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class lw extends Wt {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new ce(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Y(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class cw extends zt {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function ya(i, e, t) {
  return !i || !t && i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i);
}
function hw(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function uw(i) {
  const e = i.length, t = new Array(e);
  for (let n = 0; n !== e; ++n)
    t[n] = n;
  return t.sort(function(n, r) {
    return i[n] - i[r];
  }), t;
}
function g0(i, e, t) {
  const n = i.length, r = new i.constructor(n);
  for (let s = 0, a = 0; a !== n; ++s) {
    const o = t[s] * e;
    for (let l = 0; l !== e; ++l)
      r[a++] = i[o + l];
  }
  return r;
}
function E1(i, e, t, n) {
  let r = 1, s = i[0];
  for (; s !== void 0 && s[n] === void 0; )
    s = i[r++];
  if (s === void 0)
    return;
  let a = s[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        a = s[n], a !== void 0 && (e.push(s.time), t.push.apply(t, a)), s = i[r++];
      while (s !== void 0);
    else if (a.toArray !== void 0)
      do
        a = s[n], a !== void 0 && (e.push(s.time), a.toArray(t, t.length)), s = i[r++];
      while (s !== void 0);
    else
      do
        a = s[n], a !== void 0 && (e.push(s.time), t.push(a)), s = i[r++];
      while (s !== void 0);
}
const GA = { convertArray: ya, isTypedArray: hw, getKeyframeOrder: uw, sortedArray: g0, flattenJSON: E1, subclip: function(i, e, t, n, r = 30) {
  const s = i.clone();
  s.name = e;
  const a = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const c = s.tracks[l], h = c.getValueSize(), u = [], d = [];
    for (let p = 0; p < c.times.length; ++p) {
      const f = c.times[p] * r;
      if (!(f < t || f >= n)) {
        u.push(c.times[p]);
        for (let v = 0; v < h; ++v)
          d.push(c.values[p * h + v]);
      }
    }
    u.length !== 0 && (c.times = ya(u, c.times.constructor), c.values = ya(d, c.values.constructor), a.push(c));
  }
  s.tracks = a;
  let o = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l)
    s.tracks[l].shift(-1 * o);
  return s.resetDuration(), s;
}, makeClipAdditive: function(i, e = 0, t = i, n = 30) {
  n <= 0 && (n = 30);
  const r = t.tracks.length, s = e / n;
  for (let a = 0; a < r; ++a) {
    const o = t.tracks[a], l = o.ValueTypeName;
    if (l === "bool" || l === "string")
      continue;
    const c = i.tracks.find(function(y) {
      return y.name === o.name && y.ValueTypeName === l;
    });
    if (c === void 0)
      continue;
    let h = 0;
    const u = o.getValueSize();
    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = u / 3);
    let d = 0;
    const p = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = p / 3);
    const f = o.times.length - 1;
    let v;
    if (s <= o.times[0]) {
      const y = h, g = u - h;
      v = o.values.slice(y, g);
    } else if (s >= o.times[f]) {
      const y = f * u + h, g = y + u - h;
      v = o.values.slice(y, g);
    } else {
      const y = o.createInterpolant(), g = h, _ = u - h;
      y.evaluate(s), v = y.resultBuffer.slice(g, _);
    }
    l === "quaternion" && new Qe().fromArray(v).normalize().conjugate().toArray(v);
    const m = c.times.length;
    for (let y = 0; y < m; ++y) {
      const g = y * p + d;
      if (l === "quaternion")
        Qe.multiplyQuaternionsFlat(c.values, g, v, 0, c.values, g);
      else {
        const _ = p - 2 * d;
        for (let x = 0; x < _; ++x)
          c.values[g + x] -= v[x];
      }
    }
  }
  return i.blendMode = h1, i;
} };
class Rl {
  constructor(e, t, n, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, r = t[n], s = t[n - 1];
    e: {
      t: {
        let a;
        n: {
          i:
            if (!(e < r)) {
              for (let o = n + 2; ; ) {
                if (r === void 0) {
                  if (e < s)
                    break i;
                  return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === o)
                  break;
                if (s = r, r = t[++n], e < r)
                  break t;
              }
              a = t.length;
              break n;
            }
          if (e >= s)
            break e;
          {
            const o = t[1];
            e < o && (n = 2, s = o);
            for (let l = n - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === l)
                break;
              if (r = s, s = t[--n - 1], e >= s)
                break t;
            }
            a = n, n = 0;
          }
        }
        for (; n < a; ) {
          const o = n + a >>> 1;
          e < t[o] ? a = o : n = o + 1;
        }
        if (r = t[n], s = t[n - 1], s === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, s, r);
    }
    return this.interpolate_(n, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = e * r;
    for (let a = 0; a !== r; ++a)
      t[a] = n[s + a];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class dw extends Rl {
  constructor(e, t, n, r) {
    super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: ga, endingEnd: ga };
  }
  intervalChanged_(e, t, n) {
    const r = this.parameterPositions;
    let s = e - 2, a = e + 1, o = r[s], l = r[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case va:
          s = e, o = 2 * t - n;
          break;
        case Qc:
          s = r.length - 2, o = t + r[s] - r[s + 1];
          break;
        default:
          s = e, o = n;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case va:
          a = e, l = 2 * n - t;
          break;
        case Qc:
          a = 1, l = n + r[1] - r[0];
          break;
        default:
          a = e - 1, l = t;
      }
    const c = 0.5 * (n - t), h = this.valueSize;
    this._weightPrev = c / (t - o), this._weightNext = c / (l - n), this._offsetPrev = s * h, this._offsetNext = a * h;
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, h = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, p = this._weightNext, f = (n - t) / (r - t), v = f * f, m = v * f, y = -d * m + 2 * d * v - d * f, g = (1 + d) * m + (-1.5 - 2 * d) * v + (-0.5 + d) * f + 1, _ = (-1 - p) * m + (1.5 + p) * v + 0.5 * f, x = p * m - p * v;
    for (let M = 0; M !== o; ++M)
      s[M] = y * a[h + M] + g * a[c + M] + _ * a[l + M] + x * a[u + M];
    return s;
  }
}
class v0 extends Rl {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, h = (n - t) / (r - t), u = 1 - h;
    for (let d = 0; d !== o; ++d)
      s[d] = a[c + d] * u + a[l + d] * h;
    return s;
  }
}
class pw extends Rl {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class ji {
  constructor(e, t, n, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = ya(t, this.TimeBufferType), this.values = ya(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = { name: e.name, times: ya(e.times, Array), values: ya(e.values, Array) };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (n.interpolation = r);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new pw(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new v0(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new dw(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case hl:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case ul:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case qd:
        t = this.InterpolantFactoryMethodSmooth;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (e === this.DefaultInterpolation)
          throw new Error(n);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return hl;
      case this.InterpolantFactoryMethodLinear:
        return ul;
      case this.InterpolantFactoryMethodSmooth:
        return qd;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n)
        t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n)
        t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times, r = n.length;
    let s = 0, a = r - 1;
    for (; s !== r && n[s] < e; )
      ++s;
    for (; a !== -1 && n[a] > t; )
      --a;
    if (++a, s !== 0 || a !== r) {
      s >= a && (a = Math.max(a, 1), s = a - 1);
      const o = this.getValueSize();
      this.times = n.slice(s, a), this.values = this.values.slice(s * o, a * o);
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, r = this.values, s = n.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let a = null;
    for (let o = 0; o !== s; o++) {
      const l = n[o];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = !1;
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = !1;
        break;
      }
      a = l;
    }
    if (r !== void 0 && hw(r))
      for (let o = 0, l = r.length; o !== l; ++o) {
        const c = r[o];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), r = this.getInterpolation() === qd, s = e.length - 1;
    let a = 1;
    for (let o = 1; o < s; ++o) {
      let l = !1;
      const c = e[o];
      if (c !== e[o + 1] && (o !== 1 || c !== e[0]))
        if (r)
          l = !0;
        else {
          const h = o * n, u = h - n, d = h + n;
          for (let p = 0; p !== n; ++p) {
            const f = t[h + p];
            if (f !== t[u + p] || f !== t[d + p]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const h = o * n, u = a * n;
          for (let d = 0; d !== n; ++d)
            t[u + d] = t[h + d];
        }
        ++a;
      }
    }
    if (s > 0) {
      e[a] = e[s];
      for (let o = s * n, l = a * n, c = 0; c !== n; ++c)
        t[l + c] = t[o + c];
      ++a;
    }
    return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = new this.constructor(this.name, e, t);
    return n.createInterpolant = this.createInterpolant, n;
  }
}
ji.prototype.TimeBufferType = Float32Array, ji.prototype.ValueBufferType = Float32Array, ji.prototype.DefaultInterpolation = ul;
class ha extends ji {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
ha.prototype.ValueTypeName = "bool", ha.prototype.ValueBufferType = Array, ha.prototype.DefaultInterpolation = hl, ha.prototype.InterpolantFactoryMethodLinear = void 0, ha.prototype.InterpolantFactoryMethodSmooth = void 0;
class A1 extends ji {
}
A1.prototype.ValueTypeName = "color";
class bs extends ji {
}
bs.prototype.ValueTypeName = "number";
class fw extends Rl {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (n - t) / (r - t);
    let c = e * o;
    for (let h = c + o; c !== h; c += 4)
      Qe.slerpFlat(s, 0, a, c - o, a, c, l);
    return s;
  }
}
class Br extends ji {
  InterpolantFactoryMethodLinear(e) {
    return new fw(this.times, this.values, this.getValueSize(), e);
  }
}
Br.prototype.ValueTypeName = "quaternion", Br.prototype.InterpolantFactoryMethodSmooth = void 0;
class ua extends ji {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
ua.prototype.ValueTypeName = "string", ua.prototype.ValueBufferType = Array, ua.prototype.DefaultInterpolation = hl, ua.prototype.InterpolantFactoryMethodLinear = void 0, ua.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ms extends ji {
}
Ms.prototype.ValueTypeName = "vector";
class da {
  constructor(e = "", t = -1, n = [], r = 2500) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = ci(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, r = 1 / (e.fps || 1);
    for (let a = 0, o = n.length; a !== o; ++a)
      t.push(VA(n[a]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode };
    for (let s = 0, a = n.length; s !== a; ++s)
      t.push(ji.toJSON(n[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, n, r) {
    const s = t.length, a = [];
    for (let o = 0; o < s; o++) {
      let l = [], c = [];
      l.push((o + s - 1) % s, o, (o + 1) % s), c.push(0, 1, 0);
      const h = uw(l);
      l = g0(l, 1, h), c = g0(c, 1, h), r || l[0] !== 0 || (l.push(s), c.push(c[0])), a.push(new bs(".morphTargetInfluences[" + t[o].name + "]", l, c).scale(1 / n));
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const r = e;
      n = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < n.length; r++)
      if (n[r].name === t)
        return n[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], h = c.name.match(s);
      if (h && h.length > 1) {
        const u = h[1];
        let d = r[u];
        d || (r[u] = d = []), d.push(c);
      }
    }
    const a = [];
    for (const o in r)
      a.push(this.CreateFromMorphTargetSequence(o, r[o], t, n));
    return a;
  }
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(h, u, d, p, f) {
      if (d.length !== 0) {
        const v = [], m = [];
        E1(d, v, m, p), v.length !== 0 && f.push(new h(u, v, m));
      }
    }, r = [], s = e.name || "default", a = e.fps || 30, o = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let h = 0; h < c.length; h++) {
      const u = c[h].keys;
      if (u && u.length !== 0)
        if (u[0].morphTargets) {
          const d = {};
          let p;
          for (p = 0; p < u.length; p++)
            if (u[p].morphTargets)
              for (let f = 0; f < u[p].morphTargets.length; f++)
                d[u[p].morphTargets[f]] = -1;
          for (const f in d) {
            const v = [], m = [];
            for (let y = 0; y !== u[p].morphTargets.length; ++y) {
              const g = u[p];
              v.push(g.time), m.push(g.morphTarget === f ? 1 : 0);
            }
            r.push(new bs(".morphTargetInfluence[" + f + "]", v, m));
          }
          l = d.length * a;
        } else {
          const d = ".bones[" + t[h].name + "]";
          n(Ms, d + ".position", u, "pos", r), n(Br, d + ".quaternion", u, "rot", r), n(Ms, d + ".scale", u, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, l, r, o);
  }
  resetDuration() {
    let e = 0;
    for (let t = 0, n = this.tracks.length; t !== n; ++t) {
      const r = this.tracks[t];
      e = Math.max(e, r.times[r.times.length - 1]);
    }
    return this.duration = e, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function VA(i) {
  if (i.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = function(t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return bs;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Ms;
      case "color":
        return A1;
      case "quaternion":
        return Br;
      case "bool":
      case "boolean":
        return ha;
      case "string":
        return ua;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  }(i.type);
  if (i.times === void 0) {
    const t = [], n = [];
    E1(i.keys, t, n, "value"), i.times = t, i.values = n;
  }
  return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
}
const Dr = { enabled: !1, files: {}, add: function(i, e) {
  this.enabled !== !1 && (this.files[i] = e);
}, get: function(i) {
  if (this.enabled !== !1)
    return this.files[i];
}, remove: function(i) {
  delete this.files[i];
}, clear: function() {
  this.files = {};
} };
class y0 {
  constructor(e, t, n) {
    const r = this;
    let s = !1, a = 0, o = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(h) {
      o++, s === !1 && r.onStart !== void 0 && r.onStart(h, a, o), s = !0;
    }, this.itemEnd = function(h) {
      a++, r.onProgress !== void 0 && r.onProgress(h, a, o), a === o && (s = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(h) {
      r.onError !== void 0 && r.onError(h);
    }, this.resolveURL = function(h) {
      return l ? l(h) : h;
    }, this.setURLModifier = function(h) {
      return l = h, this;
    }, this.addHandler = function(h, u) {
      return c.push(h, u), this;
    }, this.removeHandler = function(h) {
      const u = c.indexOf(h);
      return u !== -1 && c.splice(u, 2), this;
    }, this.getHandler = function(h) {
      for (let u = 0, d = c.length; u < d; u += 2) {
        const p = c[u], f = c[u + 1];
        if (p.global && (p.lastIndex = 0), p.test(h))
          return f;
      }
      return null;
    };
  }
}
const I1 = new y0();
class Lt {
  constructor(e) {
    this.manager = e !== void 0 ? e : I1, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(r, s) {
      n.load(e, r, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Lt.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const xr = {};
class jA extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class xn extends Lt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = Dr.get(e);
    if (s !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
    if (xr[e] !== void 0)
      return void xr[e].push({ onLoad: t, onProgress: n, onError: r });
    xr[e] = [], xr[e].push({ onLoad: t, onProgress: n, onError: r });
    const a = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o = this.mimeType, l = this.responseType;
    fetch(a).then((c) => {
      if (c.status === 200 || c.status === 0) {
        if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream == "undefined" || c.body === void 0 || c.body.getReader === void 0)
          return c;
        const h = xr[e], u = c.body.getReader(), d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"), p = d ? parseInt(d) : 0, f = p !== 0;
        let v = 0;
        const m = new ReadableStream({ start(y) {
          (function g() {
            u.read().then(({ done: _, value: x }) => {
              if (_)
                y.close();
              else {
                v += x.byteLength;
                const M = new ProgressEvent("progress", { lengthComputable: f, loaded: v, total: p });
                for (let b = 0, w = h.length; b < w; b++) {
                  const T = h[b];
                  T.onProgress && T.onProgress(M);
                }
                y.enqueue(x), g();
              }
            }, (_) => {
              y.error(_);
            });
          })();
        } });
        return new Response(m);
      }
      throw new jA(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
    }).then((c) => {
      switch (l) {
        case "arraybuffer":
          return c.arrayBuffer();
        case "blob":
          return c.blob();
        case "document":
          return c.text().then((h) => new DOMParser().parseFromString(h, o));
        case "json":
          return c.json();
        default:
          if (o === void 0)
            return c.text();
          {
            const h = /charset="?([^;"\s]*)"?/i.exec(o), u = h && h[1] ? h[1].toLowerCase() : void 0, d = new TextDecoder(u);
            return c.arrayBuffer().then((p) => d.decode(p));
          }
      }
    }).then((c) => {
      Dr.add(e, c);
      const h = xr[e];
      delete xr[e];
      for (let u = 0, d = h.length; u < d; u++) {
        const p = h[u];
        p.onLoad && p.onLoad(c);
      }
    }).catch((c) => {
      const h = xr[e];
      if (h === void 0)
        throw this.manager.itemError(e), c;
      delete xr[e];
      for (let u = 0, d = h.length; u < d; u++) {
        const p = h[u];
        p.onError && p.onError(c);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class Ec extends Lt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, a = Dr.get(e);
    if (a !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(a), s.manager.itemEnd(e);
      }, 0), a;
    const o = rh("img");
    function l() {
      h(), Dr.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(u) {
      h(), r && r(u), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      o.removeEventListener("load", l, !1), o.removeEventListener("error", c, !1);
    }
    return o.addEventListener("load", l, !1), o.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(e), o.src = e, o;
  }
}
class Va extends Lt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = new vt(), a = new Ec(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
      s.image = o, s.needsUpdate = !0, t !== void 0 && t(s);
    }, n, r), s;
  }
}
class Ls extends Fe {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new ce(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class Z2 extends Ls {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Fe.DEFAULT_UP), this.updateMatrix(), this.groundColor = new ce(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Im = new fe(), K2 = new S(), Q2 = new S();
class C1 {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Y(512, 512), this.map = null, this.mapPass = null, this.matrix = new fe(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new sh(), this._frameExtents = new Y(1, 1), this._viewportCount = 1, this._viewports = [new je(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    K2.setFromMatrixPosition(e.matrixWorld), t.position.copy(K2), Q2.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Q2), t.updateMatrixWorld(), Im.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Im), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(Im);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class WA extends C1 {
  constructor() {
    super(new jt(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = 2 * dl * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    n === t.fov && r === t.aspect && s === t.far || (t.fov = n, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class dh extends Ls {
  constructor(e, t, n = 0, r = Math.PI / 3, s = 0, a = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Fe.DEFAULT_UP), this.updateMatrix(), this.target = new Fe(), this.distance = n, this.angle = r, this.penumbra = s, this.decay = a, this.map = null, this.shadow = new WA();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const J2 = new fe(), lc = new S(), Cm = new S();
class XA extends C1 {
  constructor() {
    super(new jt(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Y(4, 2), this._viewportCount = 6, this._viewports = [new je(2, 1, 1, 1), new je(0, 1, 1, 1), new je(3, 1, 1, 1), new je(1, 1, 1, 1), new je(3, 0, 1, 1), new je(1, 0, 1, 1)], this._cubeDirections = [new S(1, 0, 0), new S(-1, 0, 0), new S(0, 0, 1), new S(0, 0, -1), new S(0, 1, 0), new S(0, -1, 0)], this._cubeUps = [new S(0, 1, 0), new S(0, 1, 0), new S(0, 1, 0), new S(0, 1, 0), new S(0, 0, 1), new S(0, 0, -1)];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, r = this.matrix, s = e.distance || n.far;
    s !== n.far && (n.far = s, n.updateProjectionMatrix()), lc.setFromMatrixPosition(e.matrixWorld), n.position.copy(lc), Cm.copy(n.position), Cm.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Cm), n.updateMatrixWorld(), r.makeTranslation(-lc.x, -lc.y, -lc.z), J2.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(J2);
  }
}
class vl extends Ls {
  constructor(e, t, n = 0, r = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new XA();
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class qA extends C1 {
  constructor() {
    super(new Ha(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class ph extends Ls {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Fe.DEFAULT_UP), this.updateMatrix(), this.target = new Fe(), this.shadow = new qA();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class _0 extends Ls {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class $2 extends Ls {
  constructor(e, t, n = 10, r = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class mw {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new S());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const n = e.x, r = e.y, s = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.282095), t.addScaledVector(a[1], 0.488603 * r), t.addScaledVector(a[2], 0.488603 * s), t.addScaledVector(a[3], 0.488603 * n), t.addScaledVector(a[4], n * r * 1.092548), t.addScaledVector(a[5], r * s * 1.092548), t.addScaledVector(a[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(a[7], n * s * 1.092548), t.addScaledVector(a[8], 0.546274 * (n * n - r * r)), t;
  }
  getIrradianceAt(e, t) {
    const n = e.x, r = e.y, s = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.886227), t.addScaledVector(a[1], 1.023328 * r), t.addScaledVector(a[2], 1.023328 * s), t.addScaledVector(a[3], 1.023328 * n), t.addScaledVector(a[4], 0.858086 * n * r), t.addScaledVector(a[5], 0.858086 * r * s), t.addScaledVector(a[6], 0.743125 * s * s - 0.247708), t.addScaledVector(a[7], 0.858086 * n * s), t.addScaledVector(a[8], 0.429043 * (n * n - r * r)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].fromArray(e, t + 3 * r);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].toArray(e, t + 3 * r);
    return e;
  }
  static getBasisAt(e, t) {
    const n = e.x, r = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * r, t[2] = 0.488603 * s, t[3] = 0.488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * n * s, t[8] = 0.546274 * (n * n - r * r);
  }
}
class e3 extends Ls {
  constructor(e = new mw(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class fp extends Lt {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, r) {
    const s = this, a = new xn(s.manager);
    a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(o) {
      try {
        t(s.parse(JSON.parse(o)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(e);
      }
    }, n, r);
  }
  parse(e) {
    const t = this.textures;
    function n(s) {
      return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s];
    }
    const r = fp.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new ce().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (r.dispersion = e.dispersion), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc), e.blendDst !== void 0 && (r.blendDst = e.blendDst), e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== void 0 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const s in e.uniforms) {
        const a = e.uniforms[s];
        switch (r.uniforms[s] = {}, a.type) {
          case "t":
            r.uniforms[s].value = n(a.value);
            break;
          case "c":
            r.uniforms[s].value = new ce().setHex(a.value);
            break;
          case "v2":
            r.uniforms[s].value = new Y().fromArray(a.value);
            break;
          case "v3":
            r.uniforms[s].value = new S().fromArray(a.value);
            break;
          case "v4":
            r.uniforms[s].value = new je().fromArray(a.value);
            break;
          case "m3":
            r.uniforms[s].value = new Ue().fromArray(a.value);
            break;
          case "m4":
            r.uniforms[s].value = new fe().fromArray(a.value);
            break;
          default:
            r.uniforms[s].value = a.value;
        }
      }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const s in e.extensions)
        r.extensions[s] = e.extensions[s];
    if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = n(e.map)), e.matcap !== void 0 && (r.matcap = n(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new Y().fromArray(s);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = n(e.envMap)), e.envMapRotation !== void 0 && r.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new Y().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    return new { ShadowMaterial: ow, SpriteMaterial: Kp, RawShaderMaterial: w1, ShaderMaterial: st, PointsMaterial: ss, MeshPhysicalMaterial: Ai, MeshStandardMaterial: uh, MeshPhongMaterial: Ea, MeshToonMaterial: S1, MeshNormalMaterial: cf, MeshLambertMaterial: T1, MeshDepthMaterial: Zp, MeshDistanceMaterial: m1, MeshBasicMaterial: nn, MeshMatcapMaterial: lw, LineDashedMaterial: cw, LineBasicMaterial: zt, Material: Wt }[e]();
  }
}
class cr {
  static decodeText(e) {
    if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder != "undefined")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, r = e.length; n < r; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch (n) {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class R1 extends Re {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class t3 extends Lt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, a = new xn(s.manager);
    a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(o) {
      try {
        t(s.parse(JSON.parse(o)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(e);
      }
    }, n, r);
  }
  parse(e) {
    const t = {}, n = {};
    function r(u, d) {
      if (t[d] !== void 0)
        return t[d];
      const p = u.interleavedBuffers[d], f = function(y, g) {
        if (n[g] !== void 0)
          return n[g];
        const _ = y.arrayBuffers, x = _[g], M = new Uint32Array(x).buffer;
        return n[g] = M, M;
      }(u, p.buffer), v = ko(p.type, f), m = new zh(v, p.stride);
      return m.uuid = p.uuid, t[d] = m, m;
    }
    const s = e.isInstancedBufferGeometry ? new R1() : new Re(), a = e.data.index;
    if (a !== void 0) {
      const u = ko(a.type, a.array);
      s.setIndex(new it(u, 1));
    }
    const o = e.data.attributes;
    for (const u in o) {
      const d = o[u];
      let p;
      if (d.isInterleavedBufferAttribute) {
        const f = r(e.data, d.data);
        p = new Gn(f, d.itemSize, d.offset, d.normalized);
      } else {
        const f = ko(d.type, d.array);
        p = new (d.isInstancedBufferAttribute ? Sa : it)(f, d.itemSize, d.normalized);
      }
      d.name !== void 0 && (p.name = d.name), d.usage !== void 0 && p.setUsage(d.usage), s.setAttribute(u, p);
    }
    const l = e.data.morphAttributes;
    if (l)
      for (const u in l) {
        const d = l[u], p = [];
        for (let f = 0, v = d.length; f < v; f++) {
          const m = d[f];
          let y;
          if (m.isInterleavedBufferAttribute) {
            const g = r(e.data, m.data);
            y = new Gn(g, m.itemSize, m.offset, m.normalized);
          } else {
            const g = ko(m.type, m.array);
            y = new it(g, m.itemSize, m.normalized);
          }
          m.name !== void 0 && (y.name = m.name), p.push(y);
        }
        s.morphAttributes[u] = p;
      }
    e.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
    const c = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (c !== void 0)
      for (let u = 0, d = c.length; u !== d; ++u) {
        const p = c[u];
        s.addGroup(p.start, p.count, p.materialIndex);
      }
    const h = e.data.boundingSphere;
    if (h !== void 0) {
      const u = new S();
      h.center !== void 0 && u.fromArray(h.center), s.boundingSphere = new an(u, h.radius);
    }
    return e.name && (s.name = e.name), e.userData && (s.userData = e.userData), s;
  }
}
const YA = { UVMapping: Vp, CubeReflectionMapping: Fr, CubeRefractionMapping: ys, EquirectangularReflectionMapping: ol, EquirectangularRefractionMapping: Kc, CubeUVReflectionMapping: Il }, n3 = { RepeatWrapping: In, ClampToEdgeWrapping: ri, MirroredRepeatWrapping: Fa }, i3 = { NearestFilter: lt, NearestMipmapNearestFilter: jp, NearestMipmapLinearFilter: ma, LinearFilter: Gt, LinearMipmapNearestFilter: Zo, LinearMipmapLinearFilter: zi };
class gw extends Lt {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, a = Dr.get(e);
    if (a !== void 0)
      return s.manager.itemStart(e), a.then ? void a.then((c) => {
        t && t(c), s.manager.itemEnd(e);
      }).catch((c) => {
        r && r(c);
      }) : (setTimeout(function() {
        t && t(a), s.manager.itemEnd(e);
      }, 0), a);
    const o = {};
    o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
    const l = fetch(e, o).then(function(c) {
      return c.blob();
    }).then(function(c) {
      return createImageBitmap(c, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(c) {
      return Dr.add(e, c), t && t(c), s.manager.itemEnd(e), c;
    }).catch(function(c) {
      r && r(c), Dr.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
    });
    Dr.add(e, l), s.manager.itemStart(e);
  }
}
let cd;
class Rm {
  static getContext() {
    return cd === void 0 && (cd = new (window.AudioContext || window.webkitAudioContext)()), cd;
  }
  static setContext(e) {
    cd = e;
  }
}
const r3 = new fe(), s3 = new fe(), Ws = new fe();
class x0 {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = a3(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = a3();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function a3() {
  return (typeof performance == "undefined" ? Date : performance).now();
}
const Xs = new S(), o3 = new Qe(), ZA = new S(), qs = new S();
class l3 extends Fe {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0)
      return void console.warn("THREE.Audio: Audio is already playing.");
    if (this.hasPlaybackControl === !1)
      return void console.warn("THREE.Audio: this Audio has no playback control.");
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl !== !1)
      return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  stop() {
    if (this.hasPlaybackControl !== !1)
      return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl !== !1)
      return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl !== !1)
      return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const Ys = new S(), c3 = new Qe(), KA = new S(), Zs = new S();
class h3 {
  constructor(e, t, n) {
    let r, s, a;
    switch (this.binding = e, this.valueSize = n, t) {
      case "quaternion":
        r = this._slerp, s = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, s = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
        break;
      default:
        r = this._lerp, s = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(e, t) {
    const n = this.buffer, r = this.valueSize, s = e * r + r;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let o = 0; o !== r; ++o)
        n[s + o] = n[o];
      a = t;
    } else {
      a += t;
      const o = t / a;
      this._mixBufferRegion(n, s, 0, o, r);
    }
    this.cumulativeWeight = a;
  }
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, r = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  apply(e) {
    const t = this.valueSize, n = this.buffer, r = e * t + t, s = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(n, r, l, 1 - s, t);
    }
    a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (n[l] !== n[l + t]) {
        o.setValue(n, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, r = n * this._origIndex;
    e.getValue(t, r);
    for (let s = n, a = r; s !== a; ++s)
      t[s] = t[r + s % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const e = 3 * this.valueSize;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  _select(e, t, n, r, s) {
    if (r >= 0.5)
      for (let a = 0; a !== s; ++a)
        e[t + a] = e[n + a];
  }
  _slerp(e, t, n, r) {
    Qe.slerpFlat(e, t, e, t, e, n, r);
  }
  _slerpAdditive(e, t, n, r, s) {
    const a = this._workIndex * s;
    Qe.multiplyQuaternionsFlat(e, a, e, t, e, n), Qe.slerpFlat(e, t, e, t, e, a, r);
  }
  _lerp(e, t, n, r, s) {
    const a = 1 - r;
    for (let o = 0; o !== s; ++o) {
      const l = t + o;
      e[l] = e[l] * a + e[n + o] * r;
    }
  }
  _lerpAdditive(e, t, n, r, s) {
    for (let a = 0; a !== s; ++a) {
      const o = t + a;
      e[o] = e[o] + e[n + a] * r;
    }
  }
}
const P1 = "\\[\\]\\.:\\/", QA = new RegExp("[" + P1 + "]", "g"), Pm = "[^" + P1 + "]", JA = "[^" + P1.replace("\\.", "") + "]", $A = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Pm) + /(WCOD+)?/.source.replace("WCOD", JA) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Pm) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Pm) + "$"), e5 = ["material", "materials", "bones", "map"];
class Ze {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || Ze.parseTrackName(t), this.node = Ze.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new Ze.Composite(e, t, n) : new Ze(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(QA, "");
  }
  static parseTrackName(e) {
    const t = $A.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = n.nodeName && n.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = n.nodeName.substring(r + 1);
      e5.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = s);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(s) {
        for (let a = 0; a < s.length; a++) {
          const o = s[a];
          if (o.name === t || o.uuid === t)
            return o;
          const l = n(o.children);
          if (l)
            return l;
        }
        return null;
      }, r = n(e.children);
      if (r)
        return r;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      e[t++] = n[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, r = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = Ze.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e)
      return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
    if (n) {
      let c = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material)
            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!e.material.materials)
            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton)
            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === c) {
              c = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material)
            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!e.material.map)
            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0)
            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
          e = e[n];
      }
      if (c !== void 0) {
        if (e[c] === void 0)
          return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
        e = e[c];
      }
    }
    const a = e[r];
    if (a === void 0) {
      const c = t.nodeName;
      return void console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e);
    }
    let o = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry)
          return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
        if (!e.geometry.morphAttributes)
          return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s;
    } else
      a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Ze.Composite = class {
  constructor(i, e, t) {
    const n = t || Ze.parseTrackName(e);
    this._targetGroup = i, this._bindings = i.subscribe_(e, n);
  }
  getValue(i, e) {
    this.bind();
    const t = this._targetGroup.nCachedObjects_, n = this._bindings[t];
    n !== void 0 && n.getValue(i, e);
  }
  setValue(i, e) {
    const t = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = t.length; n !== r; ++n)
      t[n].setValue(i, e);
  }
  bind() {
    const i = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, t = i.length; e !== t; ++e)
      i[e].bind();
  }
  unbind() {
    const i = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, t = i.length; e !== t; ++e)
      i[e].unbind();
  }
}, Ze.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Ze.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Ze.prototype.GetterByBindingType = [Ze.prototype._getValue_direct, Ze.prototype._getValue_array, Ze.prototype._getValue_arrayElement, Ze.prototype._getValue_toArray], Ze.prototype.SetterByBindingTypeAndVersioning = [[Ze.prototype._setValue_direct, Ze.prototype._setValue_direct_setNeedsUpdate, Ze.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ze.prototype._setValue_array, Ze.prototype._setValue_array_setNeedsUpdate, Ze.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ze.prototype._setValue_arrayElement, Ze.prototype._setValue_arrayElement_setNeedsUpdate, Ze.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ze.prototype._setValue_fromArray, Ze.prototype._setValue_fromArray_setNeedsUpdate, Ze.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class u3 {
  constructor(e, t, n = null, r = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
    const s = t.tracks, a = s.length, o = new Array(a), l = { endingStart: ga, endingEnd: ga };
    for (let c = 0; c !== a; ++c) {
      const h = s[c].createInterpolant(null);
      o[c] = h, h.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const r = this._clip.duration, s = e._clip.duration, a = s / r, o = r / s;
      e.warp(1, a, t), this.warp(o, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const r = this._mixer, s = r.time, a = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
    const l = o.parameterPositions, c = o.sampleValues;
    return l[0] = s, l[1] = s + n, c[0] = e / a, c[1] = t / a, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, n, r) {
    if (!this.enabled)
      return void this._updateWeight(e);
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * n;
      l < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * l);
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t), o = this._updateWeight(e);
    if (o > 0) {
      const l = this._interpolants, c = this._propertyBindings;
      if (this.blendMode === h1)
        for (let h = 0, u = l.length; h !== u; ++h)
          l[h].evaluate(a), c[h].accumulateAdditive(o);
      else
        for (let h = 0, u = l.length; h !== u; ++h)
          l[h].evaluate(a), c[h].accumulate(r, o);
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const r = n.evaluate(e)[0];
        t *= r, e > n.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      n !== null && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t));
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let r = this.time + e, s = this._loopCount;
    const a = n === 2202;
    if (e === 0)
      return s === -1 || !a || 1 & ~s ? r : t - r;
    if (n === c1) {
      s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (r >= t)
          r = t;
        else {
          if (!(r < 0)) {
            this.time = r;
            break e;
          }
          r = 0;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), r >= t || r < 0) {
        const o = Math.floor(r / t);
        r -= t * o, s += Math.abs(o);
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = s, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o });
        }
      } else
        this.time = r;
      if (a && !(1 & ~s))
        return t - r;
    }
    return r;
  }
  _setEndings(e, t, n) {
    const r = this._interpolantSettings;
    n ? (r.endingStart = va, r.endingEnd = va) : (r.endingStart = e ? this.zeroSlopeAtStart ? va : ga : Qc, r.endingEnd = t ? this.zeroSlopeAtEnd ? va : ga : Qc);
  }
  _scheduleFading(e, t, n) {
    const r = this._mixer, s = r.time;
    let a = this._weightInterpolant;
    a === null && (a = r._lendControlInterpolant(), this._weightInterpolant = a);
    const o = a.parameterPositions, l = a.sampleValues;
    return o[0] = s, l[0] = t, o[1] = s + e, l[1] = n, this;
  }
}
const t5 = new Float32Array(1);
class L1 {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new L1(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let n5 = 0;
class mp extends zh {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
const d3 = new fe();
class D1 {
  constructor(e, t, n = 0, r = 1 / 0) {
    this.ray = new Ka(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new Wp(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return d3.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(d3), this;
  }
  intersectObject(e, t = !0, n = []) {
    return b0(e, this, n, t), n.sort(p3), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let r = 0, s = e.length; r < s; r++)
      b0(e[r], this, n, t);
    return n.sort(p3), n;
  }
}
function p3(i, e) {
  return i.distance - e.distance;
}
function b0(i, e, t, n) {
  let r = !0;
  if (i.layers.test(e.layers) && i.raycast(e, t) === !1 && (r = !1), r === !0 && n === !0) {
    const s = i.children;
    for (let a = 0, o = s.length; a < o; a++)
      b0(s[a], e, t, !0);
  }
}
class M0 {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Dt(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const f3 = new Y(), m3 = new S(), hd = new S();
class vw {
  constructor(e = new S(), t = new S()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    m3.subVectors(e, this.start), hd.subVectors(this.end, this.start);
    const n = hd.dot(hd);
    let r = hd.dot(m3) / n;
    return t && (r = Dt(r, 0, 1)), r;
  }
  closestPointToPoint(e, t, n) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const g3 = new S(), Jr = new S(), ud = new fe(), Lm = new fe();
function yw(i) {
  const e = [];
  i.isBone === !0 && e.push(i);
  for (let t = 0; t < i.children.length; t++)
    e.push.apply(e, yw(i.children[t]));
  return e;
}
const i5 = new S(), v3 = new ce(), y3 = new ce(), _3 = new S(), dd = new S(), x3 = new S(), pd = new S(), Rt = new qp();
function Ut(i, e, t, n, r, s, a) {
  pd.set(r, s, a).unproject(n);
  const o = e[i];
  if (o !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, h = o.length; c < h; c++)
      l.setXYZ(o[c], pd.x, pd.y, pd.z);
  }
}
const fd = new sn();
class _w extends Qn {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Re();
    r.setIndex(new it(n, 1)), r.setAttribute("position", new ye([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new zt({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const b3 = new S();
let md, Dm;
class xw {
  constructor() {
    this.type = "ShapePath", this.color = new ce(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new oh(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, r) {
    return this.currentPath.quadraticCurveTo(e, t, n, r), this;
  }
  bezierCurveTo(e, t, n, r, s, a) {
    return this.currentPath.bezierCurveTo(e, t, n, r, s, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(m, y) {
      const g = y.length;
      let _ = !1;
      for (let x = g - 1, M = 0; M < g; x = M++) {
        let b = y[x], w = y[M], T = w.x - b.x, A = w.y - b.y;
        if (Math.abs(A) > Number.EPSILON) {
          if (A < 0 && (b = y[M], T = -T, w = y[x], A = -A), m.y < b.y || m.y > w.y)
            continue;
          if (m.y === b.y) {
            if (m.x === b.x)
              return !0;
          } else {
            const L = A * (m.x - b.x) - T * (m.y - b.y);
            if (L === 0)
              return !0;
            if (L < 0)
              continue;
            _ = !_;
          }
        } else {
          if (m.y !== b.y)
            continue;
          if (w.x <= m.x && m.x <= b.x || b.x <= m.x && m.x <= w.x)
            return !0;
        }
      }
      return _;
    }
    const n = Vi.isClockWise, r = this.subPaths;
    if (r.length === 0)
      return [];
    let s, a, o;
    const l = [];
    if (r.length === 1)
      return a = r[0], o = new Ta(), o.curves = a.curves, l.push(o), l;
    let c = !n(r[0].getPoints());
    c = e ? !c : c;
    const h = [], u = [];
    let d, p, f = [], v = 0;
    u[v] = void 0, f[v] = [];
    for (let m = 0, y = r.length; m < y; m++)
      a = r[m], d = a.getPoints(), s = n(d), s = e ? !s : s, s ? (!c && u[v] && v++, u[v] = { s: new Ta(), p: d }, u[v].s.curves = a.curves, c && v++, f[v] = []) : f[v].push({ h: a, p: d[0] });
    if (!u[0])
      return function(m) {
        const y = [];
        for (let g = 0, _ = m.length; g < _; g++) {
          const x = m[g], M = new Ta();
          M.curves = x.curves, y.push(M);
        }
        return y;
      }(r);
    if (u.length > 1) {
      let m = !1, y = 0;
      for (let g = 0, _ = u.length; g < _; g++)
        h[g] = [];
      for (let g = 0, _ = u.length; g < _; g++) {
        const x = f[g];
        for (let M = 0; M < x.length; M++) {
          const b = x[M];
          let w = !0;
          for (let T = 0; T < u.length; T++)
            t(b.p, u[T].p) && (g !== T && y++, w ? (w = !1, h[T].push(b)) : m = !0);
          w && h[g].push(b);
        }
      }
      y > 0 && m === !1 && (f = h);
    }
    for (let m = 0, y = u.length; m < y; m++) {
      o = u[m].s, l.push(o), p = f[m];
      for (let g = 0, _ = p.length; g < _; g++)
        o.holes.push(p[g].h);
    }
    return l;
  }
}
typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: sp } })), typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = sp);
const W = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: r1, AddEquation: Mi, AddOperation: NM, AdditiveAnimationBlendMode: h1, AdditiveBlending: al, AgXToneMapping: s1, AlphaFormat: 1021, AlwaysCompare: 519, AlwaysDepth: 1, AlwaysStencilFunc: 519, AmbientLight: _0, AnimationAction: u3, AnimationClip: da, AnimationLoader: class extends Lt {
  constructor(i) {
    super(i);
  }
  load(i, e, t, n) {
    const r = this, s = new xn(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(i, function(a) {
      try {
        e(r.parse(JSON.parse(a)));
      } catch (o) {
        n ? n(o) : console.error(o), r.manager.itemError(i);
      }
    }, t, n);
  }
  parse(i) {
    const e = [];
    for (let t = 0; t < i.length; t++) {
      const n = da.parse(i[t]);
      e.push(n);
    }
    return e;
  }
}, AnimationMixer: class extends lr {
  constructor(i) {
    super(), this._root = i, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(i, e) {
    const t = i._localRoot || this._root, n = i._clip.tracks, r = n.length, s = i._propertyBindings, a = i._interpolants, o = t.uuid, l = this._bindingsByRootAndName;
    let c = l[o];
    c === void 0 && (c = {}, l[o] = c);
    for (let h = 0; h !== r; ++h) {
      const u = n[h], d = u.name;
      let p = c[d];
      if (p !== void 0)
        ++p.referenceCount, s[h] = p;
      else {
        if (p = s[h], p !== void 0) {
          p._cacheIndex === null && (++p.referenceCount, this._addInactiveBinding(p, o, d));
          continue;
        }
        const f = e && e._propertyBindings[h].binding.parsedPath;
        p = new h3(Ze.create(t, d, f), u.ValueTypeName, u.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, o, d), s[h] = p;
      }
      a[h].resultBuffer = p.buffer;
    }
  }
  _activateAction(i) {
    if (!this._isActiveAction(i)) {
      if (i._cacheIndex === null) {
        const t = (i._localRoot || this._root).uuid, n = i._clip.uuid, r = this._actionsByClip[n];
        this._bindAction(i, r && r.knownActions[0]), this._addInactiveAction(i, n, t);
      }
      const e = i._propertyBindings;
      for (let t = 0, n = e.length; t !== n; ++t) {
        const r = e[t];
        r.useCount++ == 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(i);
    }
  }
  _deactivateAction(i) {
    if (this._isActiveAction(i)) {
      const e = i._propertyBindings;
      for (let t = 0, n = e.length; t !== n; ++t) {
        const r = e[t];
        --r.useCount == 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(i);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const i = this;
    this.stats = { actions: { get total() {
      return i._actions.length;
    }, get inUse() {
      return i._nActiveActions;
    } }, bindings: { get total() {
      return i._bindings.length;
    }, get inUse() {
      return i._nActiveBindings;
    } }, controlInterpolants: { get total() {
      return i._controlInterpolants.length;
    }, get inUse() {
      return i._nActiveControlInterpolants;
    } } };
  }
  _isActiveAction(i) {
    const e = i._cacheIndex;
    return e !== null && e < this._nActiveActions;
  }
  _addInactiveAction(i, e, t) {
    const n = this._actions, r = this._actionsByClip;
    let s = r[e];
    if (s === void 0)
      s = { knownActions: [i], actionByRoot: {} }, i._byClipCacheIndex = 0, r[e] = s;
    else {
      const a = s.knownActions;
      i._byClipCacheIndex = a.length, a.push(i);
    }
    i._cacheIndex = n.length, n.push(i), s.actionByRoot[t] = i;
  }
  _removeInactiveAction(i) {
    const e = this._actions, t = e[e.length - 1], n = i._cacheIndex;
    t._cacheIndex = n, e[n] = t, e.pop(), i._cacheIndex = null;
    const r = i._clip.uuid, s = this._actionsByClip, a = s[r], o = a.knownActions, l = o[o.length - 1], c = i._byClipCacheIndex;
    l._byClipCacheIndex = c, o[c] = l, o.pop(), i._byClipCacheIndex = null, delete a.actionByRoot[(i._localRoot || this._root).uuid], o.length === 0 && delete s[r], this._removeInactiveBindingsForAction(i);
  }
  _removeInactiveBindingsForAction(i) {
    const e = i._propertyBindings;
    for (let t = 0, n = e.length; t !== n; ++t) {
      const r = e[t];
      --r.referenceCount == 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(i) {
    const e = this._actions, t = i._cacheIndex, n = this._nActiveActions++, r = e[n];
    i._cacheIndex = n, e[n] = i, r._cacheIndex = t, e[t] = r;
  }
  _takeBackAction(i) {
    const e = this._actions, t = i._cacheIndex, n = --this._nActiveActions, r = e[n];
    i._cacheIndex = n, e[n] = i, r._cacheIndex = t, e[t] = r;
  }
  _addInactiveBinding(i, e, t) {
    const n = this._bindingsByRootAndName, r = this._bindings;
    let s = n[e];
    s === void 0 && (s = {}, n[e] = s), s[t] = i, i._cacheIndex = r.length, r.push(i);
  }
  _removeInactiveBinding(i) {
    const e = this._bindings, t = i.binding, n = t.rootNode.uuid, r = t.path, s = this._bindingsByRootAndName, a = s[n], o = e[e.length - 1], l = i._cacheIndex;
    o._cacheIndex = l, e[l] = o, e.pop(), delete a[r], Object.keys(a).length === 0 && delete s[n];
  }
  _lendBinding(i) {
    const e = this._bindings, t = i._cacheIndex, n = this._nActiveBindings++, r = e[n];
    i._cacheIndex = n, e[n] = i, r._cacheIndex = t, e[t] = r;
  }
  _takeBackBinding(i) {
    const e = this._bindings, t = i._cacheIndex, n = --this._nActiveBindings, r = e[n];
    i._cacheIndex = n, e[n] = i, r._cacheIndex = t, e[t] = r;
  }
  _lendControlInterpolant() {
    const i = this._controlInterpolants, e = this._nActiveControlInterpolants++;
    let t = i[e];
    return t === void 0 && (t = new v0(new Float32Array(2), new Float32Array(2), 1, t5), t.__cacheIndex = e, i[e] = t), t;
  }
  _takeBackControlInterpolant(i) {
    const e = this._controlInterpolants, t = i.__cacheIndex, n = --this._nActiveControlInterpolants, r = e[n];
    i.__cacheIndex = n, e[n] = i, r.__cacheIndex = t, e[t] = r;
  }
  clipAction(i, e, t) {
    const n = e || this._root, r = n.uuid;
    let s = typeof i == "string" ? da.findByName(n, i) : i;
    const a = s !== null ? s.uuid : i, o = this._actionsByClip[a];
    let l = null;
    if (t === void 0 && (t = s !== null ? s.blendMode : Cx), o !== void 0) {
      const h = o.actionByRoot[r];
      if (h !== void 0 && h.blendMode === t)
        return h;
      l = o.knownActions[0], s === null && (s = l._clip);
    }
    if (s === null)
      return null;
    const c = new u3(this, s, e, t);
    return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
  }
  existingAction(i, e) {
    const t = e || this._root, n = t.uuid, r = typeof i == "string" ? da.findByName(t, i) : i, s = r ? r.uuid : i, a = this._actionsByClip[s];
    return a !== void 0 && a.actionByRoot[n] || null;
  }
  stopAllAction() {
    const i = this._actions;
    for (let e = this._nActiveActions - 1; e >= 0; --e)
      i[e].stop();
    return this;
  }
  update(i) {
    i *= this.timeScale;
    const e = this._actions, t = this._nActiveActions, n = this.time += i, r = Math.sign(i), s = this._accuIndex ^= 1;
    for (let l = 0; l !== t; ++l)
      e[l]._update(n, i, r, s);
    const a = this._bindings, o = this._nActiveBindings;
    for (let l = 0; l !== o; ++l)
      a[l].apply(s);
    return this;
  }
  setTime(i) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++)
      this._actions[e].time = 0;
    return this.update(i);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(i) {
    const e = this._actions, t = i.uuid, n = this._actionsByClip, r = n[t];
    if (r !== void 0) {
      const s = r.knownActions;
      for (let a = 0, o = s.length; a !== o; ++a) {
        const l = s[a];
        this._deactivateAction(l);
        const c = l._cacheIndex, h = e[e.length - 1];
        l._cacheIndex = null, l._byClipCacheIndex = null, h._cacheIndex = c, e[c] = h, e.pop(), this._removeInactiveBindingsForAction(l);
      }
      delete n[t];
    }
  }
  uncacheRoot(i) {
    const e = i.uuid, t = this._actionsByClip;
    for (const r in t) {
      const s = t[r].actionByRoot[e];
      s !== void 0 && (this._deactivateAction(s), this._removeInactiveAction(s));
    }
    const n = this._bindingsByRootAndName[e];
    if (n !== void 0)
      for (const r in n) {
        const s = n[r];
        s.restoreOriginalState(), this._removeInactiveBinding(s);
      }
  }
  uncacheAction(i, e) {
    const t = this.existingAction(i, e);
    t !== null && (this._deactivateAction(t), this._removeInactiveAction(t));
  }
}, AnimationObjectGroup: class {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = ci(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const i = {};
    this._indicesByUUID = i;
    for (let t = 0, n = arguments.length; t !== n; ++t)
      i[arguments[t].uuid] = t;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const e = this;
    this.stats = { objects: { get total() {
      return e._objects.length;
    }, get inUse() {
      return this.total - e.nCachedObjects_;
    } }, get bindingsPerObject() {
      return e._bindings.length;
    } };
  }
  add() {
    const i = this._objects, e = this._indicesByUUID, t = this._paths, n = this._parsedPaths, r = this._bindings, s = r.length;
    let a, o = i.length, l = this.nCachedObjects_;
    for (let c = 0, h = arguments.length; c !== h; ++c) {
      const u = arguments[c], d = u.uuid;
      let p = e[d];
      if (p === void 0) {
        p = o++, e[d] = p, i.push(u);
        for (let f = 0, v = s; f !== v; ++f)
          r[f].push(new Ze(u, t[f], n[f]));
      } else if (p < l) {
        a = i[p];
        const f = --l, v = i[f];
        e[v.uuid] = p, i[p] = v, e[d] = f, i[f] = u;
        for (let m = 0, y = s; m !== y; ++m) {
          const g = r[m], _ = g[f];
          let x = g[p];
          g[p] = _, x === void 0 && (x = new Ze(u, t[m], n[m])), g[f] = x;
        }
      } else
        i[p] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = l;
  }
  remove() {
    const i = this._objects, e = this._indicesByUUID, t = this._bindings, n = t.length;
    let r = this.nCachedObjects_;
    for (let s = 0, a = arguments.length; s !== a; ++s) {
      const o = arguments[s], l = o.uuid, c = e[l];
      if (c !== void 0 && c >= r) {
        const h = r++, u = i[h];
        e[u.uuid] = c, i[c] = u, e[l] = h, i[h] = o;
        for (let d = 0, p = n; d !== p; ++d) {
          const f = t[d], v = f[h], m = f[c];
          f[c] = v, f[h] = m;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  uncache() {
    const i = this._objects, e = this._indicesByUUID, t = this._bindings, n = t.length;
    let r = this.nCachedObjects_, s = i.length;
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const l = arguments[a].uuid, c = e[l];
      if (c !== void 0)
        if (delete e[l], c < r) {
          const h = --r, u = i[h], d = --s, p = i[d];
          e[u.uuid] = c, i[c] = u, e[p.uuid] = h, i[h] = p, i.pop();
          for (let f = 0, v = n; f !== v; ++f) {
            const m = t[f], y = m[h], g = m[d];
            m[c] = y, m[h] = g, m.pop();
          }
        } else {
          const h = --s, u = i[h];
          h > 0 && (e[u.uuid] = c), i[c] = u, i.pop();
          for (let d = 0, p = n; d !== p; ++d) {
            const f = t[d];
            f[c] = f[h], f.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  subscribe_(i, e) {
    const t = this._bindingsIndicesByPath;
    let n = t[i];
    const r = this._bindings;
    if (n !== void 0)
      return r[n];
    const s = this._paths, a = this._parsedPaths, o = this._objects, l = o.length, c = this.nCachedObjects_, h = new Array(l);
    n = r.length, t[i] = n, s.push(i), a.push(e), r.push(h);
    for (let u = c, d = o.length; u !== d; ++u) {
      const p = o[u];
      h[u] = new Ze(p, i, e);
    }
    return h;
  }
  unsubscribe_(i) {
    const e = this._bindingsIndicesByPath, t = e[i];
    if (t !== void 0) {
      const n = this._paths, r = this._parsedPaths, s = this._bindings, a = s.length - 1, o = s[a];
      e[i[a]] = t, s[t] = o, s.pop(), r[t] = r[a], r.pop(), n[t] = n[a], n.pop();
    }
  }
}, AnimationUtils: GA, ArcCurve: $M, ArrayCamera: KM, ArrowHelper: class extends Fe {
  constructor(i = new S(0, 0, 1), e = new S(0, 0, 0), t = 1, n = 16776960, r = 0.2 * t, s = 0.2 * r) {
    super(), this.type = "ArrowHelper", md === void 0 && (md = new Re(), md.setAttribute("position", new ye([0, 0, 0, 0, 1, 0], 3)), Dm = new Ft(0, 0.5, 1, 5, 1), Dm.translate(0, -0.5, 0)), this.position.copy(e), this.line = new dn(md, new zt({ color: n, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ve(Dm, new nn({ color: n, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(i), this.setLength(t, r, s);
  }
  setDirection(i) {
    if (i.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (i.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      b3.set(i.z, 0, -i.x).normalize();
      const e = Math.acos(i.y);
      this.quaternion.setFromAxisAngle(b3, e);
    }
  }
  setLength(i, e = 0.2 * i, t = 0.2 * e) {
    this.line.scale.set(1, Math.max(1e-4, i - e), 1), this.line.updateMatrix(), this.cone.scale.set(t, e, t), this.cone.position.y = i, this.cone.updateMatrix();
  }
  setColor(i) {
    this.line.material.color.set(i), this.cone.material.color.set(i);
  }
  copy(i) {
    return super.copy(i, !1), this.line.copy(i.line), this.cone.copy(i.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}, AttachedBindMode: Ig, Audio: l3, AudioAnalyser: class {
  constructor(i, e = 2048) {
    this.analyser = i.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), i.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let i = 0;
    const e = this.getFrequencyData();
    for (let t = 0; t < e.length; t++)
      i += e[t];
    return i / e.length;
  }
}, AudioContext: Rm, AudioListener: class extends Fe {
  constructor() {
    super(), this.type = "AudioListener", this.context = Rm.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new x0();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(i) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = i, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(i) {
    return this.gain.gain.setTargetAtTime(i, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(i) {
    super.updateMatrixWorld(i);
    const e = this.context.listener, t = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Xs, o3, ZA), qs.set(0, 0, -1).applyQuaternion(o3), e.positionX) {
      const n = this.context.currentTime + this.timeDelta;
      e.positionX.linearRampToValueAtTime(Xs.x, n), e.positionY.linearRampToValueAtTime(Xs.y, n), e.positionZ.linearRampToValueAtTime(Xs.z, n), e.forwardX.linearRampToValueAtTime(qs.x, n), e.forwardY.linearRampToValueAtTime(qs.y, n), e.forwardZ.linearRampToValueAtTime(qs.z, n), e.upX.linearRampToValueAtTime(t.x, n), e.upY.linearRampToValueAtTime(t.y, n), e.upZ.linearRampToValueAtTime(t.z, n);
    } else
      e.setPosition(Xs.x, Xs.y, Xs.z), e.setOrientation(qs.x, qs.y, qs.z, t.x, t.y, t.z);
  }
}, AudioLoader: class extends Lt {
  constructor(i) {
    super(i);
  }
  load(i, e, t, n) {
    const r = this, s = new xn(this.manager);
    function a(o) {
      n ? n(o) : console.error(o), r.manager.itemError(i);
    }
    s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(i, function(o) {
      try {
        const l = o.slice(0);
        Rm.getContext().decodeAudioData(l, function(c) {
          e(c);
        }).catch(a);
      } catch (l) {
        a(l);
      }
    }, t, n);
  }
}, AxesHelper: class extends Qn {
  constructor(i = 1) {
    const e = [0, 0, 0, i, 0, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, 0, i], t = new Re();
    t.setAttribute("position", new ye(e, 3)), t.setAttribute("color", new ye([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)), super(t, new zt({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper";
  }
  setColors(i, e, t) {
    const n = new ce(), r = this.geometry.attributes.color.array;
    return n.set(i), n.toArray(r, 0), n.toArray(r, 3), n.set(e), n.toArray(r, 6), n.toArray(r, 9), n.set(t), n.toArray(r, 12), n.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, BackSide: kn, BasicDepthPacking: 3200, BasicShadowMap: 0, BatchedMesh: O2, Bone: fl, BooleanKeyframeTrack: ha, Box2: class {
  constructor(i = new Y(1 / 0, 1 / 0), e = new Y(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = i, this.max = e;
  }
  set(i, e) {
    return this.min.copy(i), this.max.copy(e), this;
  }
  setFromPoints(i) {
    this.makeEmpty();
    for (let e = 0, t = i.length; e < t; e++)
      this.expandByPoint(i[e]);
    return this;
  }
  setFromCenterAndSize(i, e) {
    const t = f3.copy(e).multiplyScalar(0.5);
    return this.min.copy(i).sub(t), this.max.copy(i).add(t), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(i) {
    return this.min.copy(i.min), this.max.copy(i.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(i) {
    return this.isEmpty() ? i.set(0, 0) : i.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(i) {
    return this.isEmpty() ? i.set(0, 0) : i.subVectors(this.max, this.min);
  }
  expandByPoint(i) {
    return this.min.min(i), this.max.max(i), this;
  }
  expandByVector(i) {
    return this.min.sub(i), this.max.add(i), this;
  }
  expandByScalar(i) {
    return this.min.addScalar(-i), this.max.addScalar(i), this;
  }
  containsPoint(i) {
    return !(i.x < this.min.x || i.x > this.max.x || i.y < this.min.y || i.y > this.max.y);
  }
  containsBox(i) {
    return this.min.x <= i.min.x && i.max.x <= this.max.x && this.min.y <= i.min.y && i.max.y <= this.max.y;
  }
  getParameter(i, e) {
    return e.set((i.x - this.min.x) / (this.max.x - this.min.x), (i.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(i) {
    return !(i.max.x < this.min.x || i.min.x > this.max.x || i.max.y < this.min.y || i.min.y > this.max.y);
  }
  clampPoint(i, e) {
    return e.copy(i).clamp(this.min, this.max);
  }
  distanceToPoint(i) {
    return this.clampPoint(i, f3).distanceTo(i);
  }
  intersect(i) {
    return this.min.max(i.min), this.max.min(i.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(i) {
    return this.min.min(i.min), this.max.max(i.max), this;
  }
  translate(i) {
    return this.min.add(i), this.max.add(i), this;
  }
  equals(i) {
    return i.min.equals(this.min) && i.max.equals(this.max);
  }
}, Box3: sn, Box3Helper: _w, BoxGeometry: Pt, BoxHelper: class extends Qn {
  constructor(i, e = 16776960) {
    const t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(24), r = new Re();
    r.setIndex(new it(t, 1)), r.setAttribute("position", new it(n, 3)), super(r, new zt({ color: e, toneMapped: !1 })), this.object = i, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(i) {
    if (i !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && fd.setFromObject(this.object), fd.isEmpty())
      return;
    const e = fd.min, t = fd.max, n = this.geometry.attributes.position, r = n.array;
    r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = e.x, r[4] = t.y, r[5] = t.z, r[6] = e.x, r[7] = e.y, r[8] = t.z, r[9] = t.x, r[10] = e.y, r[11] = t.z, r[12] = t.x, r[13] = t.y, r[14] = e.z, r[15] = e.x, r[16] = t.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = t.x, r[22] = e.y, r[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(i) {
    return this.object = i, this.update(), this;
  }
  copy(i, e) {
    return super.copy(i, e), this.object = i.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, BufferAttribute: it, BufferGeometry: Re, BufferGeometryLoader: t3, ByteType: 1010, Cache: Dr, Camera: qp, CameraHelper: class extends Qn {
  constructor(i) {
    const e = new Re(), t = new zt({ color: 16777215, vertexColors: !0, toneMapped: !1 }), n = [], r = [], s = {};
    function a(p, f) {
      o(p), o(f);
    }
    function o(p) {
      n.push(0, 0, 0), r.push(0, 0, 0), s[p] === void 0 && (s[p] = []), s[p].push(n.length / 3 - 1);
    }
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"), e.setAttribute("position", new ye(n, 3)), e.setAttribute("color", new ye(r, 3)), super(e, t), this.type = "CameraHelper", this.camera = i, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = i.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update();
    const l = new ce(16755200), c = new ce(16711680), h = new ce(43775), u = new ce(16777215), d = new ce(3355443);
    this.setColors(l, c, h, u, d);
  }
  setColors(i, e, t, n, r) {
    const s = this.geometry.getAttribute("color");
    s.setXYZ(0, i.r, i.g, i.b), s.setXYZ(1, i.r, i.g, i.b), s.setXYZ(2, i.r, i.g, i.b), s.setXYZ(3, i.r, i.g, i.b), s.setXYZ(4, i.r, i.g, i.b), s.setXYZ(5, i.r, i.g, i.b), s.setXYZ(6, i.r, i.g, i.b), s.setXYZ(7, i.r, i.g, i.b), s.setXYZ(8, i.r, i.g, i.b), s.setXYZ(9, i.r, i.g, i.b), s.setXYZ(10, i.r, i.g, i.b), s.setXYZ(11, i.r, i.g, i.b), s.setXYZ(12, i.r, i.g, i.b), s.setXYZ(13, i.r, i.g, i.b), s.setXYZ(14, i.r, i.g, i.b), s.setXYZ(15, i.r, i.g, i.b), s.setXYZ(16, i.r, i.g, i.b), s.setXYZ(17, i.r, i.g, i.b), s.setXYZ(18, i.r, i.g, i.b), s.setXYZ(19, i.r, i.g, i.b), s.setXYZ(20, i.r, i.g, i.b), s.setXYZ(21, i.r, i.g, i.b), s.setXYZ(22, i.r, i.g, i.b), s.setXYZ(23, i.r, i.g, i.b), s.setXYZ(24, e.r, e.g, e.b), s.setXYZ(25, e.r, e.g, e.b), s.setXYZ(26, e.r, e.g, e.b), s.setXYZ(27, e.r, e.g, e.b), s.setXYZ(28, e.r, e.g, e.b), s.setXYZ(29, e.r, e.g, e.b), s.setXYZ(30, e.r, e.g, e.b), s.setXYZ(31, e.r, e.g, e.b), s.setXYZ(32, t.r, t.g, t.b), s.setXYZ(33, t.r, t.g, t.b), s.setXYZ(34, t.r, t.g, t.b), s.setXYZ(35, t.r, t.g, t.b), s.setXYZ(36, t.r, t.g, t.b), s.setXYZ(37, t.r, t.g, t.b), s.setXYZ(38, n.r, n.g, n.b), s.setXYZ(39, n.r, n.g, n.b), s.setXYZ(40, r.r, r.g, r.b), s.setXYZ(41, r.r, r.g, r.b), s.setXYZ(42, r.r, r.g, r.b), s.setXYZ(43, r.r, r.g, r.b), s.setXYZ(44, r.r, r.g, r.b), s.setXYZ(45, r.r, r.g, r.b), s.setXYZ(46, r.r, r.g, r.b), s.setXYZ(47, r.r, r.g, r.b), s.setXYZ(48, r.r, r.g, r.b), s.setXYZ(49, r.r, r.g, r.b), s.needsUpdate = !0;
  }
  update() {
    const i = this.geometry, e = this.pointMap;
    Rt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Ut("c", e, i, Rt, 0, 0, -1), Ut("t", e, i, Rt, 0, 0, 1), Ut("n1", e, i, Rt, -1, -1, -1), Ut("n2", e, i, Rt, 1, -1, -1), Ut("n3", e, i, Rt, -1, 1, -1), Ut("n4", e, i, Rt, 1, 1, -1), Ut("f1", e, i, Rt, -1, -1, 1), Ut("f2", e, i, Rt, 1, -1, 1), Ut("f3", e, i, Rt, -1, 1, 1), Ut("f4", e, i, Rt, 1, 1, 1), Ut("u1", e, i, Rt, 0.7, 1.1, -1), Ut("u2", e, i, Rt, -0.7, 1.1, -1), Ut("u3", e, i, Rt, 0, 2, -1), Ut("cf1", e, i, Rt, -1, 0, 1), Ut("cf2", e, i, Rt, 1, 0, 1), Ut("cf3", e, i, Rt, 0, -1, 1), Ut("cf4", e, i, Rt, 0, 1, 1), Ut("cn1", e, i, Rt, -1, 0, -1), Ut("cn2", e, i, Rt, 1, 0, -1), Ut("cn3", e, i, Rt, 0, -1, -1), Ut("cn4", e, i, Rt, 0, 1, -1), i.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, CanvasTexture: class extends vt {
  constructor(i, e, t, n, r, s, a, o, l) {
    super(i, e, t, n, r, s, a, o, l), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}, CapsuleGeometry: Jp, CatmullRomCurve3: ew, CineonToneMapping: i1, CircleGeometry: $p, ClampToEdgeWrapping: ri, Clock: x0, Color: ce, ColorKeyframeTrack: A1, ColorManagement: rt, CompressedArrayTexture: class extends nd {
  constructor(i, e, t, n, r, s) {
    super(i, e, t, r, s), this.isCompressedArrayTexture = !0, this.image.depth = n, this.wrapR = ri, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdates(i) {
    this.layerUpdates.add(i);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}, CompressedCubeTexture: class extends nd {
  constructor(i, e, t) {
    super(void 0, i[0].width, i[0].height, e, t, Fr), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = i;
  }
}, CompressedTexture: nd, CompressedTextureLoader: class extends Lt {
  constructor(i) {
    super(i);
  }
  load(i, e, t, n) {
    const r = this, s = [], a = new nd(), o = new xn(this.manager);
    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials);
    let l = 0;
    function c(h) {
      o.load(i[h], function(u) {
        const d = r.parse(u, !0);
        s[h] = { width: d.width, height: d.height, format: d.format, mipmaps: d.mipmaps }, l += 1, l === 6 && (d.mipmapCount === 1 && (a.minFilter = Gt), a.image = s, a.format = d.format, a.needsUpdate = !0, e && e(a));
      }, t, n);
    }
    if (Array.isArray(i))
      for (let h = 0, u = i.length; h < u; ++h)
        c(h);
    else
      o.load(i, function(h) {
        const u = r.parse(h, !0);
        if (u.isCubemap) {
          const d = u.mipmaps.length / u.mipmapCount;
          for (let p = 0; p < d; p++) {
            s[p] = { mipmaps: [] };
            for (let f = 0; f < u.mipmapCount; f++)
              s[p].mipmaps.push(u.mipmaps[p * u.mipmapCount + f]), s[p].format = u.format, s[p].width = u.width, s[p].height = u.height;
          }
          a.image = s;
        } else
          a.image.width = u.width, a.image.height = u.height, a.mipmaps = u.mipmaps;
        u.mipmapCount === 1 && (a.minFilter = Gt), a.format = u.format, a.needsUpdate = !0, e && e(a);
      }, t, n);
    return a;
  }
}, ConeGeometry: ef, ConstantAlphaFactor: 213, ConstantColorFactor: 211, CubeCamera: GM, CubeReflectionMapping: Fr, CubeRefractionMapping: ys, CubeTexture: kc, CubeTextureLoader: class extends Lt {
  constructor(i) {
    super(i);
  }
  load(i, e, t, n) {
    const r = new kc();
    r.colorSpace = yt;
    const s = new Ec(this.manager);
    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
    let a = 0;
    function o(l) {
      s.load(i[l], function(c) {
        r.images[l] = c, a++, a === 6 && (r.needsUpdate = !0, e && e(r));
      }, void 0, n);
    }
    for (let l = 0; l < i.length; ++l)
      o(l);
    return r;
  }
}, CubeUVReflectionMapping: Il, CubicBezierCurve: v1, CubicBezierCurve3: tw, CubicInterpolant: dw, CullFaceBack: 1, CullFaceFront: 2, CullFaceFrontBack: 3, CullFaceNone: 0, Curve: Ei, CurvePath: iw, CustomBlending: 5, CustomToneMapping: OM, CylinderGeometry: Ft, Cylindrical: class {
  constructor(i = 1, e = 0, t = 0) {
    return this.radius = i, this.theta = e, this.y = t, this;
  }
  set(i, e, t) {
    return this.radius = i, this.theta = e, this.y = t, this;
  }
  copy(i) {
    return this.radius = i.radius, this.theta = i.theta, this.y = i.y, this;
  }
  setFromVector3(i) {
    return this.setFromCartesianCoords(i.x, i.y, i.z);
  }
  setFromCartesianCoords(i, e, t) {
    return this.radius = Math.sqrt(i * i + t * t), this.theta = Math.atan2(i, t), this.y = e, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, Data3DTexture: l0, DataArrayTexture: lp, DataTexture: Cr, DataTextureLoader: class extends Lt {
  constructor(i) {
    super(i);
  }
  load(i, e, t, n) {
    const r = this, s = new Cr(), a = new xn(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(i, function(o) {
      let l;
      try {
        l = r.parse(o);
      } catch (c) {
        if (n === void 0)
          return void console.error(c);
        n(c);
      }
      l.image !== void 0 ? s.image = l.image : l.data !== void 0 && (s.image.width = l.width, s.image.height = l.height, s.image.data = l.data), s.wrapS = l.wrapS !== void 0 ? l.wrapS : ri, s.wrapT = l.wrapT !== void 0 ? l.wrapT : ri, s.magFilter = l.magFilter !== void 0 ? l.magFilter : Gt, s.minFilter = l.minFilter !== void 0 ? l.minFilter : Gt, s.anisotropy = l.anisotropy !== void 0 ? l.anisotropy : 1, l.colorSpace !== void 0 && (s.colorSpace = l.colorSpace), l.flipY !== void 0 && (s.flipY = l.flipY), l.format !== void 0 && (s.format = l.format), l.type !== void 0 && (s.type = l.type), l.mipmaps !== void 0 && (s.mipmaps = l.mipmaps, s.minFilter = zi), l.mipmapCount === 1 && (s.minFilter = Gt), l.generateMipmaps !== void 0 && (s.generateMipmaps = l.generateMipmaps), s.needsUpdate = !0, e && e(s, l);
    }, t, n), s;
  }
}, DataUtils: kT, DecrementStencilOp: 7683, DecrementWrapStencilOp: 34056, DefaultLoadingManager: I1, DepthFormat: cl, DepthStencilFormat: xs, DepthTexture: Bh, DetachedBindMode: UM, DirectionalLight: ph, DirectionalLightHelper: class extends Fe {
  constructor(i, e, t) {
    super(), this.light = i, this.matrix = i.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "DirectionalLightHelper", e === void 0 && (e = 1);
    let n = new Re();
    n.setAttribute("position", new ye([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
    const r = new zt({ fog: !1, toneMapped: !1 });
    this.lightPlane = new dn(n, r), this.add(this.lightPlane), n = new Re(), n.setAttribute("position", new ye([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new dn(n, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), _3.setFromMatrixPosition(this.light.matrixWorld), dd.setFromMatrixPosition(this.light.target.matrixWorld), x3.subVectors(dd, _3), this.lightPlane.lookAt(dd), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(dd), this.targetLine.scale.z = x3.length();
  }
}, DiscreteInterpolant: pw, DisplayP3ColorSpace: op, DodecahedronGeometry: tf, DoubleSide: tn, DstAlphaFactor: 206, DstColorFactor: 208, DynamicCopyUsage: 35050, DynamicDrawUsage: 35048, DynamicReadUsage: 35049, EdgesGeometry: rw, EllipseCurve: Qp, EqualCompare: 514, EqualDepth: 4, EqualStencilFunc: 514, EquirectangularReflectionMapping: ol, EquirectangularRefractionMapping: Kc, Euler: bt, EventDispatcher: lr, ExtrudeGeometry: Gh, FileLoader: xn, Float16BufferAttribute: class extends it {
  constructor(i, e, t) {
    super(new Uint16Array(i), e, t), this.isFloat16BufferAttribute = !0;
  }
  getX(i) {
    let e = Tc(this.array[i * this.itemSize]);
    return this.normalized && (e = On(e, this.array)), e;
  }
  setX(i, e) {
    return this.normalized && (e = ke(e, this.array)), this.array[i * this.itemSize] = Bn(e), this;
  }
  getY(i) {
    let e = Tc(this.array[i * this.itemSize + 1]);
    return this.normalized && (e = On(e, this.array)), e;
  }
  setY(i, e) {
    return this.normalized && (e = ke(e, this.array)), this.array[i * this.itemSize + 1] = Bn(e), this;
  }
  getZ(i) {
    let e = Tc(this.array[i * this.itemSize + 2]);
    return this.normalized && (e = On(e, this.array)), e;
  }
  setZ(i, e) {
    return this.normalized && (e = ke(e, this.array)), this.array[i * this.itemSize + 2] = Bn(e), this;
  }
  getW(i) {
    let e = Tc(this.array[i * this.itemSize + 3]);
    return this.normalized && (e = On(e, this.array)), e;
  }
  setW(i, e) {
    return this.normalized && (e = ke(e, this.array)), this.array[i * this.itemSize + 3] = Bn(e), this;
  }
  setXY(i, e, t) {
    return i *= this.itemSize, this.normalized && (e = ke(e, this.array), t = ke(t, this.array)), this.array[i + 0] = Bn(e), this.array[i + 1] = Bn(t), this;
  }
  setXYZ(i, e, t, n) {
    return i *= this.itemSize, this.normalized && (e = ke(e, this.array), t = ke(t, this.array), n = ke(n, this.array)), this.array[i + 0] = Bn(e), this.array[i + 1] = Bn(t), this.array[i + 2] = Bn(n), this;
  }
  setXYZW(i, e, t, n, r) {
    return i *= this.itemSize, this.normalized && (e = ke(e, this.array), t = ke(t, this.array), n = ke(n, this.array), r = ke(r, this.array)), this.array[i + 0] = Bn(e), this.array[i + 1] = Bn(t), this.array[i + 2] = Bn(n), this.array[i + 3] = Bn(r), this;
  }
}, Float32BufferAttribute: ye, FloatType: si, Fog: ah, FogExp2: cp, FramebufferTexture: class extends vt {
  constructor(i, e) {
    super({ width: i, height: e }), this.isFramebufferTexture = !0, this.magFilter = lt, this.minFilter = lt, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}, FrontSide: Gi, Frustum: sh, GLBufferAttribute: class {
  constructor(i, e, t, n, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = i, this.type = e, this.itemSize = t, this.elementSize = n, this.count = r, this.version = 0;
  }
  set needsUpdate(i) {
    i === !0 && this.version++;
  }
  setBuffer(i) {
    return this.buffer = i, this;
  }
  setType(i, e) {
    return this.type = i, this.elementSize = e, this;
  }
  setItemSize(i) {
    return this.itemSize = i, this;
  }
  setCount(i) {
    return this.count = i, this;
  }
}, GLSL1: "100", GLSL3: a0, GreaterCompare: 516, GreaterDepth: 6, GreaterEqualCompare: 518, GreaterEqualDepth: 5, GreaterEqualStencilFunc: 518, GreaterStencilFunc: 516, GridHelper: class extends Qn {
  constructor(i = 10, e = 10, t = 4473924, n = 8947848) {
    t = new ce(t), n = new ce(n);
    const r = e / 2, s = i / e, a = i / 2, o = [], l = [];
    for (let h = 0, u = 0, d = -a; h <= e; h++, d += s) {
      o.push(-a, 0, d, a, 0, d), o.push(d, 0, -a, d, 0, a);
      const p = h === r ? t : n;
      p.toArray(l, u), u += 3, p.toArray(l, u), u += 3, p.toArray(l, u), u += 3, p.toArray(l, u), u += 3;
    }
    const c = new Re();
    c.setAttribute("position", new ye(o, 3)), c.setAttribute("color", new ye(l, 3)), super(c, new zt({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, Group: oi, HalfFloatType: Vt, HemisphereLight: Z2, HemisphereLightHelper: class extends Fe {
  constructor(i, e, t) {
    super(), this.light = i, this.matrix = i.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "HemisphereLightHelper";
    const n = new Lr(e);
    n.rotateY(0.5 * Math.PI), this.material = new nn({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = n.getAttribute("position"), s = new Float32Array(3 * r.count);
    n.setAttribute("color", new it(s, 3)), this.add(new ve(n, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const i = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const e = i.geometry.getAttribute("color");
      v3.copy(this.light.color), y3.copy(this.light.groundColor);
      for (let t = 0, n = e.count; t < n; t++) {
        const r = t < n / 2 ? v3 : y3;
        e.setXYZ(t, r.r, r.g, r.b);
      }
      e.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), i.lookAt(i5.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}, IcosahedronGeometry: rf, ImageBitmapLoader: gw, ImageLoader: Ec, ImageUtils: FM, IncrementStencilOp: 7682, IncrementWrapStencilOp: 34055, InstancedBufferAttribute: Sa, InstancedBufferGeometry: R1, InstancedInterleavedBuffer: mp, InstancedMesh: u0, Int16BufferAttribute: class extends it {
  constructor(i, e, t) {
    super(new Int16Array(i), e, t);
  }
}, Int32BufferAttribute: class extends it {
  constructor(i, e, t) {
    super(new Int32Array(i), e, t);
  }
}, Int8BufferAttribute: class extends it {
  constructor(i, e, t) {
    super(new Int8Array(i), e, t);
  }
}, IntType: o1, InterleavedBuffer: zh, InterleavedBufferAttribute: Gn, Interpolant: Rl, InterpolateDiscrete: hl, InterpolateLinear: ul, InterpolateSmooth: qd, InvertStencilOp: 5386, KeepStencilOp: ra, KeyframeTrack: ji, LOD: S2, LatheGeometry: Hh, Layers: Wp, LessCompare: 513, LessDepth: 2, LessEqualCompare: 515, LessEqualDepth: 3, LessEqualStencilFunc: 515, LessStencilFunc: 513, Light: Ls, LightProbe: e3, Line: dn, Line3: vw, LineBasicMaterial: zt, LineCurve: y1, LineCurve3: nw, LineDashedMaterial: cw, LineLoop: d0, LineSegments: Qn, LinearDisplayP3ColorSpace: Jc, LinearFilter: Gt, LinearInterpolant: v0, LinearMipMapLinearFilter: 1008, LinearMipMapNearestFilter: 1007, LinearMipmapLinearFilter: zi, LinearMipmapNearestFilter: Zo, LinearSRGBColorSpace: on, LinearToneMapping: t1, LinearTransfer: $c, Loader: Lt, LoaderUtils: cr, LoadingManager: y0, LoopOnce: c1, LoopPingPong: 2202, LoopRepeat: 2201, LuminanceAlphaFormat: 1025, LuminanceFormat: 1024, MOUSE: na, Material: Wt, MaterialLoader: fp, MathUtils: en, Matrix3: Ue, Matrix4: fe, MaxEquation: 104, Mesh: ve, MeshBasicMaterial: nn, MeshDepthMaterial: Zp, MeshDistanceMaterial: m1, MeshLambertMaterial: T1, MeshMatcapMaterial: lw, MeshNormalMaterial: cf, MeshPhongMaterial: Ea, MeshPhysicalMaterial: Ai, MeshStandardMaterial: uh, MeshToonMaterial: S1, MinEquation: 103, MirroredRepeatWrapping: Fa, MixOperation: DM, MultiplyBlending: 4, MultiplyOperation: Fh, NearestFilter: lt, NearestMipMapLinearFilter: 1005, NearestMipMapNearestFilter: 1004, NearestMipmapLinearFilter: ma, NearestMipmapNearestFilter: jp, NeutralToneMapping: a1, NeverCompare: 512, NeverDepth: 0, NeverStencilFunc: 512, NoBlending: 0, NoColorSpace: la, NoToneMapping: Pr, NormalAnimationBlendMode: Cx, NormalBlending: 1, NotEqualCompare: 517, NotEqualDepth: 7, NotEqualStencilFunc: 517, NumberKeyframeTrack: bs, Object3D: Fe, ObjectLoader: class extends Lt {
  constructor(i) {
    super(i);
  }
  load(i, e, t, n) {
    const r = this, s = this.path === "" ? cr.extractUrlBase(i) : this.path;
    this.resourcePath = this.resourcePath || s;
    const a = new xn(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(i, function(o) {
      let l = null;
      try {
        l = JSON.parse(o);
      } catch (h) {
        return n !== void 0 && n(h), void console.error("THREE:ObjectLoader: Can't parse " + i + ".", h.message);
      }
      const c = l.metadata;
      if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry")
        return n !== void 0 && n(new Error("THREE.ObjectLoader: Can't load " + i)), void console.error("THREE.ObjectLoader: Can't load " + i);
      r.parse(l, e);
    }, t, n);
  }
  loadAsync(i, e) {
    return di(this, null, function* () {
      const t = this.path === "" ? cr.extractUrlBase(i) : this.path;
      this.resourcePath = this.resourcePath || t;
      const n = new xn(this.manager);
      n.setPath(this.path), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials);
      const r = yield n.loadAsync(i, e), s = JSON.parse(r), a = s.metadata;
      if (a === void 0 || a.type === void 0 || a.type.toLowerCase() === "geometry")
        throw new Error("THREE.ObjectLoader: Can't load " + i);
      return yield this.parseAsync(s);
    });
  }
  parse(i, e) {
    const t = this.parseAnimations(i.animations), n = this.parseShapes(i.shapes), r = this.parseGeometries(i.geometries, n), s = this.parseImages(i.images, function() {
      e !== void 0 && e(l);
    }), a = this.parseTextures(i.textures, s), o = this.parseMaterials(i.materials, a), l = this.parseObject(i.object, r, o, a, t), c = this.parseSkeletons(i.skeletons, l);
    if (this.bindSkeletons(l, c), e !== void 0) {
      let h = !1;
      for (const u in s)
        if (s[u].data instanceof HTMLImageElement) {
          h = !0;
          break;
        }
      h === !1 && e(l);
    }
    return l;
  }
  parseAsync(i) {
    return di(this, null, function* () {
      const e = this.parseAnimations(i.animations), t = this.parseShapes(i.shapes), n = this.parseGeometries(i.geometries, t), r = yield this.parseImagesAsync(i.images), s = this.parseTextures(i.textures, r), a = this.parseMaterials(i.materials, s), o = this.parseObject(i.object, n, a, s, e), l = this.parseSkeletons(i.skeletons, o);
      return this.bindSkeletons(o, l), o;
    });
  }
  parseShapes(i) {
    const e = {};
    if (i !== void 0)
      for (let t = 0, n = i.length; t < n; t++) {
        const r = new Ta().fromJSON(i[t]);
        e[r.uuid] = r;
      }
    return e;
  }
  parseSkeletons(i, e) {
    const t = {}, n = {};
    if (e.traverse(function(r) {
      r.isBone && (n[r.uuid] = r);
    }), i !== void 0)
      for (let r = 0, s = i.length; r < s; r++) {
        const a = new ml().fromJSON(i[r], n);
        t[a.uuid] = a;
      }
    return t;
  }
  parseGeometries(i, e) {
    const t = {};
    if (i !== void 0) {
      const n = new t3();
      for (let r = 0, s = i.length; r < s; r++) {
        let a;
        const o = i[r];
        switch (o.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = n.parse(o);
            break;
          default:
            o.type in Y2 ? a = Y2[o.type].fromJSON(o, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`);
        }
        a.uuid = o.uuid, o.name !== void 0 && (a.name = o.name), o.userData !== void 0 && (a.userData = o.userData), t[o.uuid] = a;
      }
    }
    return t;
  }
  parseMaterials(i, e) {
    const t = {}, n = {};
    if (i !== void 0) {
      const r = new fp();
      r.setTextures(e);
      for (let s = 0, a = i.length; s < a; s++) {
        const o = i[s];
        t[o.uuid] === void 0 && (t[o.uuid] = r.parse(o)), n[o.uuid] = t[o.uuid];
      }
    }
    return n;
  }
  parseAnimations(i) {
    const e = {};
    if (i !== void 0)
      for (let t = 0; t < i.length; t++) {
        const n = i[t], r = da.parse(n);
        e[r.uuid] = r;
      }
    return e;
  }
  parseImages(i, e) {
    const t = this, n = {};
    let r;
    function s(a) {
      if (typeof a == "string") {
        const o = a;
        return function(l) {
          return t.manager.itemStart(l), r.load(l, function() {
            t.manager.itemEnd(l);
          }, void 0, function() {
            t.manager.itemError(l), t.manager.itemEnd(l);
          });
        }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o);
      }
      return a.data ? { data: ko(a.type, a.data), width: a.width, height: a.height } : null;
    }
    if (i !== void 0 && i.length > 0) {
      const a = new y0(e);
      r = new Ec(a), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, l = i.length; o < l; o++) {
        const c = i[o], h = c.url;
        if (Array.isArray(h)) {
          const u = [];
          for (let d = 0, p = h.length; d < p; d++) {
            const f = s(h[d]);
            f !== null && (f instanceof HTMLImageElement ? u.push(f) : u.push(new Cr(f.data, f.width, f.height)));
          }
          n[c.uuid] = new ca(u);
        } else {
          const u = s(c.url);
          n[c.uuid] = new ca(u);
        }
      }
    }
    return n;
  }
  parseImagesAsync(i) {
    return di(this, null, function* () {
      const e = this, t = {};
      let n;
      function r(s) {
        return di(this, null, function* () {
          if (typeof s == "string") {
            const a = s, o = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : e.resourcePath + a;
            return yield n.loadAsync(o);
          }
          return s.data ? { data: ko(s.type, s.data), width: s.width, height: s.height } : null;
        });
      }
      if (i !== void 0 && i.length > 0) {
        n = new Ec(this.manager), n.setCrossOrigin(this.crossOrigin);
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s], l = o.url;
          if (Array.isArray(l)) {
            const c = [];
            for (let h = 0, u = l.length; h < u; h++) {
              const d = l[h], p = yield r(d);
              p !== null && (p instanceof HTMLImageElement ? c.push(p) : c.push(new Cr(p.data, p.width, p.height)));
            }
            t[o.uuid] = new ca(c);
          } else {
            const c = yield r(o.url);
            t[o.uuid] = new ca(c);
          }
        }
      }
      return t;
    });
  }
  parseTextures(i, e) {
    function t(r, s) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), s[r]);
    }
    const n = {};
    if (i !== void 0)
      for (let r = 0, s = i.length; r < s; r++) {
        const a = i[r];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), e[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const o = e[a.image], l = o.data;
        let c;
        Array.isArray(l) ? (c = new kc(), l.length === 6 && (c.needsUpdate = !0)) : (c = l && l.data ? new Cr() : new vt(), l && (c.needsUpdate = !0)), c.source = o, c.uuid = a.uuid, a.name !== void 0 && (c.name = a.name), a.mapping !== void 0 && (c.mapping = t(a.mapping, YA)), a.channel !== void 0 && (c.channel = a.channel), a.offset !== void 0 && c.offset.fromArray(a.offset), a.repeat !== void 0 && c.repeat.fromArray(a.repeat), a.center !== void 0 && c.center.fromArray(a.center), a.rotation !== void 0 && (c.rotation = a.rotation), a.wrap !== void 0 && (c.wrapS = t(a.wrap[0], n3), c.wrapT = t(a.wrap[1], n3)), a.format !== void 0 && (c.format = a.format), a.internalFormat !== void 0 && (c.internalFormat = a.internalFormat), a.type !== void 0 && (c.type = a.type), a.colorSpace !== void 0 && (c.colorSpace = a.colorSpace), a.minFilter !== void 0 && (c.minFilter = t(a.minFilter, i3)), a.magFilter !== void 0 && (c.magFilter = t(a.magFilter, i3)), a.anisotropy !== void 0 && (c.anisotropy = a.anisotropy), a.flipY !== void 0 && (c.flipY = a.flipY), a.generateMipmaps !== void 0 && (c.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (c.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (c.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (c.compareFunction = a.compareFunction), a.userData !== void 0 && (c.userData = a.userData), n[a.uuid] = c;
      }
    return n;
  }
  parseObject(i, e, t, n, r) {
    let s, a, o;
    function l(u) {
      return e[u] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", u), e[u];
    }
    function c(u) {
      if (u !== void 0) {
        if (Array.isArray(u)) {
          const d = [];
          for (let p = 0, f = u.length; p < f; p++) {
            const v = u[p];
            t[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), d.push(t[v]);
          }
          return d;
        }
        return t[u] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", u), t[u];
      }
    }
    function h(u) {
      return n[u] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", u), n[u];
    }
    switch (i.type) {
      case "Scene":
        s = new _2(), i.background !== void 0 && (Number.isInteger(i.background) ? s.background = new ce(i.background) : s.background = h(i.background)), i.environment !== void 0 && (s.environment = h(i.environment)), i.fog !== void 0 && (i.fog.type === "Fog" ? s.fog = new ah(i.fog.color, i.fog.near, i.fog.far) : i.fog.type === "FogExp2" && (s.fog = new cp(i.fog.color, i.fog.density)), i.fog.name !== "" && (s.fog.name = i.fog.name)), i.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = i.backgroundBlurriness), i.backgroundIntensity !== void 0 && (s.backgroundIntensity = i.backgroundIntensity), i.backgroundRotation !== void 0 && s.backgroundRotation.fromArray(i.backgroundRotation), i.environmentIntensity !== void 0 && (s.environmentIntensity = i.environmentIntensity), i.environmentRotation !== void 0 && s.environmentRotation.fromArray(i.environmentRotation);
        break;
      case "PerspectiveCamera":
        s = new jt(i.fov, i.aspect, i.near, i.far), i.focus !== void 0 && (s.focus = i.focus), i.zoom !== void 0 && (s.zoom = i.zoom), i.filmGauge !== void 0 && (s.filmGauge = i.filmGauge), i.filmOffset !== void 0 && (s.filmOffset = i.filmOffset), i.view !== void 0 && (s.view = Object.assign({}, i.view));
        break;
      case "OrthographicCamera":
        s = new Ha(i.left, i.right, i.top, i.bottom, i.near, i.far), i.zoom !== void 0 && (s.zoom = i.zoom), i.view !== void 0 && (s.view = Object.assign({}, i.view));
        break;
      case "AmbientLight":
        s = new _0(i.color, i.intensity);
        break;
      case "DirectionalLight":
        s = new ph(i.color, i.intensity);
        break;
      case "PointLight":
        s = new vl(i.color, i.intensity, i.distance, i.decay);
        break;
      case "RectAreaLight":
        s = new $2(i.color, i.intensity, i.width, i.height);
        break;
      case "SpotLight":
        s = new dh(i.color, i.intensity, i.distance, i.angle, i.penumbra, i.decay);
        break;
      case "HemisphereLight":
        s = new Z2(i.color, i.groundColor, i.intensity);
        break;
      case "LightProbe":
        s = new e3().fromJSON(i);
        break;
      case "SkinnedMesh":
        a = l(i.geometry), o = c(i.material), s = new hp(a, o), i.bindMode !== void 0 && (s.bindMode = i.bindMode), i.bindMatrix !== void 0 && s.bindMatrix.fromArray(i.bindMatrix), i.skeleton !== void 0 && (s.skeleton = i.skeleton);
        break;
      case "Mesh":
        a = l(i.geometry), o = c(i.material), s = new ve(a, o);
        break;
      case "InstancedMesh":
        a = l(i.geometry), o = c(i.material);
        const u = i.count, d = i.instanceMatrix, p = i.instanceColor;
        s = new u0(a, o, u), s.instanceMatrix = new Sa(new Float32Array(d.array), 16), p !== void 0 && (s.instanceColor = new Sa(new Float32Array(p.array), p.itemSize));
        break;
      case "BatchedMesh":
        a = l(i.geometry), o = c(i.material), s = new O2(i.maxGeometryCount, i.maxVertexCount, i.maxIndexCount, o), s.geometry = a, s.perObjectFrustumCulled = i.perObjectFrustumCulled, s.sortObjects = i.sortObjects, s._drawRanges = i.drawRanges, s._reservedRanges = i.reservedRanges, s._visibility = i.visibility, s._active = i.active, s._bounds = i.bounds.map((f) => {
          const v = new sn();
          v.min.fromArray(f.boxMin), v.max.fromArray(f.boxMax);
          const m = new an();
          return m.radius = f.sphereRadius, m.center.fromArray(f.sphereCenter), { boxInitialized: f.boxInitialized, box: v, sphereInitialized: f.sphereInitialized, sphere: m };
        }), s._maxGeometryCount = i.maxGeometryCount, s._maxVertexCount = i.maxVertexCount, s._maxIndexCount = i.maxIndexCount, s._geometryInitialized = i.geometryInitialized, s._geometryCount = i.geometryCount, s._matricesTexture = h(i.matricesTexture.uuid), i.colorsTexture !== void 0 && (s._colorsTexture = h(i.colorsTexture.uuid));
        break;
      case "LOD":
        s = new S2();
        break;
      case "Line":
        s = new dn(l(i.geometry), c(i.material));
        break;
      case "LineLoop":
        s = new d0(l(i.geometry), c(i.material));
        break;
      case "LineSegments":
        s = new Qn(l(i.geometry), c(i.material));
        break;
      case "PointCloud":
      case "Points":
        s = new Qo(l(i.geometry), c(i.material));
        break;
      case "Sprite":
        s = new M2(c(i.material));
        break;
      case "Group":
        s = new oi();
        break;
      case "Bone":
        s = new fl();
        break;
      default:
        s = new Fe();
    }
    if (s.uuid = i.uuid, i.name !== void 0 && (s.name = i.name), i.matrix !== void 0 ? (s.matrix.fromArray(i.matrix), i.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = i.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (i.position !== void 0 && s.position.fromArray(i.position), i.rotation !== void 0 && s.rotation.fromArray(i.rotation), i.quaternion !== void 0 && s.quaternion.fromArray(i.quaternion), i.scale !== void 0 && s.scale.fromArray(i.scale)), i.up !== void 0 && s.up.fromArray(i.up), i.castShadow !== void 0 && (s.castShadow = i.castShadow), i.receiveShadow !== void 0 && (s.receiveShadow = i.receiveShadow), i.shadow && (i.shadow.bias !== void 0 && (s.shadow.bias = i.shadow.bias), i.shadow.normalBias !== void 0 && (s.shadow.normalBias = i.shadow.normalBias), i.shadow.radius !== void 0 && (s.shadow.radius = i.shadow.radius), i.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(i.shadow.mapSize), i.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(i.shadow.camera))), i.visible !== void 0 && (s.visible = i.visible), i.frustumCulled !== void 0 && (s.frustumCulled = i.frustumCulled), i.renderOrder !== void 0 && (s.renderOrder = i.renderOrder), i.userData !== void 0 && (s.userData = i.userData), i.layers !== void 0 && (s.layers.mask = i.layers), i.children !== void 0) {
      const u = i.children;
      for (let d = 0; d < u.length; d++)
        s.add(this.parseObject(u[d], e, t, n, r));
    }
    if (i.animations !== void 0) {
      const u = i.animations;
      for (let d = 0; d < u.length; d++) {
        const p = u[d];
        s.animations.push(r[p]);
      }
    }
    if (i.type === "LOD") {
      i.autoUpdate !== void 0 && (s.autoUpdate = i.autoUpdate);
      const u = i.levels;
      for (let d = 0; d < u.length; d++) {
        const p = u[d], f = s.getObjectByProperty("uuid", p.object);
        f !== void 0 && s.addLevel(f, p.distance, p.hysteresis);
      }
    }
    return s;
  }
  bindSkeletons(i, e) {
    Object.keys(e).length !== 0 && i.traverse(function(t) {
      if (t.isSkinnedMesh === !0 && t.skeleton !== void 0) {
        const n = e[t.skeleton];
        n === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(n, t.bindMatrix);
      }
    });
  }
}, ObjectSpaceNormalMap: 1, OctahedronGeometry: Lr, OneFactor: e1, OneMinusConstantAlphaFactor: 214, OneMinusConstantColorFactor: 212, OneMinusDstAlphaFactor: 207, OneMinusDstColorFactor: 209, OneMinusSrcAlphaFactor: ka, OneMinusSrcColorFactor: 203, OrthographicCamera: Ha, P3Primaries: th, PCFShadowMap: J0, PCFSoftShadowMap: $0, PMREMGenerator: c0, Path: oh, PerspectiveCamera: jt, Plane: Fi, PlaneGeometry: Qa, PlaneHelper: class extends dn {
  constructor(i, e = 1, t = 16776960) {
    const n = t, r = new Re();
    r.setAttribute("position", new ye([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(), super(r, new zt({ color: n, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = i, this.size = e;
    const s = new Re();
    s.setAttribute("position", new ye([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), s.computeBoundingSphere(), this.add(new ve(s, new nn({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(i) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(i);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}, PointLight: vl, PointLightHelper: class extends ve {
  constructor(i, e, t) {
    super(new gl(e, 4, 2), new nn({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = i, this.color = t, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}, Points: Qo, PointsMaterial: ss, PolarGridHelper: class extends Qn {
  constructor(i = 10, e = 16, t = 8, n = 64, r = 4473924, s = 8947848) {
    r = new ce(r), s = new ce(s);
    const a = [], o = [];
    if (e > 1)
      for (let c = 0; c < e; c++) {
        const h = c / e * (2 * Math.PI), u = Math.sin(h) * i, d = Math.cos(h) * i;
        a.push(0, 0, 0), a.push(u, 0, d);
        const p = 1 & c ? r : s;
        o.push(p.r, p.g, p.b), o.push(p.r, p.g, p.b);
      }
    for (let c = 0; c < t; c++) {
      const h = 1 & c ? r : s, u = i - i / t * c;
      for (let d = 0; d < n; d++) {
        let p = d / n * (2 * Math.PI), f = Math.sin(p) * u, v = Math.cos(p) * u;
        a.push(f, 0, v), o.push(h.r, h.g, h.b), p = (d + 1) / n * (2 * Math.PI), f = Math.sin(p) * u, v = Math.cos(p) * u, a.push(f, 0, v), o.push(h.r, h.g, h.b);
      }
    }
    const l = new Re();
    l.setAttribute("position", new ye(a, 3)), l.setAttribute("color", new ye(o, 3)), super(l, new zt({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, PolyhedronGeometry: Rs, PositionalAudio: class extends l3 {
  constructor(i) {
    super(i), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(i) {
    return this.panner.refDistance = i, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(i) {
    return this.panner.rolloffFactor = i, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(i) {
    return this.panner.distanceModel = i, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(i) {
    return this.panner.maxDistance = i, this;
  }
  setDirectionalCone(i, e, t) {
    return this.panner.coneInnerAngle = i, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = t, this;
  }
  updateMatrixWorld(i) {
    if (super.updateMatrixWorld(i), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(Ys, c3, KA), Zs.set(0, 0, 1).applyQuaternion(c3);
    const e = this.panner;
    if (e.positionX) {
      const t = this.context.currentTime + this.listener.timeDelta;
      e.positionX.linearRampToValueAtTime(Ys.x, t), e.positionY.linearRampToValueAtTime(Ys.y, t), e.positionZ.linearRampToValueAtTime(Ys.z, t), e.orientationX.linearRampToValueAtTime(Zs.x, t), e.orientationY.linearRampToValueAtTime(Zs.y, t), e.orientationZ.linearRampToValueAtTime(Zs.z, t);
    } else
      e.setPosition(Ys.x, Ys.y, Ys.z), e.setOrientation(Zs.x, Zs.y, Zs.z);
  }
}, PropertyBinding: Ze, PropertyMixer: h3, QuadraticBezierCurve: _1, QuadraticBezierCurve3: x1, Quaternion: Qe, QuaternionKeyframeTrack: Br, QuaternionLinearInterpolant: fw, RED_GREEN_RGTC2_Format: r0, RED_RGTC1_Format: 36283, REVISION: sp, RGBADepthPacking: u1, RGBAFormat: ai, RGBAIntegerFormat: Dg, RGBA_ASTC_10x10_Format: Jg, RGBA_ASTC_10x5_Format: Zg, RGBA_ASTC_10x6_Format: Kg, RGBA_ASTC_10x8_Format: Qg, RGBA_ASTC_12x10_Format: $g, RGBA_ASTC_12x12_Format: e0, RGBA_ASTC_4x4_Format: Hg, RGBA_ASTC_5x4_Format: Gg, RGBA_ASTC_5x5_Format: Vg, RGBA_ASTC_6x5_Format: jg, RGBA_ASTC_6x6_Format: Wg, RGBA_ASTC_8x5_Format: Xg, RGBA_ASTC_8x6_Format: qg, RGBA_ASTC_8x8_Format: Yg, RGBA_BPTC_Format: Xd, RGBA_ETC2_EAC_Format: zg, RGBA_PVRTC_2BPPV1_Format: kg, RGBA_PVRTC_4BPPV1_Format: Ug, RGBA_S3TC_DXT1_Format: Vd, RGBA_S3TC_DXT3_Format: jd, RGBA_S3TC_DXT5_Format: Wd, RGBFormat: 1022, RGB_BPTC_SIGNED_Format: t0, RGB_BPTC_UNSIGNED_Format: n0, RGB_ETC1_Format: Fg, RGB_ETC2_Format: Bg, RGB_PVRTC_2BPPV1_Format: Og, RGB_PVRTC_4BPPV1_Format: Ng, RGB_S3TC_DXT1_Format: Gd, RGFormat: 1030, RGIntegerFormat: Lg, RawShaderMaterial: w1, Ray: Ka, Raycaster: D1, Rec709Primaries: eh, RectAreaLight: $2, RedFormat: l1, RedIntegerFormat: Pg, ReinhardToneMapping: n1, RenderTarget: BM, RepeatWrapping: In, ReplaceStencilOp: 7681, ReverseSubtractEquation: 102, RingGeometry: sf, SIGNED_RED_GREEN_RGTC2_Format: s0, SIGNED_RED_RGTC1_Format: i0, SRGBColorSpace: yt, SRGBTransfer: ft, Scene: _2, ShaderChunk: Ge, ShaderLib: Dn, ShaderMaterial: st, ShadowMaterial: ow, Shape: Ta, ShapeGeometry: af, ShapePath: xw, ShapeUtils: Vi, ShortType: 1011, Skeleton: ml, SkeletonHelper: class extends Qn {
  constructor(i) {
    const e = yw(i), t = new Re(), n = [], r = [], s = new ce(0, 0, 1), a = new ce(0, 1, 0);
    for (let o = 0; o < e.length; o++) {
      const l = e[o];
      l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b));
    }
    t.setAttribute("position", new ye(n, 3)), t.setAttribute("color", new ye(r, 3)), super(t, new zt({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = i, this.bones = e, this.matrix = i.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(i) {
    const e = this.bones, t = this.geometry, n = t.getAttribute("position");
    Lm.copy(this.root.matrixWorld).invert();
    for (let r = 0, s = 0; r < e.length; r++) {
      const a = e[r];
      a.parent && a.parent.isBone && (ud.multiplyMatrices(Lm, a.matrixWorld), Jr.setFromMatrixPosition(ud), n.setXYZ(s, Jr.x, Jr.y, Jr.z), ud.multiplyMatrices(Lm, a.parent.matrixWorld), Jr.setFromMatrixPosition(ud), n.setXYZ(s + 1, Jr.x, Jr.y, Jr.z), s += 2);
    }
    t.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(i);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, SkinnedMesh: hp, Source: ca, Sphere: an, SphereGeometry: gl, Spherical: M0, SphericalHarmonics3: mw, SplineCurve: b1, SpotLight: dh, SpotLightHelper: class extends Fe {
  constructor(i, e) {
    super(), this.light = i, this.matrixAutoUpdate = !1, this.color = e, this.type = "SpotLightHelper";
    const t = new Re(), n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (let s = 0, a = 1, o = 32; s < o; s++, a++) {
      const l = s / o * Math.PI * 2, c = a / o * Math.PI * 2;
      n.push(Math.cos(l), Math.sin(l), 1, Math.cos(c), Math.sin(c), 1);
    }
    t.setAttribute("position", new ye(n, 3));
    const r = new zt({ fog: !1, toneMapped: !1 });
    this.cone = new Qn(t, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const i = this.light.distance ? this.light.distance : 1e3, e = i * Math.tan(this.light.angle);
    this.cone.scale.set(e, e, i), g3.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(g3), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}, Sprite: M2, SpriteMaterial: Kp, SrcAlphaFactor: Ua, SrcAlphaSaturateFactor: 210, SrcColorFactor: 202, StaticCopyUsage: 35046, StaticDrawUsage: nh, StaticReadUsage: 35045, StereoCamera: class {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new jt(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new jt(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }
  update(i) {
    const e = this._cache;
    if (e.focus !== i.focus || e.fov !== i.fov || e.aspect !== i.aspect * this.aspect || e.near !== i.near || e.far !== i.far || e.zoom !== i.zoom || e.eyeSep !== this.eyeSep) {
      e.focus = i.focus, e.fov = i.fov, e.aspect = i.aspect * this.aspect, e.near = i.near, e.far = i.far, e.zoom = i.zoom, e.eyeSep = this.eyeSep, Ws.copy(i.projectionMatrix);
      const t = e.eyeSep / 2, n = t * e.near / e.focus, r = e.near * Math.tan(wa * e.fov * 0.5) / e.zoom;
      let s, a;
      s3.elements[12] = -t, r3.elements[12] = t, s = -r * e.aspect + n, a = r * e.aspect + n, Ws.elements[0] = 2 * e.near / (a - s), Ws.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(Ws), s = -r * e.aspect - n, a = r * e.aspect - n, Ws.elements[0] = 2 * e.near / (a - s), Ws.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(Ws);
    }
    this.cameraL.matrixWorld.copy(i.matrixWorld).multiply(s3), this.cameraR.matrixWorld.copy(i.matrixWorld).multiply(r3);
  }
}, StreamCopyUsage: 35042, StreamDrawUsage: 35040, StreamReadUsage: 35041, StringKeyframeTrack: ua, SubtractEquation: 101, SubtractiveBlending: 3, TOUCH: ia, TangentSpaceNormalMap: 0, TetrahedronGeometry: of, Texture: vt, TextureLoader: Va, TorusGeometry: Rr, TorusKnotGeometry: lf, Triangle: ni, TriangleFanDrawMode: 2, TriangleStripDrawMode: 1, TrianglesDrawMode: 0, TubeGeometry: Ps, UVMapping: Vp, Uint16BufferAttribute: Xp, Uint32BufferAttribute: p1, Uint8BufferAttribute: class extends it {
  constructor(i, e, t) {
    super(new Uint8Array(i), e, t);
  }
}, Uint8ClampedBufferAttribute: class extends it {
  constructor(i, e, t) {
    super(new Uint8ClampedArray(i), e, t);
  }
}, Uniform: L1, UniformsGroup: class extends lr {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: n5++ }), this.name = "", this.usage = nh, this.uniforms = [];
  }
  add(i) {
    return this.uniforms.push(i), this;
  }
  remove(i) {
    const e = this.uniforms.indexOf(i);
    return e !== -1 && this.uniforms.splice(e, 1), this;
  }
  setName(i) {
    return this.name = i, this;
  }
  setUsage(i) {
    return this.usage = i, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(i) {
    this.name = i.name, this.usage = i.usage;
    const e = i.uniforms;
    this.uniforms.length = 0;
    for (let t = 0, n = e.length; t < n; t++) {
      const r = Array.isArray(e[t]) ? e[t] : [e[t]];
      for (let s = 0; s < r.length; s++)
        this.uniforms.push(r[s].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, UniformsLib: _e, UniformsUtils: rn, UnsignedByteType: fs, UnsignedInt248Type: _s, UnsignedInt5999Type: 35902, UnsignedIntType: Ba, UnsignedShort4444Type: Cg, UnsignedShort5551Type: Rg, UnsignedShortType: ll, VSMShadowMap: nr, Vector2: Y, Vector3: S, Vector4: je, VectorKeyframeTrack: Ms, VideoTexture: JM, WebGL3DRenderTarget: class extends dt {
  constructor(i = 1, e = 1, t = 1, n = {}) {
    super(i, e, n), this.isWebGL3DRenderTarget = !0, this.depth = t, this.texture = new l0(null, i, e, t), this.texture.isRenderTargetTexture = !0;
  }
}, WebGLArrayRenderTarget: class extends dt {
  constructor(i = 1, e = 1, t = 1, n = {}) {
    super(i, e, n), this.isWebGLArrayRenderTarget = !0, this.depth = t, this.texture = new lp(null, i, e, t), this.texture.isRenderTargetTexture = !0;
  }
}, WebGLCoordinateSystem: za, WebGLCubeRenderTarget: VM, WebGLMultipleRenderTargets: class extends dt {
  constructor(i = 1, e = 1, t = 1, n = {}) {
    console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(i, e, Qt(Ee({}, n), { count: t })), this.isWebGLMultipleRenderTargets = !0;
  }
  get texture() {
    return this.textures;
  }
}, WebGLRenderTarget: dt, WebGLRenderer: class {
  constructor(i = {}) {
    const { canvas: e = Px(), context: t = null, depth: n = !0, stencil: r = !1, alpha: s = !1, antialias: a = !1, premultipliedAlpha: o = !0, preserveDrawingBuffer: l = !1, powerPreference: c = "default", failIfMajorPerformanceCaveat: h = !1 } = i;
    let u;
    if (this.isWebGLRenderer = !0, t !== null) {
      if (typeof WebGLRenderingContext != "undefined" && t instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      u = t.getContextAttributes().alpha;
    } else
      u = s;
    const d = new Uint32Array(4), p = new Int32Array(4);
    let f = null, v = null;
    const m = [], y = [];
    this.domElement = e, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = yt, this.toneMapping = Pr, this.toneMappingExposure = 1;
    const g = this;
    let _ = !1, x = 0, M = 0, b = null, w = -1, T = null;
    const A = new je(), L = new je();
    let I = null;
    const P = new ce(0);
    let N = 0, F = e.width, z = e.height, q = 1, re = null, ie = null;
    const me = new je(0, 0, F, z), Se = new je(0, 0, F, z);
    let te = !1;
    const se = new sh();
    let he = !1, ae = !1;
    const D = new fe(), R = new S(), X = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let Q = !1;
    function O() {
      return b === null ? q : 1;
    }
    let k, E, U, B, ne, V, de, xe, ue, H, j, $, be, Ne, Be, Me, Ve, ze, Ct, Ce, at, Le, mn, Ii, G = t;
    function jl(C, Z) {
      return e.getContext(C, Z);
    }
    try {
      const C = { alpha: !0, depth: n, stencil: r, antialias: a, premultipliedAlpha: o, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: h };
      if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${sp}`), e.addEventListener("webglcontextlost", Xl, !1), e.addEventListener("webglcontextrestored", dx, !1), e.addEventListener("webglcontextcreationerror", px, !1), G === null) {
        const Z = "webgl2";
        if (G = jl(Z, C), G === null)
          throw jl(Z) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (C) {
      throw console.error("THREE.WebGLRenderer: " + C.message), C;
    }
    function Wl() {
      k = new KT(G), k.init(), Le = new y2(G, k), E = new XT(G, k, i, Le), U = new pA(G), B = new $T(G), ne = new rA(), V = new fA(G, k, U, ne, E, Le, B), de = new YT(g), xe = new ZT(g), ue = new HT(G), mn = new jT(G, ue), H = new QT(G, ue, B, mn), j = new tE(G, H, ue, B), Ct = new eE(G, E, V), Me = new qT(ne), $ = new iA(g, de, xe, k, E, mn, Me), be = new _A(g, ne), Ne = new aA(), Be = new uA(k), ze = new VT(g, de, xe, U, j, u, o), Ve = new dA(g, j, E), Ii = new xA(G, B, E, U), Ce = new WT(G, k, B), at = new JT(G, k, B), B.programs = $.programs, g.capabilities = E, g.extensions = k, g.properties = ne, g.renderLists = Ne, g.shadowMap = Ve, g.state = U, g.info = B;
    }
    Wl();
    const wt = new vA(g, G);
    function Xl(C) {
      C.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0;
    }
    function dx() {
      console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
      const C = B.autoReset, Z = Ve.enabled, J = Ve.autoUpdate, oe = Ve.needsUpdate, ee = Ve.type;
      Wl(), B.autoReset = C, Ve.enabled = Z, Ve.autoUpdate = J, Ve.needsUpdate = oe, Ve.type = ee;
    }
    function px(C) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", C.statusMessage);
    }
    function fx(C) {
      const Z = C.target;
      Z.removeEventListener("dispose", fx), function(J) {
        (function(oe) {
          const ee = ne.get(oe).programs;
          ee !== void 0 && (ee.forEach(function(ge) {
            $.releaseProgram(ge);
          }), oe.isShaderMaterial && $.releaseShaderCache(oe));
        })(J), ne.remove(J);
      }(Z);
    }
    function mx(C, Z, J) {
      C.transparent === !0 && C.side === tn && C.forceSinglePass === !1 ? (C.side = kn, C.needsUpdate = !0, bu(C, Z, J), C.side = Gi, C.needsUpdate = !0, bu(C, Z, J), C.side = tn) : bu(C, Z, J);
    }
    this.xr = wt, this.getContext = function() {
      return G;
    }, this.getContextAttributes = function() {
      return G.getContextAttributes();
    }, this.forceContextLoss = function() {
      const C = k.get("WEBGL_lose_context");
      C && C.loseContext();
    }, this.forceContextRestore = function() {
      const C = k.get("WEBGL_lose_context");
      C && C.restoreContext();
    }, this.getPixelRatio = function() {
      return q;
    }, this.setPixelRatio = function(C) {
      C !== void 0 && (q = C, this.setSize(F, z, !1));
    }, this.getSize = function(C) {
      return C.set(F, z);
    }, this.setSize = function(C, Z, J = !0) {
      wt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (F = C, z = Z, e.width = Math.floor(C * q), e.height = Math.floor(Z * q), J === !0 && (e.style.width = C + "px", e.style.height = Z + "px"), this.setViewport(0, 0, C, Z));
    }, this.getDrawingBufferSize = function(C) {
      return C.set(F * q, z * q).floor();
    }, this.setDrawingBufferSize = function(C, Z, J) {
      F = C, z = Z, q = J, e.width = Math.floor(C * J), e.height = Math.floor(Z * J), this.setViewport(0, 0, C, Z);
    }, this.getCurrentViewport = function(C) {
      return C.copy(A);
    }, this.getViewport = function(C) {
      return C.copy(me);
    }, this.setViewport = function(C, Z, J, oe) {
      C.isVector4 ? me.set(C.x, C.y, C.z, C.w) : me.set(C, Z, J, oe), U.viewport(A.copy(me).multiplyScalar(q).round());
    }, this.getScissor = function(C) {
      return C.copy(Se);
    }, this.setScissor = function(C, Z, J, oe) {
      C.isVector4 ? Se.set(C.x, C.y, C.z, C.w) : Se.set(C, Z, J, oe), U.scissor(L.copy(Se).multiplyScalar(q).round());
    }, this.getScissorTest = function() {
      return te;
    }, this.setScissorTest = function(C) {
      U.setScissorTest(te = C);
    }, this.setOpaqueSort = function(C) {
      re = C;
    }, this.setTransparentSort = function(C) {
      ie = C;
    }, this.getClearColor = function(C) {
      return C.copy(ze.getClearColor());
    }, this.setClearColor = function() {
      ze.setClearColor.apply(ze, arguments);
    }, this.getClearAlpha = function() {
      return ze.getClearAlpha();
    }, this.setClearAlpha = function() {
      ze.setClearAlpha.apply(ze, arguments);
    }, this.clear = function(C = !0, Z = !0, J = !0) {
      let oe = 0;
      if (C) {
        let ee = !1;
        if (b !== null) {
          const ge = b.texture.format;
          ee = ge === Dg || ge === Lg || ge === Pg;
        }
        if (ee) {
          const ge = b.texture.type, Ae = ge === fs || ge === Ba || ge === ll || ge === _s || ge === Cg || ge === Rg, Ie = ze.getClearColor(), Pe = ze.getClearAlpha(), Oe = Ie.r, We = Ie.g, De = Ie.b;
          Ae ? (d[0] = Oe, d[1] = We, d[2] = De, d[3] = Pe, G.clearBufferuiv(G.COLOR, 0, d)) : (p[0] = Oe, p[1] = We, p[2] = De, p[3] = Pe, G.clearBufferiv(G.COLOR, 0, p));
        } else
          oe |= G.COLOR_BUFFER_BIT;
      }
      Z && (oe |= G.DEPTH_BUFFER_BIT), J && (oe |= G.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), G.clear(oe);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      e.removeEventListener("webglcontextlost", Xl, !1), e.removeEventListener("webglcontextrestored", dx, !1), e.removeEventListener("webglcontextcreationerror", px, !1), Ne.dispose(), Be.dispose(), ne.dispose(), de.dispose(), xe.dispose(), j.dispose(), mn.dispose(), Ii.dispose(), $.dispose(), wt.dispose(), wt.removeEventListener("sessionstart", gx), wt.removeEventListener("sessionend", vx), Us.stop();
    }, this.renderBufferDirect = function(C, Z, J, oe, ee, ge) {
      Z === null && (Z = X);
      const Ae = ee.isMesh && ee.matrixWorld.determinant() < 0, Ie = function(ot, Ot, Yn, Ke, Xe) {
        Ot.isScene !== !0 && (Ot = X), V.resetTextureUnits();
        const ql = Ot.fog, G4 = Ke.isMeshStandardMaterial ? Ot.environment : null, V4 = b === null ? g.outputColorSpace : b.isXRRenderTarget === !0 ? b.texture.colorSpace : on, Mu = (Ke.isMeshStandardMaterial ? xe : de).get(Ke.envMap || G4), j4 = Ke.vertexColors === !0 && !!Yn.attributes.color && Yn.attributes.color.itemSize === 4, W4 = !!Yn.attributes.tangent && (!!Ke.normalMap || Ke.anisotropy > 0), X4 = !!Yn.morphAttributes.position, q4 = !!Yn.morphAttributes.normal, Y4 = !!Yn.morphAttributes.color;
        let wx = Pr;
        Ke.toneMapped && (b !== null && b.isXRRenderTarget !== !0 || (wx = g.toneMapping));
        const Sx = Yn.morphAttributes.position || Yn.morphAttributes.normal || Yn.morphAttributes.color, Z4 = Sx !== void 0 ? Sx.length : 0, $e = ne.get(Ke), K4 = v.state.lights;
        if (he === !0 && (ae === !0 || ot !== T)) {
          const ui = ot === T && Ke.id === w;
          Me.setState(Ke, ot, ui);
        }
        let Ci = !1;
        Ke.version === $e.__version ? $e.needsLights && $e.lightsStateVersion !== K4.state.version || $e.outputColorSpace !== V4 || Xe.isBatchedMesh && $e.batching === !1 ? Ci = !0 : Xe.isBatchedMesh || $e.batching !== !0 ? Xe.isBatchedMesh && $e.batchingColor === !0 && Xe.colorTexture === null || Xe.isBatchedMesh && $e.batchingColor === !1 && Xe.colorTexture !== null || Xe.isInstancedMesh && $e.instancing === !1 ? Ci = !0 : Xe.isInstancedMesh || $e.instancing !== !0 ? Xe.isSkinnedMesh && $e.skinning === !1 ? Ci = !0 : Xe.isSkinnedMesh || $e.skinning !== !0 ? Xe.isInstancedMesh && $e.instancingColor === !0 && Xe.instanceColor === null || Xe.isInstancedMesh && $e.instancingColor === !1 && Xe.instanceColor !== null || Xe.isInstancedMesh && $e.instancingMorph === !0 && Xe.morphTexture === null || Xe.isInstancedMesh && $e.instancingMorph === !1 && Xe.morphTexture !== null || $e.envMap !== Mu || Ke.fog === !0 && $e.fog !== ql ? Ci = !0 : $e.numClippingPlanes === void 0 || $e.numClippingPlanes === Me.numPlanes && $e.numIntersection === Me.numIntersection ? ($e.vertexAlphas !== j4 || $e.vertexTangents !== W4 || $e.morphTargets !== X4 || $e.morphNormals !== q4 || $e.morphColors !== Y4 || $e.toneMapping !== wx || $e.morphTargetsCount !== Z4) && (Ci = !0) : Ci = !0 : Ci = !0 : Ci = !0 : Ci = !0 : (Ci = !0, $e.__version = Ke.version);
        let ks = $e.currentProgram;
        Ci === !0 && (ks = bu(Ke, Ot, Xe));
        let Tx = !1, Yl = !1, Hf = !1;
        const hn = ks.getUniforms(), jr = $e.uniforms;
        if (U.useProgram(ks.program) && (Tx = !0, Yl = !0, Hf = !0), Ke.id !== w && (w = Ke.id, Yl = !0), Tx || T !== ot) {
          hn.setValue(G, "projectionMatrix", ot.projectionMatrix), hn.setValue(G, "viewMatrix", ot.matrixWorldInverse);
          const ui = hn.map.cameraPosition;
          ui !== void 0 && ui.setValue(G, R.setFromMatrixPosition(ot.matrixWorld)), E.logarithmicDepthBuffer && hn.setValue(G, "logDepthBufFC", 2 / (Math.log(ot.far + 1) / Math.LN2)), (Ke.isMeshPhongMaterial || Ke.isMeshToonMaterial || Ke.isMeshLambertMaterial || Ke.isMeshBasicMaterial || Ke.isMeshStandardMaterial || Ke.isShaderMaterial) && hn.setValue(G, "isOrthographic", ot.isOrthographicCamera === !0), T !== ot && (T = ot, Yl = !0, Hf = !0);
        }
        if (Xe.isSkinnedMesh) {
          hn.setOptional(G, Xe, "bindMatrix"), hn.setOptional(G, Xe, "bindMatrixInverse");
          const ui = Xe.skeleton;
          ui && (ui.boneTexture === null && ui.computeBoneTexture(), hn.setValue(G, "boneTexture", ui.boneTexture, V));
        }
        Xe.isBatchedMesh && (hn.setOptional(G, Xe, "batchingTexture"), hn.setValue(G, "batchingTexture", Xe._matricesTexture, V), hn.setOptional(G, Xe, "batchingColorTexture"), Xe._colorsTexture !== null && hn.setValue(G, "batchingColorTexture", Xe._colorsTexture, V));
        const Gf = Yn.morphAttributes;
        Gf.position === void 0 && Gf.normal === void 0 && Gf.color === void 0 || Ct.update(Xe, Yn, ks), (Yl || $e.receiveShadow !== Xe.receiveShadow) && ($e.receiveShadow = Xe.receiveShadow, hn.setValue(G, "receiveShadow", Xe.receiveShadow)), Ke.isMeshGouraudMaterial && Ke.envMap !== null && (jr.envMap.value = Mu, jr.flipEnvMap.value = Mu.isCubeTexture && Mu.isRenderTargetTexture === !1 ? -1 : 1), Ke.isMeshStandardMaterial && Ke.envMap === null && Ot.environment !== null && (jr.envMapIntensity.value = Ot.environmentIntensity), Yl && (hn.setValue(G, "toneMappingExposure", g.toneMappingExposure), $e.needsLights && (Ri = Hf, (qi = jr).ambientLightColor.needsUpdate = Ri, qi.lightProbe.needsUpdate = Ri, qi.directionalLights.needsUpdate = Ri, qi.directionalLightShadows.needsUpdate = Ri, qi.pointLights.needsUpdate = Ri, qi.pointLightShadows.needsUpdate = Ri, qi.spotLights.needsUpdate = Ri, qi.spotLightShadows.needsUpdate = Ri, qi.rectAreaLights.needsUpdate = Ri, qi.hemisphereLights.needsUpdate = Ri), ql && Ke.fog === !0 && be.refreshFogUniforms(jr, ql), be.refreshMaterialUniforms(jr, Ke, q, z, v.state.transmissionRenderTarget[ot.id]), Yd.upload(G, bx($e), jr, V));
        var qi, Ri;
        if (Ke.isShaderMaterial && Ke.uniformsNeedUpdate === !0 && (Yd.upload(G, bx($e), jr, V), Ke.uniformsNeedUpdate = !1), Ke.isSpriteMaterial && hn.setValue(G, "center", Xe.center), hn.setValue(G, "modelViewMatrix", Xe.modelViewMatrix), hn.setValue(G, "normalMatrix", Xe.normalMatrix), hn.setValue(G, "modelMatrix", Xe.matrixWorld), Ke.isShaderMaterial || Ke.isRawShaderMaterial) {
          const ui = Ke.uniformsGroups;
          for (let Vf = 0, Q4 = ui.length; Vf < Q4; Vf++) {
            const Ex = ui[Vf];
            Ii.update(Ex, ks), Ii.bind(Ex, ks);
          }
        }
        return ks;
      }(C, Z, J, oe, ee);
      U.setMaterial(oe, Ae);
      let Pe = J.index, Oe = 1;
      if (oe.wireframe === !0) {
        if (Pe = H.getWireframeAttribute(J), Pe === void 0)
          return;
        Oe = 2;
      }
      const We = J.drawRange, De = J.attributes.position;
      let tt = We.start * Oe, St = (We.start + We.count) * Oe;
      ge !== null && (tt = Math.max(tt, ge.start * Oe), St = Math.min(St, (ge.start + ge.count) * Oe)), Pe !== null ? (tt = Math.max(tt, 0), St = Math.min(St, Pe.count)) : De != null && (tt = Math.max(tt, 0), St = Math.min(St, De.count));
      const Xt = St - tt;
      if (Xt < 0 || Xt === 1 / 0)
        return;
      let Kt;
      mn.setup(ee, oe, Ie, J, Pe);
      let Tt = Ce;
      if (Pe !== null && (Kt = ue.get(Pe), Tt = at, Tt.setIndex(Kt)), ee.isMesh)
        oe.wireframe === !0 ? (U.setLineWidth(oe.wireframeLinewidth * O()), Tt.setMode(G.LINES)) : Tt.setMode(G.TRIANGLES);
      else if (ee.isLine) {
        let ot = oe.linewidth;
        ot === void 0 && (ot = 1), U.setLineWidth(ot * O()), ee.isLineSegments ? Tt.setMode(G.LINES) : ee.isLineLoop ? Tt.setMode(G.LINE_LOOP) : Tt.setMode(G.LINE_STRIP);
      } else
        ee.isPoints ? Tt.setMode(G.POINTS) : ee.isSprite && Tt.setMode(G.TRIANGLES);
      if (ee.isBatchedMesh)
        ee._multiDrawInstances !== null ? Tt.renderMultiDrawInstances(ee._multiDrawStarts, ee._multiDrawCounts, ee._multiDrawCount, ee._multiDrawInstances) : Tt.renderMultiDraw(ee._multiDrawStarts, ee._multiDrawCounts, ee._multiDrawCount);
      else if (ee.isInstancedMesh)
        Tt.renderInstances(tt, Xt, ee.count);
      else if (J.isInstancedBufferGeometry) {
        const ot = J._maxInstanceCount !== void 0 ? J._maxInstanceCount : 1 / 0, Ot = Math.min(J.instanceCount, ot);
        Tt.renderInstances(tt, Xt, Ot);
      } else
        Tt.render(tt, Xt);
    }, this.compile = function(C, Z, J = null) {
      J === null && (J = C), v = Be.get(J), v.init(Z), y.push(v), J.traverseVisible(function(ee) {
        ee.isLight && ee.layers.test(Z.layers) && (v.pushLight(ee), ee.castShadow && v.pushShadow(ee));
      }), C !== J && C.traverseVisible(function(ee) {
        ee.isLight && ee.layers.test(Z.layers) && (v.pushLight(ee), ee.castShadow && v.pushShadow(ee));
      }), v.setupLights();
      const oe = /* @__PURE__ */ new Set();
      return C.traverse(function(ee) {
        const ge = ee.material;
        if (ge)
          if (Array.isArray(ge))
            for (let Ae = 0; Ae < ge.length; Ae++) {
              const Ie = ge[Ae];
              mx(Ie, J, ee), oe.add(Ie);
            }
          else
            mx(ge, J, ee), oe.add(ge);
      }), y.pop(), v = null, oe;
    }, this.compileAsync = function(C, Z, J = null) {
      const oe = this.compile(C, Z, J);
      return new Promise((ee) => {
        function ge() {
          oe.forEach(function(Ae) {
            ne.get(Ae).currentProgram.isReady() && oe.delete(Ae);
          }), oe.size !== 0 ? setTimeout(ge, 10) : ee(C);
        }
        k.get("KHR_parallel_shader_compile") !== null ? ge() : setTimeout(ge, 10);
      });
    };
    let Bf = null;
    function gx() {
      Us.stop();
    }
    function vx() {
      Us.start();
    }
    const Us = new jM();
    function zf(C, Z, J, oe) {
      if (C.visible === !1)
        return;
      if (C.layers.test(Z.layers)) {
        if (C.isGroup)
          J = C.renderOrder;
        else if (C.isLOD)
          C.autoUpdate === !0 && C.update(Z);
        else if (C.isLight)
          v.pushLight(C), C.castShadow && v.pushShadow(C);
        else if (C.isSprite) {
          if (!C.frustumCulled || se.intersectsSprite(C)) {
            oe && R.setFromMatrixPosition(C.matrixWorld).applyMatrix4(D);
            const ge = j.update(C), Ae = C.material;
            Ae.visible && f.push(C, ge, Ae, J, R.z, null);
          }
        } else if ((C.isMesh || C.isLine || C.isPoints) && (!C.frustumCulled || se.intersectsObject(C))) {
          const ge = j.update(C), Ae = C.material;
          if (oe && (C.boundingSphere !== void 0 ? (C.boundingSphere === null && C.computeBoundingSphere(), R.copy(C.boundingSphere.center)) : (ge.boundingSphere === null && ge.computeBoundingSphere(), R.copy(ge.boundingSphere.center)), R.applyMatrix4(C.matrixWorld).applyMatrix4(D)), Array.isArray(Ae)) {
            const Ie = ge.groups;
            for (let Pe = 0, Oe = Ie.length; Pe < Oe; Pe++) {
              const We = Ie[Pe], De = Ae[We.materialIndex];
              De && De.visible && f.push(C, ge, De, J, R.z, We);
            }
          } else
            Ae.visible && f.push(C, ge, Ae, J, R.z, null);
        }
      }
      const ee = C.children;
      for (let ge = 0, Ae = ee.length; ge < Ae; ge++)
        zf(ee[ge], Z, J, oe);
    }
    function yx(C, Z, J, oe) {
      const ee = C.opaque, ge = C.transmissive, Ae = C.transparent;
      v.setupLightsView(J), he === !0 && Me.setGlobalState(g.clippingPlanes, J), oe && U.viewport(A.copy(oe)), ee.length > 0 && xu(ee, Z, J), ge.length > 0 && xu(ge, Z, J), Ae.length > 0 && xu(Ae, Z, J), U.buffers.depth.setTest(!0), U.buffers.depth.setMask(!0), U.buffers.color.setMask(!0), U.setPolygonOffset(!1);
    }
    function _x(C, Z, J, oe) {
      if ((J.isScene === !0 ? J.overrideMaterial : null) !== null)
        return;
      v.state.transmissionRenderTarget[oe.id] === void 0 && (v.state.transmissionRenderTarget[oe.id] = new dt(1, 1, { generateMipmaps: !0, type: k.has("EXT_color_buffer_half_float") || k.has("EXT_color_buffer_float") ? Vt : fs, minFilter: zi, samples: 4, stencilBuffer: r, resolveDepthBuffer: !1, resolveStencilBuffer: !1, colorSpace: rt.workingColorSpace }));
      const ee = v.state.transmissionRenderTarget[oe.id], ge = oe.viewport || A;
      ee.setSize(ge.z, ge.w);
      const Ae = g.getRenderTarget();
      g.setRenderTarget(ee), g.getClearColor(P), N = g.getClearAlpha(), N < 1 && g.setClearColor(16777215, 0.5), Q ? ze.render(J) : g.clear();
      const Ie = g.toneMapping;
      g.toneMapping = Pr;
      const Pe = oe.viewport;
      if (oe.viewport !== void 0 && (oe.viewport = void 0), v.setupLightsView(oe), he === !0 && Me.setGlobalState(g.clippingPlanes, oe), xu(C, J, oe), V.updateMultisampleRenderTarget(ee), V.updateRenderTargetMipmap(ee), k.has("WEBGL_multisampled_render_to_texture") === !1) {
        let Oe = !1;
        for (let We = 0, De = Z.length; We < De; We++) {
          const tt = Z[We], St = tt.object, Xt = tt.geometry, Kt = tt.material, Tt = tt.group;
          if (Kt.side === tn && St.layers.test(oe.layers)) {
            const ot = Kt.side;
            Kt.side = kn, Kt.needsUpdate = !0, xx(St, J, oe, Xt, Kt, Tt), Kt.side = ot, Kt.needsUpdate = !0, Oe = !0;
          }
        }
        Oe === !0 && (V.updateMultisampleRenderTarget(ee), V.updateRenderTargetMipmap(ee));
      }
      g.setRenderTarget(Ae), g.setClearColor(P, N), Pe !== void 0 && (oe.viewport = Pe), g.toneMapping = Ie;
    }
    function xu(C, Z, J) {
      const oe = Z.isScene === !0 ? Z.overrideMaterial : null;
      for (let ee = 0, ge = C.length; ee < ge; ee++) {
        const Ae = C[ee], Ie = Ae.object, Pe = Ae.geometry, Oe = oe === null ? Ae.material : oe, We = Ae.group;
        Ie.layers.test(J.layers) && xx(Ie, Z, J, Pe, Oe, We);
      }
    }
    function xx(C, Z, J, oe, ee, ge) {
      C.onBeforeRender(g, Z, J, oe, ee, ge), C.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse, C.matrixWorld), C.normalMatrix.getNormalMatrix(C.modelViewMatrix), ee.onBeforeRender(g, Z, J, oe, C, ge), ee.transparent === !0 && ee.side === tn && ee.forceSinglePass === !1 ? (ee.side = kn, ee.needsUpdate = !0, g.renderBufferDirect(J, Z, oe, ee, C, ge), ee.side = Gi, ee.needsUpdate = !0, g.renderBufferDirect(J, Z, oe, ee, C, ge), ee.side = tn) : g.renderBufferDirect(J, Z, oe, ee, C, ge), C.onAfterRender(g, Z, J, oe, ee, ge);
    }
    function bu(C, Z, J) {
      Z.isScene !== !0 && (Z = X);
      const oe = ne.get(C), ee = v.state.lights, ge = v.state.shadowsArray, Ae = ee.state.version, Ie = $.getParameters(C, ee.state, ge, Z, J), Pe = $.getProgramCacheKey(Ie);
      let Oe = oe.programs;
      oe.environment = C.isMeshStandardMaterial ? Z.environment : null, oe.fog = Z.fog, oe.envMap = (C.isMeshStandardMaterial ? xe : de).get(C.envMap || oe.environment), oe.envMapRotation = oe.environment !== null && C.envMap === null ? Z.environmentRotation : C.envMapRotation, Oe === void 0 && (C.addEventListener("dispose", fx), Oe = /* @__PURE__ */ new Map(), oe.programs = Oe);
      let We = Oe.get(Pe);
      if (We !== void 0) {
        if (oe.currentProgram === We && oe.lightsStateVersion === Ae)
          return Mx(C, Ie), We;
      } else
        Ie.uniforms = $.getUniforms(C), C.onBuild(J, Ie, g), C.onBeforeCompile(Ie, g), We = $.acquireProgram(Ie, Pe), Oe.set(Pe, We), oe.uniforms = Ie.uniforms;
      const De = oe.uniforms;
      return (C.isShaderMaterial || C.isRawShaderMaterial) && C.clipping !== !0 || (De.clippingPlanes = Me.uniform), Mx(C, Ie), oe.needsLights = function(tt) {
        return tt.isMeshLambertMaterial || tt.isMeshToonMaterial || tt.isMeshPhongMaterial || tt.isMeshStandardMaterial || tt.isShadowMaterial || tt.isShaderMaterial && tt.lights === !0;
      }(C), oe.lightsStateVersion = Ae, oe.needsLights && (De.ambientLightColor.value = ee.state.ambient, De.lightProbe.value = ee.state.probe, De.directionalLights.value = ee.state.directional, De.directionalLightShadows.value = ee.state.directionalShadow, De.spotLights.value = ee.state.spot, De.spotLightShadows.value = ee.state.spotShadow, De.rectAreaLights.value = ee.state.rectArea, De.ltc_1.value = ee.state.rectAreaLTC1, De.ltc_2.value = ee.state.rectAreaLTC2, De.pointLights.value = ee.state.point, De.pointLightShadows.value = ee.state.pointShadow, De.hemisphereLights.value = ee.state.hemi, De.directionalShadowMap.value = ee.state.directionalShadowMap, De.directionalShadowMatrix.value = ee.state.directionalShadowMatrix, De.spotShadowMap.value = ee.state.spotShadowMap, De.spotLightMatrix.value = ee.state.spotLightMatrix, De.spotLightMap.value = ee.state.spotLightMap, De.pointShadowMap.value = ee.state.pointShadowMap, De.pointShadowMatrix.value = ee.state.pointShadowMatrix), oe.currentProgram = We, oe.uniformsList = null, We;
    }
    function bx(C) {
      if (C.uniformsList === null) {
        const Z = C.currentProgram.getUniforms();
        C.uniformsList = Yd.seqWithValue(Z.seq, C.uniforms);
      }
      return C.uniformsList;
    }
    function Mx(C, Z) {
      const J = ne.get(C);
      J.outputColorSpace = Z.outputColorSpace, J.batching = Z.batching, J.batchingColor = Z.batchingColor, J.instancing = Z.instancing, J.instancingColor = Z.instancingColor, J.instancingMorph = Z.instancingMorph, J.skinning = Z.skinning, J.morphTargets = Z.morphTargets, J.morphNormals = Z.morphNormals, J.morphColors = Z.morphColors, J.morphTargetsCount = Z.morphTargetsCount, J.numClippingPlanes = Z.numClippingPlanes, J.numIntersection = Z.numClipIntersection, J.vertexAlphas = Z.vertexAlphas, J.vertexTangents = Z.vertexTangents, J.toneMapping = Z.toneMapping;
    }
    Us.setAnimationLoop(function(C) {
      Bf && Bf(C);
    }), typeof self != "undefined" && Us.setContext(self), this.setAnimationLoop = function(C) {
      Bf = C, wt.setAnimationLoop(C), C === null ? Us.stop() : Us.start();
    }, wt.addEventListener("sessionstart", gx), wt.addEventListener("sessionend", vx), this.render = function(C, Z) {
      if (Z !== void 0 && Z.isCamera !== !0)
        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      if (_ === !0)
        return;
      if (C.matrixWorldAutoUpdate === !0 && C.updateMatrixWorld(), Z.parent === null && Z.matrixWorldAutoUpdate === !0 && Z.updateMatrixWorld(), wt.enabled === !0 && wt.isPresenting === !0 && (wt.cameraAutoUpdate === !0 && wt.updateCamera(Z), Z = wt.getCamera()), C.isScene === !0 && C.onBeforeRender(g, C, Z, b), v = Be.get(C, y.length), v.init(Z), y.push(v), D.multiplyMatrices(Z.projectionMatrix, Z.matrixWorldInverse), se.setFromProjectionMatrix(D), ae = this.localClippingEnabled, he = Me.init(this.clippingPlanes, ae), f = Ne.get(C, m.length), f.init(), m.push(f), wt.enabled === !0 && wt.isPresenting === !0) {
        const ge = g.xr.getDepthSensingMesh();
        ge !== null && zf(ge, Z, -1 / 0, g.sortObjects);
      }
      zf(C, Z, 0, g.sortObjects), f.finish(), g.sortObjects === !0 && f.sort(re, ie), Q = wt.enabled === !1 || wt.isPresenting === !1 || wt.hasDepthSensing() === !1, Q && ze.addToRenderList(f, C), this.info.render.frame++, he === !0 && Me.beginShadows();
      const J = v.state.shadowsArray;
      Ve.render(J, C, Z), he === !0 && Me.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const oe = f.opaque, ee = f.transmissive;
      if (v.setupLights(), Z.isArrayCamera) {
        const ge = Z.cameras;
        if (ee.length > 0)
          for (let Ae = 0, Ie = ge.length; Ae < Ie; Ae++)
            _x(oe, ee, C, ge[Ae]);
        Q && ze.render(C);
        for (let Ae = 0, Ie = ge.length; Ae < Ie; Ae++) {
          const Pe = ge[Ae];
          yx(f, C, Pe, Pe.viewport);
        }
      } else
        ee.length > 0 && _x(oe, ee, C, Z), Q && ze.render(C), yx(f, C, Z);
      b !== null && (V.updateMultisampleRenderTarget(b), V.updateRenderTargetMipmap(b)), C.isScene === !0 && C.onAfterRender(g, C, Z), mn.resetDefaultState(), w = -1, T = null, y.pop(), y.length > 0 ? (v = y[y.length - 1], he === !0 && Me.setGlobalState(g.clippingPlanes, v.state.camera)) : v = null, m.pop(), f = m.length > 0 ? m[m.length - 1] : null;
    }, this.getActiveCubeFace = function() {
      return x;
    }, this.getActiveMipmapLevel = function() {
      return M;
    }, this.getRenderTarget = function() {
      return b;
    }, this.setRenderTargetTextures = function(C, Z, J) {
      ne.get(C.texture).__webglTexture = Z, ne.get(C.depthTexture).__webglTexture = J;
      const oe = ne.get(C);
      oe.__hasExternalTextures = !0, oe.__autoAllocateDepthBuffer = J === void 0, oe.__autoAllocateDepthBuffer || k.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), oe.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(C, Z) {
      const J = ne.get(C);
      J.__webglFramebuffer = Z, J.__useDefaultFramebuffer = Z === void 0;
    }, this.setRenderTarget = function(C, Z = 0, J = 0) {
      b = C, x = Z, M = J;
      let oe = !0, ee = null, ge = !1, Ae = !1;
      if (C) {
        const Ie = ne.get(C);
        Ie.__useDefaultFramebuffer !== void 0 ? (U.bindFramebuffer(G.FRAMEBUFFER, null), oe = !1) : Ie.__webglFramebuffer === void 0 ? V.setupRenderTarget(C) : Ie.__hasExternalTextures && V.rebindTextures(C, ne.get(C.texture).__webglTexture, ne.get(C.depthTexture).__webglTexture);
        const Pe = C.texture;
        (Pe.isData3DTexture || Pe.isDataArrayTexture || Pe.isCompressedArrayTexture) && (Ae = !0);
        const Oe = ne.get(C).__webglFramebuffer;
        C.isWebGLCubeRenderTarget ? (ee = Array.isArray(Oe[Z]) ? Oe[Z][J] : Oe[Z], ge = !0) : ee = C.samples > 0 && V.useMultisampledRTT(C) === !1 ? ne.get(C).__webglMultisampledFramebuffer : Array.isArray(Oe) ? Oe[J] : Oe, A.copy(C.viewport), L.copy(C.scissor), I = C.scissorTest;
      } else
        A.copy(me).multiplyScalar(q).floor(), L.copy(Se).multiplyScalar(q).floor(), I = te;
      if (U.bindFramebuffer(G.FRAMEBUFFER, ee) && oe && U.drawBuffers(C, ee), U.viewport(A), U.scissor(L), U.setScissorTest(I), ge) {
        const Ie = ne.get(C.texture);
        G.framebufferTexture2D(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, G.TEXTURE_CUBE_MAP_POSITIVE_X + Z, Ie.__webglTexture, J);
      } else if (Ae) {
        const Ie = ne.get(C.texture), Pe = Z || 0;
        G.framebufferTextureLayer(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, Ie.__webglTexture, J || 0, Pe);
      }
      w = -1;
    }, this.readRenderTargetPixels = function(C, Z, J, oe, ee, ge, Ae) {
      if (!C || !C.isWebGLRenderTarget)
        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Ie = ne.get(C).__webglFramebuffer;
      if (C.isWebGLCubeRenderTarget && Ae !== void 0 && (Ie = Ie[Ae]), Ie) {
        U.bindFramebuffer(G.FRAMEBUFFER, Ie);
        try {
          const Pe = C.texture, Oe = Pe.format, We = Pe.type;
          if (!E.textureFormatReadable(Oe))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          if (!E.textureTypeReadable(We))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          Z >= 0 && Z <= C.width - oe && J >= 0 && J <= C.height - ee && G.readPixels(Z, J, oe, ee, Le.convert(Oe), Le.convert(We), ge);
        } finally {
          const Pe = b !== null ? ne.get(b).__webglFramebuffer : null;
          U.bindFramebuffer(G.FRAMEBUFFER, Pe);
        }
      }
    }, this.readRenderTargetPixelsAsync = function(C, Z, J, oe, ee, ge, Ae) {
      return di(this, null, function* () {
        if (!C || !C.isWebGLRenderTarget)
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let Ie = ne.get(C).__webglFramebuffer;
        if (C.isWebGLCubeRenderTarget && Ae !== void 0 && (Ie = Ie[Ae]), Ie) {
          U.bindFramebuffer(G.FRAMEBUFFER, Ie);
          try {
            const Pe = C.texture, Oe = Pe.format, We = Pe.type;
            if (!E.textureFormatReadable(Oe))
              throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
            if (!E.textureTypeReadable(We))
              throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
            if (Z >= 0 && Z <= C.width - oe && J >= 0 && J <= C.height - ee) {
              const De = G.createBuffer();
              G.bindBuffer(G.PIXEL_PACK_BUFFER, De), G.bufferData(G.PIXEL_PACK_BUFFER, ge.byteLength, G.STREAM_READ), G.readPixels(Z, J, oe, ee, Le.convert(Oe), Le.convert(We), 0), G.flush();
              const tt = G.fenceSync(G.SYNC_GPU_COMMANDS_COMPLETE, 0);
              yield function(St, Xt, Kt) {
                return new Promise(function(Tt, ot) {
                  setTimeout(function Ot() {
                    switch (St.clientWaitSync(Xt, St.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                      case St.WAIT_FAILED:
                        ot();
                        break;
                      case St.TIMEOUT_EXPIRED:
                        setTimeout(Ot, Kt);
                        break;
                      default:
                        Tt();
                    }
                  }, Kt);
                });
              }(G, tt, 4);
              try {
                G.bindBuffer(G.PIXEL_PACK_BUFFER, De), G.getBufferSubData(G.PIXEL_PACK_BUFFER, 0, ge);
              } finally {
                G.deleteBuffer(De), G.deleteSync(tt);
              }
              return ge;
            }
          } finally {
            const Pe = b !== null ? ne.get(b).__webglFramebuffer : null;
            U.bindFramebuffer(G.FRAMEBUFFER, Pe);
          }
        }
      });
    }, this.copyFramebufferToTexture = function(C, Z = null, J = 0) {
      C.isTexture !== !0 && (console.warn("WebGLRenderer: copyFramebufferToTexture function signature has changed."), Z = arguments[0] || null, C = arguments[1]);
      const oe = Math.pow(2, -J), ee = Math.floor(C.image.width * oe), ge = Math.floor(C.image.height * oe), Ae = Z !== null ? Z.x : 0, Ie = Z !== null ? Z.y : 0;
      V.setTexture2D(C, 0), G.copyTexSubImage2D(G.TEXTURE_2D, J, 0, 0, Ae, Ie, ee, ge), U.unbindTexture();
    }, this.copyTextureToTexture = function(C, Z, J = null, oe = null, ee = 0) {
      let ge, Ae, Ie, Pe, Oe, We;
      C.isTexture !== !0 && (console.warn("WebGLRenderer: copyTextureToTexture function signature has changed."), oe = arguments[0] || null, C = arguments[1], Z = arguments[2], ee = arguments[3] || 0, J = null), J !== null ? (ge = J.max.x - J.min.x, Ae = J.max.y - J.min.y, Ie = J.min.x, Pe = J.min.y) : (ge = C.image.width, Ae = C.image.height, Ie = 0, Pe = 0), oe !== null ? (Oe = oe.x, We = oe.y) : (Oe = 0, We = 0);
      const De = Le.convert(Z.format), tt = Le.convert(Z.type);
      V.setTexture2D(Z, 0), G.pixelStorei(G.UNPACK_FLIP_Y_WEBGL, Z.flipY), G.pixelStorei(G.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Z.premultiplyAlpha), G.pixelStorei(G.UNPACK_ALIGNMENT, Z.unpackAlignment);
      const St = G.getParameter(G.UNPACK_ROW_LENGTH), Xt = G.getParameter(G.UNPACK_IMAGE_HEIGHT), Kt = G.getParameter(G.UNPACK_SKIP_PIXELS), Tt = G.getParameter(G.UNPACK_SKIP_ROWS), ot = G.getParameter(G.UNPACK_SKIP_IMAGES), Ot = C.isCompressedTexture ? C.mipmaps[ee] : C.image;
      G.pixelStorei(G.UNPACK_ROW_LENGTH, Ot.width), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, Ot.height), G.pixelStorei(G.UNPACK_SKIP_PIXELS, Ie), G.pixelStorei(G.UNPACK_SKIP_ROWS, Pe), C.isDataTexture ? G.texSubImage2D(G.TEXTURE_2D, ee, Oe, We, ge, Ae, De, tt, Ot.data) : C.isCompressedTexture ? G.compressedTexSubImage2D(G.TEXTURE_2D, ee, Oe, We, Ot.width, Ot.height, De, Ot.data) : G.texSubImage2D(G.TEXTURE_2D, ee, Oe, We, De, tt, Ot), G.pixelStorei(G.UNPACK_ROW_LENGTH, St), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, Xt), G.pixelStorei(G.UNPACK_SKIP_PIXELS, Kt), G.pixelStorei(G.UNPACK_SKIP_ROWS, Tt), G.pixelStorei(G.UNPACK_SKIP_IMAGES, ot), ee === 0 && Z.generateMipmaps && G.generateMipmap(G.TEXTURE_2D), U.unbindTexture();
    }, this.copyTextureToTexture3D = function(C, Z, J = null, oe = null, ee = 0) {
      let ge, Ae, Ie, Pe, Oe, We, De, tt, St;
      C.isTexture !== !0 && (console.warn("WebGLRenderer: copyTextureToTexture3D function signature has changed."), J = arguments[0] || null, oe = arguments[1] || null, C = arguments[2], Z = arguments[3], ee = arguments[4] || 0);
      const Xt = C.isCompressedTexture ? C.mipmaps[ee] : C.image;
      J !== null ? (ge = J.max.x - J.min.x, Ae = J.max.y - J.min.y, Ie = J.max.z - J.min.z, Pe = J.min.x, Oe = J.min.y, We = J.min.z) : (ge = Xt.width, Ae = Xt.height, Ie = Xt.depth, Pe = 0, Oe = 0, We = 0), oe !== null ? (De = oe.x, tt = oe.y, St = oe.z) : (De = 0, tt = 0, St = 0);
      const Kt = Le.convert(Z.format), Tt = Le.convert(Z.type);
      let ot;
      if (Z.isData3DTexture)
        V.setTexture3D(Z, 0), ot = G.TEXTURE_3D;
      else {
        if (!Z.isDataArrayTexture && !Z.isCompressedArrayTexture)
          return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        V.setTexture2DArray(Z, 0), ot = G.TEXTURE_2D_ARRAY;
      }
      G.pixelStorei(G.UNPACK_FLIP_Y_WEBGL, Z.flipY), G.pixelStorei(G.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Z.premultiplyAlpha), G.pixelStorei(G.UNPACK_ALIGNMENT, Z.unpackAlignment);
      const Ot = G.getParameter(G.UNPACK_ROW_LENGTH), Yn = G.getParameter(G.UNPACK_IMAGE_HEIGHT), Ke = G.getParameter(G.UNPACK_SKIP_PIXELS), Xe = G.getParameter(G.UNPACK_SKIP_ROWS), ql = G.getParameter(G.UNPACK_SKIP_IMAGES);
      G.pixelStorei(G.UNPACK_ROW_LENGTH, Xt.width), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, Xt.height), G.pixelStorei(G.UNPACK_SKIP_PIXELS, Pe), G.pixelStorei(G.UNPACK_SKIP_ROWS, Oe), G.pixelStorei(G.UNPACK_SKIP_IMAGES, We), C.isDataTexture || C.isData3DTexture ? G.texSubImage3D(ot, ee, De, tt, St, ge, Ae, Ie, Kt, Tt, Xt.data) : Z.isCompressedArrayTexture ? G.compressedTexSubImage3D(ot, ee, De, tt, St, ge, Ae, Ie, Kt, Xt.data) : G.texSubImage3D(ot, ee, De, tt, St, ge, Ae, Ie, Kt, Tt, Xt), G.pixelStorei(G.UNPACK_ROW_LENGTH, Ot), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, Yn), G.pixelStorei(G.UNPACK_SKIP_PIXELS, Ke), G.pixelStorei(G.UNPACK_SKIP_ROWS, Xe), G.pixelStorei(G.UNPACK_SKIP_IMAGES, ql), ee === 0 && Z.generateMipmaps && G.generateMipmap(ot), U.unbindTexture();
    }, this.initRenderTarget = function(C) {
      ne.get(C).__webglFramebuffer === void 0 && V.setupRenderTarget(C);
    }, this.initTexture = function(C) {
      C.isCubeTexture ? V.setTextureCube(C, 0) : C.isData3DTexture ? V.setTexture3D(C, 0) : C.isDataArrayTexture || C.isCompressedArrayTexture ? V.setTexture2DArray(C, 0) : V.setTexture2D(C, 0), U.unbindTexture();
    }, this.resetState = function() {
      x = 0, M = 0, b = null, U.reset(), mn.reset();
    }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return za;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(i) {
    this._outputColorSpace = i;
    const e = this.getContext();
    e.drawingBufferColorSpace = i === op ? "display-p3" : "srgb", e.unpackColorSpace = rt.workingColorSpace === Jc ? "display-p3" : "srgb";
  }
}, WebGLUtils: y2, WebGPUCoordinateSystem: ih, WireframeGeometry: M1, WrapAroundEnding: Qc, ZeroCurvatureEnding: ga, ZeroFactor: ap, ZeroSlopeEnding: va, ZeroStencilOp: 0, createCanvasElement: Px }, Symbol.toStringTag, { value: "Module" }));
function Mr(i) {
  if (i === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function bw(i, e) {
  i.prototype = Object.create(e.prototype), i.prototype.constructor = i, i.__proto__ = e;
}
var N1, An, Mt, Et, rr, w0, O1, Mw, ww, Bo, fh, cc, gd, Nm, M3, w3, S3, hi = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, yl = { duration: 0.5, overwrite: !1, delay: 0 }, Nr = 1e8, Fn = 1e-8, S0 = 2 * Math.PI, r5 = S0 / 4, s5 = 0, Sw = Math.sqrt, a5 = Math.cos, o5 = Math.sin, fn = function(i) {
  return typeof i == "string";
}, Nt = function(i) {
  return typeof i == "function";
}, zr = function(i) {
  return typeof i == "number";
}, U1 = function(i) {
  return i === void 0;
}, pr = function(i) {
  return typeof i == "object";
}, jn = function(i) {
  return i !== !1;
}, k1 = function() {
  return typeof window != "undefined";
}, vd = function(i) {
  return Nt(i) || fn(i);
}, Tw = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, Tn = Array.isArray, T0 = /(?:-?\.?\d|\.)+/gi, Ew = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, zo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Om = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Aw = /[+-]=-?[.\d]+/, Iw = /[^,'"\[\]\s]+/gi, l5 = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, li = {}, gp = {}, Cw = function(i) {
  return (gp = ja(i, li)) && Xn;
}, F1 = function(i, e) {
  return console.warn("Invalid property", i, "set to", e, "Missing plugin? gsap.registerPlugin()");
}, mh = function(i, e) {
  return !e && console.warn(i);
}, Rw = function(i, e) {
  return i && (li[i] = e) && gp && (gp[i] = e) || li;
}, gh = function() {
  return 0;
}, c5 = { suppressEvents: !0, isStart: !0, kill: !1 }, Zd = { suppressEvents: !0, kill: !1 }, h5 = { suppressEvents: !0 }, B1 = {}, ms = [], E0 = {}, $n = {}, Um = {}, T3 = 30, Kd = [], z1 = "", H1 = function(i) {
  var e, t, n = i[0];
  if (pr(n) || Nt(n) || (i = [i]), !(e = (n._gsap || {}).harness)) {
    for (t = Kd.length; t-- && !Kd[t].targetTest(n); )
      ;
    e = Kd[t];
  }
  for (t = i.length; t--; )
    i[t] && (i[t]._gsap || (i[t]._gsap = new Qw(i[t], e))) || i.splice(t, 1);
  return i;
}, Aa = function(i) {
  return i._gsap || H1(wi(i))[0]._gsap;
}, Pw = function(i, e, t) {
  return (t = i[e]) && Nt(t) ? i[e]() : U1(t) && i.getAttribute && i.getAttribute(e) || t;
}, Vn = function(i, e) {
  return (i = i.split(",")).forEach(e) || i;
}, Ht = function(i) {
  return Math.round(1e5 * i) / 1e5 || 0;
}, pn = function(i) {
  return Math.round(1e7 * i) / 1e7 || 0;
}, Jo = function(i, e) {
  var t = e.charAt(0), n = parseFloat(e.substr(2));
  return i = parseFloat(i), t === "+" ? i + n : t === "-" ? i - n : t === "*" ? i * n : i / n;
}, u5 = function(i, e) {
  for (var t = e.length, n = 0; i.indexOf(e[n]) < 0 && ++n < t; )
    ;
  return n < t;
}, vp = function() {
  var i, e, t = ms.length, n = ms.slice(0);
  for (E0 = {}, ms.length = 0, i = 0; i < t; i++)
    (e = n[i]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
}, Lw = function(i, e, t, n) {
  ms.length && !An && vp(), i.render(e, t, An && e < 0 && (i._initted || i._startAt)), ms.length && !An && vp();
}, Dw = function(i) {
  var e = parseFloat(i);
  return (e || e === 0) && (i + "").match(Iw).length < 2 ? e : fn(i) ? i.trim() : i;
}, Nw = function(i) {
  return i;
}, Ti = function(i, e) {
  for (var t in e)
    t in i || (i[t] = e[t]);
  return i;
}, ja = function(i, e) {
  for (var t in e)
    i[t] = e[t];
  return i;
}, E3 = function i(e, t) {
  for (var n in t)
    n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = pr(t[n]) ? i(e[n] || (e[n] = {}), t[n]) : t[n]);
  return e;
}, yp = function(i, e) {
  var t, n = {};
  for (t in i)
    t in e || (n[t] = i[t]);
  return n;
}, zc = function(i) {
  var e, t = i.parent || Et, n = i.keyframes ? (e = Tn(i.keyframes), function(r, s) {
    for (var a in s)
      a in r || a === "duration" && e || a === "ease" || (r[a] = s[a]);
  }) : Ti;
  if (jn(i.inherit))
    for (; t; )
      n(i, t.vars.defaults), t = t.parent || t._dp;
  return i;
}, Ow = function(i, e, t, n, r) {
  var s, a = i[n];
  if (r)
    for (s = e[r]; a && a[r] > s; )
      a = a._prev;
  return a ? (e._next = a._next, a._next = e) : (e._next = i[t], i[t] = e), e._next ? e._next._prev = e : i[n] = e, e._prev = a, e.parent = e._dp = i, e;
}, hf = function(i, e, t, n) {
  t === void 0 && (t = "_first"), n === void 0 && (n = "_last");
  var r = e._prev, s = e._next;
  r ? r._next = s : i[t] === e && (i[t] = s), s ? s._prev = r : i[n] === e && (i[n] = r), e._next = e._prev = e.parent = null;
}, ws = function(i, e) {
  i.parent && (!e || i.parent.autoRemoveChildren) && i.parent.remove && i.parent.remove(i), i._act = 0;
}, Ia = function(i, e) {
  if (i && (!e || e._end > i._dur || e._start < 0))
    for (var t = i; t; )
      t._dirty = 1, t = t.parent;
  return i;
}, km = function(i, e, t, n) {
  return i._startAt && (An ? i._startAt.revert(Zd) : i.vars.immediateRender && !i.vars.autoRevert || i._startAt.render(e, !0, n));
}, d5 = function i(e) {
  return !e || e._ts && i(e.parent);
}, A3 = function(i) {
  return i._repeat ? $o(i._tTime, i = i.duration() + i._rDelay) * i : 0;
}, $o = function(i, e) {
  var t = Math.floor(i /= e);
  return i && t === i ? t - 1 : t;
}, _p = function(i, e) {
  return (i - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur);
}, uf = function(i) {
  return i._end = pn(i._start + (i._tDur / Math.abs(i._ts || i._rts || Fn) || 0));
}, df = function(i, e) {
  var t = i._dp;
  return t && t.smoothChildTiming && i._ts && (i._start = pn(t._time - (i._ts > 0 ? e / i._ts : ((i._dirty ? i.totalDuration() : i._tDur) - e) / -i._ts)), uf(i), t._dirty || Ia(t, i)), i;
}, Uw = function(i, e) {
  var t;
  if ((e._time || !e._dur && e._initted || e._start < i._time && (e._dur || !e.add)) && (t = _p(i.rawTime(), e), (!e._dur || Vh(0, e.totalDuration(), t) - e._tTime > Fn) && e.render(t, !0)), Ia(i, e)._dp && i._initted && i._time >= i._dur && i._ts) {
    if (i._dur < i.duration())
      for (t = i; t._dp; )
        t.rawTime() >= 0 && t.totalTime(t._tTime), t = t._dp;
    i._zTime = -1e-8;
  }
}, sr = function(i, e, t, n) {
  return e.parent && ws(e), e._start = pn((zr(t) ? t : t || i !== Et ? mi(i, t, e) : i._time) + e._delay), e._end = pn(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), Ow(i, e, "_first", "_last", i._sort ? "_start" : 0), A0(e) || (i._recent = e), n || Uw(i, e), i._ts < 0 && df(i, i._tTime), i;
}, kw = function(i, e) {
  return (li.ScrollTrigger || F1("scrollTrigger", e)) && li.ScrollTrigger.create(e, i);
}, I3 = function(i, e, t, n, r) {
  return L0(i, e, r), i._initted ? !t && i._pt && !An && (i._dur && i.vars.lazy !== !1 || !i._dur && i.vars.lazy) && ww !== ii.frame ? (ms.push(i), i._lazy = [r, n], 1) : void 0 : 1;
}, p5 = function i(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || i(t));
}, A0 = function(i) {
  var e = i.data;
  return e === "isFromStart" || e === "isStart";
}, _l = function(i, e, t, n) {
  var r = i._repeat, s = pn(e) || 0, a = i._tTime / i._tDur;
  return a && !n && (i._time *= s / i._dur), i._dur = s, i._tDur = r ? r < 0 ? 1e10 : pn(s * (r + 1) + i._rDelay * r) : s, a > 0 && !n && df(i, i._tTime = i._tDur * a), i.parent && uf(i), t || Ia(i.parent, i), i;
}, C3 = function(i) {
  return i instanceof Un ? Ia(i) : _l(i, i._dur);
}, f5 = { _start: 0, endTime: gh, totalDuration: gh }, mi = function i(e, t, n) {
  var r, s, a, o = e.labels, l = e._recent || f5, c = e.duration() >= Nr ? l.endTime(!1) : e._dur;
  return fn(t) && (isNaN(t) || t in o) ? (s = t.charAt(0), a = t.substr(-1) === "%", r = t.indexOf("="), s === "<" || s === ">" ? (r >= 0 && (t = t.replace(/=/, "")), (s === "<" ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (a ? (r < 0 ? l : n).totalDuration() / 100 : 1)) : r < 0 ? (t in o || (o[t] = c), o[t]) : (s = parseFloat(t.charAt(r - 1) + t.substr(r + 1)), a && n && (s = s / 100 * (Tn(n) ? n[0] : n).totalDuration()), r > 1 ? i(e, t.substr(0, r - 1), n) + s : c + s)) : t == null ? c : +t;
}, Hc = function(i, e, t) {
  var n, r, s = zr(e[1]), a = (s ? 2 : 1) + (i < 2 ? 0 : 1), o = e[a];
  if (s && (o.duration = e[1]), o.parent = t, i) {
    for (n = o, r = t; r && !("immediateRender" in n); )
      n = r.vars.defaults || {}, r = jn(r.vars.inherit) && r.parent;
    o.immediateRender = jn(n.immediateRender), i < 2 ? o.runBackwards = 1 : o.startAt = e[a - 1];
  }
  return new Zt(e[0], o, e[a + 1]);
}, as = function(i, e) {
  return i || i === 0 ? e(i) : e;
}, Vh = function(i, e, t) {
  return t < i ? i : t > e ? e : t;
}, En = function(i, e) {
  return fn(i) && (e = l5.exec(i)) ? e[1] : "";
}, I0 = [].slice, Fw = function(i, e) {
  return i && pr(i) && "length" in i && (!e && !i.length || i.length - 1 in i && pr(i[0])) && !i.nodeType && i !== rr;
}, m5 = function(i, e, t) {
  return t === void 0 && (t = []), i.forEach(function(n) {
    var r;
    return fn(n) && !e || Fw(n, 1) ? (r = t).push.apply(r, wi(n)) : t.push(n);
  }) || t;
}, wi = function(i, e, t) {
  return Mt && !e && Mt.selector ? Mt.selector(i) : !fn(i) || t || !w0 && xl() ? Tn(i) ? m5(i, t) : Fw(i) ? I0.call(i, 0) : i ? [i] : [] : I0.call((e || O1).querySelectorAll(i), 0);
}, C0 = function(i) {
  return i = wi(i)[0] || mh("Invalid scope") || {}, function(e) {
    var t = i.current || i.nativeElement || i;
    return wi(e, t.querySelectorAll ? t : t === i ? mh("Invalid scope") || O1.createElement("div") : i);
  };
}, Bw = function(i) {
  return i.sort(function() {
    return 0.5 - Math.random();
  });
}, zw = function(i) {
  if (Nt(i))
    return i;
  var e = pr(i) ? i : { each: i }, t = Ca(e.ease), n = e.from || 0, r = parseFloat(e.base) || 0, s = {}, a = n > 0 && n < 1, o = isNaN(n) || a, l = e.axis, c = n, h = n;
  return fn(n) ? c = h = { center: 0.5, edges: 0.5, end: 1 }[n] || 0 : !a && o && (c = n[0], h = n[1]), function(u, d, p) {
    var f, v, m, y, g, _, x, M, b, w = (p || e).length, T = s[w];
    if (!T) {
      if (!(b = e.grid === "auto" ? 0 : (e.grid || [1, Nr])[1])) {
        for (x = -1e8; x < (x = p[b++].getBoundingClientRect().left) && b < w; )
          ;
        b < w && b--;
      }
      for (T = s[w] = [], f = o ? Math.min(b, w) * c - 0.5 : n % b, v = b === Nr ? 0 : o ? w * h / b - 0.5 : n / b | 0, x = 0, M = Nr, _ = 0; _ < w; _++)
        m = _ % b - f, y = v - (_ / b | 0), T[_] = g = l ? Math.abs(l === "y" ? y : m) : Sw(m * m + y * y), g > x && (x = g), g < M && (M = g);
      n === "random" && Bw(T), T.max = x - M, T.min = M, T.v = w = (parseFloat(e.amount) || parseFloat(e.each) * (b > w ? w - 1 : l ? l === "y" ? w / b : b : Math.max(b, w / b)) || 0) * (n === "edges" ? -1 : 1), T.b = w < 0 ? r - w : r, T.u = En(e.amount || e.each) || 0, t = t && w < 0 ? Yw(t) : t;
    }
    return w = (T[u] - T.min) / T.max || 0, pn(T.b + (t ? t(w) : w) * T.v) + T.u;
  };
}, R0 = function(i) {
  var e = Math.pow(10, ((i + "").split(".")[1] || "").length);
  return function(t) {
    var n = pn(Math.round(parseFloat(t) / i) * i * e);
    return (n - n % 1) / e + (zr(t) ? 0 : En(t));
  };
}, Hw = function(i, e) {
  var t, n, r = Tn(i);
  return !r && pr(i) && (t = r = i.radius || Nr, i.values ? (i = wi(i.values), (n = !zr(i[0])) && (t *= t)) : i = R0(i.increment)), as(e, r ? Nt(i) ? function(s) {
    return n = i(s), Math.abs(n - s) <= t ? n : s;
  } : function(s) {
    for (var a, o, l = parseFloat(n ? s.x : s), c = parseFloat(n ? s.y : 0), h = Nr, u = 0, d = i.length; d--; )
      (a = n ? (a = i[d].x - l) * a + (o = i[d].y - c) * o : Math.abs(i[d] - l)) < h && (h = a, u = d);
    return u = !t || h <= t ? i[u] : s, n || u === s || zr(s) ? u : u + En(s);
  } : R0(i));
}, Gw = function(i, e, t, n) {
  return as(Tn(i) ? !e : t === !0 ? !!(t = 0) : !n, function() {
    return Tn(i) ? i[~~(Math.random() * i.length)] : (t = t || 1e-5) && (n = t < 1 ? Math.pow(10, (t + "").length - 2) : 1) && Math.floor(Math.round((i - t / 2 + Math.random() * (e - i + 0.99 * t)) / t) * t * n) / n;
  });
}, R3 = function(i, e, t) {
  return as(t, function(n) {
    return i[~~e(n)];
  });
}, vh = function(i) {
  for (var e, t, n, r, s = 0, a = ""; ~(e = i.indexOf("random(", s)); )
    n = i.indexOf(")", e), r = i.charAt(e + 7) === "[", t = i.substr(e + 7, n - e - 7).match(r ? Iw : T0), a += i.substr(s, e - s) + Gw(r ? t : +t[0], r ? 0 : +t[1], +t[2] || 1e-5), s = n + 1;
  return a + i.substr(s, i.length - s);
}, P3 = function(i, e, t, n, r) {
  var s = e - i, a = n - t;
  return as(r, function(o) {
    return t + ((o - i) / s * a || 0);
  });
}, L3 = function(i, e, t) {
  var n, r, s, a = i.labels, o = Nr;
  for (n in a)
    (r = a[n] - e) < 0 == !!t && r && o > (r = Math.abs(r)) && (s = n, o = r);
  return s;
}, ei = function(i, e, t) {
  var n, r, s, a = i.vars, o = a[e], l = Mt, c = i._ctx;
  if (o)
    return n = a[e + "Params"], r = a.callbackScope || i, t && ms.length && vp(), c && (Mt = c), s = n ? o.apply(r, n) : o.call(r), Mt = l, s;
}, Ac = function(i) {
  return ws(i), i.scrollTrigger && i.scrollTrigger.kill(!!An), i.progress() < 1 && ei(i, "onInterrupt"), i;
}, Vw = [], jw = function(i) {
  if (i)
    if (i = !i.name && i.default || i, k1() || i.headless) {
      var e = i.name, t = Nt(i), n = e && !t && i.init ? function() {
        this._props = [];
      } : i, r = { init: gh, render: D0, add: G1, kill: E5, modifier: T5, rawVars: 0 }, s = { targetTest: 0, get: 0, getSetter: j1, aliases: {}, register: 0 };
      if (xl(), i !== n) {
        if ($n[e])
          return;
        Ti(n, Ti(yp(i, r), s)), ja(n.prototype, ja(r, yp(i, s))), $n[n.prop = e] = n, i.targetTest && (Kd.push(n), B1[e] = 1), e = (e === "css" ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin";
      }
      Rw(e, n), i.register && i.register(Xn, n, Wn);
    } else
      Vw.push(i);
}, gt = 255, Ic = { aqua: [0, gt, gt], lime: [0, gt, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, gt], navy: [0, 0, 128], white: [gt, gt, gt], olive: [128, 128, 0], yellow: [gt, gt, 0], orange: [gt, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [gt, 0, 0], pink: [gt, 192, 203], cyan: [0, gt, gt], transparent: [gt, gt, gt, 0] }, Fm = function(i, e, t) {
  return (6 * (i += i < 0 ? 1 : i > 1 ? -1 : 0) < 1 ? e + (t - e) * i * 6 : i < 0.5 ? t : 3 * i < 2 ? e + (t - e) * (2 / 3 - i) * 6 : e) * gt + 0.5 | 0;
}, Ww = function(i, e, t) {
  var n, r, s, a, o, l, c, h, u, d, p = i ? zr(i) ? [i >> 16, i >> 8 & gt, i & gt] : 0 : Ic.black;
  if (!p) {
    if (i.substr(-1) === "," && (i = i.substr(0, i.length - 1)), Ic[i])
      p = Ic[i];
    else if (i.charAt(0) === "#") {
      if (i.length < 6 && (n = i.charAt(1), r = i.charAt(2), s = i.charAt(3), i = "#" + n + n + r + r + s + s + (i.length === 5 ? i.charAt(4) + i.charAt(4) : "")), i.length === 9)
        return [(p = parseInt(i.substr(1, 6), 16)) >> 16, p >> 8 & gt, p & gt, parseInt(i.substr(7), 16) / 255];
      p = [(i = parseInt(i.substr(1), 16)) >> 16, i >> 8 & gt, i & gt];
    } else if (i.substr(0, 3) === "hsl")
      if (p = d = i.match(T0), e) {
        if (~i.indexOf("="))
          return p = i.match(Ew), t && p.length < 4 && (p[3] = 1), p;
      } else
        a = +p[0] % 360 / 360, o = +p[1] / 100, n = 2 * (l = +p[2] / 100) - (r = l <= 0.5 ? l * (o + 1) : l + o - l * o), p.length > 3 && (p[3] *= 1), p[0] = Fm(a + 1 / 3, n, r), p[1] = Fm(a, n, r), p[2] = Fm(a - 1 / 3, n, r);
    else
      p = i.match(T0) || Ic.transparent;
    p = p.map(Number);
  }
  return e && !d && (n = p[0] / gt, r = p[1] / gt, s = p[2] / gt, l = ((c = Math.max(n, r, s)) + (h = Math.min(n, r, s))) / 2, c === h ? a = o = 0 : (u = c - h, o = l > 0.5 ? u / (2 - c - h) : u / (c + h), a = c === n ? (r - s) / u + (r < s ? 6 : 0) : c === r ? (s - n) / u + 2 : (n - r) / u + 4, a *= 60), p[0] = ~~(a + 0.5), p[1] = ~~(100 * o + 0.5), p[2] = ~~(100 * l + 0.5)), t && p.length < 4 && (p[3] = 1), p;
}, Xw = function(i) {
  var e = [], t = [], n = -1;
  return i.split(gs).forEach(function(r) {
    var s = r.match(zo) || [];
    e.push.apply(e, s), t.push(n += s.length + 1);
  }), e.c = t, e;
}, D3 = function(i, e, t) {
  var n, r, s, a, o = "", l = (i + o).match(gs), c = e ? "hsla(" : "rgba(", h = 0;
  if (!l)
    return i;
  if (l = l.map(function(u) {
    return (u = Ww(u, e, 1)) && c + (e ? u[0] + "," + u[1] + "%," + u[2] + "%," + u[3] : u.join(",")) + ")";
  }), t && (s = Xw(i), (n = t.c).join(o) !== s.c.join(o)))
    for (a = (r = i.replace(gs, "1").split(zo)).length - 1; h < a; h++)
      o += r[h] + (~n.indexOf(h) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : t).shift());
  if (!r)
    for (a = (r = i.split(gs)).length - 1; h < a; h++)
      o += r[h] + l[h];
  return o + r[a];
}, gs = function() {
  var i, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
  for (i in Ic)
    e += "|" + i + "\\b";
  return new RegExp(e + ")", "gi");
}(), g5 = /hsl[a]?\(/, qw = function(i) {
  var e, t = i.join(" ");
  if (gs.lastIndex = 0, gs.test(t))
    return e = g5.test(t), i[1] = D3(i[1], e), i[0] = D3(i[0], e, Xw(i[1])), !0;
}, ii = function() {
  var i, e, t, n, r, s, a = Date.now, o = 500, l = 33, c = a(), h = c, u = 1e3 / 240, d = u, p = [], f = function v(m) {
    var y, g, _, x, M = a() - h, b = m === !0;
    if ((M > o || M < 0) && (c += M - l), ((y = (_ = (h += M) - c) - d) > 0 || b) && (x = ++n.frame, r = _ - 1e3 * n.time, n.time = _ /= 1e3, d += y + (y >= u ? 4 : u - y), g = 1), b || (i = e(v)), g)
      for (s = 0; s < p.length; s++)
        p[s](_, r, x, m);
  };
  return n = { time: 0, frame: 0, tick: function() {
    f(!0);
  }, deltaRatio: function(v) {
    return r / (1e3 / (v || 60));
  }, wake: function() {
    Mw && (!w0 && k1() && (rr = w0 = window, O1 = rr.document || {}, li.gsap = Xn, (rr.gsapVersions || (rr.gsapVersions = [])).push(Xn.version), Cw(gp || rr.GreenSockGlobals || !rr.gsap && rr || {}), Vw.forEach(jw)), t = typeof requestAnimationFrame != "undefined" && requestAnimationFrame, i && n.sleep(), e = t || function(v) {
      return setTimeout(v, d - 1e3 * n.time + 1 | 0);
    }, fh = 1, f(2));
  }, sleep: function() {
    (t ? cancelAnimationFrame : clearTimeout)(i), fh = 0, e = gh;
  }, lagSmoothing: function(v, m) {
    o = v || 1 / 0, l = Math.min(m || 33, o);
  }, fps: function(v) {
    u = 1e3 / (v || 240), d = 1e3 * n.time + u;
  }, add: function(v, m, y) {
    var g = m ? function(_, x, M, b) {
      v(_, x, M, b), n.remove(g);
    } : v;
    return n.remove(v), p[y ? "unshift" : "push"](g), xl(), g;
  }, remove: function(v, m) {
    ~(m = p.indexOf(v)) && p.splice(m, 1) && s >= m && s--;
  }, _listeners: p }, n;
}(), xl = function() {
  return !fh && ii.wake();
}, nt = {}, v5 = /^[\d.\-M][\d.\-,\s]/, y5 = /["']/g, _5 = function(i) {
  for (var e, t, n, r = {}, s = i.substr(1, i.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++)
    t = s[o], e = o !== l - 1 ? t.lastIndexOf(",") : t.length, n = t.substr(0, e), r[a] = isNaN(n) ? n.replace(y5, "").trim() : +n, a = t.substr(e + 1).trim();
  return r;
}, Yw = function(i) {
  return function(e) {
    return 1 - i(1 - e);
  };
}, Zw = function i(e, t) {
  for (var n, r = e._first; r; )
    r instanceof Un ? i(r, t) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === t || (r.timeline ? i(r.timeline, t) : (n = r._ease, r._ease = r._yEase, r._yEase = n, r._yoyo = t)), r = r._next;
}, Ca = function(i, e) {
  return i && (Nt(i) ? i : nt[i] || function(t) {
    var n, r, s, a, o = (t + "").split("("), l = nt[o[0]];
    return l && o.length > 1 && l.config ? l.config.apply(null, ~t.indexOf("{") ? [_5(o[1])] : (n = t, r = n.indexOf("(") + 1, s = n.indexOf(")"), a = n.indexOf("(", r), n.substring(r, ~a && a < s ? n.indexOf(")", s + 1) : s)).split(",").map(Dw)) : nt._CE && v5.test(t) ? nt._CE("", t) : l;
  }(i)) || e;
}, Ks = function(i, e, t, n) {
  t === void 0 && (t = function(a) {
    return 1 - e(1 - a);
  }), n === void 0 && (n = function(a) {
    return a < 0.5 ? e(2 * a) / 2 : 1 - e(2 * (1 - a)) / 2;
  });
  var r, s = { easeIn: e, easeOut: t, easeInOut: n };
  return Vn(i, function(a) {
    for (var o in nt[a] = li[a] = s, nt[r = a.toLowerCase()] = t, s)
      nt[r + (o === "easeIn" ? ".in" : o === "easeOut" ? ".out" : ".inOut")] = nt[a + "." + o] = s[o];
  }), s;
}, Kw = function(i) {
  return function(e) {
    return e < 0.5 ? (1 - i(1 - 2 * e)) / 2 : 0.5 + i(2 * (e - 0.5)) / 2;
  };
}, Bm = function i(e, t, n) {
  var r = t >= 1 ? t : 1, s = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), a = s / S0 * (Math.asin(1 / r) || 0), o = function(c) {
    return c === 1 ? 1 : r * Math.pow(2, -10 * c) * o5((c - a) * s) + 1;
  }, l = e === "out" ? o : e === "in" ? function(c) {
    return 1 - o(1 - c);
  } : Kw(o);
  return s = S0 / s, l.config = function(c, h) {
    return i(e, c, h);
  }, l;
}, zm = function i(e, t) {
  t === void 0 && (t = 1.70158);
  var n = function(s) {
    return s ? --s * s * ((t + 1) * s + t) + 1 : 0;
  }, r = e === "out" ? n : e === "in" ? function(s) {
    return 1 - n(1 - s);
  } : Kw(n);
  return r.config = function(s) {
    return i(e, s);
  }, r;
};
Vn("Linear,Quad,Cubic,Quart,Quint,Strong", function(i, e) {
  var t = e < 5 ? e + 1 : e;
  Ks(i + ",Power" + (t - 1), e ? function(n) {
    return Math.pow(n, t);
  } : function(n) {
    return n;
  }, function(n) {
    return 1 - Math.pow(1 - n, t);
  }, function(n) {
    return n < 0.5 ? Math.pow(2 * n, t) / 2 : 1 - Math.pow(2 * (1 - n), t) / 2;
  });
}), nt.Linear.easeNone = nt.none = nt.Linear.easeIn, Ks("Elastic", Bm("in"), Bm("out"), Bm()), cc = 7.5625, M3 = 2 * (Nm = 1 / (gd = 2.75)), w3 = 2.5 * Nm, Ks("Bounce", function(i) {
  return 1 - S3(1 - i);
}, S3 = function(i) {
  return i < Nm ? cc * i * i : i < M3 ? cc * Math.pow(i - 1.5 / gd, 2) + 0.75 : i < w3 ? cc * (i -= 2.25 / gd) * i + 0.9375 : cc * Math.pow(i - 2.625 / gd, 2) + 0.984375;
}), Ks("Expo", function(i) {
  return i ? Math.pow(2, 10 * (i - 1)) : 0;
}), Ks("Circ", function(i) {
  return -(Sw(1 - i * i) - 1);
}), Ks("Sine", function(i) {
  return i === 1 ? 1 : 1 - a5(i * r5);
}), Ks("Back", zm("in"), zm("out"), zm()), nt.SteppedEase = nt.steps = li.SteppedEase = { config: function(i, e) {
  i === void 0 && (i = 1);
  var t = 1 / i, n = i + (e ? 0 : 1), r = e ? 1 : 0;
  return function(s) {
    return ((n * Vh(0, 0.99999999, s) | 0) + r) * t;
  };
} }, yl.ease = nt["quad.out"], Vn("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(i) {
  return z1 += i + "," + i + "Params,";
});
var Qw = function(i, e) {
  this.id = s5++, i._gsap = this, this.target = i, this.harness = e, this.get = e ? e.get : Pw, this.set = e ? e.getSetter : j1;
}, yh = function() {
  function i(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, _l(this, +t.duration, 1, 1), this.data = t.data, Mt && (this._ctx = Mt, Mt.data.push(this)), fh || ii.wake();
  }
  var e = i.prototype;
  return e.delay = function(t) {
    return t || t === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay;
  }, e.duration = function(t) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(t) {
    return arguments.length ? (this._dirty = 0, _l(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(t, n) {
    if (xl(), !arguments.length)
      return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (df(this, t), !r._dp || r.parent || Uw(r, this); r && r.parent; )
        r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && sr(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== t || !this._dur && !n || this._initted && Math.abs(this._zTime) === Fn || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), Lw(this, t, n)), this;
  }, e.time = function(t, n) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + A3(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), n) : this._time;
  }, e.totalProgress = function(t, n) {
    return arguments.length ? this.totalTime(this.totalDuration() * t, n) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  }, e.progress = function(t, n) {
    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + A3(this), n) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(t, n) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (t - 1) * r, n) : this._repeat ? $o(this._tTime, r) + 1 : 1;
  }, e.timeScale = function(t, n) {
    if (!arguments.length)
      return this._rts === -1e-8 ? 0 : this._rts;
    if (this._rts === t)
      return this;
    var r = this.parent && this._ts ? _p(this.parent._time, this) : this._tTime;
    return this._rts = +t || 0, this._ts = this._ps || t === -1e-8 ? 0 : this._rts, this.totalTime(Vh(-Math.abs(this._delay), this._tDur, r), n !== !1), uf(this), function(s) {
      for (var a = s.parent; a && a.parent; )
        a._dirty = 1, a.totalDuration(), a = a.parent;
      return s;
    }(this);
  }, e.paused = function(t) {
    return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (xl(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Fn && (this._tTime -= Fn)))), this) : this._ps;
  }, e.startTime = function(t) {
    if (arguments.length) {
      this._start = t;
      var n = this.parent || this._dp;
      return n && (n._sort || !this.parent) && sr(n, this, t - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(t) {
    return this._start + (jn(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(t) {
    var n = this.parent || this._dp;
    return n ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? _p(n.rawTime(t), this) : this._tTime : this._tTime;
  }, e.revert = function(t) {
    t === void 0 && (t = h5);
    var n = An;
    return An = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-0.01, t.suppressEvents)), this.data !== "nested" && t.kill !== !1 && this.kill(), An = n, this;
  }, e.globalTime = function(t) {
    for (var n = this, r = arguments.length ? t : n.rawTime(); n; )
      r = n._start + r / (Math.abs(n._ts) || 1), n = n._dp;
    return !this.parent && this._sat ? this._sat.globalTime(t) : r;
  }, e.repeat = function(t) {
    return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, C3(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(t) {
    if (arguments.length) {
      var n = this._time;
      return this._rDelay = t, C3(this), n ? this.time(n) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(t) {
    return arguments.length ? (this._yoyo = t, this) : this._yoyo;
  }, e.seek = function(t, n) {
    return this.totalTime(mi(this, t), jn(n));
  }, e.restart = function(t, n) {
    return this.play().totalTime(t ? -this._delay : 0, jn(n));
  }, e.play = function(t, n) {
    return t != null && this.seek(t, n), this.reversed(!1).paused(!1);
  }, e.reverse = function(t, n) {
    return t != null && this.seek(t || this.totalDuration(), n), this.reversed(!0).paused(!1);
  }, e.pause = function(t, n) {
    return t != null && this.seek(t, n), this.paused(!0);
  }, e.resume = function() {
    return this.paused(!1);
  }, e.reversed = function(t) {
    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -1e-8, this;
  }, e.isActive = function() {
    var t, n = this.parent || this._dp, r = this._start;
    return !(n && !(this._ts && this._initted && n.isActive() && (t = n.rawTime(!0)) >= r && t < this.endTime(!0) - Fn));
  }, e.eventCallback = function(t, n, r) {
    var s = this.vars;
    return arguments.length > 1 ? (n ? (s[t] = n, r && (s[t + "Params"] = r), t === "onUpdate" && (this._onUpdate = n)) : delete s[t], this) : s[t];
  }, e.then = function(t) {
    var n = this;
    return new Promise(function(r) {
      var s = Nt(t) ? t : Nw, a = function() {
        var o = n.then;
        n.then = null, Nt(s) && (s = s(n)) && (s.then || s === n) && (n.then = o), r(s), n.then = o;
      };
      n._initted && n.totalProgress() === 1 && n._ts >= 0 || !n._tTime && n._ts < 0 ? a() : n._prom = a;
    });
  }, e.kill = function() {
    Ac(this);
  }, i;
}();
Ti(yh.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: !1, _rts: 1 });
var Un = function(i) {
  function e(n, r) {
    var s;
    return n === void 0 && (n = {}), (s = i.call(this, n) || this).labels = {}, s.smoothChildTiming = !!n.smoothChildTiming, s.autoRemoveChildren = !!n.autoRemoveChildren, s._sort = jn(n.sortChildren), Et && sr(n.parent || Et, Mr(s), r), n.reversed && s.reverse(), n.paused && s.paused(!0), n.scrollTrigger && kw(Mr(s), n.scrollTrigger), s;
  }
  bw(e, i);
  var t = e.prototype;
  return t.to = function(n, r, s) {
    return Hc(0, arguments, this), this;
  }, t.from = function(n, r, s) {
    return Hc(1, arguments, this), this;
  }, t.fromTo = function(n, r, s, a) {
    return Hc(2, arguments, this), this;
  }, t.set = function(n, r, s) {
    return r.duration = 0, r.parent = this, zc(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new Zt(n, r, mi(this, s), 1), this;
  }, t.call = function(n, r, s) {
    return sr(this, Zt.delayedCall(0, n, r), s);
  }, t.staggerTo = function(n, r, s, a, o, l, c) {
    return s.duration = r, s.stagger = s.stagger || a, s.onComplete = l, s.onCompleteParams = c, s.parent = this, new Zt(n, s, mi(this, o)), this;
  }, t.staggerFrom = function(n, r, s, a, o, l, c) {
    return s.runBackwards = 1, zc(s).immediateRender = jn(s.immediateRender), this.staggerTo(n, r, s, a, o, l, c);
  }, t.staggerFromTo = function(n, r, s, a, o, l, c, h) {
    return a.startAt = s, zc(a).immediateRender = jn(a.immediateRender), this.staggerTo(n, r, a, o, l, c, h);
  }, t.render = function(n, r, s) {
    var a, o, l, c, h, u, d, p, f, v, m, y, g = this._time, _ = this._dirty ? this.totalDuration() : this._tDur, x = this._dur, M = n <= 0 ? 0 : pn(n), b = this._zTime < 0 != n < 0 && (this._initted || !x);
    if (this !== Et && M > _ && n >= 0 && (M = _), M !== this._tTime || s || b) {
      if (g !== this._time && x && (M += this._time - g, n += this._time - g), a = M, f = this._start, u = !(p = this._ts), b && (x || (g = this._zTime), (n || !r) && (this._zTime = n)), this._repeat) {
        if (m = this._yoyo, h = x + this._rDelay, this._repeat < -1 && n < 0)
          return this.totalTime(100 * h + n, r, s);
        if (a = pn(M % h), M === _ ? (c = this._repeat, a = x) : ((c = ~~(M / h)) && c === M / h && (a = x, c--), a > x && (a = x)), v = $o(this._tTime, h), !g && this._tTime && v !== c && this._tTime - v * h - this._dur <= 0 && (v = c), m && 1 & c && (a = x - a, y = 1), c !== v && !this._lock) {
          var w = m && 1 & v, T = w === (m && 1 & c);
          if (c < v && (w = !w), g = w ? 0 : M % x ? x : M, this._lock = 1, this.render(g || (y ? 0 : pn(c * h)), r, !x)._lock = 0, this._tTime = M, !r && this.parent && ei(this, "onRepeat"), this.vars.repeatRefresh && !y && (this.invalidate()._lock = 1), g && g !== this._time || u !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (x = this._dur, _ = this._tDur, T && (this._lock = 2, g = w ? x : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !y && this.invalidate()), this._lock = 0, !this._ts && !u)
            return this;
          Zw(this, y);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (d = function(L, I, P) {
        var N;
        if (P > I)
          for (N = L._first; N && N._start <= P; ) {
            if (N.data === "isPause" && N._start > I)
              return N;
            N = N._next;
          }
        else
          for (N = L._last; N && N._start >= P; ) {
            if (N.data === "isPause" && N._start < I)
              return N;
            N = N._prev;
          }
      }(this, pn(g), pn(a)), d && (M -= a - (a = d._start))), this._tTime = M, this._time = a, this._act = !p, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = n, g = 0), !g && a && !r && !c && (ei(this, "onStart"), this._tTime !== M))
        return this;
      if (a >= g && n >= 0)
        for (o = this._first; o; ) {
          if (l = o._next, (o._act || a >= o._start) && o._ts && d !== o) {
            if (o.parent !== this)
              return this.render(n, r, s);
            if (o.render(o._ts > 0 ? (a - o._start) * o._ts : (o._dirty ? o.totalDuration() : o._tDur) + (a - o._start) * o._ts, r, s), a !== this._time || !this._ts && !u) {
              d = 0, l && (M += this._zTime = -1e-8);
              break;
            }
          }
          o = l;
        }
      else {
        o = this._last;
        for (var A = n < 0 ? n : a; o; ) {
          if (l = o._prev, (o._act || A <= o._end) && o._ts && d !== o) {
            if (o.parent !== this)
              return this.render(n, r, s);
            if (o.render(o._ts > 0 ? (A - o._start) * o._ts : (o._dirty ? o.totalDuration() : o._tDur) + (A - o._start) * o._ts, r, s || An && (o._initted || o._startAt)), a !== this._time || !this._ts && !u) {
              d = 0, l && (M += this._zTime = A ? -1e-8 : Fn);
              break;
            }
          }
          o = l;
        }
      }
      if (d && !r && (this.pause(), d.render(a >= g ? 0 : -1e-8)._zTime = a >= g ? 1 : -1, this._ts))
        return this._start = f, uf(this), this.render(n, r, s);
      this._onUpdate && !r && ei(this, "onUpdate", !0), (M === _ && this._tTime >= this.totalDuration() || !M && g) && (f !== this._start && Math.abs(p) === Math.abs(this._ts) || this._lock || ((n || !x) && (M === _ && this._ts > 0 || !M && this._ts < 0) && ws(this, 1), r || n < 0 && !g || !M && !g && _ || (ei(this, M === _ && n >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(M < _ && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(n, r) {
    var s = this;
    if (zr(r) || (r = mi(this, r, n)), !(n instanceof yh)) {
      if (Tn(n))
        return n.forEach(function(a) {
          return s.add(a, r);
        }), this;
      if (fn(n))
        return this.addLabel(n, r);
      if (!Nt(n))
        return this;
      n = Zt.delayedCall(0, n);
    }
    return this !== n ? sr(this, n, r) : this;
  }, t.getChildren = function(n, r, s, a) {
    n === void 0 && (n = !0), r === void 0 && (r = !0), s === void 0 && (s = !0), a === void 0 && (a = -1e8);
    for (var o = [], l = this._first; l; )
      l._start >= a && (l instanceof Zt ? r && o.push(l) : (s && o.push(l), n && o.push.apply(o, l.getChildren(!0, r, s)))), l = l._next;
    return o;
  }, t.getById = function(n) {
    for (var r = this.getChildren(1, 1, 1), s = r.length; s--; )
      if (r[s].vars.id === n)
        return r[s];
  }, t.remove = function(n) {
    return fn(n) ? this.removeLabel(n) : Nt(n) ? this.killTweensOf(n) : (hf(this, n), n === this._recent && (this._recent = this._last), Ia(this));
  }, t.totalTime = function(n, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = pn(ii.time - (this._ts > 0 ? n / this._ts : (this.totalDuration() - n) / -this._ts))), i.prototype.totalTime.call(this, n, r), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(n, r) {
    return this.labels[n] = mi(this, r), this;
  }, t.removeLabel = function(n) {
    return delete this.labels[n], this;
  }, t.addPause = function(n, r, s) {
    var a = Zt.delayedCall(0, r || gh, s);
    return a.data = "isPause", this._hasPause = 1, sr(this, a, mi(this, n));
  }, t.removePause = function(n) {
    var r = this._first;
    for (n = mi(this, n); r; )
      r._start === n && r.data === "isPause" && ws(r), r = r._next;
  }, t.killTweensOf = function(n, r, s) {
    for (var a = this.getTweensOf(n, s), o = a.length; o--; )
      os !== a[o] && a[o].kill(n, r);
    return this;
  }, t.getTweensOf = function(n, r) {
    for (var s, a = [], o = wi(n), l = this._first, c = zr(r); l; )
      l instanceof Zt ? u5(l._targets, o) && (c ? (!os || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && a.push(l) : (s = l.getTweensOf(o, r)).length && a.push.apply(a, s), l = l._next;
    return a;
  }, t.tweenTo = function(n, r) {
    r = r || {};
    var s, a = this, o = mi(a, n), l = r, c = l.startAt, h = l.onStart, u = l.onStartParams, d = l.immediateRender, p = Zt.to(a, Ti({ ease: r.ease || "none", lazy: !1, immediateRender: !1, time: o, overwrite: "auto", duration: r.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale()) || Fn, onStart: function() {
      if (a.pause(), !s) {
        var f = r.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale());
        p._dur !== f && _l(p, f, 0, 1).render(p._time, !0, !0), s = 1;
      }
      h && h.apply(p, u || []);
    } }, r));
    return d ? p.render(0) : p;
  }, t.tweenFromTo = function(n, r, s) {
    return this.tweenTo(r, Ti({ startAt: { time: mi(this, n) } }, s));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(n) {
    return n === void 0 && (n = this._time), L3(this, mi(this, n));
  }, t.previousLabel = function(n) {
    return n === void 0 && (n = this._time), L3(this, mi(this, n), 1);
  }, t.currentLabel = function(n) {
    return arguments.length ? this.seek(n, !0) : this.previousLabel(this._time + Fn);
  }, t.shiftChildren = function(n, r, s) {
    s === void 0 && (s = 0);
    for (var a, o = this._first, l = this.labels; o; )
      o._start >= s && (o._start += n, o._end += n), o = o._next;
    if (r)
      for (a in l)
        l[a] >= s && (l[a] += n);
    return Ia(this);
  }, t.invalidate = function(n) {
    var r = this._first;
    for (this._lock = 0; r; )
      r.invalidate(n), r = r._next;
    return i.prototype.invalidate.call(this, n);
  }, t.clear = function(n) {
    n === void 0 && (n = !0);
    for (var r, s = this._first; s; )
      r = s._next, this.remove(s), s = r;
    return this._dp && (this._time = this._tTime = this._pTime = 0), n && (this.labels = {}), Ia(this);
  }, t.totalDuration = function(n) {
    var r, s, a, o = 0, l = this, c = l._last, h = Nr;
    if (arguments.length)
      return l.timeScale((l._repeat < 0 ? l.duration() : l.totalDuration()) / (l.reversed() ? -n : n));
    if (l._dirty) {
      for (a = l.parent; c; )
        r = c._prev, c._dirty && c.totalDuration(), (s = c._start) > h && l._sort && c._ts && !l._lock ? (l._lock = 1, sr(l, c, s - c._delay, 1)._lock = 0) : h = s, s < 0 && c._ts && (o -= s, (!a && !l._dp || a && a.smoothChildTiming) && (l._start += s / l._ts, l._time -= s, l._tTime -= s), l.shiftChildren(-s, !1, -1 / 0), h = 0), c._end > o && c._ts && (o = c._end), c = r;
      _l(l, l === Et && l._time > o ? l._time : o, 1, 1), l._dirty = 0;
    }
    return l._tDur;
  }, e.updateRoot = function(n) {
    if (Et._ts && (Lw(Et, _p(n, Et)), ww = ii.frame), ii.frame >= T3) {
      T3 += hi.autoSleep || 120;
      var r = Et._first;
      if ((!r || !r._ts) && hi.autoSleep && ii._listeners.length < 2) {
        for (; r && !r._ts; )
          r = r._next;
        r || ii.sleep();
      }
    }
  }, e;
}(yh);
Ti(Un.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var os, P0, x5 = function(i, e, t, n, r, s, a) {
  var o, l, c, h, u, d, p, f, v = new Wn(this._pt, i, e, 0, 1, iS, null, r), m = 0, y = 0;
  for (v.b = t, v.e = n, t += "", (p = ~(n += "").indexOf("random(")) && (n = vh(n)), s && (s(f = [t, n], i, e), t = f[0], n = f[1]), l = t.match(Om) || []; o = Om.exec(n); )
    h = o[0], u = n.substring(m, o.index), c ? c = (c + 1) % 5 : u.substr(-5) === "rgba(" && (c = 1), h !== l[y++] && (d = parseFloat(l[y - 1]) || 0, v._pt = { _next: v._pt, p: u || y === 1 ? u : ",", s: d, c: h.charAt(1) === "=" ? Jo(d, h) - d : parseFloat(h) - d, m: c && c < 4 ? Math.round : 0 }, m = Om.lastIndex);
  return v.c = m < n.length ? n.substring(m, n.length) : "", v.fp = a, (Aw.test(n) || p) && (v.e = 0), this._pt = v, v;
}, G1 = function(i, e, t, n, r, s, a, o, l, c) {
  Nt(n) && (n = n(r || 0, i, s));
  var h, u = i[e], d = t !== "get" ? t : Nt(u) ? l ? i[e.indexOf("set") || !Nt(i["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : i[e]() : u, p = Nt(u) ? l ? M5 : tS : V1;
  if (fn(n) && (~n.indexOf("random(") && (n = vh(n)), n.charAt(1) === "=" && ((h = Jo(d, n) + (En(d) || 0)) || h === 0) && (n = h)), !c || d !== n || P0)
    return isNaN(d * n) || n === "" ? (!u && !(e in i) && F1(e, n), x5.call(this, i, e, d, n, p, o || hi.stringFilter, l)) : (h = new Wn(this._pt, i, e, +d || 0, n - (d || 0), typeof u == "boolean" ? S5 : nS, 0, p), l && (h.fp = l), a && h.modifier(a, this, i), this._pt = h);
}, Jw = function(i, e, t, n, r, s) {
  var a, o, l, c;
  if ($n[i] && (a = new $n[i]()).init(r, a.rawVars ? e[i] : function(h, u, d, p, f) {
    if (Nt(h) && (h = Gc(h, f, u, d, p)), !pr(h) || h.style && h.nodeType || Tn(h) || Tw(h))
      return fn(h) ? Gc(h, f, u, d, p) : h;
    var v, m = {};
    for (v in h)
      m[v] = Gc(h[v], f, u, d, p);
    return m;
  }(e[i], n, r, s, t), t, n, s) !== !1 && (t._pt = o = new Wn(t._pt, r, i, 0, 1, a.render, a, 0, a.priority), t !== Bo))
    for (l = t._ptLookup[t._targets.indexOf(r)], c = a._props.length; c--; )
      l[a._props[c]] = o;
  return a;
}, L0 = function i(e, t, n) {
  var r, s, a, o, l, c, h, u, d, p, f, v, m, y = e.vars, g = y.ease, _ = y.startAt, x = y.immediateRender, M = y.lazy, b = y.onUpdate, w = y.runBackwards, T = y.yoyoEase, A = y.keyframes, L = y.autoRevert, I = e._dur, P = e._startAt, N = e._targets, F = e.parent, z = F && F.data === "nested" ? F.vars.targets : N, q = e._overwrite === "auto" && !N1, re = e.timeline;
  if (re && (!A || !g) && (g = "none"), e._ease = Ca(g, yl.ease), e._yEase = T ? Yw(Ca(T === !0 ? g : T, yl.ease)) : 0, T && e._yoyo && !e._repeat && (T = e._yEase, e._yEase = e._ease, e._ease = T), e._from = !re && !!y.runBackwards, !re || A && !y.stagger) {
    if (v = (u = N[0] ? Aa(N[0]).harness : 0) && y[u.prop], r = yp(y, B1), P && (P._zTime < 0 && P.progress(1), t < 0 && w && x && !L ? P.render(-1, !0) : P.revert(w && I ? Zd : c5), P._lazy = 0), _) {
      if (ws(e._startAt = Zt.set(N, Ti({ data: "isStart", overwrite: !1, parent: F, immediateRender: !0, lazy: !P && jn(M), startAt: null, delay: 0, onUpdate: b && function() {
        return ei(e, "onUpdate");
      }, stagger: 0 }, _))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (An || !x && !L) && e._startAt.revert(Zd), x && I && t <= 0 && n <= 0)
        return void (t && (e._zTime = t));
    } else if (w && I && !P)
      if (t && (x = !1), a = Ti({ overwrite: !1, data: "isFromStart", lazy: x && !P && jn(M), immediateRender: x, stagger: 0, parent: F }, r), v && (a[u.prop] = v), ws(e._startAt = Zt.set(N, a)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (An ? e._startAt.revert(Zd) : e._startAt.render(-1, !0)), e._zTime = t, x) {
        if (!t)
          return;
      } else
        i(e._startAt, Fn, Fn);
    for (e._pt = e._ptCache = 0, M = I && jn(M) || M && !I, s = 0; s < N.length; s++) {
      if (h = (l = N[s])._gsap || H1(N)[s]._gsap, e._ptLookup[s] = p = {}, E0[h.id] && ms.length && vp(), f = z === N ? s : z.indexOf(l), u && (d = new u()).init(l, v || r, e, f, z) !== !1 && (e._pt = o = new Wn(e._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach(function(ie) {
        p[ie] = o;
      }), d.priority && (c = 1)), !u || v)
        for (a in r)
          $n[a] && (d = Jw(a, r, e, f, l, z)) ? d.priority && (c = 1) : p[a] = o = G1.call(e, l, a, "get", r[a], f, z, 0, y.stringFilter);
      e._op && e._op[s] && e.kill(l, e._op[s]), q && e._pt && (os = e, Et.killTweensOf(l, p, e.globalTime(t)), m = !e.parent, os = 0), e._pt && M && (E0[h.id] = 1);
    }
    c && rS(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = b, e._initted = (!e._op || e._pt) && !m, A && t <= 0 && re.render(Nr, !0, !0);
}, b5 = function(i, e, t, n) {
  var r, s, a = e.ease || n || "power1.inOut";
  if (Tn(e))
    s = t[i] || (t[i] = []), e.forEach(function(o, l) {
      return s.push({ t: l / (e.length - 1) * 100, v: o, e: a });
    });
  else
    for (r in e)
      s = t[r] || (t[r] = []), r === "ease" || s.push({ t: parseFloat(i), v: e[r], e: a });
}, Gc = function(i, e, t, n, r) {
  return Nt(i) ? i.call(e, t, n, r) : fn(i) && ~i.indexOf("random(") ? vh(i) : i;
}, $w = z1 + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", eS = {};
Vn($w + ",id,stagger,delay,duration,paused,scrollTrigger", function(i) {
  return eS[i] = 1;
});
var Zt = function(i) {
  function e(n, r, s, a) {
    var o;
    typeof r == "number" && (s.duration = r, r = s, s = null);
    var l, c, h, u, d, p, f, v, m = (o = i.call(this, a ? r : zc(r)) || this).vars, y = m.duration, g = m.delay, _ = m.immediateRender, x = m.stagger, M = m.overwrite, b = m.keyframes, w = m.defaults, T = m.scrollTrigger, A = m.yoyoEase, L = r.parent || Et, I = (Tn(n) || Tw(n) ? zr(n[0]) : "length" in r) ? [n] : wi(n);
    if (o._targets = I.length ? H1(I) : mh("GSAP target " + n + " not found. https://gsap.com", !hi.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = M, b || x || vd(y) || vd(g)) {
      if (r = o.vars, (l = o.timeline = new Un({ data: "nested", defaults: w || {}, targets: L && L.data === "nested" ? L.vars.targets : I })).kill(), l.parent = l._dp = Mr(o), l._start = 0, x || vd(y) || vd(g)) {
        if (u = I.length, f = x && zw(x), pr(x))
          for (d in x)
            ~$w.indexOf(d) && (v || (v = {}), v[d] = x[d]);
        for (c = 0; c < u; c++)
          (h = yp(r, eS)).stagger = 0, A && (h.yoyoEase = A), v && ja(h, v), p = I[c], h.duration = +Gc(y, Mr(o), c, p, I), h.delay = (+Gc(g, Mr(o), c, p, I) || 0) - o._delay, !x && u === 1 && h.delay && (o._delay = g = h.delay, o._start += g, h.delay = 0), l.to(p, h, f ? f(c, p, I) : 0), l._ease = nt.none;
        l.duration() ? y = g = 0 : o.timeline = 0;
      } else if (b) {
        zc(Ti(l.vars.defaults, { ease: "none" })), l._ease = Ca(b.ease || r.ease || "none");
        var P, N, F, z = 0;
        if (Tn(b))
          b.forEach(function(q) {
            return l.to(I, q, ">");
          }), l.duration();
        else {
          for (d in h = {}, b)
            d === "ease" || d === "easeEach" || b5(d, b[d], h, b.easeEach);
          for (d in h)
            for (P = h[d].sort(function(q, re) {
              return q.t - re.t;
            }), z = 0, c = 0; c < P.length; c++)
              (F = { ease: (N = P[c]).e, duration: (N.t - (c ? P[c - 1].t : 0)) / 100 * y })[d] = N.v, l.to(I, F, z), z += F.duration;
          l.duration() < y && l.to({}, { duration: y - l.duration() });
        }
      }
      y || o.duration(y = l.duration());
    } else
      o.timeline = 0;
    return M !== !0 || N1 || (os = Mr(o), Et.killTweensOf(I), os = 0), sr(L, Mr(o), s), r.reversed && o.reverse(), r.paused && o.paused(!0), (_ || !y && !b && o._start === pn(L._time) && jn(_) && d5(Mr(o)) && L.data !== "nested") && (o._tTime = -1e-8, o.render(Math.max(0, -g) || 0)), T && kw(Mr(o), T), o;
  }
  bw(e, i);
  var t = e.prototype;
  return t.render = function(n, r, s) {
    var a, o, l, c, h, u, d, p, f, v = this._time, m = this._tDur, y = this._dur, g = n < 0, _ = n > m - Fn && !g ? m : n < Fn ? 0 : n;
    if (y) {
      if (_ !== this._tTime || !n || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g) {
        if (a = _, p = this.timeline, this._repeat) {
          if (c = y + this._rDelay, this._repeat < -1 && g)
            return this.totalTime(100 * c + n, r, s);
          if (a = pn(_ % c), _ === m ? (l = this._repeat, a = y) : ((l = ~~(_ / c)) && l === pn(_ / c) && (a = y, l--), a > y && (a = y)), (u = this._yoyo && 1 & l) && (f = this._yEase, a = y - a), h = $o(this._tTime, c), a === v && !s && this._initted && l === h)
            return this._tTime = _, this;
          l !== h && (p && this._yEase && Zw(p, u), this.vars.repeatRefresh && !u && !this._lock && this._time !== c && this._initted && (this._lock = s = 1, this.render(pn(c * l), !0).invalidate()._lock = 0));
        }
        if (!this._initted) {
          if (I3(this, g ? n : a, s, r, _))
            return this._tTime = 0, this;
          if (!(v === this._time || s && this.vars.repeatRefresh && l !== h))
            return this;
          if (y !== this._dur)
            return this.render(n, r, s);
        }
        if (this._tTime = _, this._time = a, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = d = (f || this._ease)(a / y), this._from && (this.ratio = d = 1 - d), a && !v && !r && !l && (ei(this, "onStart"), this._tTime !== _))
          return this;
        for (o = this._pt; o; )
          o.r(d, o.d), o = o._next;
        p && p.render(n < 0 ? n : p._dur * p._ease(a / this._dur), r, s) || this._startAt && (this._zTime = n), this._onUpdate && !r && (g && km(this, n, 0, s), ei(this, "onUpdate")), this._repeat && l !== h && this.vars.onRepeat && !r && this.parent && ei(this, "onRepeat"), _ !== this._tDur && _ || this._tTime !== _ || (g && !this._onUpdate && km(this, n, 0, !0), (n || !y) && (_ === this._tDur && this._ts > 0 || !_ && this._ts < 0) && ws(this, 1), r || g && !v || !(_ || v || u) || (ei(this, _ === m ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < m && this.timeScale() > 0) && this._prom()));
      }
    } else
      (function(x, M, b, w) {
        var T, A, L, I = x.ratio, P = M < 0 || !M && (!x._start && p5(x) && (x._initted || !A0(x)) || (x._ts < 0 || x._dp._ts < 0) && !A0(x)) ? 0 : 1, N = x._rDelay, F = 0;
        if (N && x._repeat && (F = Vh(0, x._tDur, M), A = $o(F, N), x._yoyo && 1 & A && (P = 1 - P), A !== $o(x._tTime, N) && (I = 1 - P, x.vars.repeatRefresh && x._initted && x.invalidate())), P !== I || An || w || x._zTime === Fn || !M && x._zTime) {
          if (!x._initted && I3(x, M, w, b, F))
            return;
          for (L = x._zTime, x._zTime = M || (b ? Fn : 0), b || (b = M && !L), x.ratio = P, x._from && (P = 1 - P), x._time = 0, x._tTime = F, T = x._pt; T; )
            T.r(P, T.d), T = T._next;
          M < 0 && km(x, M, 0, !0), x._onUpdate && !b && ei(x, "onUpdate"), F && x._repeat && !b && x.parent && ei(x, "onRepeat"), (M >= x._tDur || M < 0) && x.ratio === P && (P && ws(x, 1), b || An || (ei(x, P ? "onComplete" : "onReverseComplete", !0), x._prom && x._prom()));
        } else
          x._zTime || (x._zTime = M);
      })(this, n, r, s);
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(n) {
    return (!n || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(n), i.prototype.invalidate.call(this, n);
  }, t.resetTo = function(n, r, s, a, o) {
    fh || ii.wake(), this._ts || this.play();
    var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
    return this._initted || L0(this, l), function(c, h, u, d, p, f, v, m) {
      var y, g, _, x, M = (c._pt && c._ptCache || (c._ptCache = {}))[h];
      if (!M)
        for (M = c._ptCache[h] = [], _ = c._ptLookup, x = c._targets.length; x--; ) {
          if ((y = _[x][h]) && y.d && y.d._pt)
            for (y = y.d._pt; y && y.p !== h && y.fp !== h; )
              y = y._next;
          if (!y)
            return P0 = 1, c.vars[h] = "+=0", L0(c, v), P0 = 0, m ? mh(h + " not eligible for reset") : 1;
          M.push(y);
        }
      for (x = M.length; x--; )
        (y = (g = M[x])._pt || g).s = !d && d !== 0 || p ? y.s + (d || 0) + f * y.c : d, y.c = u - y.s, g.e && (g.e = Ht(u) + En(g.e)), g.b && (g.b = y.s + En(g.b));
    }(this, n, r, s, a, this._ease(l / this._dur), l, o) ? this.resetTo(n, r, s, a, 1) : (df(this, 0), this.parent || Ow(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(n, r) {
    if (r === void 0 && (r = "all"), !(n || r && r !== "all"))
      return this._lazy = this._pt = 0, this.parent ? Ac(this) : this;
    if (this.timeline) {
      var s = this.timeline.totalDuration();
      return this.timeline.killTweensOf(n, r, os && os.vars.overwrite !== !0)._first || Ac(this), this.parent && s !== this.timeline.totalDuration() && _l(this, this._dur * this.timeline._tDur / s, 0, 1), this;
    }
    var a, o, l, c, h, u, d, p = this._targets, f = n ? wi(n) : p, v = this._ptLookup, m = this._pt;
    if ((!r || r === "all") && function(y, g) {
      for (var _ = y.length, x = _ === g.length; x && _-- && y[_] === g[_]; )
        ;
      return _ < 0;
    }(p, f))
      return r === "all" && (this._pt = 0), Ac(this);
    for (a = this._op = this._op || [], r !== "all" && (fn(r) && (h = {}, Vn(r, function(y) {
      return h[y] = 1;
    }), r = h), r = function(y, g) {
      var _, x, M, b, w = y[0] ? Aa(y[0]).harness : 0, T = w && w.aliases;
      if (!T)
        return g;
      for (x in _ = ja({}, g), T)
        if (x in _)
          for (M = (b = T[x].split(",")).length; M--; )
            _[b[M]] = _[x];
      return _;
    }(p, r)), d = p.length; d--; )
      if (~f.indexOf(p[d]))
        for (h in o = v[d], r === "all" ? (a[d] = r, c = o, l = {}) : (l = a[d] = a[d] || {}, c = r), c)
          (u = o && o[h]) && ("kill" in u.d && u.d.kill(h) !== !0 || hf(this, u, "_pt"), delete o[h]), l !== "all" && (l[h] = 1);
    return this._initted && !this._pt && m && Ac(this), this;
  }, e.to = function(n, r) {
    return new e(n, r, arguments[2]);
  }, e.from = function(n, r) {
    return Hc(1, arguments);
  }, e.delayedCall = function(n, r, s, a) {
    return new e(r, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: n, onComplete: r, onReverseComplete: r, onCompleteParams: s, onReverseCompleteParams: s, callbackScope: a });
  }, e.fromTo = function(n, r, s) {
    return Hc(2, arguments);
  }, e.set = function(n, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(n, r);
  }, e.killTweensOf = function(n, r, s) {
    return Et.killTweensOf(n, r, s);
  }, e;
}(yh);
Ti(Zt.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), Vn("staggerTo,staggerFrom,staggerFromTo", function(i) {
  Zt[i] = function() {
    var e = new Un(), t = I0.call(arguments, 0);
    return t.splice(i === "staggerFromTo" ? 5 : 4, 0, 0), e[i].apply(e, t);
  };
});
var V1 = function(i, e, t) {
  return i[e] = t;
}, tS = function(i, e, t) {
  return i[e](t);
}, M5 = function(i, e, t, n) {
  return i[e](n.fp, t);
}, w5 = function(i, e, t) {
  return i.setAttribute(e, t);
}, j1 = function(i, e) {
  return Nt(i[e]) ? tS : U1(i[e]) && i.setAttribute ? w5 : V1;
}, nS = function(i, e) {
  return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * i)) / 1e6, e);
}, S5 = function(i, e) {
  return e.set(e.t, e.p, !!(e.s + e.c * i), e);
}, iS = function(i, e) {
  var t = e._pt, n = "";
  if (!i && e.b)
    n = e.b;
  else if (i === 1 && e.e)
    n = e.e;
  else {
    for (; t; )
      n = t.p + (t.m ? t.m(t.s + t.c * i) : Math.round(1e4 * (t.s + t.c * i)) / 1e4) + n, t = t._next;
    n += e.c;
  }
  e.set(e.t, e.p, n, e);
}, D0 = function(i, e) {
  for (var t = e._pt; t; )
    t.r(i, t.d), t = t._next;
}, T5 = function(i, e, t, n) {
  for (var r, s = this._pt; s; )
    r = s._next, s.p === n && s.modifier(i, e, t), s = r;
}, E5 = function(i) {
  for (var e, t, n = this._pt; n; )
    t = n._next, n.p === i && !n.op || n.op === i ? hf(this, n, "_pt") : n.dep || (e = 1), n = t;
  return !e;
}, A5 = function(i, e, t, n) {
  n.mSet(i, e, n.m.call(n.tween, t, n.mt), n);
}, rS = function(i) {
  for (var e, t, n, r, s = i._pt; s; ) {
    for (e = s._next, t = n; t && t.pr > s.pr; )
      t = t._next;
    (s._prev = t ? t._prev : r) ? s._prev._next = s : n = s, (s._next = t) ? t._prev = s : r = s, s = e;
  }
  i._pt = n;
}, Wn = function() {
  function i(e, t, n, r, s, a, o, l, c) {
    this.t = t, this.s = r, this.c = s, this.p = n, this.r = a || nS, this.d = o || this, this.set = l || V1, this.pr = c || 0, this._next = e, e && (e._prev = this);
  }
  return i.prototype.modifier = function(e, t, n) {
    this.mSet = this.mSet || this.set, this.set = A5, this.m = e, this.mt = n, this.tween = t;
  }, i;
}();
Vn(z1 + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(i) {
  return B1[i] = 1;
}), li.TweenMax = li.TweenLite = Zt, li.TimelineLite = li.TimelineMax = Un, Et = new Un({ sortChildren: !1, defaults: yl, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), hi.stringFilter = qw;
var Ra = [], Qd = {}, I5 = [], N3 = 0, C5 = 0, Hm = function(i) {
  return (Qd[i] || I5).map(function(e) {
    return e();
  });
}, N0 = function() {
  var i = Date.now(), e = [];
  i - N3 > 2 && (Hm("matchMediaInit"), Ra.forEach(function(t) {
    var n, r, s, a, o = t.queries, l = t.conditions;
    for (r in o)
      (n = rr.matchMedia(o[r]).matches) && (s = 1), n !== l[r] && (l[r] = n, a = 1);
    a && (t.revert(), s && e.push(t));
  }), Hm("matchMediaRevert"), e.forEach(function(t) {
    return t.onMatch(t, function(n) {
      return t.add(null, n);
    });
  }), N3 = i, Hm("matchMedia"));
}, sS = function() {
  function i(t, n) {
    this.selector = n && C0(n), this.data = [], this._r = [], this.isReverted = !1, this.id = C5++, t && this.add(t);
  }
  var e = i.prototype;
  return e.add = function(t, n, r) {
    Nt(t) && (r = n, n = t, t = Nt);
    var s = this, a = function() {
      var o, l = Mt, c = s.selector;
      return l && l !== s && l.data.push(s), r && (s.selector = C0(r)), Mt = s, o = n.apply(s, arguments), Nt(o) && s._r.push(o), Mt = l, s.selector = c, s.isReverted = !1, o;
    };
    return s.last = a, t === Nt ? a(s, function(o) {
      return s.add(null, o);
    }) : t ? s[t] = a : a;
  }, e.ignore = function(t) {
    var n = Mt;
    Mt = null, t(this), Mt = n;
  }, e.getTweens = function() {
    var t = [];
    return this.data.forEach(function(n) {
      return n instanceof i ? t.push.apply(t, n.getTweens()) : n instanceof Zt && !(n.parent && n.parent.data === "nested") && t.push(n);
    }), t;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(t, n) {
    var r = this;
    if (t ? function() {
      for (var a, o = r.getTweens(), l = r.data.length; l--; )
        (a = r.data[l]).data === "isFlip" && (a.revert(), a.getChildren(!0, !0, !1).forEach(function(c) {
          return o.splice(o.indexOf(c), 1);
        }));
      for (o.map(function(c) {
        return { g: c._dur || c._delay || c._sat && !c._sat.vars.immediateRender ? c.globalTime(0) : -1 / 0, t: c };
      }).sort(function(c, h) {
        return h.g - c.g || -1 / 0;
      }).forEach(function(c) {
        return c.t.revert(t);
      }), l = r.data.length; l--; )
        (a = r.data[l]) instanceof Un ? a.data !== "nested" && (a.scrollTrigger && a.scrollTrigger.revert(), a.kill()) : !(a instanceof Zt) && a.revert && a.revert(t);
      r._r.forEach(function(c) {
        return c(t, r);
      }), r.isReverted = !0;
    }() : this.data.forEach(function(a) {
      return a.kill && a.kill();
    }), this.clear(), n)
      for (var s = Ra.length; s--; )
        Ra[s].id === this.id && Ra.splice(s, 1);
  }, e.revert = function(t) {
    this.kill(t || {});
  }, i;
}(), R5 = function() {
  function i(t) {
    this.contexts = [], this.scope = t, Mt && Mt.data.push(this);
  }
  var e = i.prototype;
  return e.add = function(t, n, r) {
    pr(t) || (t = { matches: t });
    var s, a, o, l = new sS(0, r || this.scope), c = l.conditions = {};
    for (a in Mt && !l.selector && (l.selector = Mt.selector), this.contexts.push(l), n = l.add("onMatch", n), l.queries = t, t)
      a === "all" ? o = 1 : (s = rr.matchMedia(t[a])) && (Ra.indexOf(l) < 0 && Ra.push(l), (c[a] = s.matches) && (o = 1), s.addListener ? s.addListener(N0) : s.addEventListener("change", N0));
    return o && n(l, function(h) {
      return l.add(null, h);
    }), this;
  }, e.revert = function(t) {
    this.kill(t || {});
  }, e.kill = function(t) {
    this.contexts.forEach(function(n) {
      return n.kill(t, !0);
    });
  }, i;
}(), xp = { registerPlugin: function() {
  for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
    e[t] = arguments[t];
  e.forEach(function(n) {
    return jw(n);
  });
}, timeline: function(i) {
  return new Un(i);
}, getTweensOf: function(i, e) {
  return Et.getTweensOf(i, e);
}, getProperty: function(i, e, t, n) {
  fn(i) && (i = wi(i)[0]);
  var r = Aa(i || {}).get, s = t ? Nw : Dw;
  return t === "native" && (t = ""), i && (e ? s(($n[e] && $n[e].get || r)(i, e, t, n)) : function(a, o, l) {
    return s(($n[a] && $n[a].get || r)(i, a, o, l));
  });
}, quickSetter: function(i, e, t) {
  if ((i = wi(i)).length > 1) {
    var n = i.map(function(c) {
      return Xn.quickSetter(c, e, t);
    }), r = n.length;
    return function(c) {
      for (var h = r; h--; )
        n[h](c);
    };
  }
  i = i[0] || {};
  var s = $n[e], a = Aa(i), o = a.harness && (a.harness.aliases || {})[e] || e, l = s ? function(c) {
    var h = new s();
    Bo._pt = 0, h.init(i, t ? c + t : c, Bo, 0, [i]), h.render(1, h), Bo._pt && D0(1, Bo);
  } : a.set(i, o);
  return s ? l : function(c) {
    return l(i, o, t ? c + t : c, a, 1);
  };
}, quickTo: function(i, e, t) {
  var n, r = Xn.to(i, ja(((n = {})[e] = "+=0.1", n.paused = !0, n), t || {})), s = function(a, o, l) {
    return r.resetTo(e, a, o, l);
  };
  return s.tween = r, s;
}, isTweening: function(i) {
  return Et.getTweensOf(i, !0).length > 0;
}, defaults: function(i) {
  return i && i.ease && (i.ease = Ca(i.ease, yl.ease)), E3(yl, i || {});
}, config: function(i) {
  return E3(hi, i || {});
}, registerEffect: function(i) {
  var e = i.name, t = i.effect, n = i.plugins, r = i.defaults, s = i.extendTimeline;
  (n || "").split(",").forEach(function(a) {
    return a && !$n[a] && !li[a] && mh(e + " effect requires " + a + " plugin.");
  }), Um[e] = function(a, o, l) {
    return t(wi(a), Ti(o || {}, r), l);
  }, s && (Un.prototype[e] = function(a, o, l) {
    return this.add(Um[e](a, pr(o) ? o : (l = o) && {}, this), l);
  });
}, registerEase: function(i, e) {
  nt[i] = Ca(e);
}, parseEase: function(i, e) {
  return arguments.length ? Ca(i, e) : nt;
}, getById: function(i) {
  return Et.getById(i);
}, exportRoot: function(i, e) {
  i === void 0 && (i = {});
  var t, n, r = new Un(i);
  for (r.smoothChildTiming = jn(i.smoothChildTiming), Et.remove(r), r._dp = 0, r._time = r._tTime = Et._time, t = Et._first; t; )
    n = t._next, !e && !t._dur && t instanceof Zt && t.vars.onComplete === t._targets[0] || sr(r, t, t._start - t._delay), t = n;
  return sr(Et, r, 0), r;
}, context: function(i, e) {
  return i ? new sS(i, e) : Mt;
}, matchMedia: function(i) {
  return new R5(i);
}, matchMediaRefresh: function() {
  return Ra.forEach(function(i) {
    var e, t, n = i.conditions;
    for (t in n)
      n[t] && (n[t] = !1, e = 1);
    e && i.revert();
  }) || N0();
}, addEventListener: function(i, e) {
  var t = Qd[i] || (Qd[i] = []);
  ~t.indexOf(e) || t.push(e);
}, removeEventListener: function(i, e) {
  var t = Qd[i], n = t && t.indexOf(e);
  n >= 0 && t.splice(n, 1);
}, utils: { wrap: function i(e, t, n) {
  var r = t - e;
  return Tn(e) ? R3(e, i(0, e.length), t) : as(n, function(s) {
    return (r + (s - e) % r) % r + e;
  });
}, wrapYoyo: function i(e, t, n) {
  var r = t - e, s = 2 * r;
  return Tn(e) ? R3(e, i(0, e.length - 1), t) : as(n, function(a) {
    return e + ((a = (s + (a - e) % s) % s || 0) > r ? s - a : a);
  });
}, distribute: zw, random: Gw, snap: Hw, normalize: function(i, e, t) {
  return P3(i, e, 0, 1, t);
}, getUnit: En, clamp: function(i, e, t) {
  return as(t, function(n) {
    return Vh(i, e, n);
  });
}, splitColor: Ww, toArray: wi, selector: C0, mapRange: P3, pipe: function() {
  for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
    e[t] = arguments[t];
  return function(n) {
    return e.reduce(function(r, s) {
      return s(r);
    }, n);
  };
}, unitize: function(i, e) {
  return function(t) {
    return i(parseFloat(t)) + (e || En(t));
  };
}, interpolate: function i(e, t, n, r) {
  var s = isNaN(e + t) ? 0 : function(p) {
    return (1 - p) * e + p * t;
  };
  if (!s) {
    var a, o, l, c, h, u = fn(e), d = {};
    if (n === !0 && (r = 1) && (n = null), u)
      e = { p: e }, t = { p: t };
    else if (Tn(e) && !Tn(t)) {
      for (l = [], c = e.length, h = c - 2, o = 1; o < c; o++)
        l.push(i(e[o - 1], e[o]));
      c--, s = function(p) {
        p *= c;
        var f = Math.min(h, ~~p);
        return l[f](p - f);
      }, n = t;
    } else
      r || (e = ja(Tn(e) ? [] : {}, e));
    if (!l) {
      for (a in t)
        G1.call(d, e, a, "get", t[a]);
      s = function(p) {
        return D0(p, d) || (u ? e.p : e);
      };
    }
  }
  return as(n, s);
}, shuffle: Bw }, install: Cw, effects: Um, ticker: ii, updateRoot: Un.updateRoot, plugins: $n, globalTimeline: Et, core: { PropTween: Wn, globals: Rw, Tween: Zt, Timeline: Un, Animation: yh, getCache: Aa, _removeLinkedListItem: hf, reverting: function() {
  return An;
}, context: function(i) {
  return i && Mt && (Mt.data.push(i), i._ctx = Mt), Mt;
}, suppressOverwrites: function(i) {
  return N1 = i;
} } };
Vn("to,from,fromTo,delayedCall,set,killTweensOf", function(i) {
  return xp[i] = Zt[i];
}), ii.add(Un.updateRoot), Bo = xp.to({}, { duration: 0 });
var P5 = function(i, e) {
  for (var t = i._pt; t && t.p !== e && t.op !== e && t.fp !== e; )
    t = t._next;
  return t;
}, Gm = function(i, e) {
  return { name: i, rawVars: 1, init: function(t, n, r) {
    r._onInit = function(s) {
      var a, o;
      if (fn(n) && (a = {}, Vn(n, function(l) {
        return a[l] = 1;
      }), n = a), e) {
        for (o in a = {}, n)
          a[o] = e(n[o]);
        n = a;
      }
      (function(l, c) {
        var h, u, d, p = l._targets;
        for (h in c)
          for (u = p.length; u--; )
            (d = l._ptLookup[u][h]) && (d = d.d) && (d._pt && (d = P5(d, h)), d && d.modifier && d.modifier(c[h], l, p[u], h));
      })(s, n);
    };
  } };
}, Xn = xp.registerPlugin({ name: "attr", init: function(i, e, t, n, r) {
  var s, a, o;
  for (s in this.tween = t, e)
    o = i.getAttribute(s) || "", (a = this.add(i, "setAttribute", (o || 0) + "", e[s], n, r, 0, 0, s)).op = s, a.b = o, this._props.push(s);
}, render: function(i, e) {
  for (var t = e._pt; t; )
    An ? t.set(t.t, t.p, t.b, t) : t.r(i, t.d), t = t._next;
} }, { name: "endArray", init: function(i, e) {
  for (var t = e.length; t--; )
    this.add(i, t, i[t] || 0, e[t], 0, 0, 0, 0, 0, 1);
} }, Gm("roundProps", R0), Gm("modifiers"), Gm("snap", Hw)) || xp;
Zt.version = Un.version = Xn.version = "3.12.5", Mw = 1, k1() && xl(), nt.Power0, nt.Power1, nt.Power2, nt.Power3, nt.Power4, nt.Linear, nt.Quad, nt.Cubic, nt.Quart, nt.Quint, nt.Strong, nt.Elastic, nt.Back, nt.SteppedEase, nt.Bounce, nt.Sine, nt.Expo, nt.Circ;
var O3, ls, el, W1, _a, U3, X1, aS, Hr = {}, aa = 180 / Math.PI, tl = Math.PI / 180, So = Math.atan2, q1 = /([A-Z])/g, L5 = /(left|right|width|margin|padding|x)/i, D5 = /[\s,\(]\S/, ar = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, O0 = function(i, e) {
  return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * i)) / 1e4 + e.u, e);
}, N5 = function(i, e) {
  return e.set(e.t, e.p, i === 1 ? e.e : Math.round(1e4 * (e.s + e.c * i)) / 1e4 + e.u, e);
}, O5 = function(i, e) {
  return e.set(e.t, e.p, i ? Math.round(1e4 * (e.s + e.c * i)) / 1e4 + e.u : e.b, e);
}, U5 = function(i, e) {
  var t = e.s + e.c * i;
  e.set(e.t, e.p, ~~(t + (t < 0 ? -0.5 : 0.5)) + e.u, e);
}, oS = function(i, e) {
  return e.set(e.t, e.p, i ? e.e : e.b, e);
}, lS = function(i, e) {
  return e.set(e.t, e.p, i !== 1 ? e.b : e.e, e);
}, k5 = function(i, e, t) {
  return i.style[e] = t;
}, F5 = function(i, e, t) {
  return i.style.setProperty(e, t);
}, B5 = function(i, e, t) {
  return i._gsap[e] = t;
}, z5 = function(i, e, t) {
  return i._gsap.scaleX = i._gsap.scaleY = t;
}, H5 = function(i, e, t, n, r) {
  var s = i._gsap;
  s.scaleX = s.scaleY = t, s.renderTransform(r, s);
}, G5 = function(i, e, t, n, r) {
  var s = i._gsap;
  s[e] = t, s.renderTransform(r, s);
}, It = "transform", qn = It + "Origin", V5 = function i(e, t) {
  var n = this, r = this.target, s = r.style, a = r._gsap;
  if (e in Hr && s) {
    if (this.tfm = this.tfm || {}, e === "transform")
      return ar.transform.split(",").forEach(function(o) {
        return i.call(n, o, t);
      });
    if (~(e = ar[e] || e).indexOf(",") ? e.split(",").forEach(function(o) {
      return n.tfm[o] = Sr(r, o);
    }) : this.tfm[e] = a.x ? a[e] : Sr(r, e), e === qn && (this.tfm.zOrigin = a.zOrigin), this.props.indexOf(It) >= 0)
      return;
    a.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(qn, t, "")), e = It;
  }
  (s || t) && this.props.push(e, t, s[e]);
}, cS = function(i) {
  i.translate && (i.removeProperty("translate"), i.removeProperty("scale"), i.removeProperty("rotate"));
}, j5 = function() {
  var i, e, t = this.props, n = this.target, r = n.style, s = n._gsap;
  for (i = 0; i < t.length; i += 3)
    t[i + 1] ? n[t[i]] = t[i + 2] : t[i + 2] ? r[t[i]] = t[i + 2] : r.removeProperty(t[i].substr(0, 2) === "--" ? t[i] : t[i].replace(q1, "-$1").toLowerCase());
  if (this.tfm) {
    for (e in this.tfm)
      s[e] = this.tfm[e];
    s.svg && (s.renderTransform(), n.setAttribute("data-svg-origin", this.svgo || "")), (i = X1()) && i.isStart || r[It] || (cS(r), s.zOrigin && r[qn] && (r[qn] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1);
  }
}, hS = function(i, e) {
  var t = { target: i, props: [], revert: j5, save: V5 };
  return i._gsap || Xn.core.getCache(i), e && e.split(",").forEach(function(n) {
    return t.save(n);
  }), t;
}, U0 = function(i, e) {
  var t = ls.createElementNS ? ls.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), i) : ls.createElement(i);
  return t && t.style ? t : ls.createElement(i);
}, hr = function i(e, t, n) {
  var r = getComputedStyle(e);
  return r[t] || r.getPropertyValue(t.replace(q1, "-$1").toLowerCase()) || r.getPropertyValue(t) || !n && i(e, bl(t) || t, 1) || "";
}, k3 = "O,Moz,ms,Ms,Webkit".split(","), bl = function(i, e, t) {
  var n = (e || _a).style, r = 5;
  if (i in n && !t)
    return i;
  for (i = i.charAt(0).toUpperCase() + i.substr(1); r-- && !(k3[r] + i in n); )
    ;
  return r < 0 ? null : (r === 3 ? "ms" : r >= 0 ? k3[r] : "") + i;
}, k0 = function() {
  typeof window != "undefined" && window.document && (O3 = window, ls = O3.document, el = ls.documentElement, _a = U0("div") || { style: {} }, U0("div"), It = bl(It), qn = It + "Origin", _a.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", aS = !!bl("perspective"), X1 = Xn.core.reverting, W1 = 1);
}, Vm = function i(e) {
  var t, n = U0("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, a = this.style.cssText;
  if (el.appendChild(n), n.appendChild(this), this.style.display = "block", e)
    try {
      t = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = i;
    } catch (o) {
    }
  else
    this._gsapBBox && (t = this._gsapBBox());
  return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), el.removeChild(n), this.style.cssText = a, t;
}, F3 = function(i, e) {
  for (var t = e.length; t--; )
    if (i.hasAttribute(e[t]))
      return i.getAttribute(e[t]);
}, uS = function(i) {
  var e;
  try {
    e = i.getBBox();
  } catch (t) {
    e = Vm.call(i, !0);
  }
  return e && (e.width || e.height) || i.getBBox === Vm || (e = Vm.call(i, !0)), !e || e.width || e.x || e.y ? e : { x: +F3(i, ["x", "cx", "x1"]) || 0, y: +F3(i, ["y", "cy", "y1"]) || 0, width: 0, height: 0 };
}, dS = function(i) {
  return !(!i.getCTM || i.parentNode && !i.ownerSVGElement || !uS(i));
}, Wa = function(i, e) {
  if (e) {
    var t, n = i.style;
    e in Hr && e !== qn && (e = It), n.removeProperty ? ((t = e.substr(0, 2)) !== "ms" && e.substr(0, 6) !== "webkit" || (e = "-" + e), n.removeProperty(t === "--" ? e : e.replace(q1, "-$1").toLowerCase())) : n.removeAttribute(e);
  }
}, cs = function(i, e, t, n, r, s) {
  var a = new Wn(i._pt, e, t, 0, 1, s ? lS : oS);
  return i._pt = a, a.b = n, a.e = r, i._props.push(t), a;
}, B3 = { deg: 1, rad: 1, turn: 1 }, W5 = { grid: 1, flex: 1 }, Ss = function i(e, t, n, r) {
  var s, a, o, l, c = parseFloat(n) || 0, h = (n + "").trim().substr((c + "").length) || "px", u = _a.style, d = L5.test(t), p = e.tagName.toLowerCase() === "svg", f = (p ? "client" : "offset") + (d ? "Width" : "Height"), v = 100, m = r === "px", y = r === "%";
  if (r === h || !c || B3[r] || B3[h])
    return c;
  if (h !== "px" && !m && (c = i(e, t, n, "px")), l = e.getCTM && dS(e), (y || h === "%") && (Hr[t] || ~t.indexOf("adius")))
    return s = l ? e.getBBox()[d ? "width" : "height"] : e[f], Ht(y ? c / s * v : c / 100 * s);
  if (u[d ? "width" : "height"] = v + (m ? h : r), a = ~t.indexOf("adius") || r === "em" && e.appendChild && !p ? e : e.parentNode, l && (a = (e.ownerSVGElement || {}).parentNode), a && a !== ls && a.appendChild || (a = ls.body), (o = a._gsap) && y && o.width && d && o.time === ii.time && !o.uncache)
    return Ht(c / o.width * v);
  if (!y || t !== "height" && t !== "width")
    (y || h === "%") && !W5[hr(a, "display")] && (u.position = hr(e, "position")), a === e && (u.position = "static"), a.appendChild(_a), s = _a[f], a.removeChild(_a), u.position = "absolute";
  else {
    var g = e.style[t];
    e.style[t] = v + r, s = e[f], g ? e.style[t] = g : Wa(e, t);
  }
  return d && y && ((o = Aa(a)).time = ii.time, o.width = a[f]), Ht(m ? s * c / v : s && c ? v / s * c : 0);
}, Sr = function(i, e, t, n) {
  var r;
  return W1 || k0(), e in ar && e !== "transform" && ~(e = ar[e]).indexOf(",") && (e = e.split(",")[0]), Hr[e] && e !== "transform" ? (r = xh(i, n), r = e !== "transformOrigin" ? r[e] : r.svg ? r.origin : Mp(hr(i, qn)) + " " + r.zOrigin + "px") : (!(r = i.style[e]) || r === "auto" || n || ~(r + "").indexOf("calc(")) && (r = bp[e] && bp[e](i, e, t) || hr(i, e) || Pw(i, e) || (e === "opacity" ? 1 : 0)), t && !~(r + "").trim().indexOf(" ") ? Ss(i, e, r, t) + t : r;
}, X5 = function(i, e, t, n) {
  if (!t || t === "none") {
    var r = bl(e, i, 1), s = r && hr(i, r, 1);
    s && s !== t ? (e = r, t = s) : e === "borderColor" && (t = hr(i, "borderTopColor"));
  }
  var a, o, l, c, h, u, d, p, f, v, m, y = new Wn(this._pt, i.style, e, 0, 1, iS), g = 0, _ = 0;
  if (y.b = t, y.e = n, t += "", (n += "") == "auto" && (u = i.style[e], i.style[e] = n, n = hr(i, e) || n, u ? i.style[e] = u : Wa(i, e)), qw(a = [t, n]), n = a[1], l = (t = a[0]).match(zo) || [], (n.match(zo) || []).length) {
    for (; o = zo.exec(n); )
      d = o[0], f = n.substring(g, o.index), h ? h = (h + 1) % 5 : f.substr(-5) !== "rgba(" && f.substr(-5) !== "hsla(" || (h = 1), d !== (u = l[_++] || "") && (c = parseFloat(u) || 0, m = u.substr((c + "").length), d.charAt(1) === "=" && (d = Jo(c, d) + m), p = parseFloat(d), v = d.substr((p + "").length), g = zo.lastIndex - v.length, v || (v = v || hi.units[e] || m, g === n.length && (n += v, y.e += v)), m !== v && (c = Ss(i, e, u, v) || 0), y._pt = { _next: y._pt, p: f || _ === 1 ? f : ",", s: c, c: p - c, m: h && h < 4 || e === "zIndex" ? Math.round : 0 });
    y.c = g < n.length ? n.substring(g, n.length) : "";
  } else
    y.r = e === "display" && n === "none" ? lS : oS;
  return Aw.test(n) && (y.e = 0), this._pt = y, y;
}, z3 = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, q5 = function(i) {
  var e = i.split(" "), t = e[0], n = e[1] || "50%";
  return t !== "top" && t !== "bottom" && n !== "left" && n !== "right" || (i = t, t = n, n = i), e[0] = z3[t] || t, e[1] = z3[n] || n, e.join(" ");
}, Y5 = function(i, e) {
  if (e.tween && e.tween._time === e.tween._dur) {
    var t, n, r, s = e.t, a = s.style, o = e.u, l = s._gsap;
    if (o === "all" || o === !0)
      a.cssText = "", n = 1;
    else
      for (r = (o = o.split(",")).length; --r > -1; )
        t = o[r], Hr[t] && (n = 1, t = t === "transformOrigin" ? qn : It), Wa(s, t);
    n && (Wa(s, It), l && (l.svg && s.removeAttribute("transform"), xh(s, 1), l.uncache = 1, cS(a)));
  }
}, bp = { clearProps: function(i, e, t, n, r) {
  if (r.data !== "isFromStart") {
    var s = i._pt = new Wn(i._pt, e, t, 0, 0, Y5);
    return s.u = n, s.pr = -10, s.tween = r, i._props.push(t), 1;
  }
} }, _h = [1, 0, 0, 1, 0, 0], pS = {}, fS = function(i) {
  return i === "matrix(1, 0, 0, 1, 0, 0)" || i === "none" || !i;
}, H3 = function(i) {
  var e = hr(i, It);
  return fS(e) ? _h : e.substr(7).match(Ew).map(Ht);
}, Y1 = function(i, e) {
  var t, n, r, s, a = i._gsap || Aa(i), o = i.style, l = H3(i);
  return a.svg && i.getAttribute("transform") ? (l = [(r = i.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") === "1,0,0,1,0,0" ? _h : l : (l !== _h || i.offsetParent || i === el || a.svg || (r = o.display, o.display = "block", (t = i.parentNode) && i.offsetParent || (s = 1, n = i.nextElementSibling, el.appendChild(i)), l = H3(i), r ? o.display = r : Wa(i, "display"), s && (n ? t.insertBefore(i, n) : t ? t.appendChild(i) : el.removeChild(i))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
}, F0 = function(i, e, t, n, r, s) {
  var a, o, l, c = i._gsap, h = r || Y1(i, !0), u = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, v = h[0], m = h[1], y = h[2], g = h[3], _ = h[4], x = h[5], M = e.split(" "), b = parseFloat(M[0]) || 0, w = parseFloat(M[1]) || 0;
  t ? h !== _h && (o = v * g - m * y) && (l = b * (-m / o) + w * (v / o) - (v * x - m * _) / o, b = b * (g / o) + w * (-y / o) + (y * x - g * _) / o, w = l) : (b = (a = uS(i)).x + (~M[0].indexOf("%") ? b / 100 * a.width : b), w = a.y + (~(M[1] || M[0]).indexOf("%") ? w / 100 * a.height : w)), n || n !== !1 && c.smooth ? (_ = b - u, x = w - d, c.xOffset = p + (_ * v + x * y) - _, c.yOffset = f + (_ * m + x * g) - x) : c.xOffset = c.yOffset = 0, c.xOrigin = b, c.yOrigin = w, c.smooth = !!n, c.origin = e, c.originIsAbsolute = !!t, i.style[qn] = "0px 0px", s && (cs(s, c, "xOrigin", u, b), cs(s, c, "yOrigin", d, w), cs(s, c, "xOffset", p, c.xOffset), cs(s, c, "yOffset", f, c.yOffset)), i.setAttribute("data-svg-origin", b + " " + w);
}, xh = function(i, e) {
  var t = i._gsap || new Qw(i);
  if ("x" in t && !e && !t.uncache)
    return t;
  var n, r, s, a, o, l, c, h, u, d, p, f, v, m, y, g, _, x, M, b, w, T, A, L, I, P, N, F, z, q, re, ie, me = i.style, Se = t.scaleX < 0, te = "px", se = "deg", he = getComputedStyle(i), ae = hr(i, qn) || "0";
  return n = r = s = l = c = h = u = d = p = 0, a = o = 1, t.svg = !(!i.getCTM || !dS(i)), he.translate && (he.translate === "none" && he.scale === "none" && he.rotate === "none" || (me[It] = (he.translate !== "none" ? "translate3d(" + (he.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (he.rotate !== "none" ? "rotate(" + he.rotate + ") " : "") + (he.scale !== "none" ? "scale(" + he.scale.split(" ").join(",") + ") " : "") + (he[It] !== "none" ? he[It] : "")), me.scale = me.rotate = me.translate = "none"), m = Y1(i, t.svg), t.svg && (t.uncache ? (I = i.getBBox(), ae = t.xOrigin - I.x + "px " + (t.yOrigin - I.y) + "px", L = "") : L = !e && i.getAttribute("data-svg-origin"), F0(i, L || ae, !!L || t.originIsAbsolute, t.smooth !== !1, m)), f = t.xOrigin || 0, v = t.yOrigin || 0, m !== _h && (x = m[0], M = m[1], b = m[2], w = m[3], n = T = m[4], r = A = m[5], m.length === 6 ? (a = Math.sqrt(x * x + M * M), o = Math.sqrt(w * w + b * b), l = x || M ? So(M, x) * aa : 0, (u = b || w ? So(b, w) * aa + l : 0) && (o *= Math.abs(Math.cos(u * tl))), t.svg && (n -= f - (f * x + v * b), r -= v - (f * M + v * w))) : (ie = m[6], q = m[7], N = m[8], F = m[9], z = m[10], re = m[11], n = m[12], r = m[13], s = m[14], c = (y = So(ie, z)) * aa, y && (L = T * (g = Math.cos(-y)) + N * (_ = Math.sin(-y)), I = A * g + F * _, P = ie * g + z * _, N = T * -_ + N * g, F = A * -_ + F * g, z = ie * -_ + z * g, re = q * -_ + re * g, T = L, A = I, ie = P), h = (y = So(-b, z)) * aa, y && (g = Math.cos(-y), re = w * (_ = Math.sin(-y)) + re * g, x = L = x * g - N * _, M = I = M * g - F * _, b = P = b * g - z * _), l = (y = So(M, x)) * aa, y && (L = x * (g = Math.cos(y)) + M * (_ = Math.sin(y)), I = T * g + A * _, M = M * g - x * _, A = A * g - T * _, x = L, T = I), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, h = 180 - h), a = Ht(Math.sqrt(x * x + M * M + b * b)), o = Ht(Math.sqrt(A * A + ie * ie)), y = So(T, A), u = Math.abs(y) > 2e-4 ? y * aa : 0, p = re ? 1 / (re < 0 ? -re : re) : 0), t.svg && (L = i.getAttribute("transform"), t.forceCSS = i.setAttribute("transform", "") || !fS(hr(i, It)), L && i.setAttribute("transform", L))), Math.abs(u) > 90 && Math.abs(u) < 270 && (Se ? (a *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, u += u <= 0 ? 180 : -180)), e = e || t.uncache, t.x = n - ((t.xPercent = n && (!e && t.xPercent || (Math.round(i.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? i.offsetWidth * t.xPercent / 100 : 0) + te, t.y = r - ((t.yPercent = r && (!e && t.yPercent || (Math.round(i.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? i.offsetHeight * t.yPercent / 100 : 0) + te, t.z = s + te, t.scaleX = Ht(a), t.scaleY = Ht(o), t.rotation = Ht(l) + se, t.rotationX = Ht(c) + se, t.rotationY = Ht(h) + se, t.skewX = u + se, t.skewY = d + se, t.transformPerspective = p + te, (t.zOrigin = parseFloat(ae.split(" ")[2]) || !e && t.zOrigin || 0) && (me[qn] = Mp(ae)), t.xOffset = t.yOffset = 0, t.force3D = hi.force3D, t.renderTransform = t.svg ? K5 : aS ? mS : Z5, t.uncache = 0, t;
}, Mp = function(i) {
  return (i = i.split(" "))[0] + " " + i[1];
}, jm = function(i, e, t) {
  var n = En(e);
  return Ht(parseFloat(e) + parseFloat(Ss(i, "x", t + "px", n))) + n;
}, Z5 = function(i, e) {
  e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, mS(i, e);
}, Qs = "0deg", hc = "0px", Js = ") ", mS = function(i, e) {
  var t = e || this, n = t.xPercent, r = t.yPercent, s = t.x, a = t.y, o = t.z, l = t.rotation, c = t.rotationY, h = t.rotationX, u = t.skewX, d = t.skewY, p = t.scaleX, f = t.scaleY, v = t.transformPerspective, m = t.force3D, y = t.target, g = t.zOrigin, _ = "", x = m === "auto" && i && i !== 1 || m === !0;
  if (g && (h !== Qs || c !== Qs)) {
    var M, b = parseFloat(c) * tl, w = Math.sin(b), T = Math.cos(b);
    b = parseFloat(h) * tl, M = Math.cos(b), s = jm(y, s, w * M * -g), a = jm(y, a, -Math.sin(b) * -g), o = jm(y, o, T * M * -g + g);
  }
  v !== hc && (_ += "perspective(" + v + Js), (n || r) && (_ += "translate(" + n + "%, " + r + "%) "), (x || s !== hc || a !== hc || o !== hc) && (_ += o !== hc || x ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + Js), l !== Qs && (_ += "rotate(" + l + Js), c !== Qs && (_ += "rotateY(" + c + Js), h !== Qs && (_ += "rotateX(" + h + Js), u === Qs && d === Qs || (_ += "skew(" + u + ", " + d + Js), p === 1 && f === 1 || (_ += "scale(" + p + ", " + f + Js), y.style[It] = _ || "translate(0, 0)";
}, K5 = function(i, e) {
  var t, n, r, s, a, o = e || this, l = o.xPercent, c = o.yPercent, h = o.x, u = o.y, d = o.rotation, p = o.skewX, f = o.skewY, v = o.scaleX, m = o.scaleY, y = o.target, g = o.xOrigin, _ = o.yOrigin, x = o.xOffset, M = o.yOffset, b = o.forceCSS, w = parseFloat(h), T = parseFloat(u);
  d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= tl, p *= tl, t = Math.cos(d) * v, n = Math.sin(d) * v, r = Math.sin(d - p) * -m, s = Math.cos(d - p) * m, p && (f *= tl, a = Math.tan(p - f), r *= a = Math.sqrt(1 + a * a), s *= a, f && (a = Math.tan(f), t *= a = Math.sqrt(1 + a * a), n *= a)), t = Ht(t), n = Ht(n), r = Ht(r), s = Ht(s)) : (t = v, s = m, n = r = 0), (w && !~(h + "").indexOf("px") || T && !~(u + "").indexOf("px")) && (w = Ss(y, "x", h, "px"), T = Ss(y, "y", u, "px")), (g || _ || x || M) && (w = Ht(w + g - (g * t + _ * r) + x), T = Ht(T + _ - (g * n + _ * s) + M)), (l || c) && (a = y.getBBox(), w = Ht(w + l / 100 * a.width), T = Ht(T + c / 100 * a.height)), a = "matrix(" + t + "," + n + "," + r + "," + s + "," + w + "," + T + ")", y.setAttribute("transform", a), b && (y.style[It] = a);
}, Q5 = function(i, e, t, n, r) {
  var s, a, o = 360, l = fn(r), c = parseFloat(r) * (l && ~r.indexOf("rad") ? aa : 1) - n, h = n + c + "deg";
  return l && ((s = r.split("_")[1]) === "short" && (c %= o) !== c % 180 && (c += c < 0 ? o : -360), s === "cw" && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : s === "ccw" && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)), i._pt = a = new Wn(i._pt, e, t, n, c, N5), a.e = h, a.u = "deg", i._props.push(t), a;
}, G3 = function(i, e) {
  for (var t in e)
    i[t] = e[t];
  return i;
}, J5 = function(i, e, t) {
  var n, r, s, a, o, l, c, h = G3({}, t._gsap), u = t.style;
  for (r in h.svg ? (s = t.getAttribute("transform"), t.setAttribute("transform", ""), u[It] = e, n = xh(t, 1), Wa(t, It), t.setAttribute("transform", s)) : (s = getComputedStyle(t)[It], u[It] = e, n = xh(t, 1), u[It] = s), Hr)
    (s = h[r]) !== (a = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = En(s) !== (c = En(a)) ? Ss(t, r, s, c) : parseFloat(s), l = parseFloat(a), i._pt = new Wn(i._pt, n, r, o, l - o, O0), i._pt.u = c || 0, i._props.push(r));
  G3(n, h);
};
Vn("padding,margin,Width,Radius", function(i, e) {
  var t = "Top", n = "Right", r = "Bottom", s = "Left", a = (e < 3 ? [t, n, r, s] : [t + s, t + n, r + n, r + s]).map(function(o) {
    return e < 2 ? i + o : "border" + o + i;
  });
  bp[e > 1 ? "border" + i : i] = function(o, l, c, h, u) {
    var d, p;
    if (arguments.length < 4)
      return d = a.map(function(f) {
        return Sr(o, f, c);
      }), (p = d.join(" ")).split(d[0]).length === 5 ? d[0] : p;
    d = (h + "").split(" "), p = {}, a.forEach(function(f, v) {
      return p[f] = d[v] = d[v] || d[(v - 1) / 2 | 0];
    }), o.init(l, p, u);
  };
});
var V3, Wm, Xm, gS = { name: "css", register: k0, targetTest: function(i) {
  return i.style && i.nodeType;
}, init: function(i, e, t, n, r) {
  var s, a, o, l, c, h, u, d, p, f, v, m, y, g, _, x, M = this._props, b = i.style, w = t.vars.startAt;
  for (u in W1 || k0(), this.styles = this.styles || hS(i), x = this.styles.props, this.tween = t, e)
    if (u !== "autoRound" && (a = e[u], !$n[u] || !Jw(u, e, t, n, i, r))) {
      if (c = typeof a, h = bp[u], c === "function" && (c = typeof (a = a.call(t, n, i, r))), c === "string" && ~a.indexOf("random(") && (a = vh(a)), h)
        h(this, i, u, a, t) && (_ = 1);
      else if (u.substr(0, 2) === "--")
        s = (getComputedStyle(i).getPropertyValue(u) + "").trim(), a += "", gs.lastIndex = 0, gs.test(s) || (d = En(s), p = En(a)), p ? d !== p && (s = Ss(i, u, s, p) + p) : d && (a += d), this.add(b, "setProperty", s, a, n, r, 0, 0, u), M.push(u), x.push(u, 0, b[u]);
      else if (c !== "undefined") {
        if (w && u in w ? (s = typeof w[u] == "function" ? w[u].call(t, n, i, r) : w[u], fn(s) && ~s.indexOf("random(") && (s = vh(s)), En(s + "") || s === "auto" || (s += hi.units[u] || En(Sr(i, u)) || ""), (s + "").charAt(1) === "=" && (s = Sr(i, u))) : s = Sr(i, u), l = parseFloat(s), (f = c === "string" && a.charAt(1) === "=" && a.substr(0, 2)) && (a = a.substr(2)), o = parseFloat(a), u in ar && (u === "autoAlpha" && (l === 1 && Sr(i, "visibility") === "hidden" && o && (l = 0), x.push("visibility", 0, b.visibility), cs(this, b, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), u !== "scale" && u !== "transform" && ~(u = ar[u]).indexOf(",") && (u = u.split(",")[0])), v = u in Hr)
          if (this.styles.save(u), m || ((y = i._gsap).renderTransform && !e.parseTransform || xh(i, e.parseTransform), g = e.smoothOrigin !== !1 && y.smooth, (m = this._pt = new Wn(this._pt, b, It, 0, 1, y.renderTransform, y, 0, -1)).dep = 1), u === "scale")
            this._pt = new Wn(this._pt, y, "scaleY", y.scaleY, (f ? Jo(y.scaleY, f + o) : o) - y.scaleY || 0, O0), this._pt.u = 0, M.push("scaleY", u), u += "X";
          else {
            if (u === "transformOrigin") {
              x.push(qn, 0, b[qn]), a = q5(a), y.svg ? F0(i, a, 0, g, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== y.zOrigin && cs(this, y, "zOrigin", y.zOrigin, p), cs(this, b, u, Mp(s), Mp(a)));
              continue;
            }
            if (u === "svgOrigin") {
              F0(i, a, 1, g, 0, this);
              continue;
            }
            if (u in pS) {
              Q5(this, y, u, l, f ? Jo(l, f + a) : a);
              continue;
            }
            if (u === "smoothOrigin") {
              cs(this, y, "smooth", y.smooth, a);
              continue;
            }
            if (u === "force3D") {
              y[u] = a;
              continue;
            }
            if (u === "transform") {
              J5(this, a, i);
              continue;
            }
          }
        else
          u in b || (u = bl(u) || u);
        if (v || (o || o === 0) && (l || l === 0) && !D5.test(a) && u in b)
          o || (o = 0), (d = (s + "").substr((l + "").length)) !== (p = En(a) || (u in hi.units ? hi.units[u] : d)) && (l = Ss(i, u, s, p)), this._pt = new Wn(this._pt, v ? y : b, u, l, (f ? Jo(l, f + o) : o) - l, v || p !== "px" && u !== "zIndex" || e.autoRound === !1 ? O0 : U5), this._pt.u = p || 0, d !== p && p !== "%" && (this._pt.b = s, this._pt.r = O5);
        else if (u in b)
          X5.call(this, i, u, s, f ? f + a : a);
        else if (u in i)
          this.add(i, u, s || i[u], f ? f + a : a, n, r);
        else if (u !== "parseTransform") {
          F1(u, a);
          continue;
        }
        v || (u in b ? x.push(u, 0, b[u]) : x.push(u, 1, s || i[u])), M.push(u);
      }
    }
  _ && rS(this);
}, render: function(i, e) {
  if (e.tween._time || !X1())
    for (var t = e._pt; t; )
      t.r(i, t.d), t = t._next;
  else
    e.styles.revert();
}, get: Sr, aliases: ar, getSetter: function(i, e, t) {
  var n = ar[e];
  return n && n.indexOf(",") < 0 && (e = n), e in Hr && e !== qn && (i._gsap.x || Sr(i, "x")) ? t && U3 === t ? e === "scale" ? z5 : B5 : (U3 = t || {}) && (e === "scale" ? H5 : G5) : i.style && !U1(i.style[e]) ? k5 : ~e.indexOf("-") ? F5 : j1(i, e);
}, core: { _removeProperty: Wa, _getMatrix: Y1 } };
Xn.utils.checkPrefix = bl, Xn.core.getStyleSaver = hS, Xm = Vn((V3 = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Wm = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function(i) {
  Hr[i] = 1;
}), Vn(Wm, function(i) {
  hi.units[i] = "deg", pS[i] = 1;
}), ar[Xm[13]] = V3 + "," + Wm, Vn("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function(i) {
  var e = i.split(":");
  ar[e[1]] = Xm[e[0]];
}), Vn("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(i) {
  hi.units[i] = "px";
}), Xn.registerPlugin(gS);
var Z1 = Xn.registerPlugin(gS) || Xn;
function Ho(i, e) {
  var t = i.__state.conversionName.toString(), n = Math.round(i.r), r = Math.round(i.g), s = Math.round(i.b), a = i.a, o = Math.round(i.h), l = i.s.toFixed(1), c = i.v.toFixed(1);
  if (e || t === "THREE_CHAR_HEX" || t === "SIX_CHAR_HEX") {
    for (var h = i.hex.toString(16); h.length < 6; )
      h = "0" + h;
    return "#" + h;
  }
  return t === "CSS_RGB" ? "rgb(" + n + "," + r + "," + s + ")" : t === "CSS_RGBA" ? "rgba(" + n + "," + r + "," + s + "," + a + ")" : t === "HEX" ? "0x" + i.hex.toString(16) : t === "RGB_ARRAY" ? "[" + n + "," + r + "," + s + "]" : t === "RGBA_ARRAY" ? "[" + n + "," + r + "," + s + "," + a + "]" : t === "RGB_OBJ" ? "{r:" + n + ",g:" + r + ",b:" + s + "}" : t === "RGBA_OBJ" ? "{r:" + n + ",g:" + r + ",b:" + s + ",a:" + a + "}" : t === "HSV_OBJ" ? "{h:" + o + ",s:" + l + ",v:" + c + "}" : t === "HSVA_OBJ" ? "{h:" + o + ",s:" + l + ",v:" + c + ",a:" + a + "}" : "unknown format";
}
Z1.core.Tween;
var j3 = Array.prototype.forEach, uc = Array.prototype.slice, le = { BREAK: {}, extend: function(i) {
  return this.each(uc.call(arguments, 1), function(e) {
    (this.isObject(e) ? Object.keys(e) : []).forEach(function(t) {
      this.isUndefined(e[t]) || (i[t] = e[t]);
    }.bind(this));
  }, this), i;
}, defaults: function(i) {
  return this.each(uc.call(arguments, 1), function(e) {
    (this.isObject(e) ? Object.keys(e) : []).forEach(function(t) {
      this.isUndefined(i[t]) && (i[t] = e[t]);
    }.bind(this));
  }, this), i;
}, compose: function() {
  var i = uc.call(arguments);
  return function() {
    for (var e = uc.call(arguments), t = i.length - 1; t >= 0; t--)
      e = [i[t].apply(this, e)];
    return e[0];
  };
}, each: function(i, e, t) {
  if (i) {
    if (j3 && i.forEach && i.forEach === j3)
      i.forEach(e, t);
    else if (i.length === i.length + 0) {
      var n, r = void 0;
      for (r = 0, n = i.length; r < n; r++)
        if (r in i && e.call(t, i[r], r) === this.BREAK)
          return;
    } else
      for (var s in i)
        if (e.call(t, i[s], s) === this.BREAK)
          return;
  }
}, defer: function(i) {
  setTimeout(i, 0);
}, debounce: function(i, e, t) {
  var n = void 0;
  return function() {
    var r = this, s = arguments, a = t || !n;
    clearTimeout(n), n = setTimeout(function() {
      n = null, t || i.apply(r, s);
    }, e), a && i.apply(r, s);
  };
}, toArray: function(i) {
  return i.toArray ? i.toArray() : uc.call(i);
}, isUndefined: function(i) {
  return i === void 0;
}, isNull: function(i) {
  return i === null;
}, isNaN: function(i) {
  function e(t) {
    return i.apply(this, arguments);
  }
  return e.toString = function() {
    return i.toString();
  }, e;
}(function(i) {
  return isNaN(i);
}), isArray: Array.isArray || function(i) {
  return i.constructor === Array;
}, isObject: function(i) {
  return i === Object(i);
}, isNumber: function(i) {
  return i === i + 0;
}, isString: function(i) {
  return i === i + "";
}, isBoolean: function(i) {
  return i === !1 || i === !0;
}, isFunction: function(i) {
  return i instanceof Function;
} }, $5 = [{ litmus: le.isString, conversions: { THREE_CHAR_HEX: { read: function(i) {
  var e = i.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
  return e !== null && { space: "HEX", hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0) };
}, write: Ho }, SIX_CHAR_HEX: { read: function(i) {
  var e = i.match(/^#([A-F0-9]{6})$/i);
  return e !== null && { space: "HEX", hex: parseInt("0x" + e[1].toString(), 0) };
}, write: Ho }, CSS_RGB: { read: function(i) {
  var e = i.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
  return e !== null && { space: "RGB", r: parseFloat(e[1]), g: parseFloat(e[2]), b: parseFloat(e[3]) };
}, write: Ho }, CSS_RGBA: { read: function(i) {
  var e = i.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
  return e !== null && { space: "RGB", r: parseFloat(e[1]), g: parseFloat(e[2]), b: parseFloat(e[3]), a: parseFloat(e[4]) };
}, write: Ho } } }, { litmus: le.isNumber, conversions: { HEX: { read: function(i) {
  return { space: "HEX", hex: i, conversionName: "HEX" };
}, write: function(i) {
  return i.hex;
} } } }, { litmus: le.isArray, conversions: { RGB_ARRAY: { read: function(i) {
  return i.length === 3 && { space: "RGB", r: i[0], g: i[1], b: i[2] };
}, write: function(i) {
  return [i.r, i.g, i.b];
} }, RGBA_ARRAY: { read: function(i) {
  return i.length === 4 && { space: "RGB", r: i[0], g: i[1], b: i[2], a: i[3] };
}, write: function(i) {
  return [i.r, i.g, i.b, i.a];
} } } }, { litmus: le.isObject, conversions: { RGBA_OBJ: { read: function(i) {
  return !!(le.isNumber(i.r) && le.isNumber(i.g) && le.isNumber(i.b) && le.isNumber(i.a)) && { space: "RGB", r: i.r, g: i.g, b: i.b, a: i.a };
}, write: function(i) {
  return { r: i.r, g: i.g, b: i.b, a: i.a };
} }, RGB_OBJ: { read: function(i) {
  return !!(le.isNumber(i.r) && le.isNumber(i.g) && le.isNumber(i.b)) && { space: "RGB", r: i.r, g: i.g, b: i.b };
}, write: function(i) {
  return { r: i.r, g: i.g, b: i.b };
} }, HSVA_OBJ: { read: function(i) {
  return !!(le.isNumber(i.h) && le.isNumber(i.s) && le.isNumber(i.v) && le.isNumber(i.a)) && { space: "HSV", h: i.h, s: i.s, v: i.v, a: i.a };
}, write: function(i) {
  return { h: i.h, s: i.s, v: i.v, a: i.a };
} }, HSV_OBJ: { read: function(i) {
  return !!(le.isNumber(i.h) && le.isNumber(i.s) && le.isNumber(i.v)) && { space: "HSV", h: i.h, s: i.s, v: i.v };
}, write: function(i) {
  return { h: i.h, s: i.s, v: i.v };
} } } }], dc = void 0, yd = void 0, wp = function() {
  yd = !1;
  var i = arguments.length > 1 ? le.toArray(arguments) : arguments[0];
  return le.each($5, function(e) {
    if (e.litmus(i))
      return le.each(e.conversions, function(t, n) {
        if (dc = t.read(i), yd === !1 && dc !== !1)
          return yd = dc, dc.conversionName = n, dc.conversion = t, le.BREAK;
      }), le.BREAK;
  }), yd;
}, W3 = void 0, Cc = { hsv_to_rgb: function(i, e, t) {
  var n = Math.floor(i / 60) % 6, r = i / 60 - Math.floor(i / 60), s = t * (1 - e), a = t * (1 - r * e), o = t * (1 - (1 - r) * e), l = [[t, o, s], [a, t, s], [s, t, o], [s, a, t], [o, s, t], [t, s, a]][n];
  return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] };
}, rgb_to_hsv: function(i, e, t) {
  var n = Math.min(i, e, t), r = Math.max(i, e, t), s = r - n, a = void 0;
  return r === 0 ? { h: NaN, s: 0, v: 0 } : (a = i === r ? (e - t) / s : e === r ? 2 + (t - i) / s : 4 + (i - e) / s, (a /= 6) < 0 && (a += 1), { h: 360 * a, s: s / r, v: r / 255 });
}, rgb_to_hex: function(i, e, t) {
  var n = this.hex_with_component(0, 2, i);
  return n = this.hex_with_component(n, 1, e), n = this.hex_with_component(n, 0, t);
}, component_from_hex: function(i, e) {
  return i >> 8 * e & 255;
}, hex_with_component: function(i, e, t) {
  return t << (W3 = 8 * e) | i & ~(255 << W3);
} }, eI = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
  return typeof i;
} : function(i) {
  return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
}, Wi = function(i, e) {
  if (!(i instanceof e))
    throw new TypeError("Cannot call a class as a function");
}, Xi = /* @__PURE__ */ function() {
  function i(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
    }
  }
  return function(e, t, n) {
    return t && i(e.prototype, t), n && i(e, n), e;
  };
}(), Ts = function i(e, t, n) {
  e === null && (e = Function.prototype);
  var r = Object.getOwnPropertyDescriptor(e, t);
  if (r === void 0) {
    var s = Object.getPrototypeOf(e);
    return s === null ? void 0 : i(s, t, n);
  }
  if ("value" in r)
    return r.value;
  var a = r.get;
  return a === void 0 ? void 0 : a.call(n);
}, Ds = function(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  i.prototype = Object.create(e && e.prototype, { constructor: { value: i, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(i, e) : i.__proto__ = e);
}, Ns = function(i, e) {
  if (!i)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return !e || typeof e != "object" && typeof e != "function" ? i : e;
}, $t = function() {
  function i() {
    if (Wi(this, i), this.__state = wp.apply(this, arguments), this.__state === !1)
      throw new Error("Failed to interpret color arguments");
    this.__state.a = this.__state.a || 1;
  }
  return Xi(i, [{ key: "toString", value: function() {
    return Ho(this);
  } }, { key: "toHexString", value: function() {
    return Ho(this, !0);
  } }, { key: "toOriginal", value: function() {
    return this.__state.conversion.write(this);
  } }]), i;
}();
function qm(i, e, t) {
  Object.defineProperty(i, e, { get: function() {
    return this.__state.space === "RGB" || $t.recalculateRGB(this, e, t), this.__state[e];
  }, set: function(n) {
    this.__state.space !== "RGB" && ($t.recalculateRGB(this, e, t), this.__state.space = "RGB"), this.__state[e] = n;
  } });
}
function Ym(i, e) {
  Object.defineProperty(i, e, { get: function() {
    return this.__state.space === "HSV" || $t.recalculateHSV(this), this.__state[e];
  }, set: function(t) {
    this.__state.space !== "HSV" && ($t.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t;
  } });
}
$t.recalculateRGB = function(i, e, t) {
  if (i.__state.space === "HEX")
    i.__state[e] = Cc.component_from_hex(i.__state.hex, t);
  else {
    if (i.__state.space !== "HSV")
      throw new Error("Corrupted color state");
    le.extend(i.__state, Cc.hsv_to_rgb(i.__state.h, i.__state.s, i.__state.v));
  }
}, $t.recalculateHSV = function(i) {
  var e = Cc.rgb_to_hsv(i.r, i.g, i.b);
  le.extend(i.__state, { s: e.s, v: e.v }), le.isNaN(e.h) ? le.isUndefined(i.__state.h) && (i.__state.h = 0) : i.__state.h = e.h;
}, $t.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], qm($t.prototype, "r", 2), qm($t.prototype, "g", 1), qm($t.prototype, "b", 0), Ym($t.prototype, "h"), Ym($t.prototype, "s"), Ym($t.prototype, "v"), Object.defineProperty($t.prototype, "a", { get: function() {
  return this.__state.a;
}, set: function(i) {
  this.__state.a = i;
} }), Object.defineProperty($t.prototype, "hex", { get: function() {
  return this.__state.space !== "HEX" && (this.__state.hex = Cc.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex;
}, set: function(i) {
  this.__state.space = "HEX", this.__state.hex = i;
} });
var Os = function() {
  function i(e, t) {
    Wi(this, i), this.initialValue = e[t], this.domElement = document.createElement("div"), this.object = e, this.property = t, this.__onChange = void 0, this.__onFinishChange = void 0;
  }
  return Xi(i, [{ key: "onChange", value: function(e) {
    return this.__onChange = e, this;
  } }, { key: "onFinishChange", value: function(e) {
    return this.__onFinishChange = e, this;
  } }, { key: "setValue", value: function(e) {
    return this.object[this.property] = e, this.__onChange && this.__onChange.call(this, e), this.updateDisplay(), this;
  } }, { key: "getValue", value: function() {
    return this.object[this.property];
  } }, { key: "updateDisplay", value: function() {
    return this;
  } }, { key: "isModified", value: function() {
    return this.initialValue !== this.getValue();
  } }]), i;
}(), vS = {};
le.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, function(i, e) {
  le.each(i, function(t) {
    vS[t] = e;
  });
});
var tI = /(\d+(\.\d+)?)px/;
function Yi(i) {
  if (i === "0" || le.isUndefined(i))
    return 0;
  var e = i.match(tI);
  return le.isNull(e) ? 0 : parseFloat(e[1]);
}
var K = { makeSelectable: function(i, e) {
  i !== void 0 && i.style !== void 0 && (i.onselectstart = e ? function() {
    return !1;
  } : function() {
  }, i.style.MozUserSelect = e ? "auto" : "none", i.style.KhtmlUserSelect = e ? "auto" : "none", i.unselectable = e ? "on" : "off");
}, makeFullscreen: function(i, e, t) {
  var n = t, r = e;
  le.isUndefined(r) && (r = !0), le.isUndefined(n) && (n = !0), i.style.position = "absolute", r && (i.style.left = 0, i.style.right = 0), n && (i.style.top = 0, i.style.bottom = 0);
}, fakeEvent: function(i, e, t, n) {
  var r = t || {}, s = vS[e];
  if (!s)
    throw new Error("Event type " + e + " not supported.");
  var a = document.createEvent(s);
  switch (s) {
    case "MouseEvents":
      var o = r.x || r.clientX || 0, l = r.y || r.clientY || 0;
      a.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, o, l, !1, !1, !1, !1, 0, null);
      break;
    case "KeyboardEvents":
      var c = a.initKeyboardEvent || a.initKeyEvent;
      le.defaults(r, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), c(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
      break;
    default:
      a.initEvent(e, r.bubbles || !1, r.cancelable || !0);
  }
  le.defaults(a, n), i.dispatchEvent(a);
}, bind: function(i, e, t, n) {
  var r = n || !1;
  return i.addEventListener ? i.addEventListener(e, t, r) : i.attachEvent && i.attachEvent("on" + e, t), K;
}, unbind: function(i, e, t, n) {
  var r = n || !1;
  return i.removeEventListener ? i.removeEventListener(e, t, r) : i.detachEvent && i.detachEvent("on" + e, t), K;
}, addClass: function(i, e) {
  if (i.className === void 0)
    i.className = e;
  else if (i.className !== e) {
    var t = i.className.split(/ +/);
    t.indexOf(e) === -1 && (t.push(e), i.className = t.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
  }
  return K;
}, removeClass: function(i, e) {
  if (e)
    if (i.className === e)
      i.removeAttribute("class");
    else {
      var t = i.className.split(/ +/), n = t.indexOf(e);
      n !== -1 && (t.splice(n, 1), i.className = t.join(" "));
    }
  else
    i.className = void 0;
  return K;
}, hasClass: function(i, e) {
  return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(i.className) || !1;
}, getWidth: function(i) {
  var e = getComputedStyle(i);
  return Yi(e["border-left-width"]) + Yi(e["border-right-width"]) + Yi(e["padding-left"]) + Yi(e["padding-right"]) + Yi(e.width);
}, getHeight: function(i) {
  var e = getComputedStyle(i);
  return Yi(e["border-top-width"]) + Yi(e["border-bottom-width"]) + Yi(e["padding-top"]) + Yi(e["padding-bottom"]) + Yi(e.height);
}, getOffset: function(i) {
  var e = i, t = { left: 0, top: 0 };
  if (e.offsetParent)
    do
      t.left += e.offsetLeft, t.top += e.offsetTop, e = e.offsetParent;
    while (e);
  return t;
}, isActive: function(i) {
  return i === document.activeElement && (i.type || i.href);
} }, K1 = function(i) {
  function e(t, n) {
    Wi(this, e);
    var r = Ns(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), s = r;
    return r.__prev = r.getValue(), r.__checkbox = document.createElement("input"), r.__checkbox.setAttribute("type", "checkbox"), K.bind(r.__checkbox, "change", function() {
      s.setValue(!s.__prev);
    }, !1), r.domElement.appendChild(r.__checkbox), r.updateDisplay(), r;
  }
  return Ds(e, Os), Xi(e, [{ key: "setValue", value: function(t) {
    var n = Ts(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n;
  } }, { key: "updateDisplay", value: function() {
    return this.getValue() === !0 ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), Ts(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
  } }]), e;
}(), yS = function(i) {
  function e(t, n, r) {
    Wi(this, e);
    var s = Ns(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), a = r, o = s;
    if (s.__select = document.createElement("select"), le.isArray(a)) {
      var l = {};
      le.each(a, function(c) {
        l[c] = c;
      }), a = l;
    }
    return le.each(a, function(c, h) {
      var u = document.createElement("option");
      u.innerHTML = h, u.setAttribute("value", c), o.__select.appendChild(u);
    }), s.updateDisplay(), K.bind(s.__select, "change", function() {
      var c = this.options[this.selectedIndex].value;
      o.setValue(c);
    }), s.domElement.appendChild(s.__select), s;
  }
  return Ds(e, Os), Xi(e, [{ key: "setValue", value: function(t) {
    var n = Ts(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n;
  } }, { key: "updateDisplay", value: function() {
    return K.isActive(this.__select) ? this : (this.__select.value = this.getValue(), Ts(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this));
  } }]), e;
}(), _S = function(i) {
  function e(t, n) {
    Wi(this, e);
    var r = Ns(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), s = r;
    function a() {
      s.setValue(s.__input.value);
    }
    return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), K.bind(r.__input, "keyup", a), K.bind(r.__input, "change", a), K.bind(r.__input, "blur", function() {
      s.__onFinishChange && s.__onFinishChange.call(s, s.getValue());
    }), K.bind(r.__input, "keydown", function(o) {
      o.keyCode === 13 && this.blur();
    }), r.updateDisplay(), r.domElement.appendChild(r.__input), r;
  }
  return Ds(e, Os), Xi(e, [{ key: "updateDisplay", value: function() {
    return K.isActive(this.__input) || (this.__input.value = this.getValue()), Ts(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
  } }]), e;
}();
function X3(i) {
  var e = i.toString();
  return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0;
}
var Q1 = function(i) {
  function e(t, n, r) {
    Wi(this, e);
    var s = Ns(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), a = r || {};
    return s.__min = a.min, s.__max = a.max, s.__step = a.step, le.isUndefined(s.__step) ? s.initialValue === 0 ? s.__impliedStep = 1 : s.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(s.initialValue)) / Math.LN10)) / 10 : s.__impliedStep = s.__step, s.__precision = X3(s.__impliedStep), s;
  }
  return Ds(e, Os), Xi(e, [{ key: "setValue", value: function(t) {
    var n = t;
    return this.__min !== void 0 && n < this.__min ? n = this.__min : this.__max !== void 0 && n > this.__max && (n = this.__max), this.__step !== void 0 && n % this.__step != 0 && (n = Math.round(n / this.__step) * this.__step), Ts(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n);
  } }, { key: "min", value: function(t) {
    return this.__min = t, this;
  } }, { key: "max", value: function(t) {
    return this.__max = t, this;
  } }, { key: "step", value: function(t) {
    return this.__step = t, this.__impliedStep = t, this.__precision = X3(t), this;
  } }]), e;
}(), bh = function(i) {
  function e(t, n, r) {
    Wi(this, e);
    var s = Ns(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, r));
    s.__truncationSuspended = !1;
    var a = s, o = void 0;
    function l() {
      a.__onFinishChange && a.__onFinishChange.call(a, a.getValue());
    }
    function c(u) {
      var d = o - u.clientY;
      a.setValue(a.getValue() + d * a.__impliedStep), o = u.clientY;
    }
    function h() {
      K.unbind(window, "mousemove", c), K.unbind(window, "mouseup", h), l();
    }
    return s.__input = document.createElement("input"), s.__input.setAttribute("type", "text"), K.bind(s.__input, "change", function() {
      var u = parseFloat(a.__input.value);
      le.isNaN(u) || a.setValue(u);
    }), K.bind(s.__input, "blur", function() {
      l();
    }), K.bind(s.__input, "mousedown", function(u) {
      K.bind(window, "mousemove", c), K.bind(window, "mouseup", h), o = u.clientY;
    }), K.bind(s.__input, "keydown", function(u) {
      u.keyCode === 13 && (a.__truncationSuspended = !0, this.blur(), a.__truncationSuspended = !1, l());
    }), s.updateDisplay(), s.domElement.appendChild(s.__input), s;
  }
  return Ds(e, Q1), Xi(e, [{ key: "updateDisplay", value: function() {
    var t, n, r;
    return this.__input.value = this.__truncationSuspended ? this.getValue() : (t = this.getValue(), n = this.__precision, r = Math.pow(10, n), Math.round(t * r) / r), Ts(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
  } }]), e;
}();
function q3(i, e, t, n, r) {
  return n + (i - e) / (t - e) * (r - n);
}
var Sp = function(i) {
  function e(t, n, r, s, a) {
    Wi(this, e);
    var o = Ns(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, { min: r, max: s, step: a })), l = o;
    function c(p) {
      p.preventDefault();
      var f = l.__background.getBoundingClientRect();
      return l.setValue(q3(p.clientX, f.left, f.right, l.__min, l.__max)), !1;
    }
    function h() {
      K.unbind(window, "mousemove", c), K.unbind(window, "mouseup", h), l.__onFinishChange && l.__onFinishChange.call(l, l.getValue());
    }
    function u(p) {
      var f = p.touches[0].clientX, v = l.__background.getBoundingClientRect();
      l.setValue(q3(f, v.left, v.right, l.__min, l.__max));
    }
    function d() {
      K.unbind(window, "touchmove", u), K.unbind(window, "touchend", d), l.__onFinishChange && l.__onFinishChange.call(l, l.getValue());
    }
    return o.__background = document.createElement("div"), o.__foreground = document.createElement("div"), K.bind(o.__background, "mousedown", function(p) {
      document.activeElement.blur(), K.bind(window, "mousemove", c), K.bind(window, "mouseup", h), c(p);
    }), K.bind(o.__background, "touchstart", function(p) {
      p.touches.length === 1 && (K.bind(window, "touchmove", u), K.bind(window, "touchend", d), u(p));
    }), K.addClass(o.__background, "slider"), K.addClass(o.__foreground, "slider-fg"), o.updateDisplay(), o.__background.appendChild(o.__foreground), o.domElement.appendChild(o.__background), o;
  }
  return Ds(e, Q1), Xi(e, [{ key: "updateDisplay", value: function() {
    var t = (this.getValue() - this.__min) / (this.__max - this.__min);
    return this.__foreground.style.width = 100 * t + "%", Ts(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
  } }]), e;
}(), J1 = function(i) {
  function e(t, n, r) {
    Wi(this, e);
    var s = Ns(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), a = s;
    return s.__button = document.createElement("div"), s.__button.innerHTML = r === void 0 ? "Fire" : r, K.bind(s.__button, "click", function(o) {
      return o.preventDefault(), a.fire(), !1;
    }), K.addClass(s.__button, "button"), s.domElement.appendChild(s.__button), s;
  }
  return Ds(e, Os), Xi(e, [{ key: "fire", value: function() {
    this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
  } }]), e;
}(), Jd = function(i) {
  function e(t, n) {
    Wi(this, e);
    var r = Ns(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
    r.__color = new $t(r.getValue()), r.__temp = new $t(0);
    var s = r;
    r.domElement = document.createElement("div"), K.makeSelectable(r.domElement, !1), r.__selector = document.createElement("div"), r.__selector.className = "selector", r.__saturation_field = document.createElement("div"), r.__saturation_field.className = "saturation-field", r.__field_knob = document.createElement("div"), r.__field_knob.className = "field-knob", r.__field_knob_border = "2px solid ", r.__hue_knob = document.createElement("div"), r.__hue_knob.className = "hue-knob", r.__hue_field = document.createElement("div"), r.__hue_field.className = "hue-field", r.__input = document.createElement("input"), r.__input.type = "text", r.__input_textShadow = "0 1px 1px ", K.bind(r.__input, "keydown", function(m) {
      m.keyCode === 13 && d.call(this);
    }), K.bind(r.__input, "blur", d), K.bind(r.__selector, "mousedown", function() {
      K.addClass(this, "drag").bind(window, "mouseup", function() {
        K.removeClass(s.__selector, "drag");
      });
    }), K.bind(r.__selector, "touchstart", function() {
      K.addClass(this, "drag").bind(window, "touchend", function() {
        K.removeClass(s.__selector, "drag");
      });
    });
    var a, o = document.createElement("div");
    function l(m) {
      f(m), K.bind(window, "mousemove", f), K.bind(window, "touchmove", f), K.bind(window, "mouseup", h), K.bind(window, "touchend", h);
    }
    function c(m) {
      v(m), K.bind(window, "mousemove", v), K.bind(window, "touchmove", v), K.bind(window, "mouseup", u), K.bind(window, "touchend", u);
    }
    function h() {
      K.unbind(window, "mousemove", f), K.unbind(window, "touchmove", f), K.unbind(window, "mouseup", h), K.unbind(window, "touchend", h), p();
    }
    function u() {
      K.unbind(window, "mousemove", v), K.unbind(window, "touchmove", v), K.unbind(window, "mouseup", u), K.unbind(window, "touchend", u), p();
    }
    function d() {
      var m = wp(this.value);
      m !== !1 ? (s.__color.__state = m, s.setValue(s.__color.toOriginal())) : this.value = s.__color.toString();
    }
    function p() {
      s.__onFinishChange && s.__onFinishChange.call(s, s.__color.toOriginal());
    }
    function f(m) {
      m.type.indexOf("touch") === -1 && m.preventDefault();
      var y = s.__saturation_field.getBoundingClientRect(), g = m.touches && m.touches[0] || m, _ = g.clientX, x = g.clientY, M = (_ - y.left) / (y.right - y.left), b = 1 - (x - y.top) / (y.bottom - y.top);
      return b > 1 ? b = 1 : b < 0 && (b = 0), M > 1 ? M = 1 : M < 0 && (M = 0), s.__color.v = b, s.__color.s = M, s.setValue(s.__color.toOriginal()), !1;
    }
    function v(m) {
      m.type.indexOf("touch") === -1 && m.preventDefault();
      var y = s.__hue_field.getBoundingClientRect(), g = 1 - ((m.touches && m.touches[0] || m).clientY - y.top) / (y.bottom - y.top);
      return g > 1 ? g = 1 : g < 0 && (g = 0), s.__color.h = 360 * g, s.setValue(s.__color.toOriginal()), !1;
    }
    return le.extend(r.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), le.extend(r.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: r.__field_knob_border + (r.__color.v < 0.5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), le.extend(r.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), le.extend(r.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), le.extend(o.style, { width: "100%", height: "100%", background: "none" }), Y3(o, "top", "rgba(0,0,0,0)", "#000"), le.extend(r.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), (a = r.__hue_field).style.background = "", a.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", a.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", le.extend(r.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: r.__input_textShadow + "rgba(0,0,0,0.7)" }), K.bind(r.__saturation_field, "mousedown", l), K.bind(r.__saturation_field, "touchstart", l), K.bind(r.__field_knob, "mousedown", l), K.bind(r.__field_knob, "touchstart", l), K.bind(r.__hue_field, "mousedown", c), K.bind(r.__hue_field, "touchstart", c), r.__saturation_field.appendChild(o), r.__selector.appendChild(r.__field_knob), r.__selector.appendChild(r.__saturation_field), r.__selector.appendChild(r.__hue_field), r.__hue_field.appendChild(r.__hue_knob), r.domElement.appendChild(r.__input), r.domElement.appendChild(r.__selector), r.updateDisplay(), r;
  }
  return Ds(e, Os), Xi(e, [{ key: "updateDisplay", value: function() {
    var t = wp(this.getValue());
    if (t !== !1) {
      var n = !1;
      le.each($t.COMPONENTS, function(a) {
        if (!le.isUndefined(t[a]) && !le.isUndefined(this.__color.__state[a]) && t[a] !== this.__color.__state[a])
          return n = !0, {};
      }, this), n && le.extend(this.__color.__state, t);
    }
    le.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
    var r = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0, s = 255 - r;
    le.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + r + "," + r + "," + r + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, Y3(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), le.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + r + "," + r + "," + r + ")", textShadow: this.__input_textShadow + "rgba(" + s + "," + s + "," + s + ",.7)" });
  } }]), e;
}(), nI = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
function Y3(i, e, t, n) {
  i.style.background = "", le.each(nI, function(r) {
    i.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + t + " 0%, " + n + " 100%); ";
  });
}
var iI = function(i, e) {
  var t = e || document, n = document.createElement("style");
  n.type = "text/css", n.innerHTML = i;
  var r = t.getElementsByTagName("head")[0];
  try {
    r.appendChild(n);
  } catch (s) {
  }
}, rI = function(i, e) {
  var t = i[e];
  return le.isArray(arguments[2]) || le.isObject(arguments[2]) ? new yS(i, e, arguments[2]) : le.isNumber(t) ? le.isNumber(arguments[2]) && le.isNumber(arguments[3]) ? le.isNumber(arguments[4]) ? new Sp(i, e, arguments[2], arguments[3], arguments[4]) : new Sp(i, e, arguments[2], arguments[3]) : le.isNumber(arguments[4]) ? new bh(i, e, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new bh(i, e, { min: arguments[2], max: arguments[3] }) : le.isString(t) ? new _S(i, e) : le.isFunction(t) ? new J1(i, e, "") : le.isBoolean(t) ? new K1(i, e) : null;
}, sI = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(i) {
  setTimeout(i, 1e3 / 60);
}, aI = function() {
  function i() {
    Wi(this, i), this.backgroundElement = document.createElement("div"), le.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), K.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), le.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
    var e = this;
    K.bind(this.backgroundElement, "click", function() {
      e.hide();
    });
  }
  return Xi(i, [{ key: "show", value: function() {
    var e = this;
    this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), le.defer(function() {
      e.backgroundElement.style.opacity = 1, e.domElement.style.opacity = 1, e.domElement.style.webkitTransform = "scale(1)";
    });
  } }, { key: "hide", value: function() {
    var e = this, t = function n() {
      e.domElement.style.display = "none", e.backgroundElement.style.display = "none", K.unbind(e.domElement, "webkitTransitionEnd", n), K.unbind(e.domElement, "transitionend", n), K.unbind(e.domElement, "oTransitionEnd", n);
    };
    K.bind(this.domElement, "webkitTransitionEnd", t), K.bind(this.domElement, "transitionend", t), K.bind(this.domElement, "oTransitionEnd", t), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
  } }, { key: "layout", value: function() {
    this.domElement.style.left = window.innerWidth / 2 - K.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - K.getHeight(this.domElement) / 2 + "px";
  } }]), i;
}(), oI = function(i) {
  if (typeof window != "undefined") {
    var e = document.createElement("style");
    return e.setAttribute("type", "text/css"), e.innerHTML = i, document.head.appendChild(e), i;
  }
}(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);
iI(oI);
var Mh = "Default", Rc = function() {
  try {
    return !!window.localStorage;
  } catch (i) {
    return !1;
  }
}(), _d = void 0, Z3 = !0, Lo = void 0, Zm = !1, xS = [], pt = function i(e) {
  var t = this, n = e || {};
  this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), K.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], n = le.defaults(n, { closeOnTop: !1, autoPlace: !0, width: i.DEFAULT_WIDTH }), n = le.defaults(n, { resizable: n.autoPlace, hideable: n.autoPlace }), le.isUndefined(n.load) ? n.load = { preset: Mh } : n.preset && (n.load.preset = n.preset), le.isUndefined(n.parent) && n.hideable && xS.push(this), n.resizable = le.isUndefined(n.parent) && n.resizable, n.autoPlace && le.isUndefined(n.scrollable) && (n.scrollable = !0);
  var r, s = Rc && localStorage.getItem(Do(this, "isLocal")) === "true", a = void 0, o = void 0;
  if (Object.defineProperties(this, { parent: { get: function() {
    return n.parent;
  } }, scrollable: { get: function() {
    return n.scrollable;
  } }, autoPlace: { get: function() {
    return n.autoPlace;
  } }, closeOnTop: { get: function() {
    return n.closeOnTop;
  } }, preset: { get: function() {
    return t.parent ? t.getRoot().preset : n.load.preset;
  }, set: function(h) {
    t.parent ? t.getRoot().preset = h : n.load.preset = h, function(u) {
      for (var d = 0; d < u.__preset_select.length; d++)
        u.__preset_select[d].value === u.preset && (u.__preset_select.selectedIndex = d);
    }(this), t.revert();
  } }, width: { get: function() {
    return n.width;
  }, set: function(h) {
    n.width = h, z0(t, h);
  } }, name: { get: function() {
    return n.name;
  }, set: function(h) {
    n.name = h, o && (o.innerHTML = n.name);
  } }, closed: { get: function() {
    return n.closed;
  }, set: function(h) {
    n.closed = h, n.closed ? K.addClass(t.__ul, i.CLASS_CLOSED) : K.removeClass(t.__ul, i.CLASS_CLOSED), this.onResize(), t.__closeButton && (t.__closeButton.innerHTML = h ? i.TEXT_OPEN : i.TEXT_CLOSED);
  } }, load: { get: function() {
    return n.load;
  } }, useLocalStorage: { get: function() {
    return s;
  }, set: function(h) {
    Rc && (s = h, h ? K.bind(window, "unload", a) : K.unbind(window, "unload", a), localStorage.setItem(Do(t, "isLocal"), h));
  } } }), le.isUndefined(n.parent)) {
    if (this.closed = n.closed || !1, K.addClass(this.domElement, i.CLASS_MAIN), K.makeSelectable(this.domElement, !1), Rc && s) {
      t.useLocalStorage = !0;
      var l = localStorage.getItem(Do(this, "gui"));
      l && (n.load = JSON.parse(l));
    }
    this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = i.TEXT_CLOSED, K.addClass(this.__closeButton, i.CLASS_CLOSE_BUTTON), n.closeOnTop ? (K.addClass(this.__closeButton, i.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (K.addClass(this.__closeButton, i.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), K.bind(this.__closeButton, "click", function() {
      t.closed = !t.closed;
    });
  } else {
    n.closed === void 0 && (n.closed = !0);
    var c = document.createTextNode(n.name);
    K.addClass(c, "controller-name"), o = $1(t, c), K.addClass(this.__ul, i.CLASS_CLOSED), K.addClass(o, "title"), K.bind(o, "click", function(h) {
      return h.preventDefault(), t.closed = !t.closed, !1;
    }), n.closed || (this.closed = !1);
  }
  n.autoPlace && (le.isUndefined(n.parent) && (Z3 && (Lo = document.createElement("div"), K.addClass(Lo, "dg"), K.addClass(Lo, i.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Lo), Z3 = !1), Lo.appendChild(this.domElement), K.addClass(this.domElement, i.CLASS_AUTO_PLACE)), this.parent || z0(t, n.width)), this.__resizeHandler = function() {
    t.onResizeDebounced();
  }, K.bind(window, "resize", this.__resizeHandler), K.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), K.bind(this.__ul, "transitionend", this.__resizeHandler), K.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), n.resizable && lI(this), a = function() {
    Rc && localStorage.getItem(Do(t, "isLocal")) === "true" && localStorage.setItem(Do(t, "gui"), JSON.stringify(t.getSaveObject()));
  }, this.saveToLocalStorageIfPossible = a, n.parent || ((r = t.getRoot()).width += 1, le.defer(function() {
    r.width -= 1;
  }));
};
function $1(i, e, t) {
  var n = document.createElement("li");
  return e && n.appendChild(e), t ? i.__ul.insertBefore(n, t) : i.__ul.appendChild(n), i.onResize(), n;
}
function K3(i) {
  K.unbind(window, "resize", i.__resizeHandler), i.saveToLocalStorageIfPossible && K.unbind(window, "unload", i.saveToLocalStorageIfPossible);
}
function B0(i, e) {
  var t = i.__preset_select[i.__preset_select.selectedIndex];
  t.innerHTML = e ? t.value + "*" : t.value;
}
function bS(i, e) {
  var t = i.getRoot(), n = t.__rememberedObjects.indexOf(e.object);
  if (n !== -1) {
    var r = t.__rememberedObjectIndecesToControllers[n];
    if (r === void 0 && (r = {}, t.__rememberedObjectIndecesToControllers[n] = r), r[e.property] = e, t.load && t.load.remembered) {
      var s = t.load.remembered, a = void 0;
      if (s[i.preset])
        a = s[i.preset];
      else {
        if (!s[Mh])
          return;
        a = s[Mh];
      }
      if (a[n] && a[n][e.property] !== void 0) {
        var o = a[n][e.property];
        e.initialValue = o, e.setValue(o);
      }
    }
  }
}
function Vc(i, e, t, n) {
  if (e[t] === void 0)
    throw new Error('Object "' + e + '" has no property "' + t + '"');
  var r = void 0;
  if (n.color)
    r = new Jd(e, t);
  else {
    var s = [e, t].concat(n.factoryArgs);
    r = rI.apply(i, s);
  }
  n.before instanceof Os && (n.before = n.before.__li), bS(i, r), K.addClass(r.domElement, "c");
  var a = document.createElement("span");
  K.addClass(a, "property-name"), a.innerHTML = r.property;
  var o = document.createElement("div");
  o.appendChild(a), o.appendChild(r.domElement);
  var l = $1(i, o, n.before);
  return K.addClass(l, pt.CLASS_CONTROLLER_ROW), r instanceof Jd ? K.addClass(l, "color") : K.addClass(l, eI(r.getValue())), function(c, h, u) {
    if (u.__li = h, u.__gui = c, le.extend(u, { options: function(f) {
      if (arguments.length > 1) {
        var v = u.__li.nextElementSibling;
        return u.remove(), Vc(c, u.object, u.property, { before: v, factoryArgs: [le.toArray(arguments)] });
      }
      if (le.isArray(f) || le.isObject(f)) {
        var m = u.__li.nextElementSibling;
        return u.remove(), Vc(c, u.object, u.property, { before: m, factoryArgs: [f] });
      }
    }, name: function(f) {
      return u.__li.firstElementChild.firstElementChild.innerHTML = f, u;
    }, listen: function() {
      return u.__gui.listen(u), u;
    }, remove: function() {
      return u.__gui.remove(u), u;
    } }), u instanceof Sp) {
      var d = new bh(u.object, u.property, { min: u.__min, max: u.__max, step: u.__step });
      le.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(f) {
        var v = u[f], m = d[f];
        u[f] = d[f] = function() {
          var y = Array.prototype.slice.call(arguments);
          return m.apply(d, y), v.apply(u, y);
        };
      }), K.addClass(h, "has-slider"), u.domElement.insertBefore(d.domElement, u.domElement.firstElementChild);
    } else if (u instanceof bh) {
      var p = function(f) {
        if (le.isNumber(u.__min) && le.isNumber(u.__max)) {
          var v = u.__li.firstElementChild.firstElementChild.innerHTML, m = u.__gui.__listening.indexOf(u) > -1;
          u.remove();
          var y = Vc(c, u.object, u.property, { before: u.__li.nextElementSibling, factoryArgs: [u.__min, u.__max, u.__step] });
          return y.name(v), m && y.listen(), y;
        }
        return f;
      };
      u.min = le.compose(p, u.min), u.max = le.compose(p, u.max);
    } else
      u instanceof K1 ? (K.bind(h, "click", function() {
        K.fakeEvent(u.__checkbox, "click");
      }), K.bind(u.__checkbox, "click", function(f) {
        f.stopPropagation();
      })) : u instanceof J1 ? (K.bind(h, "click", function() {
        K.fakeEvent(u.__button, "click");
      }), K.bind(h, "mouseover", function() {
        K.addClass(u.__button, "hover");
      }), K.bind(h, "mouseout", function() {
        K.removeClass(u.__button, "hover");
      })) : u instanceof Jd && (K.addClass(h, "color"), u.updateDisplay = le.compose(function(f) {
        return h.style.borderLeftColor = u.__color.toString(), f;
      }, u.updateDisplay), u.updateDisplay());
    u.setValue = le.compose(function(f) {
      return c.getRoot().__preset_select && u.isModified() && B0(c.getRoot(), !0), f;
    }, u.setValue);
  }(i, l, r), i.__controllers.push(r), r;
}
function Do(i, e) {
  return document.location.href + "." + e;
}
function Km(i, e, t) {
  var n = document.createElement("option");
  n.innerHTML = e, n.value = e, i.__preset_select.appendChild(n), t && (i.__preset_select.selectedIndex = i.__preset_select.length - 1);
}
function Q3(i, e) {
  e.style.display = i.useLocalStorage ? "block" : "none";
}
function lI(i) {
  var e = void 0;
  function t(s) {
    return s.preventDefault(), i.width += e - s.clientX, i.onResize(), e = s.clientX, !1;
  }
  function n() {
    K.removeClass(i.__closeButton, pt.CLASS_DRAG), K.unbind(window, "mousemove", t), K.unbind(window, "mouseup", n);
  }
  function r(s) {
    return s.preventDefault(), e = s.clientX, K.addClass(i.__closeButton, pt.CLASS_DRAG), K.bind(window, "mousemove", t), K.bind(window, "mouseup", n), !1;
  }
  i.__resize_handle = document.createElement("div"), le.extend(i.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), K.bind(i.__resize_handle, "mousedown", r), K.bind(i.__closeButton, "mousedown", r), i.domElement.insertBefore(i.__resize_handle, i.domElement.firstElementChild);
}
function z0(i, e) {
  i.domElement.style.width = e + "px", i.__save_row && i.autoPlace && (i.__save_row.style.width = e + "px"), i.__closeButton && (i.__closeButton.style.width = e + "px");
}
function xd(i, e) {
  var t = {};
  return le.each(i.__rememberedObjects, function(n, r) {
    var s = {}, a = i.__rememberedObjectIndecesToControllers[r];
    le.each(a, function(o, l) {
      s[l] = e ? o.initialValue : o.getValue();
    }), t[r] = s;
  }), t;
}
function MS(i) {
  i.length !== 0 && sI.call(window, function() {
    MS(i);
  }), le.each(i, function(e) {
    e.updateDisplay();
  });
}
pt.toggleHide = function() {
  Zm = !Zm, le.each(xS, function(i) {
    i.domElement.style.display = Zm ? "none" : "";
  });
}, pt.CLASS_AUTO_PLACE = "a", pt.CLASS_AUTO_PLACE_CONTAINER = "ac", pt.CLASS_MAIN = "main", pt.CLASS_CONTROLLER_ROW = "cr", pt.CLASS_TOO_TALL = "taller-than-window", pt.CLASS_CLOSED = "closed", pt.CLASS_CLOSE_BUTTON = "close-button", pt.CLASS_CLOSE_TOP = "close-top", pt.CLASS_CLOSE_BOTTOM = "close-bottom", pt.CLASS_DRAG = "drag", pt.DEFAULT_WIDTH = 245, pt.TEXT_CLOSED = "Close Controls", pt.TEXT_OPEN = "Open Controls", pt._keydownHandler = function(i) {
  document.activeElement.type === "text" || i.which !== 72 && i.keyCode !== 72 || pt.toggleHide();
}, K.bind(window, "keydown", pt._keydownHandler, !1), le.extend(pt.prototype, { add: function(i, e) {
  return Vc(this, i, e, { factoryArgs: Array.prototype.slice.call(arguments, 2) });
}, addColor: function(i, e) {
  return Vc(this, i, e, { color: !0 });
}, remove: function(i) {
  this.__ul.removeChild(i.__li), this.__controllers.splice(this.__controllers.indexOf(i), 1);
  var e = this;
  le.defer(function() {
    e.onResize();
  });
}, destroy: function() {
  if (this.parent)
    throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
  this.autoPlace && Lo.removeChild(this.domElement);
  var i = this;
  le.each(this.__folders, function(e) {
    i.removeFolder(e);
  }), K.unbind(window, "keydown", pt._keydownHandler, !1), K3(this);
}, addFolder: function(i) {
  if (this.__folders[i] !== void 0)
    throw new Error('You already have a folder in this GUI by the name "' + i + '"');
  var e = { name: i, parent: this };
  e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[i] && (e.closed = this.load.folders[i].closed, e.load = this.load.folders[i]);
  var t = new pt(e);
  this.__folders[i] = t;
  var n = $1(this, t.domElement);
  return K.addClass(n, "folder"), t;
}, removeFolder: function(i) {
  this.__ul.removeChild(i.domElement.parentElement), delete this.__folders[i.name], this.load && this.load.folders && this.load.folders[i.name] && delete this.load.folders[i.name], K3(i);
  var e = this;
  le.each(i.__folders, function(t) {
    i.removeFolder(t);
  }), le.defer(function() {
    e.onResize();
  });
}, open: function() {
  this.closed = !1;
}, close: function() {
  this.closed = !0;
}, hide: function() {
  this.domElement.style.display = "none";
}, show: function() {
  this.domElement.style.display = "";
}, onResize: function() {
  var i = this.getRoot();
  if (i.scrollable) {
    var e = K.getOffset(i.__ul).top, t = 0;
    le.each(i.__ul.childNodes, function(n) {
      i.autoPlace && n === i.__save_row || (t += K.getHeight(n));
    }), window.innerHeight - e - 20 < t ? (K.addClass(i.domElement, pt.CLASS_TOO_TALL), i.__ul.style.height = window.innerHeight - e - 20 + "px") : (K.removeClass(i.domElement, pt.CLASS_TOO_TALL), i.__ul.style.height = "auto");
  }
  i.__resize_handle && le.defer(function() {
    i.__resize_handle.style.height = i.__ul.offsetHeight + "px";
  }), i.__closeButton && (i.__closeButton.style.width = i.width + "px");
}, onResizeDebounced: le.debounce(function() {
  this.onResize();
}, 50), remember: function() {
  if (le.isUndefined(_d) && ((_d = new aI()).domElement.innerHTML = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`), this.parent)
    throw new Error("You can only call remember on a top level GUI.");
  var i = this;
  le.each(Array.prototype.slice.call(arguments), function(e) {
    i.__rememberedObjects.length === 0 && function(t) {
      var n = t.__save_row = document.createElement("li");
      K.addClass(t.domElement, "has-save"), t.__ul.insertBefore(n, t.__ul.firstChild), K.addClass(n, "save-row");
      var r = document.createElement("span");
      r.innerHTML = "&nbsp;", K.addClass(r, "button gears");
      var s = document.createElement("span");
      s.innerHTML = "Save", K.addClass(s, "button"), K.addClass(s, "save");
      var a = document.createElement("span");
      a.innerHTML = "New", K.addClass(a, "button"), K.addClass(a, "save-as");
      var o = document.createElement("span");
      o.innerHTML = "Revert", K.addClass(o, "button"), K.addClass(o, "revert");
      var l = t.__preset_select = document.createElement("select");
      if (t.load && t.load.remembered ? le.each(t.load.remembered, function(d, p) {
        Km(t, p, p === t.preset);
      }) : Km(t, Mh, !1), K.bind(l, "change", function() {
        for (var d = 0; d < t.__preset_select.length; d++)
          t.__preset_select[d].innerHTML = t.__preset_select[d].value;
        t.preset = this.value;
      }), n.appendChild(l), n.appendChild(r), n.appendChild(s), n.appendChild(a), n.appendChild(o), Rc) {
        var c = document.getElementById("dg-local-explain"), h = document.getElementById("dg-local-storage");
        document.getElementById("dg-save-locally").style.display = "block", localStorage.getItem(Do(t, "isLocal")) === "true" && h.setAttribute("checked", "checked"), Q3(t, c), K.bind(h, "change", function() {
          t.useLocalStorage = !t.useLocalStorage, Q3(t, c);
        });
      }
      var u = document.getElementById("dg-new-constructor");
      K.bind(u, "keydown", function(d) {
        !d.metaKey || d.which !== 67 && d.keyCode !== 67 || _d.hide();
      }), K.bind(r, "click", function() {
        u.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), _d.show(), u.focus(), u.select();
      }), K.bind(s, "click", function() {
        t.save();
      }), K.bind(a, "click", function() {
        var d = prompt("Enter a new preset name.");
        d && t.saveAs(d);
      }), K.bind(o, "click", function() {
        t.revert();
      });
    }(i), i.__rememberedObjects.indexOf(e) === -1 && i.__rememberedObjects.push(e);
  }), this.autoPlace && z0(this, this.width);
}, getRoot: function() {
  for (var i = this; i.parent; )
    i = i.parent;
  return i;
}, getSaveObject: function() {
  var i = this.load;
  return i.closed = this.closed, this.__rememberedObjects.length > 0 && (i.preset = this.preset, i.remembered || (i.remembered = {}), i.remembered[this.preset] = xd(this)), i.folders = {}, le.each(this.__folders, function(e, t) {
    i.folders[t] = e.getSaveObject();
  }), i;
}, save: function() {
  this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = xd(this), B0(this, !1), this.saveToLocalStorageIfPossible();
}, saveAs: function(i) {
  this.load.remembered || (this.load.remembered = {}, this.load.remembered[Mh] = xd(this, !0)), this.load.remembered[i] = xd(this), this.preset = i, Km(this, i, !0), this.saveToLocalStorageIfPossible();
}, revert: function(i) {
  le.each(this.__controllers, function(e) {
    this.getRoot().load.remembered ? bS(i || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue());
  }, this), le.each(this.__folders, function(e) {
    e.revert(e);
  }), i || B0(this.getRoot(), !1);
}, listen: function(i) {
  var e = this.__listening.length === 0;
  this.__listening.push(i), e && MS(this.__listening);
}, updateDisplay: function() {
  le.each(this.__controllers, function(i) {
    i.updateDisplay();
  }), le.each(this.__folders, function(i) {
    i.updateDisplay();
  });
} });
var wS = { Color: $t, math: Cc, interpret: wp }, SS = { Controller: Os, BooleanController: K1, OptionController: yS, StringController: _S, NumberController: Q1, NumberControllerBox: bh, NumberControllerSlider: Sp, FunctionController: J1, ColorController: Jd }, TS = { dom: K }, ES = { GUI: pt }, Tp = pt, cI = { color: wS, controllers: SS, dom: TS, gui: ES, GUI: Tp };
const To = Object.freeze(Object.defineProperty({ __proto__: null, GUI: Tp, color: wS, controllers: SS, default: cI, dom: TS, gui: ES }, Symbol.toStringTag, { value: "Module" }));
var Pa = 1, La = 2, nl = 3, hI = 4, H0 = 5, J3 = 6378137, uI = 6356752314e-3, $3 = 0.0066943799901413165, jc = 484813681109536e-20, pe = Math.PI / 2, dI = 0.16666666666666666, pI = 0.04722222222222222, fI = 0.022156084656084655, we = 1e-10, _n = 0.017453292519943295, or = 57.29577951308232, ht = Math.PI / 4, wh = 2 * Math.PI, kt = 3.14159265359, mI = { greenwich: 0, lisbon: -9.131906111111, paris: 2.337229166667, bogota: -74.080916666667, madrid: -3.687938888889, rome: 12.452333333333, bern: 7.439583333333, jakarta: 106.807719444444, ferro: -17.666666666667, brussels: 4.367975, stockholm: 18.058277777778, athens: 23.7163375, oslo: 10.722916666667 };
const gI = { ft: { to_meter: 0.3048 }, "us-ft": { to_meter: 1200 / 3937 } };
var eb = /[\s_\-\/\(\)]/g;
function hs(i, e) {
  if (i[e])
    return i[e];
  for (var t, n = Object.keys(i), r = e.toLowerCase().replace(eb, ""), s = -1; ++s < n.length; )
    if ((t = n[s]).toLowerCase().replace(eb, "") === r)
      return i[t];
}
function G0(i) {
  var e, t, n, r = {}, s = i.split("+").map(function(o) {
    return o.trim();
  }).filter(function(o) {
    return o;
  }).reduce(function(o, l) {
    var c = l.split("=");
    return c.push(!0), o[c[0].toLowerCase()] = c[1], o;
  }, {}), a = { proj: "projName", datum: "datumCode", rf: function(o) {
    r.rf = parseFloat(o);
  }, lat_0: function(o) {
    r.lat0 = o * _n;
  }, lat_1: function(o) {
    r.lat1 = o * _n;
  }, lat_2: function(o) {
    r.lat2 = o * _n;
  }, lat_ts: function(o) {
    r.lat_ts = o * _n;
  }, lon_0: function(o) {
    r.long0 = o * _n;
  }, lon_1: function(o) {
    r.long1 = o * _n;
  }, lon_2: function(o) {
    r.long2 = o * _n;
  }, alpha: function(o) {
    r.alpha = parseFloat(o) * _n;
  }, gamma: function(o) {
    r.rectified_grid_angle = parseFloat(o);
  }, lonc: function(o) {
    r.longc = o * _n;
  }, x_0: function(o) {
    r.x0 = parseFloat(o);
  }, y_0: function(o) {
    r.y0 = parseFloat(o);
  }, k_0: function(o) {
    r.k0 = parseFloat(o);
  }, k: function(o) {
    r.k0 = parseFloat(o);
  }, a: function(o) {
    r.a = parseFloat(o);
  }, b: function(o) {
    r.b = parseFloat(o);
  }, r: function(o) {
    r.a = r.b = parseFloat(o);
  }, r_a: function() {
    r.R_A = !0;
  }, zone: function(o) {
    r.zone = parseInt(o, 10);
  }, south: function() {
    r.utmSouth = !0;
  }, towgs84: function(o) {
    r.datum_params = o.split(",").map(function(l) {
      return parseFloat(l);
    });
  }, to_meter: function(o) {
    r.to_meter = parseFloat(o);
  }, units: function(o) {
    r.units = o;
    var l = hs(gI, o);
    l && (r.to_meter = l.to_meter);
  }, from_greenwich: function(o) {
    r.from_greenwich = o * _n;
  }, pm: function(o) {
    var l = hs(mI, o);
    r.from_greenwich = (l || parseFloat(o)) * _n;
  }, nadgrids: function(o) {
    o === "@null" ? r.datumCode = "none" : r.nadgrids = o;
  }, axis: function(o) {
    var l = "ewnsud";
    o.length === 3 && l.indexOf(o.substr(0, 1)) !== -1 && l.indexOf(o.substr(1, 1)) !== -1 && l.indexOf(o.substr(2, 1)) !== -1 && (r.axis = o);
  }, approx: function() {
    r.approx = !0;
  } };
  for (e in s)
    t = s[e], e in a ? typeof (n = a[e]) == "function" ? n(t) : r[n] = t : r[e] = t;
  return typeof r.datumCode == "string" && r.datumCode !== "WGS84" && (r.datumCode = r.datumCode.toLowerCase()), r;
}
var Pc = 1, vI = /\s/, yI = /[A-Za-z]/, _I = /[A-Za-z84_]/, bd = /[,\]]/, tb = /[\d\.E\-\+]/;
function br(i) {
  if (typeof i != "string")
    throw new Error("not a string");
  this.text = i.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Pc;
}
function nb(i, e, t) {
  Array.isArray(e) && (t.unshift(e), e = null);
  var n = e ? {} : i, r = t.reduce(function(s, a) {
    return Go(a, s), s;
  }, n);
  e && (i[e] = r);
}
function Go(i, e) {
  if (Array.isArray(i)) {
    var t = i.shift();
    if (t === "PARAMETER" && (t = i.shift()), i.length === 1)
      return Array.isArray(i[0]) ? (e[t] = {}, void Go(i[0], e[t])) : void (e[t] = i[0]);
    if (i.length)
      if (t !== "TOWGS84") {
        if (t === "AXIS")
          return t in e || (e[t] = []), void e[t].push(i);
        var n;
        switch (Array.isArray(t) || (e[t] = {}), t) {
          case "UNIT":
          case "PRIMEM":
          case "VERT_DATUM":
            return e[t] = { name: i[0].toLowerCase(), convert: i[1] }, void (i.length === 3 && Go(i[2], e[t]));
          case "SPHEROID":
          case "ELLIPSOID":
            return e[t] = { name: i[0], a: i[1], rf: i[2] }, void (i.length === 4 && Go(i[3], e[t]));
          case "PROJECTEDCRS":
          case "PROJCRS":
          case "GEOGCS":
          case "GEOCCS":
          case "PROJCS":
          case "LOCAL_CS":
          case "GEODCRS":
          case "GEODETICCRS":
          case "GEODETICDATUM":
          case "EDATUM":
          case "ENGINEERINGDATUM":
          case "VERT_CS":
          case "VERTCRS":
          case "VERTICALCRS":
          case "COMPD_CS":
          case "COMPOUNDCRS":
          case "ENGINEERINGCRS":
          case "ENGCRS":
          case "FITTED_CS":
          case "LOCAL_DATUM":
          case "DATUM":
            return i[0] = ["name", i[0]], void nb(e, t, i);
          default:
            for (n = -1; ++n < i.length; )
              if (!Array.isArray(i[n]))
                return Go(i, e[t]);
            return nb(e, t, i);
        }
      } else
        e[t] = i;
    else
      e[t] = !0;
  } else
    e[i] = !0;
}
br.prototype.readCharicter = function() {
  var i = this.text[this.place++];
  if (this.state !== 4)
    for (; vI.test(i); ) {
      if (this.place >= this.text.length)
        return;
      i = this.text[this.place++];
    }
  switch (this.state) {
    case Pc:
      return this.neutral(i);
    case 2:
      return this.keyword(i);
    case 4:
      return this.quoted(i);
    case 5:
      return this.afterquote(i);
    case 3:
      return this.number(i);
    case -1:
      return;
  }
}, br.prototype.afterquote = function(i) {
  if (i === '"')
    return this.word += '"', void (this.state = 4);
  if (bd.test(i))
    return this.word = this.word.trim(), void this.afterItem(i);
  throw new Error(`havn't handled "` + i + '" in afterquote yet, index ' + this.place);
}, br.prototype.afterItem = function(i) {
  return i === "," ? (this.word !== null && this.currentObject.push(this.word), this.word = null, void (this.state = Pc)) : i === "]" ? (this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Pc, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = -1))) : void 0;
}, br.prototype.number = function(i) {
  if (!tb.test(i)) {
    if (bd.test(i))
      return this.word = parseFloat(this.word), void this.afterItem(i);
    throw new Error(`havn't handled "` + i + '" in number yet, index ' + this.place);
  }
  this.word += i;
}, br.prototype.quoted = function(i) {
  i !== '"' ? this.word += i : this.state = 5;
}, br.prototype.keyword = function(i) {
  if (_I.test(i))
    this.word += i;
  else {
    if (i === "[") {
      var e = [];
      return e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, void (this.state = Pc);
    }
    if (!bd.test(i))
      throw new Error(`havn't handled "` + i + '" in keyword yet, index ' + this.place);
    this.afterItem(i);
  }
}, br.prototype.neutral = function(i) {
  if (yI.test(i))
    return this.word = i, void (this.state = 2);
  if (i === '"')
    return this.word = "", void (this.state = 4);
  if (tb.test(i))
    return this.word = i, void (this.state = 3);
  if (!bd.test(i))
    throw new Error(`havn't handled "` + i + '" in neutral yet, index ' + this.place);
  this.afterItem(i);
}, br.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === -1)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
var xI = 0.017453292519943295;
function Zi(i) {
  return i * xI;
}
function AS(i) {
  var e = new br(i).output(), t = e.shift(), n = e.shift();
  e.unshift(["name", n]), e.unshift(["type", t]);
  var r = {};
  return Go(e, r), function(s) {
    if (s.type === "GEOGCS" ? s.projName = "longlat" : s.type === "LOCAL_CS" ? (s.projName = "identity", s.local = !0) : typeof s.PROJECTION == "object" ? s.projName = Object.keys(s.PROJECTION)[0] : s.projName = s.PROJECTION, s.AXIS) {
      for (var a = "", o = 0, l = s.AXIS.length; o < l; ++o) {
        var c = [s.AXIS[o][0].toLowerCase(), s.AXIS[o][1].toLowerCase()];
        c[0].indexOf("north") !== -1 || (c[0] === "y" || c[0] === "lat") && c[1] === "north" ? a += "n" : c[0].indexOf("south") !== -1 || (c[0] === "y" || c[0] === "lat") && c[1] === "south" ? a += "s" : c[0].indexOf("east") !== -1 || (c[0] === "x" || c[0] === "lon") && c[1] === "east" ? a += "e" : c[0].indexOf("west") === -1 && (c[0] !== "x" && c[0] !== "lon" || c[1] !== "west") || (a += "w");
      }
      a.length === 2 && (a += "u"), a.length === 3 && (s.axis = a);
    }
    s.UNIT && (s.units = s.UNIT.name.toLowerCase(), s.units === "metre" && (s.units = "meter"), s.UNIT.convert && (s.type === "GEOGCS" ? s.DATUM && s.DATUM.SPHEROID && (s.to_meter = s.UNIT.convert * s.DATUM.SPHEROID.a) : s.to_meter = s.UNIT.convert));
    var h = s.GEOGCS;
    function u(d) {
      return d * (s.to_meter || 1);
    }
    s.type === "GEOGCS" && (h = s), h && (h.DATUM ? s.datumCode = h.DATUM.name.toLowerCase() : s.datumCode = h.name.toLowerCase(), s.datumCode.slice(0, 2) === "d_" && (s.datumCode = s.datumCode.slice(2)), s.datumCode !== "new_zealand_geodetic_datum_1949" && s.datumCode !== "new_zealand_1949" || (s.datumCode = "nzgd49"), s.datumCode !== "wgs_1984" && s.datumCode !== "world_geodetic_system_1984" || (s.PROJECTION === "Mercator_Auxiliary_Sphere" && (s.sphere = !0), s.datumCode = "wgs84"), s.datumCode.slice(-6) === "_ferro" && (s.datumCode = s.datumCode.slice(0, -6)), s.datumCode.slice(-8) === "_jakarta" && (s.datumCode = s.datumCode.slice(0, -8)), ~s.datumCode.indexOf("belge") && (s.datumCode = "rnb72"), h.DATUM && h.DATUM.SPHEROID && (s.ellps = h.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), s.ellps.toLowerCase().slice(0, 13) === "international" && (s.ellps = "intl"), s.a = h.DATUM.SPHEROID.a, s.rf = parseFloat(h.DATUM.SPHEROID.rf, 10)), h.DATUM && h.DATUM.TOWGS84 && (s.datum_params = h.DATUM.TOWGS84), ~s.datumCode.indexOf("osgb_1936") && (s.datumCode = "osgb36"), ~s.datumCode.indexOf("osni_1952") && (s.datumCode = "osni52"), (~s.datumCode.indexOf("tm65") || ~s.datumCode.indexOf("geodetic_datum_of_1965")) && (s.datumCode = "ire65"), s.datumCode === "ch1903+" && (s.datumCode = "ch1903"), ~s.datumCode.indexOf("israel") && (s.datumCode = "isr93")), s.b && !isFinite(s.b) && (s.b = s.a), [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_1", "Latitude of 1st standard parallel"], ["standard_parallel_2", "Standard_Parallel_2"], ["standard_parallel_2", "Latitude of 2nd standard parallel"], ["false_easting", "False_Easting"], ["false_easting", "False easting"], ["false-easting", "Easting at false origin"], ["false_northing", "False_Northing"], ["false_northing", "False northing"], ["false_northing", "Northing at false origin"], ["central_meridian", "Central_Meridian"], ["central_meridian", "Longitude of natural origin"], ["central_meridian", "Longitude of false origin"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["latitude_of_origin", "Latitude of natural origin"], ["latitude_of_origin", "Latitude of false origin"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", Zi], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", Zi], ["x0", "false_easting", u], ["y0", "false_northing", u], ["long0", "central_meridian", Zi], ["lat0", "latitude_of_origin", Zi], ["lat0", "standard_parallel_1", Zi], ["lat1", "standard_parallel_1", Zi], ["lat2", "standard_parallel_2", Zi], ["azimuth", "Azimuth"], ["alpha", "azimuth", Zi], ["srsCode", "name"]].forEach(function(d) {
      return function(p, f) {
        var v = f[0], m = f[1];
        !(v in p) && m in p && (p[v] = p[m], f.length === 3 && (p[v] = f[2](p[v])));
      }(s, d);
    }), s.long0 || !s.longc || s.projName !== "Albers_Conic_Equal_Area" && s.projName !== "Lambert_Azimuthal_Equal_Area" || (s.long0 = s.longc), s.lat_ts || !s.lat1 || s.projName !== "Stereographic_South_Pole" && s.projName !== "Polar Stereographic (variant B)" ? !s.lat_ts && s.lat0 && s.projName === "Polar_Stereographic" && (s.lat_ts = s.lat0, s.lat0 = Zi(s.lat0 > 0 ? 90 : -90)) : (s.lat0 = Zi(s.lat1 > 0 ? 90 : -90), s.lat_ts = s.lat1);
  }(r), r;
}
function Ln(i) {
  var e = this;
  if (arguments.length === 2) {
    var t = arguments[1];
    typeof t == "string" ? t.charAt(0) === "+" ? Ln[i] = G0(arguments[1]) : Ln[i] = AS(arguments[1]) : Ln[i] = t;
  } else if (arguments.length === 1) {
    if (Array.isArray(i))
      return i.map(function(n) {
        Array.isArray(n) ? Ln.apply(e, n) : Ln(n);
      });
    if (typeof i == "string") {
      if (i in Ln)
        return Ln[i];
    } else
      "EPSG" in i ? Ln["EPSG:" + i.EPSG] = i : "ESRI" in i ? Ln["ESRI:" + i.ESRI] = i : "IAU2000" in i ? Ln["IAU2000:" + i.IAU2000] = i : console.log(i);
    return;
  }
}
(function(i) {
  i("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), i("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), i("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), i.WGS84 = i["EPSG:4326"], i["EPSG:3785"] = i["EPSG:3857"], i.GOOGLE = i["EPSG:3857"], i["EPSG:900913"] = i["EPSG:3857"], i["EPSG:102113"] = i["EPSG:3857"];
})(Ln);
var bI = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"], MI = ["3857", "900913", "3785", "102113"];
function wI(i) {
  if (!/* @__PURE__ */ function(n) {
    return typeof n == "string";
  }(i))
    return i;
  if (function(n) {
    return n in Ln;
  }(i))
    return Ln[i];
  if (function(n) {
    return bI.some(function(r) {
      return n.indexOf(r) > -1;
    });
  }(i)) {
    var e = AS(i);
    if (function(n) {
      var r = hs(n, "authority");
      if (r) {
        var s = hs(r, "epsg");
        return s && MI.indexOf(s) > -1;
      }
    }(e))
      return Ln["EPSG:3857"];
    var t = function(n) {
      var r = hs(n, "extension");
      if (r)
        return hs(r, "proj4");
    }(e);
    return t ? G0(t) : e;
  }
  return function(n) {
    return n[0] === "+";
  }(i) ? G0(i) : void 0;
}
function ib(i, e) {
  var t, n;
  if (i = i || {}, !e)
    return i;
  for (n in e)
    (t = e[n]) !== void 0 && (i[n] = t);
  return i;
}
function fr(i, e, t) {
  var n = i * e;
  return t / Math.sqrt(1 - n * n);
}
function jh(i) {
  return i < 0 ? -1 : 1;
}
function Te(i) {
  return Math.abs(i) <= kt ? i : i - jh(i) * wh;
}
function Hi(i, e, t) {
  var n = i * t, r = 0.5 * i;
  return n = Math.pow((1 - n) / (1 + n), r), Math.tan(0.5 * (pe - e)) / n;
}
function Sh(i, e) {
  for (var t, n, r = 0.5 * i, s = pe - 2 * Math.atan(e), a = 0; a <= 15; a++)
    if (t = i * Math.sin(s), s += n = pe - 2 * Math.atan(e * Math.pow((1 - t) / (1 + t), r)) - s, Math.abs(n) <= 1e-10)
      return s;
  return -9999;
}
const SI = { init: function() {
  var i = this.b / this.a;
  this.es = 1 - i * i, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = fr(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}, forward: function(i) {
  var e, t, n = i.x, r = i.y;
  if (r * or > 90 && r * or < -90 && n * or > 180 && n * or < -180 || Math.abs(Math.abs(r) - pe) <= we)
    return null;
  if (this.sphere)
    e = this.x0 + this.a * this.k0 * Te(n - this.long0), t = this.y0 + this.a * this.k0 * Math.log(Math.tan(ht + 0.5 * r));
  else {
    var s = Math.sin(r), a = Hi(this.e, r, s);
    e = this.x0 + this.a * this.k0 * Te(n - this.long0), t = this.y0 - this.a * this.k0 * Math.log(a);
  }
  return i.x = e, i.y = t, i;
}, inverse: function(i) {
  var e, t, n = i.x - this.x0, r = i.y - this.y0;
  if (this.sphere)
    t = pe - 2 * Math.atan(Math.exp(-r / (this.a * this.k0)));
  else {
    var s = Math.exp(-r / (this.a * this.k0));
    if ((t = Sh(this.e, s)) === -9999)
      return null;
  }
  return e = Te(this.long0 + n / (this.a * this.k0)), i.x = e, i.y = t, i;
}, names: ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"] };
function rb(i) {
  return i;
}
var TI = [SI, { init: function() {
}, forward: rb, inverse: rb, names: ["longlat", "identity"] }], $d = {}, Ep = [];
function sb(i, e) {
  var t = Ep.length;
  return i.names ? (Ep[t] = i, i.names.forEach(function(n) {
    $d[n.toLowerCase()] = t;
  }), this) : (console.log(e), !0);
}
const EI = { start: function() {
  TI.forEach(sb);
}, add: sb, get: function(i) {
  if (!i)
    return !1;
  var e = i.toLowerCase();
  return typeof $d[e] != "undefined" && Ep[$d[e]] ? Ep[$d[e]] : void 0;
} };
var ev = { MERIT: { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, SGS85: { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, GRS80: { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, IAU76: { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, airy: { a: 6377563396e-3, b: 635625691e-2, ellipseName: "Airy 1830" }, APL4: { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, NWL9D: { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, mod_airy: { a: 6377340189e-3, b: 6356034446e-3, ellipseName: "Modified Airy" }, andrae: { a: 637710443e-2, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, aust_SA: { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, GRS67: { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, bessel: { a: 6377397155e-3, rf: 299.1528128, ellipseName: "Bessel 1841" }, bess_nam: { a: 6377483865e-3, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, clrk66: { a: 63782064e-1, b: 63565838e-1, ellipseName: "Clarke 1866" }, clrk80: { a: 6378249145e-3, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, clrk80ign: { a: 63782492e-1, b: 6356515, rf: 293.4660213, ellipseName: "Clarke 1880 (IGN)" }, clrk58: { a: 6378293645208759e-9, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, CPM: { a: 63757387e-1, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, delmbr: { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, engelis: { a: 637813605e-2, rf: 298.2566, ellipseName: "Engelis 1985" }, evrst30: { a: 6377276345e-3, rf: 300.8017, ellipseName: "Everest 1830" }, evrst48: { a: 6377304063e-3, rf: 300.8017, ellipseName: "Everest 1948" }, evrst56: { a: 6377301243e-3, rf: 300.8017, ellipseName: "Everest 1956" }, evrst69: { a: 6377295664e-3, rf: 300.8017, ellipseName: "Everest 1969" }, evrstSS: { a: 6377298556e-3, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, fschr60: { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, fschr60m: { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, fschr68: { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, helmert: { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, hough: { a: 6378270, rf: 297, ellipseName: "Hough" }, intl: { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, kaula: { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, lerch: { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, mprts: { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, new_intl: { a: 63781575e-1, b: 63567722e-1, ellipseName: "New International 1967" }, plessis: { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, krass: { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, SEasia: { a: 6378155, b: 63567733205e-4, ellipseName: "Southeast Asia" }, walbeck: { a: 6376896, b: 63558348467e-4, ellipseName: "Walbeck" }, WGS60: { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, WGS66: { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, WGS7: { a: 6378135, rf: 298.26, ellipseName: "WGS 72" } }, AI = ev.WGS84 = { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" };
ev.sphere = { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" };
var Jt = {};
Jt.wgs84 = { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, Jt.ch1903 = { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, Jt.ggrs87 = { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, Jt.nad83 = { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, Jt.nad27 = { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, Jt.potsdam = { towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, Jt.carthage = { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, Jt.hermannskogel = { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Hermannskogel" }, Jt.militargeographische_institut = { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Militar-Geographische Institut" }, Jt.osni52 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "airy", datumName: "Irish National" }, Jt.ire65 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, Jt.rassadiran = { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, Jt.nzgd49 = { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, Jt.osgb36 = { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Airy 1830" }, Jt.s_jtsk = { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, Jt.beduaram = { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, Jt.gunung_segara = { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, Jt.rnb72 = { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" };
var IS = {};
function II(i) {
  if (i.length === 0)
    return null;
  var e = i[0] === "@";
  return e && (i = i.slice(1)), i === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : { name: i, mandatory: !e, grid: IS[i] || null, isNull: !1 };
}
function Vo(i) {
  return i / 3600 * Math.PI / 180;
}
function V0(i, e, t) {
  return String.fromCharCode.apply(null, new Uint8Array(i.buffer.slice(e, t)));
}
function CI(i) {
  return i.map(function(e) {
    return [Vo(e.longitudeShift), Vo(e.latitudeShift)];
  });
}
function RI(i, e, t) {
  return { name: V0(i, e + 8, e + 16).trim(), parent: V0(i, e + 24, e + 24 + 8).trim(), lowerLatitude: i.getFloat64(e + 72, t), upperLatitude: i.getFloat64(e + 88, t), lowerLongitude: i.getFloat64(e + 104, t), upperLongitude: i.getFloat64(e + 120, t), latitudeInterval: i.getFloat64(e + 136, t), longitudeInterval: i.getFloat64(e + 152, t), gridNodeCount: i.getInt32(e + 168, t) };
}
function PI(i, e, t, n) {
  for (var r = e + 176, s = [], a = 0; a < t.gridNodeCount; a++) {
    var o = { latitudeShift: i.getFloat32(r + 16 * a, n), longitudeShift: i.getFloat32(r + 16 * a + 4, n), latitudeAccuracy: i.getFloat32(r + 16 * a + 8, n), longitudeAccuracy: i.getFloat32(r + 16 * a + 12, n) };
    s.push(o);
  }
  return s;
}
function ur(i, e) {
  if (!(this instanceof ur))
    return new ur(i);
  e = e || function(c) {
    if (c)
      throw c;
  };
  var t = wI(i);
  if (typeof t == "object") {
    var n = ur.projections.get(t.projName);
    if (n) {
      if (t.datumCode && t.datumCode !== "none") {
        var r = hs(Jt, t.datumCode);
        r && (t.datum_params = t.datum_params || (r.towgs84 ? r.towgs84.split(",") : null), t.ellps = r.ellipse, t.datumName = r.datumName ? r.datumName : t.datumCode);
      }
      t.k0 = t.k0 || 1, t.axis = t.axis || "enu", t.ellps = t.ellps || "wgs84", t.lat1 = t.lat1 || t.lat0;
      var s = function(c, h, u, d, p) {
        if (!c) {
          var f = hs(ev, d);
          f || (f = AI), c = f.a, h = f.b, u = f.rf;
        }
        return u && !h && (h = (1 - 1 / u) * c), (u === 0 || Math.abs(c - h) < we) && (p = !0, h = c), { a: c, b: h, rf: u, sphere: p };
      }(t.a, t.b, t.rf, t.ellps, t.sphere), a = function(c, h, u, d) {
        var p = c * c, f = h * h, v = (p - f) / p, m = 0;
        return d ? (p = (c *= 1 - v * (dI + v * (pI + v * fI))) * c, v = 0) : m = Math.sqrt(v), { es: v, e: m, ep2: (p - f) / f };
      }(s.a, s.b, s.rf, t.R_A), o = function(c) {
        return c === void 0 ? null : c.split(",").map(II);
      }(t.nadgrids), l = t.datum || function(c, h, u, d, p, f, v) {
        var m = {};
        return c === void 0 || c === "none" ? m.datum_type = H0 : m.datum_type = hI, h && (m.datum_params = h.map(parseFloat), m.datum_params[0] === 0 && m.datum_params[1] === 0 && m.datum_params[2] === 0 || (m.datum_type = Pa), m.datum_params.length > 3 && (m.datum_params[3] === 0 && m.datum_params[4] === 0 && m.datum_params[5] === 0 && m.datum_params[6] === 0 || (m.datum_type = La, m.datum_params[3] *= jc, m.datum_params[4] *= jc, m.datum_params[5] *= jc, m.datum_params[6] = m.datum_params[6] / 1e6 + 1))), v && (m.datum_type = nl, m.grids = v), m.a = u, m.b = d, m.es = p, m.ep2 = f, m;
      }(t.datumCode, t.datum_params, s.a, s.b, a.es, a.ep2, o);
      ib(this, t), ib(this, n), this.a = s.a, this.b = s.b, this.rf = s.rf, this.sphere = s.sphere, this.es = a.es, this.e = a.e, this.ep2 = a.ep2, this.datum = l, this.init(), e(null, this);
    } else
      e(i);
  } else
    e(i);
}
function CS(i, e, t) {
  var n, r, s, a, o = i.x, l = i.y, c = i.z ? i.z : 0;
  if (l < -pe && l > -1.001 * pe)
    l = -pe;
  else if (l > pe && l < 1.001 * pe)
    l = pe;
  else {
    if (l < -pe)
      return { x: -1 / 0, y: -1 / 0, z: i.z };
    if (l > pe)
      return { x: 1 / 0, y: 1 / 0, z: i.z };
  }
  return o > Math.PI && (o -= 2 * Math.PI), r = Math.sin(l), a = Math.cos(l), s = r * r, { x: ((n = t / Math.sqrt(1 - e * s)) + c) * a * Math.cos(o), y: (n + c) * a * Math.sin(o), z: (n * (1 - e) + c) * r };
}
function RS(i, e, t, n) {
  var r, s, a, o, l, c, h, u, d, p, f, v, m, y, g, _ = 1e-12, x = i.x, M = i.y, b = i.z ? i.z : 0;
  if (r = Math.sqrt(x * x + M * M), s = Math.sqrt(x * x + M * M + b * b), r / t < _) {
    if (y = 0, s / t < _)
      return g = -n, { x: i.x, y: i.y, z: i.z };
  } else
    y = Math.atan2(M, x);
  a = b / s, u = (o = r / s) * (1 - e) * (l = 1 / Math.sqrt(1 - e * (2 - e) * o * o)), d = a * l, m = 0;
  do
    m++, c = e * (h = t / Math.sqrt(1 - e * d * d)) / (h + (g = r * u + b * d - h * (1 - e * d * d))), v = (f = a * (l = 1 / Math.sqrt(1 - c * (2 - c) * o * o))) * u - (p = o * (1 - c) * l) * d, u = p, d = f;
  while (v * v > 1e-24 && m < 30);
  return { x: y, y: Math.atan(f / Math.abs(p)), z: g };
}
function Md(i) {
  return i === Pa || i === La;
}
function LI(i, e, t) {
  if (function(l, c) {
    return l.datum_type === c.datum_type && !(l.a !== c.a || Math.abs(l.es - c.es) > 5e-11) && (l.datum_type === Pa ? l.datum_params[0] === c.datum_params[0] && l.datum_params[1] === c.datum_params[1] && l.datum_params[2] === c.datum_params[2] : l.datum_type !== La || l.datum_params[0] === c.datum_params[0] && l.datum_params[1] === c.datum_params[1] && l.datum_params[2] === c.datum_params[2] && l.datum_params[3] === c.datum_params[3] && l.datum_params[4] === c.datum_params[4] && l.datum_params[5] === c.datum_params[5] && l.datum_params[6] === c.datum_params[6]);
  }(i, e) || i.datum_type === H0 || e.datum_type === H0)
    return t;
  var n = i.a, r = i.es;
  if (i.datum_type === nl) {
    if (ab(i, !1, t) !== 0)
      return;
    n = J3, r = $3;
  }
  var s = e.a, a = e.b, o = e.es;
  if (e.datum_type === nl && (s = J3, a = uI, o = $3), r === o && n === s && !Md(i.datum_type) && !Md(e.datum_type))
    return t;
  if (t = CS(t, r, n), Md(i.datum_type) && (t = function(l, c, h) {
    if (c === Pa)
      return { x: l.x + h[0], y: l.y + h[1], z: l.z + h[2] };
    if (c === La) {
      var u = h[0], d = h[1], p = h[2], f = h[3], v = h[4], m = h[5], y = h[6];
      return { x: y * (l.x - m * l.y + v * l.z) + u, y: y * (m * l.x + l.y - f * l.z) + d, z: y * (-v * l.x + f * l.y + l.z) + p };
    }
  }(t, i.datum_type, i.datum_params)), Md(e.datum_type) && (t = function(l, c, h) {
    if (c === Pa)
      return { x: l.x - h[0], y: l.y - h[1], z: l.z - h[2] };
    if (c === La) {
      var u = h[0], d = h[1], p = h[2], f = h[3], v = h[4], m = h[5], y = h[6], g = (l.x - u) / y, _ = (l.y - d) / y, x = (l.z - p) / y;
      return { x: g + m * _ - v * x, y: -m * g + _ + f * x, z: v * g - f * _ + x };
    }
  }(t, e.datum_type, e.datum_params)), t = RS(t, o, s, a), !(e.datum_type === nl && ab(e, !0, t) !== 0))
    return t;
}
function ab(i, e, t) {
  if (i.grids === null || i.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  var n = { x: -t.x, y: t.y }, r = { x: Number.NaN, y: Number.NaN }, s = [];
  e:
    for (var a = 0; a < i.grids.length; a++) {
      var o = i.grids[a];
      if (s.push(o.name), o.isNull) {
        r = n;
        break;
      }
      if (o.mandatory, o.grid !== null)
        for (var l = o.grid.subgrids, c = 0, h = l.length; c < h; c++) {
          var u = l[c], d = (Math.abs(u.del[1]) + Math.abs(u.del[0])) / 1e4, p = u.ll[0] - d, f = u.ll[1] - d, v = u.ll[0] + (u.lim[0] - 1) * u.del[0] + d, m = u.ll[1] + (u.lim[1] - 1) * u.del[1] + d;
          if (!(f > n.y || p > n.x || m < n.y || v < n.x) && (r = DI(n, e, u), !isNaN(r.x)))
            break e;
        }
      else if (o.mandatory)
        return console.log("Unable to find mandatory grid '" + o.name + "'"), -1;
    }
  return isNaN(r.x) ? (console.log("Failed to find a grid shift table for location '" + -n.x * or + " " + n.y * or + " tried: '" + s + "'"), -1) : (t.x = -r.x, t.y = r.y, 0);
}
function DI(i, e, t) {
  var n = { x: Number.NaN, y: Number.NaN };
  if (isNaN(i.x))
    return n;
  var r = { x: i.x, y: i.y };
  r.x -= t.ll[0], r.y -= t.ll[1], r.x = Te(r.x - Math.PI) + Math.PI;
  var s = ob(r, t);
  if (e) {
    if (isNaN(s.x))
      return n;
    s.x = r.x - s.x, s.y = r.y - s.y;
    var a, o, l = 9;
    do {
      if (o = ob(s, t), isNaN(o.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      a = { x: r.x - (o.x + s.x), y: r.y - (o.y + s.y) }, s.x += a.x, s.y += a.y;
    } while (l-- && Math.abs(a.x) > 1e-12 && Math.abs(a.y) > 1e-12);
    if (l < 0)
      return console.log("Inverse grid shift iterator failed to converge."), n;
    n.x = Te(s.x + t.ll[0]), n.y = s.y + t.ll[1];
  } else
    isNaN(s.x) || (n.x = i.x + s.x, n.y = i.y + s.y);
  return n;
}
function ob(i, e) {
  var t, n = { x: i.x / e.del[0], y: i.y / e.del[1] }, r = Math.floor(n.x), s = Math.floor(n.y), a = n.x - 1 * r, o = n.y - 1 * s, l = { x: Number.NaN, y: Number.NaN };
  if (r < 0 || r >= e.lim[0] || s < 0 || s >= e.lim[1])
    return l;
  t = s * e.lim[0] + r;
  var c = e.cvs[t][0], h = e.cvs[t][1];
  t++;
  var u = e.cvs[t][0], d = e.cvs[t][1];
  t += e.lim[0];
  var p = e.cvs[t][0], f = e.cvs[t][1];
  t--;
  var v = e.cvs[t][0], m = e.cvs[t][1], y = a * o, g = a * (1 - o), _ = (1 - a) * (1 - o), x = (1 - a) * o;
  return l.x = _ * c + g * u + x * v + y * p, l.y = _ * h + g * d + x * m + y * f, l;
}
function lb(i, e, t) {
  var n, r, s, a = t.x, o = t.y, l = t.z || 0, c = {};
  for (s = 0; s < 3; s++)
    if (!e || s !== 2 || t.z !== void 0)
      switch (s === 0 ? (n = a, r = "ew".indexOf(i.axis[s]) !== -1 ? "x" : "y") : s === 1 ? (n = o, r = "ns".indexOf(i.axis[s]) !== -1 ? "y" : "x") : (n = l, r = "z"), i.axis[s]) {
        case "e":
        case "n":
          c[r] = n;
          break;
        case "w":
        case "s":
          c[r] = -n;
          break;
        case "u":
          t[r] !== void 0 && (c.z = n);
          break;
        case "d":
          t[r] !== void 0 && (c.z = -n);
          break;
        default:
          return null;
      }
  return c;
}
function PS(i) {
  var e = { x: i[0], y: i[1] };
  return i.length > 2 && (e.z = i[2]), i.length > 3 && (e.m = i[3]), e;
}
function cb(i) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(i))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof i != "number" || i != i || !isFinite(i))
    throw new TypeError("coordinates must be finite numbers");
}
function Ap(i, e, t, n) {
  var r, s = (t = Array.isArray(t) ? PS(t) : { x: t.x, y: t.y, z: t.z, m: t.m }).z !== void 0;
  if (function(a) {
    cb(a.x), cb(a.y);
  }(t), i.datum && e.datum && function(a, o) {
    return (a.datum.datum_type === Pa || a.datum.datum_type === La || a.datum.datum_type === nl) && o.datumCode !== "WGS84" || (o.datum.datum_type === Pa || o.datum.datum_type === La || o.datum.datum_type === nl) && a.datumCode !== "WGS84";
  }(i, e) && (t = Ap(i, r = new ur("WGS84"), t, n), i = r), n && i.axis !== "enu" && (t = lb(i, !1, t)), i.projName === "longlat")
    t = { x: t.x * _n, y: t.y * _n, z: t.z || 0 };
  else if (i.to_meter && (t = { x: t.x * i.to_meter, y: t.y * i.to_meter, z: t.z || 0 }), !(t = i.inverse(t)))
    return;
  if (i.from_greenwich && (t.x += i.from_greenwich), t = LI(i.datum, e.datum, t))
    return e.from_greenwich && (t = { x: t.x - e.from_greenwich, y: t.y, z: t.z || 0 }), e.projName === "longlat" ? t = { x: t.x * or, y: t.y * or, z: t.z || 0 } : (t = e.forward(t), e.to_meter && (t = { x: t.x / e.to_meter, y: t.y / e.to_meter, z: t.z || 0 })), n && e.axis !== "enu" ? lb(e, !0, t) : (t && !s && delete t.z, t);
}
ur.projections = EI, ur.projections.start();
var hb = ur("WGS84");
function Qm(i, e, t, n) {
  var r, s, a;
  return Array.isArray(t) ? (r = Ap(i, e, t, n) || { x: NaN, y: NaN }, t.length > 2 ? typeof i.name != "undefined" && i.name === "geocent" || typeof e.name != "undefined" && e.name === "geocent" ? typeof r.z == "number" ? [r.x, r.y, r.z].concat(t.splice(3)) : [r.x, r.y, t[2]].concat(t.splice(3)) : [r.x, r.y].concat(t.splice(2)) : [r.x, r.y]) : (s = Ap(i, e, t, n), (a = Object.keys(t)).length === 2 || a.forEach(function(o) {
    if (typeof i.name != "undefined" && i.name === "geocent" || typeof e.name != "undefined" && e.name === "geocent") {
      if (o === "x" || o === "y" || o === "z")
        return;
    } else if (o === "x" || o === "y")
      return;
    s[o] = t[o];
  }), s);
}
function ub(i) {
  return i instanceof ur ? i : i.oProj ? i.oProj : ur(i);
}
function zn(i, e, t) {
  i = ub(i);
  var n, r = !1;
  return e === void 0 ? (e = i, i = hb, r = !0) : (typeof e.x != "undefined" || Array.isArray(e)) && (t = e, e = i, i = hb, r = !0), e = ub(e), t ? Qm(i, e, t) : (n = { forward: function(s, a) {
    return Qm(i, e, s, a);
  }, inverse: function(s, a) {
    return Qm(e, i, s, a);
  } }, r && (n.oProj = e), n);
}
var db = 6, LS = "AJSAJS", DS = "AFAFAF", jo = 65, Hn = 73, gi = 79, Lc = 86, Dc = 90;
const NI = { forward: NS, inverse: function(i) {
  var e = tv(kS(i.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}, toPoint: OS };
function NS(i, e) {
  return e = e || 5, function(t, n) {
    var r = "00000" + t.easting, s = "00000" + t.northing;
    return t.zoneNumber + t.zoneLetter + (a = t.easting, o = t.northing, l = t.zoneNumber, c = US(l), h = Math.floor(a / 1e5), u = Math.floor(o / 1e5) % 20, function(d, p, f) {
      var v = f - 1, m = LS.charCodeAt(v), y = DS.charCodeAt(v), g = m + d - 1, _ = y + p, x = !1;
      return g > Dc && (g = g - Dc + jo - 1, x = !0), (g === Hn || m < Hn && g > Hn || (g > Hn || m < Hn) && x) && g++, (g === gi || m < gi && g > gi || (g > gi || m < gi) && x) && ++g === Hn && g++, g > Dc && (g = g - Dc + jo - 1), _ > Lc ? (_ = _ - Lc + jo - 1, x = !0) : x = !1, (_ === Hn || y < Hn && _ > Hn || (_ > Hn || y < Hn) && x) && _++, (_ === gi || y < gi && _ > gi || (_ > gi || y < gi) && x) && ++_ === Hn && _++, _ > Lc && (_ = _ - Lc + jo - 1), String.fromCharCode(g) + String.fromCharCode(_);
    }(h, u, c)) + r.substr(r.length - 5, n) + s.substr(s.length - 5, n);
    var a, o, l, c, h, u;
  }(function(t) {
    var n, r, s, a, o, l, c, h, u = t.lat, d = t.lon, p = 6378137, f = 669438e-8, v = 0.9996, m = Jm(u), y = Jm(d);
    h = Math.floor((d + 180) / 6) + 1, d === 180 && (h = 60), u >= 56 && u < 64 && d >= 3 && d < 12 && (h = 32), u >= 72 && u < 84 && (d >= 0 && d < 9 ? h = 31 : d >= 9 && d < 21 ? h = 33 : d >= 21 && d < 33 ? h = 35 : d >= 33 && d < 42 && (h = 37)), c = Jm(6 * (h - 1) - 180 + 3), n = f / (1 - f), r = p / Math.sqrt(1 - f * Math.sin(m) * Math.sin(m)), s = Math.tan(m) * Math.tan(m), a = n * Math.cos(m) * Math.cos(m), o = Math.cos(m) * (y - c), l = p * ((1 - f / 4 - 3 * f * f / 64 - 5 * f * f * f / 256) * m - (3 * f / 8 + 3 * f * f / 32 + 45 * f * f * f / 1024) * Math.sin(2 * m) + (15 * f * f / 256 + 45 * f * f * f / 1024) * Math.sin(4 * m) - 35 * f * f * f / 3072 * Math.sin(6 * m));
    var g = v * r * (o + (1 - s + a) * o * o * o / 6 + (5 - 18 * s + s * s + 72 * a - 58 * n) * o * o * o * o * o / 120) + 5e5, _ = v * (l + r * Math.tan(m) * (o * o / 2 + (5 - s + 9 * a + 4 * a * a) * o * o * o * o / 24 + (61 - 58 * s + s * s + 600 * a - 330 * n) * o * o * o * o * o * o / 720));
    return u < 0 && (_ += 1e7), { northing: Math.round(_), easting: Math.round(g), zoneNumber: h, zoneLetter: OI(u) };
  }({ lat: i[1], lon: i[0] }), e);
}
function OS(i) {
  var e = tv(kS(i.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function Jm(i) {
  return i * (Math.PI / 180);
}
function pb(i) {
  return i / Math.PI * 180;
}
function tv(i) {
  var e = i.northing, t = i.easting, n = i.zoneLetter, r = i.zoneNumber;
  if (r < 0 || r > 60)
    return null;
  var s, a, o, l, c, h, u, d, p, f = 0.9996, v = 6378137, m = 669438e-8, y = (1 - Math.sqrt(0.99330562)) / (1 + Math.sqrt(0.99330562)), g = t - 5e5, _ = e;
  n < "N" && (_ -= 1e7), u = 6 * (r - 1) - 180 + 3, s = 0.006739496752268451, p = (d = _ / f / 6367449145945056e-9) + (3 * y / 2 - 27 * y * y * y / 32) * Math.sin(2 * d) + (21 * y * y / 16 - 55 * y * y * y * y / 32) * Math.sin(4 * d) + 151 * y * y * y / 96 * Math.sin(6 * d), a = v / Math.sqrt(1 - m * Math.sin(p) * Math.sin(p)), o = Math.tan(p) * Math.tan(p), l = s * Math.cos(p) * Math.cos(p), c = 0.99330562 * v / Math.pow(1 - m * Math.sin(p) * Math.sin(p), 1.5), h = g / (a * f);
  var x = p - a * Math.tan(p) / c * (h * h / 2 - (5 + 3 * o + 10 * l - 4 * l * l - 9 * s) * h * h * h * h / 24 + (61 + 90 * o + 298 * l + 45 * o * o - 1.6983531815716497 - 3 * l * l) * h * h * h * h * h * h / 720);
  x = pb(x);
  var M, b = (h - (1 + 2 * o + l) * h * h * h / 6 + (5 - 2 * l + 28 * o - 3 * l * l + 8 * s + 24 * o * o) * h * h * h * h * h / 120) / Math.cos(p);
  if (b = u + pb(b), i.accuracy) {
    var w = tv({ northing: i.northing + i.accuracy, easting: i.easting + i.accuracy, zoneLetter: i.zoneLetter, zoneNumber: i.zoneNumber });
    M = { top: w.lat, right: w.lon, bottom: x, left: b };
  } else
    M = { lat: x, lon: b };
  return M;
}
function OI(i) {
  var e = "Z";
  return 84 >= i && i >= 72 ? e = "X" : 72 > i && i >= 64 ? e = "W" : 64 > i && i >= 56 ? e = "V" : 56 > i && i >= 48 ? e = "U" : 48 > i && i >= 40 ? e = "T" : 40 > i && i >= 32 ? e = "S" : 32 > i && i >= 24 ? e = "R" : 24 > i && i >= 16 ? e = "Q" : 16 > i && i >= 8 ? e = "P" : 8 > i && i >= 0 ? e = "N" : 0 > i && i >= -8 ? e = "M" : -8 > i && i >= -16 ? e = "L" : -16 > i && i >= -24 ? e = "K" : -24 > i && i >= -32 ? e = "J" : -32 > i && i >= -40 ? e = "H" : -40 > i && i >= -48 ? e = "G" : -48 > i && i >= -56 ? e = "F" : -56 > i && i >= -64 ? e = "E" : -64 > i && i >= -72 ? e = "D" : -72 > i && i >= -80 && (e = "C"), e;
}
function US(i) {
  var e = i % db;
  return e === 0 && (e = db), e;
}
function kS(i) {
  if (i && i.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e, t = i.length, n = null, r = "", s = 0; !/[A-Z]/.test(e = i.charAt(s)); ) {
    if (s >= 2)
      throw "MGRSPoint bad conversion from: " + i;
    r += e, s++;
  }
  var a = parseInt(r, 10);
  if (s === 0 || s + 3 > t)
    throw "MGRSPoint bad conversion from: " + i;
  var o = i.charAt(s++);
  if (o <= "A" || o === "B" || o === "Y" || o >= "Z" || o === "I" || o === "O")
    throw "MGRSPoint zone letter " + o + " not handled: " + i;
  n = i.substring(s, s += 2);
  for (var l = US(a), c = function(g, _) {
    for (var x = LS.charCodeAt(_ - 1), M = 1e5, b = !1; x !== g.charCodeAt(0); ) {
      if (++x === Hn && x++, x === gi && x++, x > Dc) {
        if (b)
          throw "Bad character: " + g;
        x = jo, b = !0;
      }
      M += 1e5;
    }
    return M;
  }(n.charAt(0), l), h = function(g, _) {
    if (g > "V")
      throw "MGRSPoint given invalid Northing " + g;
    for (var x = DS.charCodeAt(_ - 1), M = 0, b = !1; x !== g.charCodeAt(0); ) {
      if (++x === Hn && x++, x === gi && x++, x > Lc) {
        if (b)
          throw "Bad character: " + g;
        x = jo, b = !0;
      }
      M += 1e5;
    }
    return M;
  }(n.charAt(1), l); h < UI(o); )
    h += 2e6;
  var u = t - s;
  if (u % 2 != 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + i;
  var d, p, f, v = u / 2, m = 0, y = 0;
  return v > 0 && (d = 1e5 / Math.pow(10, v), p = i.substring(s, s + v), m = parseFloat(p) * d, f = i.substring(s + v), y = parseFloat(f) * d), { easting: m + c, northing: y + h, zoneLetter: o, zoneNumber: a, accuracy: d };
}
function UI(i) {
  var e;
  switch (i) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + i;
}
function il(i, e, t) {
  if (!(this instanceof il))
    return new il(i, e, t);
  if (Array.isArray(i))
    this.x = i[0], this.y = i[1], this.z = i[2] || 0;
  else if (typeof i == "object")
    this.x = i.x, this.y = i.y, this.z = i.z || 0;
  else if (typeof i == "string" && e === void 0) {
    var n = i.split(",");
    this.x = parseFloat(n[0], 10), this.y = parseFloat(n[1], 10), this.z = parseFloat(n[2], 10) || 0;
  } else
    this.x = i, this.y = e, this.z = t || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
il.fromMGRS = function(i) {
  return new il(OS(i));
}, il.prototype.toMGRS = function(i) {
  return NS([this.x, this.y], i);
};
var kI = 1, FI = 0.25, fb = 0.046875, mb = 0.01953125, gb = 0.01068115234375, BI = 0.75, zI = 0.46875, HI = 0.013020833333333334, GI = 0.007120768229166667, VI = 0.3645833333333333, jI = 0.005696614583333333, WI = 0.3076171875;
function FS(i) {
  var e = [];
  e[0] = kI - i * (FI + i * (fb + i * (mb + i * gb))), e[1] = i * (BI - i * (fb + i * (mb + i * gb)));
  var t = i * i;
  return e[2] = t * (zI - i * (HI + i * GI)), t *= i, e[3] = t * (VI - i * jI), e[4] = t * i * WI, e;
}
function Ip(i, e, t, n) {
  return t *= e, e *= e, n[0] * i - t * (n[1] + e * (n[2] + e * (n[3] + e * n[4])));
}
var XI = 20;
function BS(i, e, t) {
  for (var n = 1 / (1 - e), r = i, s = XI; s; --s) {
    var a = Math.sin(r), o = 1 - e * a * a;
    if (r -= o = (Ip(r, a, Math.cos(r), t) - i) * (o * Math.sqrt(o)) * n, Math.abs(o) < we)
      return r;
  }
  return r;
}
const ep = { init: function() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = FS(this.es), this.ml0 = Ip(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}, forward: function(i) {
  var e, t, n, r = i.x, s = i.y, a = Te(r - this.long0), o = Math.sin(s), l = Math.cos(s);
  if (this.es) {
    var c = l * a, h = Math.pow(c, 2), u = this.ep2 * Math.pow(l, 2), d = Math.pow(u, 2), p = Math.abs(l) > we ? Math.tan(s) : 0, f = Math.pow(p, 2), v = Math.pow(f, 2);
    e = 1 - this.es * Math.pow(o, 2), c /= Math.sqrt(e);
    var m = Ip(s, o, l, this.en);
    t = this.a * (this.k0 * c * (1 + h / 6 * (1 - f + u + h / 20 * (5 - 18 * f + v + 14 * u - 58 * f * u + h / 42 * (61 + 179 * v - v * f - 479 * f))))) + this.x0, n = this.a * (this.k0 * (m - this.ml0 + o * a * c / 2 * (1 + h / 12 * (5 - f + 9 * u + 4 * d + h / 30 * (61 + v - 58 * f + 270 * u - 330 * f * u + h / 56 * (1385 + 543 * v - v * f - 3111 * f)))))) + this.y0;
  } else {
    var y = l * Math.sin(a);
    if (Math.abs(Math.abs(y) - 1) < we)
      return 93;
    if (t = 0.5 * this.a * this.k0 * Math.log((1 + y) / (1 - y)) + this.x0, n = l * Math.cos(a) / Math.sqrt(1 - Math.pow(y, 2)), (y = Math.abs(n)) >= 1) {
      if (y - 1 > we)
        return 93;
      n = 0;
    } else
      n = Math.acos(n);
    s < 0 && (n = -n), n = this.a * this.k0 * (n - this.lat0) + this.y0;
  }
  return i.x = t, i.y = n, i;
}, inverse: function(i) {
  var e, t, n, r, s = (i.x - this.x0) * (1 / this.a), a = (i.y - this.y0) * (1 / this.a);
  if (this.es)
    if (t = BS(e = this.ml0 + a / this.k0, this.es, this.en), Math.abs(t) < pe) {
      var o = Math.sin(t), l = Math.cos(t), c = Math.abs(l) > we ? Math.tan(t) : 0, h = this.ep2 * Math.pow(l, 2), u = Math.pow(h, 2), d = Math.pow(c, 2), p = Math.pow(d, 2);
      e = 1 - this.es * Math.pow(o, 2);
      var f = s * Math.sqrt(e) / this.k0, v = Math.pow(f, 2);
      n = t - (e *= c) * v / (1 - this.es) * 0.5 * (1 - v / 12 * (5 + 3 * d - 9 * h * d + h - 4 * u - v / 30 * (61 + 90 * d - 252 * h * d + 45 * p + 46 * h - v / 56 * (1385 + 3633 * d + 4095 * p + 1574 * p * d)))), r = Te(this.long0 + f * (1 - v / 6 * (1 + 2 * d + h - v / 20 * (5 + 28 * d + 24 * p + 8 * h * d + 6 * h - v / 42 * (61 + 662 * d + 1320 * p + 720 * p * d)))) / l);
    } else
      n = pe * jh(a), r = 0;
  else {
    var m = Math.exp(s / this.k0), y = 0.5 * (m - 1 / m), g = this.lat0 + a / this.k0, _ = Math.cos(g);
    e = Math.sqrt((1 - Math.pow(_, 2)) / (1 + Math.pow(y, 2))), n = Math.asin(e), a < 0 && (n = -n), r = y === 0 && _ === 0 ? 0 : Te(Math.atan2(y, _) + this.long0);
  }
  return i.x = r, i.y = n, i;
}, names: ["Fast_Transverse_Mercator", "Fast Transverse Mercator"] };
function zS(i) {
  var e = Math.exp(i);
  return e = (e - 1 / e) / 2;
}
function _i(i, e) {
  i = Math.abs(i), e = Math.abs(e);
  var t = Math.max(i, e), n = Math.min(i, e) / (t || 1);
  return t * Math.sqrt(1 + Math.pow(n, 2));
}
function qI(i) {
  var e = Math.abs(i);
  return e = function(t) {
    var n = 1 + t, r = n - 1;
    return r === 0 ? t : t * Math.log(n) / r;
  }(e * (1 + e / (_i(1, e) + 1))), i < 0 ? -e : e;
}
function $m(i, e) {
  for (var t, n = 2 * Math.cos(2 * e), r = i.length - 1, s = i[r], a = 0; --r >= 0; )
    t = n * s - a + i[r], a = s, s = t;
  return e + t * Math.sin(2 * e);
}
function vb(i, e, t) {
  for (var n, r, s = Math.sin(e), a = Math.cos(e), o = zS(t), l = function(m) {
    var y = Math.exp(m);
    return (y + 1 / y) / 2;
  }(t), c = 2 * a * l, h = -2 * s * o, u = i.length - 1, d = i[u], p = 0, f = 0, v = 0; --u >= 0; )
    n = f, r = p, d = c * (f = d) - n - h * (p = v) + i[u], v = h * f - r + c * p;
  return [(c = s * l) * d - (h = a * o) * v, c * v + h * d];
}
const tp = { init: function() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (ep.init.apply(this), this.forward = ep.forward, this.inverse = ep.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var i = this.es / (1 + Math.sqrt(1 - this.es)), e = i / (2 - i), t = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675))) - 2))), this.cbg[0] = e * (e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725))))) - 2), t *= e, this.cgb[1] = t * (7 / 3 + e * (e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))) - 1.6)), this.cbg[1] = t * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), t *= e, this.cgb[2] = t * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = t * (-26 / 15 + e * (34 / 21 + e * (1.6 + e * (-12686 / 2835)))), t *= e, this.cgb[3] = t * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = t * (1237 / 630 + e * (e * (-24832 / 14175) - 2.4)), t *= e, this.cgb[4] = t * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = t * (-734 / 315 + e * (109598 / 31185)), t *= e, this.cgb[5] = t * (601676 / 22275), this.cbg[5] = t * (444337 / 155925), t = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + t * (1 / 4 + t * (1 / 64 + t / 256))), this.utg[0] = e * (e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800))))) - 0.5), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = t * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = t * (13 / 48 + e * (e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))) - 0.6)), t *= e, this.utg[2] = t * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = t * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), t *= e, this.utg[3] = t * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = t * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), t *= e, this.utg[4] = t * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = t * (34729 / 80640 + e * (-3418889 / 1995840)), t *= e, this.utg[5] = t * (-20648693 / 638668800), this.gtu[5] = 0.6650675310896665 * t;
  var n = $m(this.cbg, this.lat0);
  this.Zb = -this.Qn * (n + function(r, s) {
    for (var a, o = 2 * Math.cos(s), l = r.length - 1, c = r[l], h = 0; --l >= 0; )
      a = o * c - h + r[l], h = c, c = a;
    return Math.sin(s) * a;
  }(this.gtu, 2 * n));
}, forward: function(i) {
  var e = Te(i.x - this.long0), t = i.y;
  t = $m(this.cbg, t);
  var n = Math.sin(t), r = Math.cos(t), s = Math.sin(e), a = Math.cos(e);
  t = Math.atan2(n, a * r), e = Math.atan2(s * r, _i(n, r * a)), e = qI(Math.tan(e));
  var o, l, c = vb(this.gtu, 2 * t, 2 * e);
  return t += c[0], e += c[1], Math.abs(e) <= 2.623395162778 ? (o = this.a * (this.Qn * e) + this.x0, l = this.a * (this.Qn * t + this.Zb) + this.y0) : (o = 1 / 0, l = 1 / 0), i.x = o, i.y = l, i;
}, inverse: function(i) {
  var e, t, n = (i.x - this.x0) * (1 / this.a), r = (i.y - this.y0) * (1 / this.a);
  if (r = (r - this.Zb) / this.Qn, n /= this.Qn, Math.abs(n) <= 2.623395162778) {
    var s = vb(this.utg, 2 * r, 2 * n);
    r += s[0], n += s[1], n = Math.atan(zS(n));
    var a = Math.sin(r), o = Math.cos(r), l = Math.sin(n), c = Math.cos(n);
    r = Math.atan2(a * c, _i(l, c * o)), e = Te((n = Math.atan2(l, c * o)) + this.long0), t = $m(this.cgb, r);
  } else
    e = 1 / 0, t = 1 / 0;
  return i.x = e, i.y = t, i;
}, names: ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"] }, YI = { init: function() {
  var i = function(e, t) {
    if (e === void 0) {
      if ((e = Math.floor(30 * (Te(t) + Math.PI) / Math.PI) + 1) < 0)
        return 0;
      if (e > 60)
        return 60;
    }
    return e;
  }(this.zone, this.long0);
  if (i === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(i) - 183) * _n, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, tp.init.apply(this), this.forward = tp.forward, this.inverse = tp.inverse;
}, names: ["Universal Transverse Mercator System", "utm"], dependsOn: "etmerc" };
function eg(i, e) {
  return Math.pow((1 - i) / (1 + i), e);
}
const tg = { init: function() {
  var i = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * i * i), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(i / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + ht) / (Math.pow(Math.tan(0.5 * this.lat0 + ht), this.C) * eg(this.e * i, this.ratexp));
}, forward: function(i) {
  var e = i.x, t = i.y;
  return i.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * t + ht), this.C) * eg(this.e * Math.sin(t), this.ratexp)) - pe, i.x = this.C * e, i;
}, inverse: function(i) {
  for (var e = i.x / this.C, t = i.y, n = Math.pow(Math.tan(0.5 * t + ht) / this.K, 1 / this.C), r = 20; r > 0 && (t = 2 * Math.atan(n * eg(this.e * Math.sin(i.y), -0.5 * this.e)) - pe, !(Math.abs(t - i.y) < 1e-14)); --r)
    i.y = t;
  return r ? (i.x = e, i.y = t, i) : null;
}, names: ["gauss"] }, ZI = { init: function() {
  tg.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}, forward: function(i) {
  var e, t, n, r;
  return i.x = Te(i.x - this.long0), tg.forward.apply(this, [i]), e = Math.sin(i.y), t = Math.cos(i.y), n = Math.cos(i.x), r = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * t * n), i.x = r * t * Math.sin(i.x), i.y = r * (this.cosc0 * e - this.sinc0 * t * n), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
}, inverse: function(i) {
  var e, t, n, r, s;
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, s = _i(i.x, i.y)) {
    var a = 2 * Math.atan2(s, this.R2);
    e = Math.sin(a), t = Math.cos(a), r = Math.asin(t * this.sinc0 + i.y * e * this.cosc0 / s), n = Math.atan2(i.x * e, s * this.cosc0 * t - i.y * this.sinc0 * e);
  } else
    r = this.phic0, n = 0;
  return i.x = n, i.y = r, tg.inverse.apply(this, [i]), i.x = Te(i.x + this.long0), i;
}, names: ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"] }, KI = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= we && (this.k0 = 0.5 * (1 + jh(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= we && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= we && Math.abs(Math.cos(this.lat_ts)) > we && (this.k0 = 0.5 * this.cons * fr(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Hi(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = fr(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - pe, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}, forward: function(i) {
  var e, t, n, r, s, a, o = i.x, l = i.y, c = Math.sin(l), h = Math.cos(l), u = Te(o - this.long0);
  return Math.abs(Math.abs(o - this.long0) - Math.PI) <= we && Math.abs(l + this.lat0) <= we ? (i.x = NaN, i.y = NaN, i) : this.sphere ? (e = 2 * this.k0 / (1 + this.sinlat0 * c + this.coslat0 * h * Math.cos(u)), i.x = this.a * e * h * Math.sin(u) + this.x0, i.y = this.a * e * (this.coslat0 * c - this.sinlat0 * h * Math.cos(u)) + this.y0, i) : (t = 2 * Math.atan(this.ssfn_(l, c, this.e)) - pe, r = Math.cos(t), n = Math.sin(t), Math.abs(this.coslat0) <= we ? (s = Hi(this.e, l * this.con, this.con * c), a = 2 * this.a * this.k0 * s / this.cons, i.x = this.x0 + a * Math.sin(o - this.long0), i.y = this.y0 - this.con * a * Math.cos(o - this.long0), i) : (Math.abs(this.sinlat0) < we ? (e = 2 * this.a * this.k0 / (1 + r * Math.cos(u)), i.y = e * n) : (e = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * n + this.cosX0 * r * Math.cos(u))), i.y = e * (this.cosX0 * n - this.sinX0 * r * Math.cos(u)) + this.y0), i.x = e * r * Math.sin(u) + this.x0, i));
}, inverse: function(i) {
  var e, t, n, r, s;
  i.x -= this.x0, i.y -= this.y0;
  var a = Math.sqrt(i.x * i.x + i.y * i.y);
  if (this.sphere) {
    var o = 2 * Math.atan(a / (2 * this.a * this.k0));
    return e = this.long0, t = this.lat0, a <= we ? (i.x = e, i.y = t, i) : (t = Math.asin(Math.cos(o) * this.sinlat0 + i.y * Math.sin(o) * this.coslat0 / a), e = Math.abs(this.coslat0) < we ? this.lat0 > 0 ? Te(this.long0 + Math.atan2(i.x, -1 * i.y)) : Te(this.long0 + Math.atan2(i.x, i.y)) : Te(this.long0 + Math.atan2(i.x * Math.sin(o), a * this.coslat0 * Math.cos(o) - i.y * this.sinlat0 * Math.sin(o))), i.x = e, i.y = t, i);
  }
  if (Math.abs(this.coslat0) <= we) {
    if (a <= we)
      return t = this.lat0, e = this.long0, i.x = e, i.y = t, i;
    i.x *= this.con, i.y *= this.con, n = a * this.cons / (2 * this.a * this.k0), t = this.con * Sh(this.e, n), e = this.con * Te(this.con * this.long0 + Math.atan2(i.x, -1 * i.y));
  } else
    r = 2 * Math.atan(a * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, a <= we ? s = this.X0 : (s = Math.asin(Math.cos(r) * this.sinX0 + i.y * Math.sin(r) * this.cosX0 / a), e = Te(this.long0 + Math.atan2(i.x * Math.sin(r), a * this.cosX0 * Math.cos(r) - i.y * this.sinX0 * Math.sin(r)))), t = -1 * Sh(this.e, Math.tan(0.5 * (pe + s)));
  return i.x = e, i.y = t, i;
}, names: ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"], ssfn_: function(i, e, t) {
  return e *= t, Math.tan(0.5 * (pe + i)) * Math.pow((1 - e) / (1 + e), 0.5 * t);
} }, QI = { init: function() {
  var i = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(i), t = this.a, n = 1 / this.rf, r = 2 * n - Math.pow(n, 2), s = this.e = Math.sqrt(r);
  this.R = this.k0 * t * Math.sqrt(1 - r) / (1 - r * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + r / (1 - r) * Math.pow(Math.cos(i), 4)), this.b0 = Math.asin(e / this.alpha);
  var a = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), o = Math.log(Math.tan(Math.PI / 4 + i / 2)), l = Math.log((1 + s * e) / (1 - s * e));
  this.K = a - this.alpha * o + this.alpha * s / 2 * l;
}, forward: function(i) {
  var e = Math.log(Math.tan(Math.PI / 4 - i.y / 2)), t = this.e / 2 * Math.log((1 + this.e * Math.sin(i.y)) / (1 - this.e * Math.sin(i.y))), n = -this.alpha * (e + t) + this.K, r = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4), s = this.alpha * (i.x - this.lambda0), a = Math.atan(Math.sin(s) / (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(s))), o = Math.asin(Math.cos(this.b0) * Math.sin(r) - Math.sin(this.b0) * Math.cos(r) * Math.cos(s));
  return i.y = this.R / 2 * Math.log((1 + Math.sin(o)) / (1 - Math.sin(o))) + this.y0, i.x = this.R * a + this.x0, i;
}, inverse: function(i) {
  for (var e = i.x - this.x0, t = i.y - this.y0, n = e / this.R, r = 2 * (Math.atan(Math.exp(t / this.R)) - Math.PI / 4), s = Math.asin(Math.cos(this.b0) * Math.sin(r) + Math.sin(this.b0) * Math.cos(r) * Math.cos(n)), a = Math.atan(Math.sin(n) / (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(r))), o = this.lambda0 + a / this.alpha, l = 0, c = s, h = -1e3, u = 0; Math.abs(c - h) > 1e-7; ) {
    if (++u > 20)
      return;
    l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + s / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(c)) / 2)), h = c, c = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
  }
  return i.x = o, i.y = c, i;
}, names: ["somerc"] };
var Eo = 1e-7;
const JI = { init: function() {
  var i, e, t, n, r, s, a, o, l, c, h, u, d, p = 0, f = 0, v = 0, m = 0, y = 0, g = 0, _ = 0;
  this.no_off = (d = typeof (u = this).PROJECTION == "object" ? Object.keys(u.PROJECTION)[0] : u.PROJECTION, "no_uoff" in u || "no_off" in u || ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"].indexOf(d) !== -1), this.no_rot = "no_rot" in this;
  var x = !1;
  "alpha" in this && (x = !0);
  var M = !1;
  if ("rectified_grid_angle" in this && (M = !0), x && (_ = this.alpha), M && (p = this.rectified_grid_angle * _n), x || M)
    f = this.longc;
  else if (v = this.long1, y = this.lat1, m = this.long2, g = this.lat2, Math.abs(y - g) <= Eo || (i = Math.abs(y)) <= Eo || Math.abs(i - pe) <= Eo || Math.abs(Math.abs(this.lat0) - pe) <= Eo || Math.abs(Math.abs(g) - pe) <= Eo)
    throw new Error();
  var b = 1 - this.es;
  e = Math.sqrt(b), Math.abs(this.lat0) > we ? (o = Math.sin(this.lat0), t = Math.cos(this.lat0), i = 1 - this.es * o * o, this.B = t * t, this.B = Math.sqrt(1 + this.es * this.B * this.B / b), this.A = this.B * this.k0 * e / i, (r = (n = this.B * e / (t * Math.sqrt(i))) * n - 1) <= 0 ? r = 0 : (r = Math.sqrt(r), this.lat0 < 0 && (r = -r)), this.E = r += n, this.E *= Math.pow(Hi(this.e, this.lat0, o), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = n = r = 1), x || M ? (x ? (h = Math.asin(Math.sin(_) / n), M || (p = _)) : (h = p, _ = Math.asin(n * Math.sin(h))), this.lam0 = f - Math.asin(0.5 * (r - 1 / r) * Math.tan(h)) / this.B) : (s = Math.pow(Hi(this.e, y, Math.sin(y)), this.B), a = Math.pow(Hi(this.e, g, Math.sin(g)), this.B), r = this.E / s, l = (a - s) / (a + s), c = ((c = this.E * this.E) - a * s) / (c + a * s), (i = v - m) < -Math.pi ? m -= wh : i > Math.pi && (m += wh), this.lam0 = Te(0.5 * (v + m) - Math.atan(c * Math.tan(0.5 * this.B * (v - m)) / l) / this.B), h = Math.atan(2 * Math.sin(this.B * Te(v - this.lam0)) / (r - 1 / r)), p = _ = Math.asin(n * Math.sin(h))), this.singam = Math.sin(h), this.cosgam = Math.cos(h), this.sinrot = Math.sin(p), this.cosrot = Math.cos(p), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A, this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(n * n - 1) / Math.cos(_))), this.lat0 < 0 && (this.u_0 = -this.u_0)), r = 0.5 * h, this.v_pole_n = this.ArB * Math.log(Math.tan(ht - r)), this.v_pole_s = this.ArB * Math.log(Math.tan(ht + r));
}, forward: function(i) {
  var e, t, n, r, s, a, o, l, c = {};
  if (i.x = i.x - this.lam0, Math.abs(Math.abs(i.y) - pe) > we) {
    if (e = 0.5 * ((s = this.E / Math.pow(Hi(this.e, i.y, Math.sin(i.y)), this.B)) - (a = 1 / s)), t = 0.5 * (s + a), r = Math.sin(this.B * i.x), n = (e * this.singam - r * this.cosgam) / t, Math.abs(Math.abs(n) - 1) < we)
      throw new Error();
    l = 0.5 * this.ArB * Math.log((1 - n) / (1 + n)), a = Math.cos(this.B * i.x), o = Math.abs(a) < Eo ? this.A * i.x : this.ArB * Math.atan2(e * this.cosgam + r * this.singam, a);
  } else
    l = i.y > 0 ? this.v_pole_n : this.v_pole_s, o = this.ArB * i.y;
  return this.no_rot ? (c.x = o, c.y = l) : (o -= this.u_0, c.x = l * this.cosrot + o * this.sinrot, c.y = o * this.cosrot - l * this.sinrot), c.x = this.a * c.x + this.x0, c.y = this.a * c.y + this.y0, c;
}, inverse: function(i) {
  var e, t, n, r, s, a, o, l = {};
  if (i.x = (i.x - this.x0) * (1 / this.a), i.y = (i.y - this.y0) * (1 / this.a), this.no_rot ? (t = i.y, e = i.x) : (t = i.x * this.cosrot - i.y * this.sinrot, e = i.y * this.cosrot + i.x * this.sinrot + this.u_0), r = 0.5 * ((n = Math.exp(-this.BrA * t)) - 1 / n), s = 0.5 * (n + 1 / n), o = ((a = Math.sin(this.BrA * e)) * this.cosgam + r * this.singam) / s, Math.abs(Math.abs(o) - 1) < we)
    l.x = 0, l.y = o < 0 ? -pe : pe;
  else {
    if (l.y = this.E / Math.sqrt((1 + o) / (1 - o)), l.y = Sh(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0)
      throw new Error();
    l.x = -this.rB * Math.atan2(r * this.cosgam - a * this.singam, Math.cos(this.BrA * e));
  }
  return l.x += this.lam0, l;
}, names: ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"] }, $I = { init: function() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < we)) {
    var i = this.b / this.a;
    this.e = Math.sqrt(1 - i * i);
    var e = Math.sin(this.lat1), t = Math.cos(this.lat1), n = fr(this.e, e, t), r = Hi(this.e, this.lat1, e), s = Math.sin(this.lat2), a = Math.cos(this.lat2), o = fr(this.e, s, a), l = Hi(this.e, this.lat2, s), c = Hi(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > we ? this.ns = Math.log(n / o) / Math.log(r / l) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = n / (this.ns * Math.pow(r, this.ns)), this.rh = this.a * this.f0 * Math.pow(c, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}, forward: function(i) {
  var e = i.x, t = i.y;
  Math.abs(2 * Math.abs(t) - Math.PI) <= we && (t = jh(t) * (pe - 2 * we));
  var n, r, s = Math.abs(Math.abs(t) - pe);
  if (s > we)
    n = Hi(this.e, t, Math.sin(t)), r = this.a * this.f0 * Math.pow(n, this.ns);
  else {
    if ((s = t * this.ns) <= 0)
      return null;
    r = 0;
  }
  var a = this.ns * Te(e - this.long0);
  return i.x = this.k0 * (r * Math.sin(a)) + this.x0, i.y = this.k0 * (this.rh - r * Math.cos(a)) + this.y0, i;
}, inverse: function(i) {
  var e, t, n, r, s, a = (i.x - this.x0) / this.k0, o = this.rh - (i.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(a * a + o * o), t = 1) : (e = -Math.sqrt(a * a + o * o), t = -1);
  var l = 0;
  if (e !== 0 && (l = Math.atan2(t * a, t * o)), e !== 0 || this.ns > 0) {
    if (t = 1 / this.ns, n = Math.pow(e / (this.a * this.f0), t), (r = Sh(this.e, n)) === -9999)
      return null;
  } else
    r = -pe;
  return s = Te(l / this.ns + this.long0), i.x = s, i.y = r, i;
}, names: ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"] }, eC = { init: function() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.4334234309119251), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}, forward: function(i) {
  var e, t, n, r, s, a, o, l = i.x, c = i.y, h = Te(l - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(c)) / (1 - this.e * Math.sin(c)), this.alfa * this.e / 2), t = 2 * (Math.atan(this.k * Math.pow(Math.tan(c / 2 + this.s45), this.alfa) / e) - this.s45), n = -h * this.alfa, r = Math.asin(Math.cos(this.ad) * Math.sin(t) + Math.sin(this.ad) * Math.cos(t) * Math.cos(n)), s = Math.asin(Math.cos(t) * Math.sin(n) / Math.cos(r)), a = this.n * s, o = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(r / 2 + this.s45), this.n), i.y = o * Math.cos(a) / 1, i.x = o * Math.sin(a) / 1, this.czech || (i.y *= -1, i.x *= -1), i;
}, inverse: function(i) {
  var e, t, n, r, s, a, o, l = i.x;
  i.x = i.y, i.y = l, this.czech || (i.y *= -1, i.x *= -1), s = Math.sqrt(i.x * i.x + i.y * i.y), r = Math.atan2(i.y, i.x) / Math.sin(this.s0), n = 2 * (Math.atan(Math.pow(this.ro0 / s, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(n) - Math.sin(this.ad) * Math.cos(n) * Math.cos(r)), t = Math.asin(Math.cos(n) * Math.sin(r) / Math.cos(e)), i.x = this.long0 - t / this.alfa, a = e, o = 0;
  var c = 0;
  do
    i.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(a)) / (1 - this.e * Math.sin(a)), this.e / 2)) - this.s45), Math.abs(a - i.y) < 1e-10 && (o = 1), a = i.y, c += 1;
  while (o === 0 && c < 15);
  return c >= 15 ? null : i;
}, names: ["Krovak", "krovak"] };
function Nn(i, e, t, n, r) {
  return i * r - e * Math.sin(2 * r) + t * Math.sin(4 * r) - n * Math.sin(6 * r);
}
function Th(i) {
  return 1 - 0.25 * i * (1 + i / 16 * (3 + 1.25 * i));
}
function Eh(i) {
  return 0.375 * i * (1 + 0.25 * i * (1 + 0.46875 * i));
}
function Ah(i) {
  return 0.05859375 * i * i * (1 + 0.75 * i);
}
function Ih(i) {
  return i * i * i * (35 / 3072);
}
function rl(i, e, t) {
  var n = e * t;
  return i / Math.sqrt(1 - n * n);
}
function Ml(i) {
  return Math.abs(i) < pe ? i : i - jh(i) * Math.PI;
}
function Cp(i, e, t, n, r) {
  var s, a;
  s = i / e;
  for (var o = 0; o < 15; o++)
    if (s += a = (i - (e * s - t * Math.sin(2 * s) + n * Math.sin(4 * s) - r * Math.sin(6 * s))) / (e - 2 * t * Math.cos(2 * s) + 4 * n * Math.cos(4 * s) - 6 * r * Math.cos(6 * s)), Math.abs(a) <= 1e-10)
      return s;
  return NaN;
}
const tC = { init: function() {
  this.sphere || (this.e0 = Th(this.es), this.e1 = Eh(this.es), this.e2 = Ah(this.es), this.e3 = Ih(this.es), this.ml0 = this.a * Nn(this.e0, this.e1, this.e2, this.e3, this.lat0));
}, forward: function(i) {
  var e, t, n = i.x, r = i.y;
  if (n = Te(n - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(r) * Math.sin(n)), t = this.a * (Math.atan2(Math.tan(r), Math.cos(n)) - this.lat0);
  else {
    var s = Math.sin(r), a = Math.cos(r), o = rl(this.a, this.e, s), l = Math.tan(r) * Math.tan(r), c = n * Math.cos(r), h = c * c, u = this.es * a * a / (1 - this.es);
    e = o * c * (1 - h * l * (1 / 6 - (8 - l + 8 * u) * h / 120)), t = this.a * Nn(this.e0, this.e1, this.e2, this.e3, r) - this.ml0 + o * s / a * h * (0.5 + (5 - l + 6 * u) * h / 24);
  }
  return i.x = e + this.x0, i.y = t + this.y0, i;
}, inverse: function(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t, n = i.x / this.a, r = i.y / this.a;
  if (this.sphere) {
    var s = r + this.lat0;
    e = Math.asin(Math.sin(s) * Math.cos(n)), t = Math.atan2(Math.tan(n), Math.cos(s));
  } else {
    var a = Cp(this.ml0 / this.a + r, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(a) - pe) <= we)
      return i.x = this.long0, i.y = pe, r < 0 && (i.y *= -1), i;
    var o = rl(this.a, this.e, Math.sin(a)), l = o * o * o / this.a / this.a * (1 - this.es), c = Math.pow(Math.tan(a), 2), h = n * this.a / o, u = h * h;
    e = a - o * Math.tan(a) / l * h * h * (0.5 - (1 + 3 * c) * h * h / 24), t = h * (1 - u * (c / 3 + (1 + 3 * c) * c * u / 15)) / Math.cos(a);
  }
  return i.x = Te(t + this.long0), i.y = Ml(e), i;
}, names: ["Cassini", "Cassini_Soldner", "cass"] };
function us(i, e) {
  var t;
  return i > 1e-7 ? (1 - i * i) * (e / (1 - (t = i * e) * t) - 0.5 / i * Math.log((1 - t) / (1 + t))) : 2 * e;
}
var nC = 0.3333333333333333, iC = 0.17222222222222222, rC = 0.10257936507936508, sC = 0.06388888888888888, aC = 0.0664021164021164, oC = 0.016415012942191543;
const lC = { init: function() {
  var i, e = Math.abs(this.lat0);
  if (Math.abs(e - pe) < we ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(e) < we ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0)
    switch (this.qp = us(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = function(t) {
      var n, r = [];
      return r[0] = t * nC, n = t * t, r[0] += n * iC, r[1] = n * sC, n *= t, r[0] += n * rC, r[1] += n * aC, r[2] = n * oC, r;
    }(this.es), this.mode) {
      case this.N_POLE:
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), i = Math.sin(this.lat0), this.sinb1 = us(this.e, i) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * i * i) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
    }
  else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}, forward: function(i) {
  var e, t, n, r, s, a, o, l, c, h, u = i.x, d = i.y;
  if (u = Te(u - this.long0), this.sphere) {
    if (s = Math.sin(d), h = Math.cos(d), n = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if ((t = this.mode === this.EQUIT ? 1 + h * n : 1 + this.sinph0 * s + this.cosph0 * h * n) <= we)
        return null;
      e = (t = Math.sqrt(2 / t)) * h * Math.sin(u), t *= this.mode === this.EQUIT ? s : this.cosph0 * s - this.sinph0 * h * n;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), Math.abs(d + this.lat0) < we)
        return null;
      t = ht - 0.5 * d, e = (t = 2 * (this.mode === this.S_POLE ? Math.cos(t) : Math.sin(t))) * Math.sin(u), t *= n;
    }
  } else {
    switch (o = 0, l = 0, c = 0, n = Math.cos(u), r = Math.sin(u), s = Math.sin(d), a = us(this.e, s), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (o = a / this.qp, l = Math.sqrt(1 - o * o)), this.mode) {
      case this.OBLIQ:
        c = 1 + this.sinb1 * o + this.cosb1 * l * n;
        break;
      case this.EQUIT:
        c = 1 + l * n;
        break;
      case this.N_POLE:
        c = pe + d, a = this.qp - a;
        break;
      case this.S_POLE:
        c = d - pe, a = this.qp + a;
    }
    if (Math.abs(c) < we)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        c = Math.sqrt(2 / c), t = this.mode === this.OBLIQ ? this.ymf * c * (this.cosb1 * o - this.sinb1 * l * n) : (c = Math.sqrt(2 / (1 + l * n))) * o * this.ymf, e = this.xmf * c * l * r;
        break;
      case this.N_POLE:
      case this.S_POLE:
        a >= 0 ? (e = (c = Math.sqrt(a)) * r, t = n * (this.mode === this.S_POLE ? c : -c)) : e = t = 0;
    }
  }
  return i.x = this.a * e + this.x0, i.y = this.a * t + this.y0, i;
}, inverse: function(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t, n, r, s, a, o, l, c, h, u = i.x / this.a, d = i.y / this.a;
  if (this.sphere) {
    var p, f = 0, v = 0;
    if ((t = 0.5 * (p = Math.sqrt(u * u + d * d))) > 1)
      return null;
    switch (t = 2 * Math.asin(t), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (v = Math.sin(t), f = Math.cos(t)), this.mode) {
      case this.EQUIT:
        t = Math.abs(p) <= we ? 0 : Math.asin(d * v / p), u *= v, d = f * p;
        break;
      case this.OBLIQ:
        t = Math.abs(p) <= we ? this.lat0 : Math.asin(f * this.sinph0 + d * v * this.cosph0 / p), u *= v * this.cosph0, d = (f - Math.sin(t) * this.sinph0) * p;
        break;
      case this.N_POLE:
        d = -d, t = pe - t;
        break;
      case this.S_POLE:
        t -= pe;
    }
    e = d !== 0 || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(u, d) : 0;
  } else {
    if (o = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (u /= this.dd, d *= this.dd, (a = Math.sqrt(u * u + d * d)) < we)
        return i.x = this.long0, i.y = this.lat0, i;
      r = 2 * Math.asin(0.5 * a / this.rq), n = Math.cos(r), u *= r = Math.sin(r), this.mode === this.OBLIQ ? (o = n * this.sinb1 + d * r * this.cosb1 / a, s = this.qp * o, d = a * this.cosb1 * n - d * this.sinb1 * r) : (o = d * r / a, s = this.qp * o, d = a * n);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (d = -d), !(s = u * u + d * d))
        return i.x = this.long0, i.y = this.lat0, i;
      o = 1 - s / this.qp, this.mode === this.S_POLE && (o = -o);
    }
    e = Math.atan2(u, d), l = Math.asin(o), c = this.apa, h = l + l, t = l + c[0] * Math.sin(h) + c[1] * Math.sin(h + h) + c[2] * Math.sin(h + h + h);
  }
  return i.x = Te(this.long0 + e), i.y = t, i;
}, names: ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"], S_POLE: 1, N_POLE: 2, EQUIT: 3, OBLIQ: 4 };
function Es(i) {
  return Math.abs(i) > 1 && (i = i > 1 ? 1 : -1), Math.asin(i);
}
const cC = { init: function() {
  Math.abs(this.lat1 + this.lat2) < we || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = fr(this.e3, this.sin_po, this.cos_po), this.qs1 = us(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = fr(this.e3, this.sin_po, this.cos_po), this.qs2 = us(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = us(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > we ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}, forward: function(i) {
  var e = i.x, t = i.y;
  this.sin_phi = Math.sin(t), this.cos_phi = Math.cos(t);
  var n = us(this.e3, this.sin_phi), r = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0, s = this.ns0 * Te(e - this.long0), a = r * Math.sin(s) + this.x0, o = this.rh - r * Math.cos(s) + this.y0;
  return i.x = a, i.y = o, i;
}, inverse: function(i) {
  var e, t, n, r, s, a;
  return i.x -= this.x0, i.y = this.rh - i.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(i.x * i.x + i.y * i.y), n = 1) : (e = -Math.sqrt(i.x * i.x + i.y * i.y), n = -1), r = 0, e !== 0 && (r = Math.atan2(n * i.x, n * i.y)), n = e * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - n * n) / (2 * this.ns0)) : (t = (this.c - n * n) / this.ns0, a = this.phi1z(this.e3, t)), s = Te(r / this.ns0 + this.long0), i.x = s, i.y = a, i;
}, names: ["Albers_Conic_Equal_Area", "Albers", "aea"], phi1z: function(i, e) {
  var t, n, r, s, a = Es(0.5 * e);
  if (i < we)
    return a;
  for (var o = i * i, l = 1; l <= 25; l++)
    if (a += s = 0.5 * (r = 1 - (n = i * (t = Math.sin(a))) * n) * r / Math.cos(a) * (e / (1 - o) - t / r + 0.5 / i * Math.log((1 - n) / (1 + n))), Math.abs(s) <= 1e-7)
      return a;
  return null;
} }, hC = { init: function() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}, forward: function(i) {
  var e, t, n, r, s, a, o, l = i.x, c = i.y;
  return n = Te(l - this.long0), e = Math.sin(c), t = Math.cos(c), r = Math.cos(n), (s = this.sin_p14 * e + this.cos_p14 * t * r) > 0 || Math.abs(s) <= we ? (a = this.x0 + 1 * this.a * t * Math.sin(n) / s, o = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * t * r) / s) : (a = this.x0 + this.infinity_dist * t * Math.sin(n), o = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * t * r)), i.x = a, i.y = o, i;
}, inverse: function(i) {
  var e, t, n, r, s, a;
  return i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, (e = Math.sqrt(i.x * i.x + i.y * i.y)) ? (r = Math.atan2(e, this.rc), t = Math.sin(r), a = Es((n = Math.cos(r)) * this.sin_p14 + i.y * t * this.cos_p14 / e), s = Math.atan2(i.x * t, e * this.cos_p14 * n - i.y * this.sin_p14 * t), s = Te(this.long0 + s)) : (a = this.phic0, s = 0), i.x = s, i.y = a, i;
}, names: ["gnom"] }, uC = { init: function() {
  this.sphere || (this.k0 = fr(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}, forward: function(i) {
  var e, t, n = i.x, r = i.y, s = Te(n - this.long0);
  if (this.sphere)
    e = this.x0 + this.a * s * Math.cos(this.lat_ts), t = this.y0 + this.a * Math.sin(r) / Math.cos(this.lat_ts);
  else {
    var a = us(this.e, Math.sin(r));
    e = this.x0 + this.a * this.k0 * s, t = this.y0 + this.a * a * 0.5 / this.k0;
  }
  return i.x = e, i.y = t, i;
}, inverse: function(i) {
  var e, t;
  return i.x -= this.x0, i.y -= this.y0, this.sphere ? (e = Te(this.long0 + i.x / this.a / Math.cos(this.lat_ts)), t = Math.asin(i.y / this.a * Math.cos(this.lat_ts))) : (t = function(n, r) {
    var s = 1 - (1 - n * n) / (2 * n) * Math.log((1 - n) / (1 + n));
    if (Math.abs(Math.abs(r) - s) < 1e-6)
      return r < 0 ? -1 * pe : pe;
    for (var a, o, l, c, h = Math.asin(0.5 * r), u = 0; u < 30; u++)
      if (o = Math.sin(h), l = Math.cos(h), c = n * o, h += a = Math.pow(1 - c * c, 2) / (2 * l) * (r / (1 - n * n) - o / (1 - c * c) + 0.5 / n * Math.log((1 - c) / (1 + c))), Math.abs(a) <= 1e-10)
        return h;
    return NaN;
  }(this.e, 2 * i.y * this.k0 / this.a), e = Te(this.long0 + i.x / (this.a * this.k0))), i.x = e, i.y = t, i;
}, names: ["cea"] }, dC = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}, forward: function(i) {
  var e = i.x, t = i.y, n = Te(e - this.long0), r = Ml(t - this.lat0);
  return i.x = this.x0 + this.a * n * this.rc, i.y = this.y0 + this.a * r, i;
}, inverse: function(i) {
  var e = i.x, t = i.y;
  return i.x = Te(this.long0 + (e - this.x0) / (this.a * this.rc)), i.y = Ml(this.lat0 + (t - this.y0) / this.a), i;
}, names: ["Equirectangular", "Equidistant_Cylindrical", "eqc"] }, pC = { init: function() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Th(this.es), this.e1 = Eh(this.es), this.e2 = Ah(this.es), this.e3 = Ih(this.es), this.ml0 = this.a * Nn(this.e0, this.e1, this.e2, this.e3, this.lat0);
}, forward: function(i) {
  var e, t, n, r = i.x, s = i.y, a = Te(r - this.long0);
  if (n = a * Math.sin(s), this.sphere)
    Math.abs(s) <= we ? (e = this.a * a, t = -1 * this.a * this.lat0) : (e = this.a * Math.sin(n) / Math.tan(s), t = this.a * (Ml(s - this.lat0) + (1 - Math.cos(n)) / Math.tan(s)));
  else if (Math.abs(s) <= we)
    e = this.a * a, t = -1 * this.ml0;
  else {
    var o = rl(this.a, this.e, Math.sin(s)) / Math.tan(s);
    e = o * Math.sin(n), t = this.a * Nn(this.e0, this.e1, this.e2, this.e3, s) - this.ml0 + o * (1 - Math.cos(n));
  }
  return i.x = e + this.x0, i.y = t + this.y0, i;
}, inverse: function(i) {
  var e, t, n, r, s, a, o, l, c;
  if (n = i.x - this.x0, r = i.y - this.y0, this.sphere)
    if (Math.abs(r + this.a * this.lat0) <= we)
      e = Te(n / this.a + this.long0), t = 0;
    else {
      var h;
      for (a = this.lat0 + r / this.a, o = n * n / this.a / this.a + a * a, l = a, s = 20; s; --s)
        if (l += c = -1 * (a * (l * (h = Math.tan(l)) + 1) - l - 0.5 * (l * l + o) * h) / ((l - a) / h - 1), Math.abs(c) <= we) {
          t = l;
          break;
        }
      e = Te(this.long0 + Math.asin(n * Math.tan(l) / this.a) / Math.sin(t));
    }
  else if (Math.abs(r + this.ml0) <= we)
    t = 0, e = Te(this.long0 + n / this.a);
  else {
    var u, d, p, f, v;
    for (a = (this.ml0 + r) / this.a, o = n * n / this.a / this.a + a * a, l = a, s = 20; s; --s)
      if (v = this.e * Math.sin(l), u = Math.sqrt(1 - v * v) * Math.tan(l), d = this.a * Nn(this.e0, this.e1, this.e2, this.e3, l), p = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), l -= c = (a * (u * (f = d / this.a) + 1) - f - 0.5 * u * (f * f + o)) / (this.es * Math.sin(2 * l) * (f * f + o - 2 * a * f) / (4 * u) + (a - f) * (u * p - 2 / Math.sin(2 * l)) - p), Math.abs(c) <= we) {
        t = l;
        break;
      }
    u = Math.sqrt(1 - this.es * Math.pow(Math.sin(t), 2)) * Math.tan(t), e = Te(this.long0 + Math.asin(n * u / this.a) / Math.sin(t));
  }
  return i.x = e, i.y = t, i;
}, names: ["Polyconic", "poly"] }, fC = { init: function() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}, forward: function(i) {
  var e, t = i.x, n = i.y - this.lat0, r = t - this.long0, s = n / jc * 1e-5, a = r, o = 1, l = 0;
  for (e = 1; e <= 10; e++)
    o *= s, l += this.A[e] * o;
  var c, h = l, u = a, d = 1, p = 0, f = 0, v = 0;
  for (e = 1; e <= 6; e++)
    c = p * h + d * u, d = d * h - p * u, p = c, f = f + this.B_re[e] * d - this.B_im[e] * p, v = v + this.B_im[e] * d + this.B_re[e] * p;
  return i.x = v * this.a + this.x0, i.y = f * this.a + this.y0, i;
}, inverse: function(i) {
  var e, t, n = i.x, r = i.y, s = n - this.x0, a = (r - this.y0) / this.a, o = s / this.a, l = 1, c = 0, h = 0, u = 0;
  for (e = 1; e <= 6; e++)
    t = c * a + l * o, l = l * a - c * o, c = t, h = h + this.C_re[e] * l - this.C_im[e] * c, u = u + this.C_im[e] * l + this.C_re[e] * c;
  for (var d = 0; d < this.iterations; d++) {
    var p, f = h, v = u, m = a, y = o;
    for (e = 2; e <= 6; e++)
      p = v * h + f * u, f = f * h - v * u, v = p, m += (e - 1) * (this.B_re[e] * f - this.B_im[e] * v), y += (e - 1) * (this.B_im[e] * f + this.B_re[e] * v);
    f = 1, v = 0;
    var g = this.B_re[1], _ = this.B_im[1];
    for (e = 2; e <= 6; e++)
      p = v * h + f * u, f = f * h - v * u, v = p, g += e * (this.B_re[e] * f - this.B_im[e] * v), _ += e * (this.B_im[e] * f + this.B_re[e] * v);
    var x = g * g + _ * _;
    h = (m * g + y * _) / x, u = (y * g - m * _) / x;
  }
  var M = h, b = u, w = 1, T = 0;
  for (e = 1; e <= 9; e++)
    w *= M, T += this.D[e] * w;
  var A = this.lat0 + T * jc * 1e5, L = this.long0 + b;
  return i.x = L, i.y = A, i;
}, names: ["New_Zealand_Map_Grid", "nzmg"] }, mC = { init: function() {
}, forward: function(i) {
  var e = i.x, t = i.y, n = Te(e - this.long0), r = this.x0 + this.a * n, s = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + t / 2.5)) * 1.25;
  return i.x = r, i.y = s, i;
}, inverse: function(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = Te(this.long0 + i.x / this.a), t = 2.5 * (Math.atan(Math.exp(0.8 * i.y / this.a)) - Math.PI / 4);
  return i.x = e, i.y = t, i;
}, names: ["Miller_Cylindrical", "mill"] }, gC = { init: function() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = FS(this.es);
}, forward: function(i) {
  var e, t, n = i.x, r = i.y;
  if (n = Te(n - this.long0), this.sphere) {
    if (this.m)
      for (var s = this.n * Math.sin(r), a = 20; a; --a) {
        var o = (this.m * r + Math.sin(r) - s) / (this.m + Math.cos(r));
        if (r -= o, Math.abs(o) < we)
          break;
      }
    else
      r = this.n !== 1 ? Math.asin(this.n * Math.sin(r)) : r;
    e = this.a * this.C_x * n * (this.m + Math.cos(r)), t = this.a * this.C_y * r;
  } else {
    var l = Math.sin(r), c = Math.cos(r);
    t = this.a * Ip(r, l, c, this.en), e = this.a * n * c / Math.sqrt(1 - this.es * l * l);
  }
  return i.x = e, i.y = t, i;
}, inverse: function(i) {
  var e, t, n;
  return i.x -= this.x0, t = i.x / this.a, i.y -= this.y0, e = i.y / this.a, this.sphere ? (e /= this.C_y, t /= this.C_x * (this.m + Math.cos(e)), this.m ? e = Es((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = Es(Math.sin(e) / this.n)), t = Te(t + this.long0), e = Ml(e)) : (e = BS(i.y / this.a, this.es, this.en), (n = Math.abs(e)) < pe ? (n = Math.sin(e), t = Te(this.long0 + i.x * Math.sqrt(1 - this.es * n * n) / (this.a * Math.cos(e)))) : n - we < pe && (t = this.long0)), i.x = t, i.y = e, i;
}, names: ["Sinusoidal", "sinu"] }, vC = { init: function() {
}, forward: function(i) {
  for (var e = i.x, t = i.y, n = Te(e - this.long0), r = t, s = Math.PI * Math.sin(t); ; ) {
    var a = -(r + Math.sin(r) - s) / (1 + Math.cos(r));
    if (r += a, Math.abs(a) < we)
      break;
  }
  r /= 2, Math.PI / 2 - Math.abs(t) < we && (n = 0);
  var o = 0.900316316158 * this.a * n * Math.cos(r) + this.x0, l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
  return i.x = o, i.y = l, i;
}, inverse: function(i) {
  var e, t;
  i.x -= this.x0, i.y -= this.y0, t = i.y / (1.4142135623731 * this.a), Math.abs(t) > 0.999999999999 && (t = 0.999999999999), e = Math.asin(t);
  var n = Te(this.long0 + i.x / (0.900316316158 * this.a * Math.cos(e)));
  n < -Math.PI && (n = -Math.PI), n > Math.PI && (n = Math.PI), t = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(t) > 1 && (t = 1);
  var r = Math.asin(t);
  return i.x = n, i.y = r, i;
}, names: ["Mollweide", "moll"] }, yC = { init: function() {
  Math.abs(this.lat1 + this.lat2) < we || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Th(this.es), this.e1 = Eh(this.es), this.e2 = Ah(this.es), this.e3 = Ih(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = fr(this.e, this.sinphi, this.cosphi), this.ml1 = Nn(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < we ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = fr(this.e, this.sinphi, this.cosphi), this.ml2 = Nn(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Nn(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}, forward: function(i) {
  var e, t = i.x, n = i.y;
  if (this.sphere)
    e = this.a * (this.g - n);
  else {
    var r = Nn(this.e0, this.e1, this.e2, this.e3, n);
    e = this.a * (this.g - r);
  }
  var s = this.ns * Te(t - this.long0), a = this.x0 + e * Math.sin(s), o = this.y0 + this.rh - e * Math.cos(s);
  return i.x = a, i.y = o, i;
}, inverse: function(i) {
  var e, t, n, r;
  i.x -= this.x0, i.y = this.rh - i.y + this.y0, this.ns >= 0 ? (t = Math.sqrt(i.x * i.x + i.y * i.y), e = 1) : (t = -Math.sqrt(i.x * i.x + i.y * i.y), e = -1);
  var s = 0;
  return t !== 0 && (s = Math.atan2(e * i.x, e * i.y)), this.sphere ? (r = Te(this.long0 + s / this.ns), n = Ml(this.g - t / this.a), i.x = r, i.y = n, i) : (n = Cp(this.g - t / this.a, this.e0, this.e1, this.e2, this.e3), r = Te(this.long0 + s / this.ns), i.x = r, i.y = n, i);
}, names: ["Equidistant_Conic", "eqdc"] }, _C = { init: function() {
  this.R = this.a;
}, forward: function(i) {
  var e, t, n = i.x, r = i.y, s = Te(n - this.long0);
  Math.abs(r) <= we && (e = this.x0 + this.R * s, t = this.y0);
  var a = Es(2 * Math.abs(r / Math.PI));
  (Math.abs(s) <= we || Math.abs(Math.abs(r) - pe) <= we) && (e = this.x0, t = r >= 0 ? this.y0 + Math.PI * this.R * Math.tan(0.5 * a) : this.y0 + Math.PI * this.R * -Math.tan(0.5 * a));
  var o = 0.5 * Math.abs(Math.PI / s - s / Math.PI), l = o * o, c = Math.sin(a), h = Math.cos(a), u = h / (c + h - 1), d = u * u, p = u * (2 / c - 1), f = p * p, v = Math.PI * this.R * (o * (u - f) + Math.sqrt(l * (u - f) * (u - f) - (f + l) * (d - f))) / (f + l);
  s < 0 && (v = -v), e = this.x0 + v;
  var m = l + u;
  return v = Math.PI * this.R * (p * m - o * Math.sqrt((f + l) * (l + 1) - m * m)) / (f + l), t = r >= 0 ? this.y0 + v : this.y0 - v, i.x = e, i.y = t, i;
}, inverse: function(i) {
  var e, t, n, r, s, a, o, l, c, h, u, d;
  return i.x -= this.x0, i.y -= this.y0, u = Math.PI * this.R, s = (n = i.x / u) * n + (r = i.y / u) * r, u = 3 * (r * r / (l = -2 * (a = -Math.abs(r) * (1 + s)) + 1 + 2 * r * r + s * s) + (2 * (o = a - 2 * r * r + n * n) * o * o / l / l / l - 9 * a * o / l / l) / 27) / (c = (a - o * o / 3 / l) / l) / (h = 2 * Math.sqrt(-c / 3)), Math.abs(u) > 1 && (u = u >= 0 ? 1 : -1), d = Math.acos(u) / 3, t = i.y >= 0 ? (-h * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI : -(-h * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI, e = Math.abs(n) < we ? this.long0 : Te(this.long0 + Math.PI * (s - 1 + Math.sqrt(1 + 2 * (n * n - r * r) + s * s)) / 2 / n), i.x = e, i.y = t, i;
}, names: ["Van_der_Grinten_I", "VanDerGrinten", "vandg"] }, xC = { init: function() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}, forward: function(i) {
  var e, t, n, r, s, a, o, l, c, h, u, d, p, f, v, m, y, g, _, x, M, b, w = i.x, T = i.y, A = Math.sin(i.y), L = Math.cos(i.y), I = Te(w - this.long0);
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= we ? (i.x = this.x0 + this.a * (pe - T) * Math.sin(I), i.y = this.y0 - this.a * (pe - T) * Math.cos(I), i) : Math.abs(this.sin_p12 + 1) <= we ? (i.x = this.x0 + this.a * (pe + T) * Math.sin(I), i.y = this.y0 + this.a * (pe + T) * Math.cos(I), i) : (g = this.sin_p12 * A + this.cos_p12 * L * Math.cos(I), y = (m = Math.acos(g)) ? m / Math.sin(m) : 1, i.x = this.x0 + this.a * y * L * Math.sin(I), i.y = this.y0 + this.a * y * (this.cos_p12 * A - this.sin_p12 * L * Math.cos(I)), i) : (e = Th(this.es), t = Eh(this.es), n = Ah(this.es), r = Ih(this.es), Math.abs(this.sin_p12 - 1) <= we ? (s = this.a * Nn(e, t, n, r, pe), a = this.a * Nn(e, t, n, r, T), i.x = this.x0 + (s - a) * Math.sin(I), i.y = this.y0 - (s - a) * Math.cos(I), i) : Math.abs(this.sin_p12 + 1) <= we ? (s = this.a * Nn(e, t, n, r, pe), a = this.a * Nn(e, t, n, r, T), i.x = this.x0 + (s + a) * Math.sin(I), i.y = this.y0 + (s + a) * Math.cos(I), i) : (o = A / L, l = rl(this.a, this.e, this.sin_p12), c = rl(this.a, this.e, A), h = Math.atan((1 - this.es) * o + this.es * l * this.sin_p12 / (c * L)), _ = (u = Math.atan2(Math.sin(I), this.cos_p12 * Math.tan(h) - this.sin_p12 * Math.cos(I))) === 0 ? Math.asin(this.cos_p12 * Math.sin(h) - this.sin_p12 * Math.cos(h)) : Math.abs(Math.abs(u) - Math.PI) <= we ? -Math.asin(this.cos_p12 * Math.sin(h) - this.sin_p12 * Math.cos(h)) : Math.asin(Math.sin(I) * Math.cos(h) / Math.sin(u)), d = this.e * this.sin_p12 / Math.sqrt(1 - this.es), m = l * _ * (1 - (x = _ * _) * (v = (p = this.e * this.cos_p12 * Math.cos(u) / Math.sqrt(1 - this.es)) * p) * (1 - v) / 6 + (M = x * _) / 8 * (f = d * p) * (1 - 2 * v) + (b = M * _) / 120 * (v * (4 - 7 * v) - 3 * d * d * (1 - 7 * v)) - b * _ / 48 * f), i.x = this.x0 + m * Math.sin(u), i.y = this.y0 + m * Math.cos(u), i));
}, inverse: function(i) {
  var e, t, n, r, s, a, o, l, c, h, u, d, p, f, v, m, y, g, _, x, M, b, w;
  return i.x -= this.x0, i.y -= this.y0, this.sphere ? (e = Math.sqrt(i.x * i.x + i.y * i.y)) > 2 * pe * this.a ? void 0 : (t = e / this.a, n = Math.sin(t), r = Math.cos(t), s = this.long0, Math.abs(e) <= we ? a = this.lat0 : (a = Es(r * this.sin_p12 + i.y * n * this.cos_p12 / e), o = Math.abs(this.lat0) - pe, s = Math.abs(o) <= we ? this.lat0 >= 0 ? Te(this.long0 + Math.atan2(i.x, -i.y)) : Te(this.long0 - Math.atan2(-i.x, i.y)) : Te(this.long0 + Math.atan2(i.x * n, e * this.cos_p12 * r - i.y * this.sin_p12 * n))), i.x = s, i.y = a, i) : (l = Th(this.es), c = Eh(this.es), h = Ah(this.es), u = Ih(this.es), Math.abs(this.sin_p12 - 1) <= we ? (a = Cp(((d = this.a * Nn(l, c, h, u, pe)) - (e = Math.sqrt(i.x * i.x + i.y * i.y))) / this.a, l, c, h, u), s = Te(this.long0 + Math.atan2(i.x, -1 * i.y)), i.x = s, i.y = a, i) : Math.abs(this.sin_p12 + 1) <= we ? (d = this.a * Nn(l, c, h, u, pe), a = Cp(((e = Math.sqrt(i.x * i.x + i.y * i.y)) - d) / this.a, l, c, h, u), s = Te(this.long0 + Math.atan2(i.x, i.y)), i.x = s, i.y = a, i) : (e = Math.sqrt(i.x * i.x + i.y * i.y), v = Math.atan2(i.x, i.y), p = rl(this.a, this.e, this.sin_p12), m = Math.cos(v), g = -(y = this.e * this.cos_p12 * m) * y / (1 - this.es), _ = 3 * this.es * (1 - g) * this.sin_p12 * this.cos_p12 * m / (1 - this.es), b = 1 - g * (M = (x = e / p) - g * (1 + g) * Math.pow(x, 3) / 6 - _ * (1 + 3 * g) * Math.pow(x, 4) / 24) * M / 2 - x * M * M * M / 6, f = Math.asin(this.sin_p12 * Math.cos(M) + this.cos_p12 * Math.sin(M) * m), s = Te(this.long0 + Math.asin(Math.sin(v) * Math.sin(M) / Math.cos(f))), w = Math.sin(f), a = Math.atan2((w - this.es * b * this.sin_p12) * Math.tan(f), w * (1 - this.es)), i.x = s, i.y = a, i));
}, names: ["Azimuthal_Equidistant", "aeqd"] }, bC = { init: function() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}, forward: function(i) {
  var e, t, n, r, s, a, o, l = i.x, c = i.y;
  return n = Te(l - this.long0), e = Math.sin(c), t = Math.cos(c), r = Math.cos(n), ((s = this.sin_p14 * e + this.cos_p14 * t * r) > 0 || Math.abs(s) <= we) && (a = 1 * this.a * t * Math.sin(n), o = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * t * r)), i.x = a, i.y = o, i;
}, inverse: function(i) {
  var e, t, n, r, s, a, o;
  return i.x -= this.x0, i.y -= this.y0, t = Es((e = Math.sqrt(i.x * i.x + i.y * i.y)) / this.a), n = Math.sin(t), r = Math.cos(t), a = this.long0, Math.abs(e) <= we ? (o = this.lat0, i.x = a, i.y = o, i) : (o = Es(r * this.sin_p14 + i.y * n * this.cos_p14 / e), s = Math.abs(this.lat0) - pe, Math.abs(s) <= we ? (a = this.lat0 >= 0 ? Te(this.long0 + Math.atan2(i.x, -i.y)) : Te(this.long0 - Math.atan2(-i.x, i.y)), i.x = a, i.y = o, i) : (a = Te(this.long0 + Math.atan2(i.x * n, e * this.cos_p14 * r - i.y * this.sin_p14 * n)), i.x = a, i.y = o, i));
}, names: ["ortho"] };
var yb = 1, pc = 2, fc = 3, mc = 4, ng = 5, ig = 6, ct = { AREA_0: 1, AREA_1: 2, AREA_2: 3, AREA_3: 4 };
function wd(i, e, t, n) {
  var r;
  return i < we ? (n.value = ct.AREA_0, r = 0) : (r = Math.atan2(e, t), Math.abs(r) <= ht ? n.value = ct.AREA_0 : r > ht && r <= pe + ht ? (n.value = ct.AREA_1, r -= pe) : r > pe + ht || r <= -(pe + ht) ? (n.value = ct.AREA_2, r = r >= 0 ? r - kt : r + kt) : (n.value = ct.AREA_3, r += pe)), r;
}
function Ao(i, e) {
  var t = i + e;
  return t < -kt ? t += wh : t > +kt && (t -= wh), t;
}
const MC = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= pe - ht / 2 ? this.face = ng : this.lat0 <= -(pe - ht / 2) ? this.face = ig : Math.abs(this.long0) <= ht ? this.face = yb : Math.abs(this.long0) <= pe + ht ? this.face = this.long0 > 0 ? pc : mc : this.face = fc, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}, forward: function(i) {
  var e, t, n, r, s, a, o = { x: 0, y: 0 }, l = { value: 0 };
  if (i.x -= this.long0, e = this.es !== 0 ? Math.atan(this.one_minus_f_squared * Math.tan(i.y)) : i.y, t = i.x, this.face === ng)
    r = pe - e, t >= ht && t <= pe + ht ? (l.value = ct.AREA_0, n = t - pe) : t > pe + ht || t <= -(pe + ht) ? (l.value = ct.AREA_1, n = t > 0 ? t - kt : t + kt) : t > -(pe + ht) && t <= -ht ? (l.value = ct.AREA_2, n = t + pe) : (l.value = ct.AREA_3, n = t);
  else if (this.face === ig)
    r = pe + e, t >= ht && t <= pe + ht ? (l.value = ct.AREA_0, n = -t + pe) : t < ht && t >= -ht ? (l.value = ct.AREA_1, n = -t) : t < -ht && t >= -(pe + ht) ? (l.value = ct.AREA_2, n = -t - pe) : (l.value = ct.AREA_3, n = t > 0 ? -t + kt : -t - kt);
  else {
    var c, h, u, d, p, f;
    this.face === pc ? t = Ao(t, +pe) : this.face === fc ? t = Ao(t, +kt) : this.face === mc && (t = Ao(t, -pe)), d = Math.sin(e), p = Math.cos(e), f = Math.sin(t), c = p * Math.cos(t), h = p * f, u = d, this.face === yb ? n = wd(r = Math.acos(c), u, h, l) : this.face === pc ? n = wd(r = Math.acos(h), u, -c, l) : this.face === fc ? n = wd(r = Math.acos(-c), u, -h, l) : this.face === mc ? n = wd(r = Math.acos(-h), u, c, l) : (r = n = 0, l.value = ct.AREA_0);
  }
  return a = Math.atan(12 / kt * (n + Math.acos(Math.sin(n) * Math.cos(ht)) - pe)), s = Math.sqrt((1 - Math.cos(r)) / (Math.cos(a) * Math.cos(a)) / (1 - Math.cos(Math.atan(1 / Math.cos(n))))), l.value === ct.AREA_1 ? a += pe : l.value === ct.AREA_2 ? a += kt : l.value === ct.AREA_3 && (a += 1.5 * kt), o.x = s * Math.cos(a), o.y = s * Math.sin(a), o.x = o.x * this.a + this.x0, o.y = o.y * this.a + this.y0, i.x = o.x, i.y = o.y, i;
}, inverse: function(i) {
  var e, t, n, r, s, a, o, l, c, h, u, d, p = { lam: 0, phi: 0 }, f = { value: 0 };
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, t = Math.atan(Math.sqrt(i.x * i.x + i.y * i.y)), e = Math.atan2(i.y, i.x), i.x >= 0 && i.x >= Math.abs(i.y) ? f.value = ct.AREA_0 : i.y >= 0 && i.y >= Math.abs(i.x) ? (f.value = ct.AREA_1, e -= pe) : i.x < 0 && -i.x >= Math.abs(i.y) ? (f.value = ct.AREA_2, e = e < 0 ? e + kt : e - kt) : (f.value = ct.AREA_3, e += pe), c = kt / 12 * Math.tan(e), s = Math.sin(c) / (Math.cos(c) - 1 / Math.sqrt(2)), a = Math.atan(s), (o = 1 - (n = Math.cos(e)) * n * (r = Math.tan(t)) * r * (1 - Math.cos(Math.atan(1 / Math.cos(a))))) < -1 ? o = -1 : o > 1 && (o = 1), this.face === ng)
    l = Math.acos(o), p.phi = pe - l, f.value === ct.AREA_0 ? p.lam = a + pe : f.value === ct.AREA_1 ? p.lam = a < 0 ? a + kt : a - kt : f.value === ct.AREA_2 ? p.lam = a - pe : p.lam = a;
  else if (this.face === ig)
    l = Math.acos(o), p.phi = l - pe, f.value === ct.AREA_0 ? p.lam = -a + pe : f.value === ct.AREA_1 ? p.lam = -a : f.value === ct.AREA_2 ? p.lam = -a - pe : p.lam = a < 0 ? -a - kt : -a + kt;
  else {
    var v, m, y;
    c = (v = o) * v, m = (c += (y = c >= 1 ? 0 : Math.sqrt(1 - c) * Math.sin(a)) * y) >= 1 ? 0 : Math.sqrt(1 - c), f.value === ct.AREA_1 ? (c = m, m = -y, y = c) : f.value === ct.AREA_2 ? (m = -m, y = -y) : f.value === ct.AREA_3 && (c = m, m = y, y = -c), this.face === pc ? (c = v, v = -m, m = c) : this.face === fc ? (v = -v, m = -m) : this.face === mc && (c = v, v = m, m = -c), p.phi = Math.acos(-y) - pe, p.lam = Math.atan2(m, v), this.face === pc ? p.lam = Ao(p.lam, -pe) : this.face === fc ? p.lam = Ao(p.lam, -kt) : this.face === mc && (p.lam = Ao(p.lam, +pe));
  }
  return this.es !== 0 && (h = p.phi < 0 ? 1 : 0, u = Math.tan(p.phi), d = this.b / Math.sqrt(u * u + this.one_minus_f_squared), p.phi = Math.atan(Math.sqrt(this.a * this.a - d * d) / (this.one_minus_f * d)), h && (p.phi = -p.phi)), p.lam += this.long0, i.x = p.lam, i.y = p.phi, i;
}, names: ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"] };
var rg = [[1, 22199e-21, -715515e-10, 31103e-10], [0.9986, -482243e-9, -24897e-9, -13309e-10], [0.9954, -83103e-8, -448605e-10, -986701e-12], [0.99, -135364e-8, -59661e-9, 36777e-10], [0.9822, -167442e-8, -449547e-11, -572411e-11], [0.973, -214868e-8, -903571e-10, 18736e-12], [0.96, -305085e-8, -900761e-10, 164917e-11], [0.9427, -382792e-8, -653386e-10, -26154e-10], [0.9216, -467746e-8, -10457e-8, 481243e-11], [0.8962, -536223e-8, -323831e-10, -543432e-11], [0.8679, -609363e-8, -113898e-9, 332484e-11], [0.835, -698325e-8, -640253e-10, 934959e-12], [0.7986, -755338e-8, -500009e-10, 935324e-12], [0.7597, -798324e-8, -35971e-9, -227626e-11], [0.7186, -851367e-8, -701149e-10, -86303e-10], [0.6732, -986209e-8, -199569e-9, 191974e-10], [0.6213, -0.010418, 883923e-10, 624051e-11], [0.5722, -906601e-8, 182e-6, 624051e-11], [0.5322, -677797e-8, 275608e-9, 624051e-11]], gc = [[-520417e-23, 0.0124, 121431e-23, -845284e-16], [0.062, 0.0124, -126793e-14, 422642e-15], [0.124, 0.0124, 507171e-14, -160604e-14], [0.186, 0.0123999, -190189e-13, 600152e-14], [0.248, 0.0124002, 710039e-13, -224e-10], [0.31, 0.0123992, -264997e-12, 835986e-13], [0.372, 0.0124029, 988983e-12, -311994e-12], [0.434, 0.0123893, -369093e-11, -435621e-12], [0.4958, 0.0123198, -102252e-10, -345523e-12], [0.5571, 0.0121916, -154081e-10, -582288e-12], [0.6176, 0.0119938, -241424e-10, -525327e-12], [0.6769, 0.011713, -320223e-10, -516405e-12], [0.7346, 0.0113541, -397684e-10, -609052e-12], [0.7903, 0.0109107, -489042e-10, -104739e-11], [0.8435, 0.0103431, -64615e-9, -140374e-14], [0.8936, 969686e-8, -64636e-9, -8547e-9], [0.9394, 840947e-8, -192841e-9, -42106e-10], [0.9761, 616527e-8, -256e-6, -42106e-10], [1, 328947e-8, -319159e-9, -42106e-10]], _b = 0.8487, xb = 1.3523, HS = or / 5, wC = 1 / HS, sg = 18, Sd = function(i, e) {
  return i[0] + e * (i[1] + e * (i[2] + e * i[3]));
};
const SC = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}, forward: function(i) {
  var e = Te(i.x - this.long0), t = Math.abs(i.y), n = Math.floor(t * HS);
  n < 0 ? n = 0 : n >= sg && (n = 17);
  var r = { x: Sd(rg[n], t = or * (t - wC * n)) * e, y: Sd(gc[n], t) };
  return i.y < 0 && (r.y = -r.y), r.x = r.x * this.a * _b + this.x0, r.y = r.y * this.a * xb + this.y0, r;
}, inverse: function(i) {
  var e = { x: (i.x - this.x0) / (this.a * _b), y: Math.abs(i.y - this.y0) / (this.a * xb) };
  if (e.y >= 1)
    e.x /= rg[18][0], e.y = i.y < 0 ? -pe : pe;
  else {
    var t = Math.floor(e.y * sg);
    for (t < 0 ? t = 0 : t >= sg && (t = 17); ; )
      if (gc[t][0] > e.y)
        --t;
      else {
        if (!(gc[t + 1][0] <= e.y))
          break;
        ++t;
      }
    var n = gc[t], r = 5 * (e.y - n[0]) / (gc[t + 1][0] - n[0]);
    r = function(s, a, o, l) {
      for (var c = a; l; --l) {
        var h = s(c);
        if (c -= h, Math.abs(h) < o)
          break;
      }
      return c;
    }(function(s) {
      return (Sd(n, s) - e.y) / function(a, o) {
        return a[1] + o * (2 * a[2] + 3 * o * a[3]);
      }(n, s);
    }, r, we, 100), e.x /= Sd(rg[t], r), e.y = (5 * t + r) * _n, i.y < 0 && (e.y = -e.y);
  }
  return e.x = Te(e.x + this.long0), e;
}, names: ["Robinson", "robin"] }, TC = { init: function() {
  this.name = "geocent";
}, forward: function(i) {
  return CS(i, this.es, this.a);
}, inverse: function(i) {
  return RS(i, this.es, this.a, this.b);
}, names: ["Geocentric", "geocentric", "geocent", "Geocent"] };
var Td = 0, Ed = 1, Ad = 2, Id = 3, vc = { h: { def: 1e5, num: !0 }, azi: { def: 0, num: !0, degrees: !0 }, tilt: { def: 0, num: !0, degrees: !0 }, long0: { def: 0, num: !0 }, lat0: { def: 0, num: !0 } };
const EC = { init: function() {
  if (Object.keys(vc).forEach(function(t) {
    if (typeof this[t] == "undefined")
      this[t] = vc[t].def;
    else {
      if (vc[t].num && isNaN(this[t]))
        throw new Error("Invalid parameter value, must be numeric " + t + " = " + this[t]);
      vc[t].num && (this[t] = parseFloat(this[t]));
    }
    vc[t].degrees && (this[t] = this[t] * _n);
  }.bind(this)), Math.abs(Math.abs(this.lat0) - pe) < we ? this.mode = this.lat0 < 0 ? Ed : Td : Math.abs(this.lat0) < we ? this.mode = Ad : (this.mode = Id, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var i = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(i), this.sw = Math.sin(i);
}, forward: function(i) {
  i.x -= this.long0;
  var e, t, n, r, s = Math.sin(i.y), a = Math.cos(i.y), o = Math.cos(i.x);
  switch (this.mode) {
    case Id:
      t = this.sinph0 * s + this.cosph0 * a * o;
      break;
    case Ad:
      t = a * o;
      break;
    case Ed:
      t = -s;
      break;
    case Td:
      t = s;
  }
  switch (e = (t = this.pn1 / (this.p - t)) * a * Math.sin(i.x), this.mode) {
    case Id:
      t *= this.cosph0 * s - this.sinph0 * a * o;
      break;
    case Ad:
      t *= s;
      break;
    case Td:
      t *= -a * o;
      break;
    case Ed:
      t *= a * o;
  }
  return r = 1 / ((n = t * this.cg + e * this.sg) * this.sw * this.h1 + this.cw), e = (e * this.cg - t * this.sg) * this.cw * r, t = n * r, i.x = e * this.a, i.y = t * this.a, i;
}, inverse: function(i) {
  i.x /= this.a, i.y /= this.a;
  var e, t, n, r = { x: i.x, y: i.y };
  n = 1 / (this.pn1 - i.y * this.sw), e = this.pn1 * i.x * n, t = this.pn1 * i.y * this.cw * n, i.x = e * this.cg + t * this.sg, i.y = t * this.cg - e * this.sg;
  var s = _i(i.x, i.y);
  if (Math.abs(s) < we)
    r.x = 0, r.y = i.y;
  else {
    var a, o;
    switch (o = 1 - s * s * this.pfact, o = (this.p - Math.sqrt(o)) / (this.pn1 / s + s / this.pn1), a = Math.sqrt(1 - o * o), this.mode) {
      case Id:
        r.y = Math.asin(a * this.sinph0 + i.y * o * this.cosph0 / s), i.y = (a - this.sinph0 * Math.sin(r.y)) * s, i.x *= o * this.cosph0;
        break;
      case Ad:
        r.y = Math.asin(i.y * o / s), i.y = a * s, i.x *= o;
        break;
      case Td:
        r.y = Math.asin(a), i.y = -i.y;
        break;
      case Ed:
        r.y = -Math.asin(a);
    }
    r.x = Math.atan2(i.x, i.y);
  }
  return i.x = r.x + this.long0, i.y = r.y, i;
}, names: ["Tilted_Perspective", "tpers"] }, AC = { init: function() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var i = 1 - this.es, e = 1 / i;
    this.radius_p = Math.sqrt(i), this.radius_p2 = i, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}, forward: function(i) {
  var e, t, n, r, s = i.x, a = i.y;
  if (s -= this.long0, this.shape === "ellipse") {
    a = Math.atan(this.radius_p2 * Math.tan(a));
    var o = this.radius_p / _i(this.radius_p * Math.cos(a), Math.sin(a));
    if (t = o * Math.cos(s) * Math.cos(a), n = o * Math.sin(s) * Math.cos(a), r = o * Math.sin(a), (this.radius_g - t) * t - n * n - r * r * this.radius_p_inv2 < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    e = this.radius_g - t, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(n / _i(r, e)), i.y = this.radius_g_1 * Math.atan(r / e)) : (i.x = this.radius_g_1 * Math.atan(n / e), i.y = this.radius_g_1 * Math.atan(r / _i(n, e)));
  } else
    this.shape === "sphere" && (e = Math.cos(a), t = Math.cos(s) * e, n = Math.sin(s) * e, r = Math.sin(a), e = this.radius_g - t, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(n / _i(r, e)), i.y = this.radius_g_1 * Math.atan(r / e)) : (i.x = this.radius_g_1 * Math.atan(n / e), i.y = this.radius_g_1 * Math.atan(r / _i(n, e))));
  return i.x = i.x * this.a, i.y = i.y * this.a, i;
}, inverse: function(i) {
  var e, t, n, r, s = -1, a = 0, o = 0;
  if (i.x = i.x / this.a, i.y = i.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (o = Math.tan(i.y / this.radius_g_1), a = Math.tan(i.x / this.radius_g_1) * _i(1, o)) : (a = Math.tan(i.x / this.radius_g_1), o = Math.tan(i.y / this.radius_g_1) * _i(1, a));
    var l = o / this.radius_p;
    if (e = a * a + l * l + s * s, (n = (t = 2 * this.radius_g * s) * t - 4 * e * this.C) < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    r = (-t - Math.sqrt(n)) / (2 * e), s = this.radius_g + r * s, a *= r, o *= r, i.x = Math.atan2(a, s), i.y = Math.atan(o * Math.cos(i.x) / s), i.y = Math.atan(this.radius_p_inv2 * Math.tan(i.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (o = Math.tan(i.y / this.radius_g_1), a = Math.tan(i.x / this.radius_g_1) * Math.sqrt(1 + o * o)) : (a = Math.tan(i.x / this.radius_g_1), o = Math.tan(i.y / this.radius_g_1) * Math.sqrt(1 + a * a)), e = a * a + o * o + s * s, (n = (t = 2 * this.radius_g * s) * t - 4 * e * this.C) < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    r = (-t - Math.sqrt(n)) / (2 * e), s = this.radius_g + r * s, a *= r, o *= r, i.x = Math.atan2(a, s), i.y = Math.atan(o * Math.cos(i.x) / s);
  }
  return i.x = i.x + this.long0, i;
}, names: ["Geostationary Satellite View", "Geostationary_Satellite", "geos"] };
var yc = 1.340264, _c = -0.081106, xc = 893e-6, bc = 3796e-6, Cd = Math.sqrt(3) / 2;
const IC = { init: function() {
  this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}, forward: function(i) {
  var e = Te(i.x - this.long0), t = i.y, n = Math.asin(Cd * Math.sin(t)), r = n * n, s = r * r * r;
  return i.x = e * Math.cos(n) / (Cd * (yc + 3 * _c * r + s * (7 * xc + 9 * bc * r))), i.y = n * (yc + _c * r + s * (xc + bc * r)), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
}, inverse: function(i) {
  i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a;
  var e, t, n, r, s = i.y;
  for (r = 0; r < 12 && (s -= n = (s * (yc + _c * (e = s * s) + (t = e * e * e) * (xc + bc * e)) - i.y) / (yc + 3 * _c * e + t * (7 * xc + 9 * bc * e)), !(Math.abs(n) < 1e-9)); ++r)
    ;
  return t = (e = s * s) * e * e, i.x = Cd * i.x * (yc + 3 * _c * e + t * (7 * xc + 9 * bc * e)) / Math.cos(s), i.y = Math.asin(Math.sin(s) / Cd), i.x = Te(i.x + this.long0), i;
}, names: ["eqearth", "Equal Earth", "Equal_Earth"] };
zn.defaultDatum = "WGS84", zn.Proj = ur, zn.WGS84 = new zn.Proj("WGS84"), zn.Point = il, zn.toPoint = PS, zn.defs = Ln, zn.nadgrid = function(i, e) {
  var t = new DataView(e), n = function(o) {
    var l = o.getInt32(8, !1);
    return l === 11 ? !1 : (l = o.getInt32(8, !0), l !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
  }(t), r = function(o, l) {
    return { nFields: o.getInt32(8, l), nSubgridFields: o.getInt32(24, l), nSubgrids: o.getInt32(40, l), shiftType: V0(o, 56, 64).trim(), fromSemiMajorAxis: o.getFloat64(120, l), fromSemiMinorAxis: o.getFloat64(136, l), toSemiMajorAxis: o.getFloat64(152, l), toSemiMinorAxis: o.getFloat64(168, l) };
  }(t, n), s = function(o, l, c) {
    for (var h = 176, u = [], d = 0; d < l.nSubgrids; d++) {
      var p = RI(o, h, c), f = PI(o, h, p, c), v = Math.round(1 + (p.upperLongitude - p.lowerLongitude) / p.longitudeInterval), m = Math.round(1 + (p.upperLatitude - p.lowerLatitude) / p.latitudeInterval);
      u.push({ ll: [Vo(p.lowerLongitude), Vo(p.lowerLatitude)], del: [Vo(p.longitudeInterval), Vo(p.latitudeInterval)], lim: [v, m], count: p.gridNodeCount, cvs: CI(f) }), h += 176 + 16 * p.gridNodeCount;
    }
    return u;
  }(t, r, n), a = { header: r, subgrids: s };
  return IS[i] = a, a;
}, zn.transform = Ap, zn.mgrs = NI, zn.version = "__VERSION__", function(i) {
  i.Proj.projections.add(ep), i.Proj.projections.add(tp), i.Proj.projections.add(YI), i.Proj.projections.add(ZI), i.Proj.projections.add(KI), i.Proj.projections.add(QI), i.Proj.projections.add(JI), i.Proj.projections.add($I), i.Proj.projections.add(eC), i.Proj.projections.add(tC), i.Proj.projections.add(lC), i.Proj.projections.add(cC), i.Proj.projections.add(hC), i.Proj.projections.add(uC), i.Proj.projections.add(dC), i.Proj.projections.add(pC), i.Proj.projections.add(fC), i.Proj.projections.add(mC), i.Proj.projections.add(gC), i.Proj.projections.add(vC), i.Proj.projections.add(yC), i.Proj.projections.add(_C), i.Proj.projections.add(xC), i.Proj.projections.add(bC), i.Proj.projections.add(MC), i.Proj.projections.add(SC), i.Proj.projections.add(TC), i.Proj.projections.add(EC), i.Proj.projections.add(AC), i.Proj.projections.add(IC);
}(zn);
class GS extends Fe {
  constructor(e = document.createElement("div")) {
    super(), this.isCSS2DObject = !0, this.element = e, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.center = new Y(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(t) {
        t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element);
      });
    });
  }
  copy(e, t) {
    return super.copy(e, t), this.element = e.element.cloneNode(!0), this.center = e.center, this;
  }
}
const Io = new S(), bb = new fe(), Mb = new fe(), wb = new S(), Sb = new S();
class CC {
  constructor(e = {}) {
    const t = this;
    let n, r, s, a;
    const o = { objects: /* @__PURE__ */ new WeakMap() }, l = e.element !== void 0 ? e.element : document.createElement("div");
    function c(d) {
      d.isCSS2DObject && (d.element.style.display = "none");
      for (let p = 0, f = d.children.length; p < f; p++)
        c(d.children[p]);
    }
    function h(d, p, f) {
      if (d.visible !== !1) {
        if (d.isCSS2DObject) {
          Io.setFromMatrixPosition(d.matrixWorld), Io.applyMatrix4(Mb);
          const v = Io.z >= -1 && Io.z <= 1 && d.layers.test(f.layers) === !0, m = d.element;
          m.style.display = v === !0 ? "" : "none", v === !0 && (d.onBeforeRender(t, p, f), m.style.transform = "translate(" + -100 * d.center.x + "%," + -100 * d.center.y + "%)translate(" + (Io.x * s + s) + "px," + (-Io.y * a + a) + "px)", m.parentNode !== l && l.appendChild(m), d.onAfterRender(t, p, f));
          const y = { distanceToCameraSquared: u(f, d) };
          o.objects.set(d, y);
        }
        for (let v = 0, m = d.children.length; v < m; v++)
          h(d.children[v], p, f);
      } else
        c(d);
    }
    function u(d, p) {
      return wb.setFromMatrixPosition(d.matrixWorld), Sb.setFromMatrixPosition(p.matrixWorld), wb.distanceToSquared(Sb);
    }
    l.style.overflow = "hidden", this.domElement = l, this.getSize = function() {
      return { width: n, height: r };
    }, this.render = function(d, p) {
      d.matrixWorldAutoUpdate === !0 && d.updateMatrixWorld(), p.parent === null && p.matrixWorldAutoUpdate === !0 && p.updateMatrixWorld(), bb.copy(p.matrixWorldInverse), Mb.multiplyMatrices(p.projectionMatrix, bb), h(d, d, p), function(f) {
        const v = function(y) {
          const g = [];
          return y.traverseVisible(function(_) {
            _.isCSS2DObject && g.push(_);
          }), g;
        }(f).sort(function(y, g) {
          return y.renderOrder !== g.renderOrder ? g.renderOrder - y.renderOrder : o.objects.get(y).distanceToCameraSquared - o.objects.get(g).distanceToCameraSquared;
        }), m = v.length;
        for (let y = 0, g = v.length; y < g; y++)
          v[y].element.style.zIndex = m - y;
      }(d);
    }, this.setSize = function(d, p) {
      n = d, r = p, s = n / 2, a = r / 2, l.style.width = d + "px", l.style.height = p + "px";
    };
  }
}
const Tb = new S(), RC = new Qe(), Eb = new S();
class VS extends Fe {
  constructor(e = document.createElement("div")) {
    super(), this.isCSS3DObject = !0, this.element = e, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.addEventListener("removed", function() {
      this.traverse(function(t) {
        t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element);
      });
    });
  }
  copy(e, t) {
    return super.copy(e, t), this.element = e.element.cloneNode(!0), this;
  }
}
const Ki = new fe(), PC = new fe();
class LC {
  constructor(e = {}) {
    const t = this;
    let n, r, s, a;
    const o = { camera: { style: "" }, objects: /* @__PURE__ */ new WeakMap() }, l = e.element !== void 0 ? e.element : document.createElement("div");
    l.style.overflow = "hidden", this.domElement = l;
    const c = document.createElement("div");
    c.style.transformOrigin = "0 0", c.style.pointerEvents = "none", l.appendChild(c);
    const h = document.createElement("div");
    function u(m) {
      return Math.abs(m) < 1e-10 ? 0 : m;
    }
    function d(m) {
      const y = m.elements;
      return "matrix3d(" + u(y[0]) + "," + u(-y[1]) + "," + u(y[2]) + "," + u(y[3]) + "," + u(y[4]) + "," + u(-y[5]) + "," + u(y[6]) + "," + u(y[7]) + "," + u(y[8]) + "," + u(-y[9]) + "," + u(y[10]) + "," + u(y[11]) + "," + u(y[12]) + "," + u(-y[13]) + "," + u(y[14]) + "," + u(y[15]) + ")";
    }
    function p(m) {
      const y = m.elements;
      return "translate(-50%,-50%)" + ("matrix3d(" + u(y[0]) + "," + u(y[1]) + "," + u(y[2]) + "," + u(y[3]) + "," + u(-y[4]) + "," + u(-y[5]) + "," + u(-y[6]) + "," + u(-y[7]) + "," + u(y[8]) + "," + u(y[9]) + "," + u(y[10]) + "," + u(y[11]) + "," + u(y[12]) + "," + u(y[13]) + "," + u(y[14]) + "," + u(y[15]) + ")");
    }
    function f(m) {
      m.isCSS3DObject && (m.element.style.display = "none");
      for (let y = 0, g = m.children.length; y < g; y++)
        f(m.children[y]);
    }
    function v(m, y, g, _) {
      if (m.visible !== !1) {
        if (m.isCSS3DObject) {
          const x = m.layers.test(g.layers) === !0, M = m.element;
          if (M.style.display = x === !0 ? "" : "none", x === !0) {
            let b;
            m.onBeforeRender(t, y, g), m.isCSS3DSprite ? (Ki.copy(g.matrixWorldInverse), Ki.transpose(), m.rotation2D !== 0 && Ki.multiply(PC.makeRotationZ(m.rotation2D)), m.matrixWorld.decompose(Tb, RC, Eb), Ki.setPosition(Tb), Ki.scale(Eb), Ki.elements[3] = 0, Ki.elements[7] = 0, Ki.elements[11] = 0, Ki.elements[15] = 1, b = p(Ki)) : b = p(m.matrixWorld);
            const w = o.objects.get(m);
            if (w === void 0 || w.style !== b) {
              M.style.transform = b;
              const T = { style: b };
              o.objects.set(m, T);
            }
            M.parentNode !== h && h.appendChild(M), m.onAfterRender(t, y, g);
          }
        }
        for (let x = 0, M = m.children.length; x < M; x++)
          v(m.children[x], y, g);
      } else
        f(m);
    }
    h.style.transformStyle = "preserve-3d", c.appendChild(h), this.getSize = function() {
      return { width: n, height: r };
    }, this.render = function(m, y) {
      const g = y.projectionMatrix.elements[5] * a;
      let _, x;
      y.view && y.view.enabled ? (c.style.transform = `translate( ${-y.view.offsetX * (n / y.view.width)}px, ${-y.view.offsetY * (r / y.view.height)}px )`, c.style.transform += `scale( ${y.view.fullWidth / y.view.width}, ${y.view.fullHeight / y.view.height} )`) : c.style.transform = "", m.matrixWorldAutoUpdate === !0 && m.updateMatrixWorld(), y.parent === null && y.matrixWorldAutoUpdate === !0 && y.updateMatrixWorld(), y.isOrthographicCamera && (_ = -(y.right + y.left) / 2, x = (y.top + y.bottom) / 2);
      const M = y.view && y.view.enabled ? y.view.height / y.view.fullHeight : 1, b = y.isOrthographicCamera ? `scale( ${M} )scale(` + g + ")translate(" + u(_) + "px," + u(x) + "px)" + d(y.matrixWorldInverse) : `scale( ${M} )translateZ(` + g + "px)" + d(y.matrixWorldInverse), w = (y.isPerspectiveCamera ? "perspective(" + g + "px) " : "") + b + "translate(" + s + "px," + a + "px)";
      o.camera.style !== w && (h.style.transform = w, o.camera.style = w), v(m, m, y);
    }, this.setSize = function(m, y) {
      n = m, r = y, s = n / 2, a = r / 2, l.style.width = m + "px", l.style.height = y + "px", c.style.width = m + "px", c.style.height = y + "px", h.style.width = m + "px", h.style.height = y + "px";
    };
  }
}
function nv() {
  const i = ["childNodes", "clientWidth", "744XPKmXv", "zIndex", "pointerEvents", "height", "resize", "744591dXZoCS", "522urDImD", "style", "2858954fqJVBK", "top", "none", "3323058IysyDC", "setSize", "554XZYhUh", "711770mdncSc", "reset", "2092zUekZx", "relative", "position", "clientHeight", "appendChild", "width", "domElement", "924500eleVUg", "remove", "forEach"];
  return (nv = function() {
    return i;
  })();
}
function Rp(i, e) {
  const t = nv();
  return (Rp = function(n, r) {
    return t[n -= 157];
  })(i, e);
}
function EL(i, e, t = 0.9) {
  const n = Pl, r = i[n(387)](e);
  return new W[n(377)]().subVectors(e, i)[n(394)]().multiplyScalar(r * t)[n(382)](i);
}
function AL(i, e) {
  const t = Pl;
  return i[t(386)](e[t(376)]), i.applyEuler(e[t(380)]), i[t(382)](e[t(381)]), i;
}
function Pl(i, e) {
  const t = iv();
  return (Pl = function(n, r) {
    return t[n -= 370];
  })(i, e);
}
function IL(i, e) {
  const t = Pl, n = new W[t(377)]();
  n[t(395)](e, i)[t(394)]();
  const r = new W[t(378)]();
  r[t(389)](new W[t(377)](0, 1, 0), n);
  const s = new W[t(393)]();
  return s[t(373)](r), { quaternion: r, euler: s };
}
function iv() {
  const i = ["position", "add", "850236hUDOhJ", "1015256HnkBfU", "797370EpKywt", "multiply", "distanceTo", "4PHQnzi", "setFromUnitVectors", "813438YkxHit", "6178932xPXOez", "multiplyScalar", "Euler", "normalize", "subVectors", "12fhmhSs", "7yPHQJT", "44126QzWaBS", "setFromQuaternion", "30DMPeyG", "81093TopRfx", "scale", "Vector3", "Quaternion", "24ruUReP", "rotation"];
  return (iv = function() {
    return i;
  })();
}
function Ll(i, e) {
  const t = rv();
  return (Ll = function(n, r) {
    return t[n -= 450];
  })(i, e);
}
function rv() {
  const i = ["1635333tYXdhg", "706612fJWGgl", "add", "tan", "6KPeTMu", "150DRvxab", "length", "setFromObject", "subVectors", "type", "Vector3", "clone", "2085510ytifke", "5184945GglSLy", "getWorldDirection", "distanceTo", "12285700eJPATc", "getCenter", "16MLkGwZ", "1690492qLoxHc", "Scene", "applyAxisAngle", "35661KGnDhh", "parent", "Box3"];
  return (rv = function() {
    return i;
  })();
}
function Ab(i) {
  const e = Ll;
  for (; i != null && i[e(470)] && i.parent[e(456)] !== e(467); )
    i = i[e(470)];
  return i;
}
function wl(i) {
  const e = Ll;
  if (i)
    return i.type === e(467) ? i : wl(i[e(470)]);
}
function DC(i) {
  const e = Ll, t = new W[e(471)]()[e(454)](i), { max: n, min: r } = t, s = new S();
  return t[e(464)](s), { box: t, max: n, min: r, center: s, radius: new W[e(457)]()[e(455)](n, r)[e(453)]() / 2 };
}
function NC(i, e = 50) {
  const t = Ll, { center: n, radius: r, max: s } = DC(i), a = i[t(461)](new S()), o = r / Math[t(450)](Math.PI * e / 360), l = a.multiplyScalar(o);
  return { frontView: l[t(458)]()[t(474)](n), leftView: l[t(458)]().applyAxisAngle(new S(0, 1, 0), -Math.PI / 2)[t(474)](n), rightView: l[t(458)]()[t(468)](new W[t(457)](0, 1, 0), Math.PI / 2)[t(474)](n), topView: l.clone()[t(468)](new W[t(457)](1, 0, 0), -Math.PI / 2)[t(474)](n), bottomView: l[t(458)]()[t(468)](new W[t(457)](1, 0, 0), Math.PI / 2)[t(474)](n), backView: l[t(458)]().applyAxisAngle(new S(0, 1, 0), Math.PI)[t(474)](n), maxView: function(c, h, u) {
    const d = Pl;
    return new S()[d(395)](h, c)[d(394)]()[d(392)](u)[d(382)](c);
  }(n, s, n[t(462)](s) / Math.tan(Math.PI * e / 360)), target: n };
}
(function(i, e) {
  const t = Rp, n = nv();
  for (; ; )
    try {
      if (-parseInt(t(171)) / 1 * (-parseInt(t(174)) / 2) + parseInt(t(163)) / 3 + -parseInt(t(181)) / 4 + -parseInt(t(172)) / 5 + -parseInt(t(169)) / 6 + parseInt(t(166)) / 7 + -parseInt(t(158)) / 8 * (-parseInt(t(164)) / 9) === 314175)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = Pl, n = iv();
  for (; ; )
    try {
      if (parseInt(t(388)) / 1 * (parseInt(t(372)) / 2) + -parseInt(t(375)) / 3 * (-parseInt(t(370)) / 4) + parseInt(t(385)) / 5 + parseInt(t(383)) / 6 * (-parseInt(t(371)) / 7) + parseInt(t(379)) / 8 * (-parseInt(t(390)) / 9) + parseInt(t(374)) / 10 * (-parseInt(t(384)) / 11) + parseInt(t(391)) / 12 === 153990)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Ll, n = rv();
  for (; ; )
    try {
      if (parseInt(t(473)) / 1 + parseInt(t(452)) / 2 * (parseInt(t(469)) / 3) + parseInt(t(466)) / 4 + parseInt(t(459)) / 5 * (-parseInt(t(451)) / 6) + parseInt(t(472)) / 7 * (-parseInt(t(465)) / 8) + parseInt(t(460)) / 9 + -parseInt(t(463)) / 10 === 483955)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const Oi = av;
(function(i, e) {
  const t = av, n = sv();
  for (; ; )
    try {
      if (-parseInt(t(134)) / 1 + parseInt(t(108)) / 2 + -parseInt(t(116)) / 3 * (-parseInt(t(142)) / 4) + parseInt(t(118)) / 5 * (-parseInt(t(112)) / 6) + -parseInt(t(115)) / 7 * (-parseInt(t(139)) / 8) + -parseInt(t(123)) / 9 + parseInt(t(110)) / 10 === 305568)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const OC = [Oi(122), "球体", "平面", "胶囊", "圆锥", "圆面", "圆柱", "圆环", "环面"];
function sv() {
  const i = ["tubularSegments", "1230560OFCdrj", "PlaneGeometry", "CircleGeometry", "heightSegments", "立方体", "4869828glOWPG", "thetaStart", "width", "outerRadius", "depthSegments", "thetaLength", "length", "phiSegments", "ConeGeometry", "BoxGeometry", "radiusTop", "257318kAEYpY", "height", "CapsuleGeometry", "depth", "radius", "8IlIpQT", "RingGeometry", "thetaSegments", "897100OKzKvZ", "geometryType", "capSegments", "829648MWIMVi", "radialSegments", "7824570pEzHtn", "TorusGeometry", "12aWgweB", "radiusBottom", "SphereGeometry", "1222522HLPByl", "3OOiZWe"];
  return (sv = function() {
    return i;
  })();
}
function pf(i, e = {}) {
  const t = Oi;
  let n = null;
  switch (i) {
    case t(122):
      n = Ib(e);
      break;
    case "球体":
      n = function(r = {}) {
        const s = Oi;
        return new W[s(114)](r[s(138)] || 5, r.widthSegments || 32, r[s(121)] || 32);
      }(e);
      break;
    case "平面":
      n = function(r = {}) {
        const s = Oi;
        return new W[s(119)](r[s(125)] || 5, r[s(135)] || 5, r.widthSegments || 32, r[s(121)] || 32);
      }(e);
      break;
    case "胶囊":
      n = function(r = {}) {
        const s = Oi;
        return new W[s(136)](r.radius || 5, r[s(129)] || 5, r[s(107)] || 32, r[s(109)] || 32);
      }(e);
      break;
    case "圆锥":
      n = function(r = {}) {
        const s = Oi;
        return new W[s(131)](r[s(138)] || 5, r[s(135)] || 5, r[s(109)] || 32);
      }(e);
      break;
    case "圆面":
      n = function(r = {}) {
        const s = Oi;
        return new W[s(120)](r.radius || 5, r.segments || 32, r[s(124)] || 0, r[s(128)] || 2 * Math.PI);
      }(e);
      break;
    case "圆柱":
      n = function(r = {}) {
        const s = Oi;
        return new Ft(r[s(133)] || 5, r[s(113)] || 5, r[s(135)] || 5, r[s(109)] || 32);
      }(e);
      break;
    case "圆环":
      n = function(r = {}) {
        const s = Oi;
        return new W[s(111)](r[s(138)] || 10, r.tube || 3, r[s(109)] || 32, r[s(117)] || 32, r.arc || 2 * Math.PI);
      }(e);
      break;
    case "环面":
      n = function(r = {}) {
        const s = Oi;
        return new W[s(140)](r.innerRadius || 5, r[s(126)] || 10, r[s(141)] || 32, r[s(130)] || 32, r[s(124)] || 0, r.thetaLength || 2 * Math.PI);
      }(e);
      break;
    default:
      n = Ib(e);
  }
  return n[t(143)] = i, n;
}
function Ib(i = {}) {
  const e = Oi;
  return new W[e(132)](i[e(125)] || 5, i.height || 5, i[e(137)] || 5, i.widthSegments || 1, i.heightSegments || 1, i[e(127)] || 1);
}
function av(i, e) {
  const t = sv();
  return (av = function(n, r) {
    return t[n -= 107];
  })(i, e);
}
function Pp(i, e) {
  const t = ov();
  return (Pp = function(n, r) {
    return t[n -= 378];
  })(i, e);
}
function ov() {
  const i = ["tube", "height", "宽度分段", "widthSegments", "管道半径", "thetaStart", "内半径", "step", "管道分段", "geometryType", "thetaLength", "立方体", "innerRadius", "name", "length", "弧度分段", "深度分段", "3729576mEeewE", "56jpTFqn", "radialSegments", "顶部半径", "width", "458838ZhQRHs", "depth", "9zFJGkg", "起始角度", "48TjQckS", "radiusTop", "10176830AYjbFA", "thetaSegments", "28422xXuGik", "底部半径", "409248tBFITx", "arc", "onChange", "geometry", "add", "phiSegments", "半径分段", "938200eJPTMy", "125845DHJRLd", "heightSegments", "高度分段", "tubularSegments", "dispose", "radius", "outerRadius", "外半径", "结束角度"];
  return (ov = function() {
    return i;
  })();
}
(function(i, e) {
  const t = Pp, n = ov();
  for (; ; )
    try {
      if (-parseInt(t(400)) / 1 + parseInt(t(417)) / 2 + -parseInt(t(408)) / 3 * (-parseInt(t(396)) / 4) + parseInt(t(418)) / 5 + parseInt(t(404)) / 6 * (-parseInt(t(410)) / 7) + -parseInt(t(395)) / 8 + -parseInt(t(402)) / 9 * (-parseInt(t(406)) / 10) === 251841)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const xi = cv;
function lv() {
  const i = ["12gITcGG", "1973310ILaFjV", "281295RnfEeq", "3INeWas", "160mxWJTo", "基础材质", "11DYRgfo", "19859JaslXW", "550790dppPcM", "MeshBasicMaterial", "MeshLambertMaterial", "镜面高光材质", "9399kKOEFi", "MeshToonMaterial", "MeshPhongMaterial", "DoubleSide", "Lambert材质", "45IoCrKo", "卡通材质", "MeshStandardMaterial", "标准材质", "MeshPhysicalMaterial", "物理材质", "1978428YnAkCv", "94756CsPJXU", "transparent"];
  return (lv = function() {
    return i;
  })();
}
function cv(i, e) {
  const t = lv();
  return (cv = function(n, r) {
    return t[n -= 259];
  })(i, e);
}
(function(i, e) {
  const t = cv, n = lv();
  for (; ; )
    try {
      if (-parseInt(t(280)) / 1 * (parseInt(t(275)) / 2) + parseInt(t(263)) / 3 * (-parseInt(t(277)) / 4) + parseInt(t(279)) / 5 + parseInt(t(278)) / 6 + -parseInt(t(284)) / 7 * (-parseInt(t(281)) / 8) + parseInt(t(268)) / 9 * (-parseInt(t(259)) / 10) + -parseInt(t(283)) / 11 * (-parseInt(t(274)) / 12) === 179825)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const No = [xi(282), xi(271), xi(262), xi(267), xi(273), xi(269)];
function Si(i, e = null) {
  const t = xi;
  let n = null;
  switch (i) {
    case t(282):
    case t(260):
      n = Cb(e);
      break;
    case "标准材质":
    case t(270):
      o = e, n = new W[xi(270)](Ee({ color: 16777215, side: tn }, o));
      break;
    case t(262):
    case t(265):
      a = e, n = new W[xi(265)](Ee({ color: 16777215, side: tn }, a));
      break;
    case t(267):
    case t(261):
      n = function(l) {
        const c = xi;
        return new W[c(261)](Ee({ color: 16777215, side: W[c(266)] }, l));
      }(e);
      break;
    case t(273):
    case t(272):
      s = e, n = new W[xi(272)](Ee({ color: 16777215, side: tn }, s));
      break;
    case "卡通材质":
    case t(264):
      r = e, n = new S1(Ee({ color: 16777215, side: tn }, r));
      break;
    default:
      n = Cb(e);
  }
  var r, s, a, o;
  return n.materialType = i || t(282), n[t(276)] = !0, n;
}
function Cb(i) {
  const e = xi;
  return new W[e(260)](Ee({ color: 16777215, side: W[e(266)] }, i));
}
function hv(i, e) {
  const t = uv();
  return (hv = function(n, r) {
    return t[n -= 253];
  })(i, e);
}
function jS(i) {
  const e = hv, t = document.createElement(e(260));
  return t.crossOrigin = e(266), t[e(263)] = i, t[e(255)] = !0, t.loop = !0, t.play(), new JM(t);
}
function uv() {
  const i = ["7173lBJDBH", "src", "6880640kCuDEm", "3402918EbSazm", "anonymous", "2837947UzcdlI", "3rIvRTg", "muted", "573650BNljzu", "6104dxNAmH", "20lVlEsE", "178Rdjdhv", "video", "1774132mhWIsw"];
  return (uv = function() {
    return i;
  })();
}
function Xa(i, e) {
  const t = dv();
  return (Xa = function(n, r) {
    return t[n -= 247];
  })(i, e);
}
function UC(i) {
  const e = Xa, { mapType: t, mapUrl: n, map: r } = i;
  if (n && r)
    return { mapType: t, mapUrl: n, map: { wrapS: r[e(252)], wrapT: r[e(248)], rotation: r[e(278)], center: r[e(249)], repeat: r[e(247)], offset: r[e(284)], textureAnimation: r.textureAnimation } };
}
function WS(i, e, t) {
  var r;
  const n = Xa;
  if (!e[n(272)])
    return e.map = null;
  e[n(261)] == "视频" ? e[n(285)] = jS(e[n(272)]) : e.map = new W[n(277)]().load(e[n(272)]), t && (e[n(285)][n(252)] = t[n(252)], e[n(285)].wrapT = t[n(248)], e[n(285)][n(247)][n(254)](t[n(247)].x, t[n(247)].y), e[n(285)][n(284)].set(t[n(284)].x, t[n(284)].y), e[n(285)][n(249)][n(254)](t[n(249)].x, t[n(249)].y), e.map[n(278)] = t[n(278)], (r = t[n(259)]) != null && r[n(293)] && (e[n(285)][n(259)] = t.textureAnimation, e.map[n(260)] = function() {
    const s = n;
    e.map[s(284)].x += t.textureAnimation[s(284)].x, e[s(285)].offset.y += t[s(259)][s(284)].y, e.map[s(278)] += t[s(259)].rotation;
  }, i[n(251)](e[n(285)]))), e.map[n(249)].set(0.5, 0.5), e[n(253)] = !0, e[n(286)] = !0;
}
function dv() {
  const i = ["wrapS", "isCustomTexture", "set", "has", "674ClciyM", "2420EEUAdc", "MirroredRepeatWrapping", "textureAnimation", "commonAnimateRender", "mapType", "x偏移", "7876512QqmOYI", "垂直环绕方式", "更新贴图", "198441WQkecd", "1570HfOAtO", "RepeatWrapping", "旋转速度", "3399160hBQoOX", "贴图类型", "mapUrl", "add", "onChange", "4893224KEvIEJ", "findIndex", "TextureLoader", "rotation", "splice", "max", "水平环绕方式", "3279GpYODH", "贴图动画", "offset", "map", "needsUpdate", "min", "ClampToEdgeWrapping", "x偏移速度", "y中心", "3529128edAuGr", "x中心", "isTextureAnimation", "repeat", "wrapT", "center", "name", "push"];
  return (dv = function() {
    return i;
  })();
}
(function(i, e) {
  const t = hv, n = uv();
  for (; ; )
    try {
      if (parseInt(t(258)) / 1 * (parseInt(t(259)) / 2) + -parseInt(t(254)) / 3 * (-parseInt(t(261)) / 4) + -parseInt(t(256)) / 5 + parseInt(t(265)) / 6 + -parseInt(t(253)) / 7 + -parseInt(t(257)) / 8 * (-parseInt(t(262)) / 9) + -parseInt(t(264)) / 10 === 412362)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = Xa, n = dv();
  for (; ; )
    try {
      if (parseInt(t(266)) / 1 + -parseInt(t(256)) / 2 * (-parseInt(t(282)) / 3) + parseInt(t(257)) / 4 * (parseInt(t(267)) / 5) + -parseInt(t(291)) / 6 + parseInt(t(275)) / 7 + parseInt(t(270)) / 8 + -parseInt(t(263)) / 9 === 417323)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const ut = mv;
function pv() {
  const i = ["DstAlphaFactor", "setHex", "CustomBlending", "324566yYkdJP", "add", "ReverseSubtractEquation", "name", "404451esfmNm", "onFinishChange", "1878rhqbej", "SrcAlphaFactor", "SubtractEquation", "ZeroFactor", "24tJyuQs", "BackSide", "AddEquation", "addFolder", "MinEquation", "面类型", "10dmRHLb", "DoubleSide", "visible", "OneMinusSrcAlphaFactor", "SrcColorFactor", "30ZuSSBk", "color", "addHexColor", "alphaTest", "13DSzxUY", "OneFactor", "154XrkGku", "needsUpdate", "wireframe", "AdditiveBlending", "NoBlending", "mapType", "onChange", "199768pYyLwT", "56aVMKiP", "OneMinusDstColorFactor", "blending", "141192HCcRrg", "opacity", "OneMinusDstAlphaFactor", "混合模式", "4637234oJjwex", "side", "SrcAlphaSaturateFactor", "4fqNjGE", "MultiplyBlending", "DstColorFactor", "FrontSide", "transparent", "OneMinusSrcColorFactor", "53215daZArf", "线框模式"];
  return (pv = function() {
    return i;
  })();
}
(function(i, e) {
  const t = mv, n = pv();
  for (; ; )
    try {
      if (-parseInt(t(410)) / 1 * (-parseInt(t(431)) / 2) + parseInt(t(464)) / 3 * (-parseInt(t(449)) / 4) + -parseInt(t(455)) / 5 * (-parseInt(t(425)) / 6) + -parseInt(t(439)) / 7 * (parseInt(t(438)) / 8) + parseInt(t(442)) / 9 * (-parseInt(t(420)) / 10) + parseInt(t(460)) / 11 * (-parseInt(t(414)) / 12) + -parseInt(t(429)) / 13 * (-parseInt(t(446)) / 14) === 119767)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const fv = { 无混合: W[ut(435)], 正常混合: 1, 叠加混合: W[ut(434)], 减去混合: 3, 乘法混合: W[ut(450)], 自定义混合: W[ut(459)] }, kC = { 加法: W[ut(416)], 减法: W[ut(412)], 反向减法: W[ut(462)], 最小值: W[ut(418)], 最大值: 104 }, FC = { 零: W[ut(413)], 一: W[ut(430)], 源颜色: W[ut(424)], "1-源颜色": W[ut(454)], 源透明度: W[ut(411)], "1-源透明度": W[ut(423)], 目标透明度: W[ut(457)], "1-目标透明度": 207, 目标颜色: W[ut(451)], "1-目标颜色": W[ut(440)], 源透明饱和: W[ut(448)] }, BC = { 零: W[ut(413)], 一: W[ut(430)], 源颜色: W[ut(424)], "1-源颜色": W[ut(454)], 源透明度: Ua, "1-源透明度": ka, 目标透明度: W[ut(457)], "1-目标透明度": W[ut(444)], 目标颜色: W[ut(451)], "1-目标颜色": W[ut(440)] };
function mv(i, e) {
  const t = pv();
  return (mv = function(n, r) {
    return t[n -= 409];
  })(i, e);
}
const zC = { 正面: W[ut(452)], 背面: W[ut(415)], 双面: tn };
function HC(i) {
  const { visible: e, color: t, wireframe: n, transparent: r, opacity: s, alphaTest: a, blending: o, side: l } = i;
  return Ee({ visible: e, color: t, wireframe: n, transparent: r, opacity: s, alphaTest: a, blending: o, side: l }, UC(i));
}
function GC(i, e, t) {
  const n = ut;
  t[n(461)](e, n(422))[n(463)]("显示"), t[n(427)](e[n(426)])[n(463)]("颜色"), t.add(e, n(433))[n(463)](n(456)), t.add(e, n(447), zC)[n(463)](n(419))[n(409)]((r) => (e[n(447)] = Number(r), e[n(432)] = !0)), t.add(e, n(453)).name("透明"), t[n(461)](e, n(443), 0, 1).name("透明度"), t.add(e, n(428), 0, 1)[n(463)]("剔除阈值"), t[n(461)](e, n(441), fv)[n(463)](n(445))[n(437)]((r) => (e[n(441)] = Number(r), e.needsUpdate = !0)), function(r, s, a) {
    const o = Xa;
    !Reflect[o(255)](s, o(272)) && (s[o(272)] = ""), a.add(s, o(272))[o(250)]("贴图"), !Reflect[o(255)](s, o(261)) && (s[o(261)] = "图片"), a[o(273)](s, o(261), ["图片", "视频"])[o(250)](o(271)), a.add({ updateMap: () => WS(r, s) }, "updateMap").name(o(265));
  }(i, e, t[n(417)]("贴图"));
}
function Wh(i, e) {
  var t = gv();
  return (Wh = function(n, r) {
    return t[n -= 137];
  })(i, e);
}
function VC(i) {
  var e = Wh;
  switch (i[e(178)]) {
    case "MeshBasicMaterial":
      return { envMap: !!i[e(194)], reflectivity: i[e(185)] };
    case e(176):
      return { emissive: i[e(150)][e(141)](), emissiveIntensity: i.emissiveIntensity, metalness: i[e(138)], roughness: i.roughness, envMap: !!i[e(194)], envMapIntensity: i[e(140)] };
    case e(171):
      return { emissive: i.emissive[e(141)](), emissiveIntensity: i.emissiveIntensity, envMap: !!i[e(194)], reflectivity: i[e(185)] };
    case e(137):
      return { shininess: i[e(153)], specular: i.specular.getHex(), emissive: i[e(150)].getHex(), emissiveIntensity: i[e(151)], envMap: !!i[e(194)], reflectivity: i[e(185)] };
    case e(154):
      return { emissive: i[e(150)][e(141)](), emissiveIntensity: i[e(151)] };
    case "MeshPhysicalMaterial":
      return { metalness: i[e(138)], roughness: i[e(162)], clearcoat: i.clearcoat, clearcoatRoughness: i.clearcoatRoughness, sheen: i.sheen, sheenRoughness: i.sheenRoughness, sheenColor: i[e(196)][e(141)](), specularColor: i[e(195)][e(141)](), specularIntensity: i[e(170)], transmission: i[e(172)], emissive: i[e(150)].getHex(), emissiveIntensity: i.emissiveIntensity, envMap: !!i.envMap, envMapIntensity: i[e(140)], reflectivity: i[e(185)] };
  }
}
function gv() {
  var i = ["138YfeEYm", "push", "emissive", "emissiveIntensity", "1453256VWvyoD", "shininess", "MeshToonMaterial", "564MPdKuV", "2711342iXnoIN", "3OyBpLC", "setHex", "高光颜色", "透射率", "环境贴图", "roughness", "isEnvMap", "清漆层", "MeshBasicMaterial", "MeshPhysicalMaterial", "金属度", "133064RBfFtt", "自发光强度", "specularIntensity", "MeshLambertMaterial", "transmission", "clearcoat", "125810oyKzMv", "name", "MeshStandardMaterial", "50SdiBiF", "type", "addHexColor", "252657FQMFnJ", "clearcoatRoughness", "524426BhAwAQ", "清漆层粗糙度", "needsUpdate", "reflectivity", "sheenRoughness", "光泽度", "光泽颜色", "577027eBgugY", "specular", "add", "自发光颜色", "envBackground", "envMap", "specularColor", "sheenColor", "MeshPhongMaterial", "metalness", "sheen", "envMapIntensity", "getHex", "onChange", "反射率", "环境贴图强度", "envMapChangeUseList", "高光强度", "133PCYMcz"];
  return (gv = function() {
    return i;
  })();
}
function vv() {
  var i = ["3225695xAGraK", "239wgAvmW", "297UlFNri", "materialType", "addFolder", "6840372SaLFii", "3846052hTWLvR", "6xQZHaw", "commonFrames", "7898yNJASX", "1180065QXqNXi", "1073890NMuVBR", "7740032mOOSjO"];
  return (vv = function() {
    return i;
  })();
}
function ff(i, e) {
  var t = vv();
  return (ff = function(n, r) {
    return t[n -= 110];
  })(i, e);
}
function mf(i) {
  return Ee(Ee({ materialType: i[ff(117)] }, HC(i)), VC(i));
}
function gf(i, e, t) {
  t && (function(n, r, s) {
    const a = ut, { visible: o, color: l, wireframe: c, side: h, transparent: u, opacity: d, alphaTest: p, blending: f, map: v, mapUrl: m, mapType: y } = s;
    r[a(422)] = o, r[a(426)][a(458)](l), r[a(433)] = c, r[a(453)] = u, r[a(443)] = d, r.alphaTest = p, r[a(441)] = f, r.side = h != null ? h : W[a(421)], m && (r.mapUrl = m, r[a(436)] = y, WS(n, r, v));
  }(i.commonFrames, e, t), function(n, r, s) {
    var a = Wh;
    switch (r.type) {
      case a(165):
        s[a(194)] && (r[a(194)] = n[a(193)], n[a(145)][a(149)](() => r[a(194)] = n[a(193)])), r.reflectivity = s[a(185)];
        break;
      case a(176):
        r[a(150)][a(158)](s[a(150)]), r.emissiveIntensity = s[a(151)], s[a(194)] && (r[a(194)] = n[a(193)], n[a(145)].push(() => r.envMap = n.envBackground)), r.envMapIntensity = s.envMapIntensity, r[a(138)] = s.metalness, r.roughness = s[a(162)];
        break;
      case a(171):
        r[a(150)][a(158)](s[a(150)]), r.emissiveIntensity = s[a(151)], s[a(194)] && (r[a(194)] = n[a(193)], n[a(145)][a(149)](() => r[a(194)] = n[a(193)])), r[a(185)] = s[a(185)];
        break;
      case a(137):
        r[a(153)] = s[a(153)], r[a(190)][a(158)](s[a(190)]), r[a(150)][a(158)](s[a(150)]), r[a(151)] = s.emissiveIntensity, s[a(194)] && (r[a(194)] = n.envBackground, n[a(145)][a(149)](() => r[a(194)] = n[a(193)])), r[a(185)] = s[a(185)];
        break;
      case "MeshToonMaterial":
        r[a(150)][a(158)](s[a(150)]), r.emissiveIntensity = s.emissiveIntensity;
        break;
      case a(166):
        r[a(138)] = s[a(138)], r.roughness = s[a(162)], r.clearcoat = s[a(173)], r[a(181)] = s[a(181)], r[a(139)] = s[a(139)], r[a(186)] = s[a(186)], r[a(196)].setHex(s[a(196)]), r.specularColor.setHex(s[a(195)]), r[a(170)] = s[a(170)], r[a(172)] = s[a(172)], r[a(150)][a(158)](s.emissive), r.emissiveIntensity = s[a(151)], s[a(194)] && (r.envMap = n[a(193)], n[a(145)].push(() => r.envMap = n[a(193)])), r[a(140)] = s[a(140)], r[a(185)] = s[a(185)];
    }
  }(i, e, t));
}
function vf(i, e, t) {
  var n = ff;
  GC(i[n(122)], e, t), function(r, s, a) {
    var o = Wh;
    switch (s[o(178)]) {
      case "MeshBasicMaterial":
        a[o(191)]({ isEnvMap: !!s[o(194)] }, o(163))[o(175)]("环境贴图")[o(142)]((l) => s.envMap = l ? r[o(193)] : null), a[o(191)](s, o(185), 0, 1)[o(175)]("反射率");
        break;
      case "MeshStandardMaterial":
        a[o(179)](s.emissive)[o(175)]("自发光颜色"), a[o(191)](s, o(151), 0)[o(175)](o(169)), a.add(s, "metalness", 0, 1)[o(175)](o(167)), a.add(s, o(162), 0, 1)[o(175)]("粗糙度"), a.add({ isEnvMap: !!s[o(194)] }, o(163))[o(175)](o(161)).onChange((l) => s[o(194)] = l ? r.envBackground : null), a[o(191)](s, o(140), 0)[o(175)](o(144));
        break;
      case o(171):
        a[o(179)](s.emissive)[o(175)](o(192)), a.add(s, o(151), 0)[o(175)]("自发光强度"), a.add({ isEnvMap: !!s[o(194)] }, o(163))[o(175)]("环境贴图")[o(142)]((l) => s[o(194)] = l ? r[o(193)] : null), a.add(s, o(185), 0, 1)[o(175)](o(143));
        break;
      case o(137):
        a[o(191)](s, o(153), 0, 100).name("高光亮度")[o(142)]((l) => s[o(184)] = !0), a[o(179)](s[o(190)])[o(175)](o(159)), a[o(179)](s[o(150)])[o(175)](o(192)), a[o(191)](s, o(151), 0)[o(175)](o(169)), a[o(191)]({ isEnvMap: !!s[o(194)] }, "isEnvMap")[o(175)](o(161))[o(142)]((l) => s[o(194)] = l ? r[o(193)] : null), a[o(191)](s, o(185), 0, 1)[o(175)](o(143));
        break;
      case o(154):
        a[o(179)](s[o(150)])[o(175)](o(192)), a[o(191)](s, "emissiveIntensity", 0)[o(175)](o(169));
        break;
      case "MeshPhysicalMaterial":
        a.add(s, o(138), 0, 1)[o(175)]("金属度"), a[o(191)](s, o(162), 0, 1).name("粗糙度"), a[o(191)](s, o(173), 0, 1)[o(175)](o(164)), a[o(191)](s, o(181), 0, 1)[o(175)](o(183)), a[o(191)](s, o(139), 0, 1)[o(175)](o(187)), a[o(191)](s, o(186), 0, 1)[o(175)]("光泽粗糙度"), a[o(179)](s.sheenColor)[o(175)](o(188)), a[o(179)](s.specularColor).name("高光颜色"), a[o(191)](s, o(170), 0, 1)[o(175)](o(146)), a.add(s, o(172), 0, 1).name(o(160)), a.addHexColor(s[o(150)])[o(175)](o(192)), a.add(s, o(151), 0)[o(175)](o(169)), a[o(191)]({ isEnvMap: !!s[o(194)] }, o(163)).name(o(161))[o(142)]((l) => s[o(194)] = l ? r[o(193)] : null), a[o(191)](s, o(140), 0)[o(175)](o(144)), a[o(191)](s, o(185), 0, 1)[o(175)](o(143));
    }
  }(i, e, t[n(118)](e[n(117)] + "配置"));
}
function yv(i, e) {
  const t = _v();
  return (yv = function(n, r) {
    return t[n -= 363];
  })(i, e);
}
(function(i, e) {
  for (var t = Wh, n = gv(); ; )
    try {
      if (parseInt(t(182)) / 1 + -parseInt(t(156)) / 2 + parseInt(t(157)) / 3 * (parseInt(t(152)) / 4) + parseInt(t(174)) / 5 * (-parseInt(t(148)) / 6) + parseInt(t(147)) / 7 * (-parseInt(t(168)) / 8) + -parseInt(t(180)) / 9 * (parseInt(t(177)) / 10) + parseInt(t(189)) / 11 * (parseInt(t(155)) / 12) === 962430)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  for (var t = ff, n = vv(); ; )
    try {
      if (-parseInt(t(115)) / 1 * (-parseInt(t(110)) / 2) + -parseInt(t(111)) / 3 + parseInt(t(120)) / 4 + -parseInt(t(114)) / 5 * (-parseInt(t(121)) / 6) + parseInt(t(119)) / 7 + parseInt(t(113)) / 8 + -parseInt(t(116)) / 9 * (parseInt(t(112)) / 10) === 557971)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const Oo = yv;
(function(i, e) {
  const t = yv, n = _v();
  for (; ; )
    try {
      if (parseInt(t(378)) / 1 + -parseInt(t(364)) / 2 + parseInt(t(368)) / 3 * (-parseInt(t(367)) / 4) + -parseInt(t(372)) / 5 + -parseInt(t(363)) / 6 + -parseInt(t(375)) / 7 * (parseInt(t(376)) / 8) + -parseInt(t(374)) / 9 * (-parseInt(t(370)) / 10) === 583406)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const XS = { material: "vUv = uv;", position: Oo(366), modelMatrix: Oo(377), modelViewMatrix: Oo(371), projectionMatrix: "vUv = (projectionMatrix * vec4(position, 1.0)).xy;", viewMatrix: Oo(369), custom_uv1: Oo(373) }, jC = Object[Oo(365)](XS);
function _v() {
  const i = ["vUv = (viewMatrix * vec4(position, 1.0)).xy;", "5740NsChHb", "vUv = (modelViewMatrix * vec4(position, 1.0)).xy;", "2014340YVAgqh", `
    
        vec4 projectedPosition = projectionMatrix * modelMatrix  * vec4(position, 1.0);

        vec3 ndcPosition = projectedPosition.xyz / projectedPosition.w;

        vUv = ndcPosition.xy / ndcPosition.z;
    `, "59355NrInOn", "7RbSSkP", "6582584BWPltq", "vUv = (modelMatrix * vec4(position, 1.0)).xy;", "154967nzGTBu", "6258450UaOumG", "226518iNTyvi", "keys", "vUv = position.xy/ position.z;", "650044BaBDeE", "18NclmAA"];
  return (_v = function() {
    return i;
  })();
}
var He = xv;
function xv(i, e) {
  var t = bv();
  return (xv = function(n, r) {
    return t[n -= 473];
  })(i, e);
}
function bv() {
  var i = ["vUv-material", "circleWidth-number-float-2", "color3-color-vec3-0.0,0.0,1.0", "9ipjMKu", "iTime+speed", `
            float gTime = 0.;
            const float REPEAT = 5.0;
            mat2 rot(float a) {
                float c = cos(a), s = sin(a);
                return mat2(c,s,-s,c);
            }
            float sdBox( vec3 p, vec3 b )
            {
                vec3 q = abs(p) - b;
                return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
            }
            float box(vec3 pos, float scale) {
                pos *= scale;
                float base = sdBox(pos, vec3(.4,.4,.1)) /1.5;
                pos.xy *= 5.;
                pos.y -= 3.5;
                pos.xy *= rot(.75);
                float result = -base;
                return result;
            }
            float box_set(vec3 pos, float iTime) {
                vec3 pos_origin = pos;
                pos = pos_origin;
                pos .y += sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);
                pos = pos_origin;
                pos .y -=sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);
                pos = pos_origin;
                pos .x +=sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);	
                pos = pos_origin;
                pos .x -=sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);	
                pos = pos_origin;
                pos.xy *=   rot(.8);
                float box5 = box(pos,.5) * 6.;	
                pos = pos_origin;
                float box6 = box(pos,.5) * 6.;	
                float result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);
                return result;
            }
            float mapf(vec3 pos, float iTime) {
                vec3 pos_origin = pos;
                float box_set1 = box_set(pos, iTime);

                return box_set1;
            }
            <SPLIT_PLACEHOLDER>
            vec2 p = gl_FragCoord.xy / iResolution.xy;
            p.x -=.5;
            p.y -=.5;
            p.x *= iResolution.x / iResolution.y;
            vec2 uv = p;
            <UV_PLACEHOLDER>
            p = uv;
            vec3 ro = vec3(0., -0.2 ,iTime * 4.);
            vec3 ray = normalize(vec3(p, 1.5));
            ray.xy = ray.xy * rot(sin(iTime * .03) * 5.);
            ray.yz = ray.yz * rot(sin(iTime * .05) * .2);
            float t = 0.1;
            vec3 col = vec3(0.);
            float ac = 0.0;
            for (int i = 0; i < 99; i++){
                vec3 pos = ro + ray * t;
                pos = mod(pos-2., 4.) -2.;
                gTime = iTime -float(i) * 0.01;
                
                float d = mapf(pos, iTime);

                d = max(abs(d), 0.01);
                ac += exp(-d*23.);

                t += d* 0.55;
            }
            col = vec3(ac * 0.02);
            col +=vec3(0.,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);  
        `, "彩虹光", "precision-lowp,vUv-material", "3522OnPwcV", "晶片着色", "center-position-vec3-0,0,0", "绚烂线条", "iTime-number-float-0.0", "this.innerCircleWidth.value < this.circleMax.value ? this.innerCircleWidth.value += this.circleSpeed.value : this.innerCircleWidth.value = 0", "光圈扫射", "medium-number-float-0.4", "intensity-number-float-2", `
            vec4 fragColor = vec4(0.);
            float sin = sin((vUv.y - iTime * speed) * 10. * density);
            if (sin > high) {
            fragColor = vec4( mixColor, (1. - sin) / (1. - high));
            } else if(sin > medium) {
            fragColor = vec4(mixColor, mix(1., 0., 1.-(sin - medium) / (high - medium)));
            } else {
            fragColor = vec4(mixColor, 0.);
            }
            fragColor = mix(fragColor, vec4(mix(mixColor, vec3(0., 0., 0.), vUv.y), 1.), 0.);
            vec4 diffuseColor = vec4(fragColor.rgb * vec3(intensity, intensity, intensity), fragColor.a * opacity * (1. - vUv.y));
        `, "opacityScale-number-float-1", "col", "雪片着色", `
            vec3 hsv2rgb( vec3 c ){
                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                        6.0)-3.0)-1.0,
                                0.0,
                                1.0 );
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * mix(vec3(1.0), rgb, c.y);
            }
            float rands(vec2 v){
                v = fract(v * vec2(70.26593, 1.6682));
                v += dot(v, v+23.45);
                return fract(v.x*v.y);
            }
            vec2 rand_2(vec2 v){
                float n = rands(v);
                return vec2(n, rands(v + n));
            }
            float dist_line(vec2 which, vec2 p1, vec2 p2){
                float r = clamp(dot(which - p1, p2 - p1) / dot(p2 - p1, p2 - p1), .0, 1.);
                return length((which - p1)-(p2 - p1)*r);
            }
            float drawline(vec2 which, vec2 p1, vec2 p2, float w){
                float dis = dist_line(which, p1, p2);
                return smoothstep(.015*w, .005*w, dis)*smoothstep(.8, .0, distance(p1, p2)-.25);
            }
            vec2 Getpos(vec2 v){
                vec2 p = rand_2(v);
                return vec2(.5)+.4*vec2(cos(p.x*(iTime+5.)), sin(p.y*(iTime+5.)));
            }
            vec3 layer(vec2 uv, float w){
                float m=.0;
                vec2 fl_uv = floor(uv);
                vec2 fr_uv = fract(uv);
                vec2 id = Getpos(fl_uv);
                m = smoothstep(.08*w, .01*w, distance(fr_uv, id))*abs(sin((iTime+id.x)*4.));
                vec2 p[9];
                int num = 0;
                for(float i=-1.; i<=1.; i++){
                    for(float j=-1.; j<=1.; j++){
                        p[num++] = vec2(i,j)+Getpos(fl_uv + vec2(i,j));
                    }
                }
                for(int i=0; i<9; i++){
                m += drawline(fr_uv, p[4], p[i], w);
                }
                m += drawline(fr_uv, p[1], p[3], w);
                m += drawline(fr_uv, p[1], p[5], w);
                m += drawline(fr_uv, p[3], p[7], w);
                m += drawline(fr_uv, p[5], p[7], w);
                return vec3(m);
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            <UV_PLACEHOLDER>
            float yy = uv.y;
            uv -= .5;
            uv.x *= iResolution.x / iResolution.y;
            uv *= .5;
            float t = iTime*.1;
            float rs = sin(2.*t);
            float rc = cos(2.*t);
            uv *= mat2(rc, -rs, rs, rc);
            float m = .0;
            vec3 v3 = vec3(1.);
            vec2 fl_uv = floor(uv);
            vec2 fr_uv = fract(uv);
            
            vec2 id = Getpos(fl_uv);
            vec3 col = vec3(.0);
            
            for(float i=.0; i<1.; i+=1./8.){
                float z = fract(i+t);
                float size = mix(10., .5, z);
                float al = smoothstep(.0, .8, z) * smoothstep(1., .8, z);
                v3 = 0.5 + 0.5*cos(-1.2*z+iTime+uv.xyx+vec3(0,2,4));
            col += layer(uv*size + i*27.385, 1.)*al*v3;
            col += layer(uv*size + i*27.385, .4)*pow(al, 2.);
            }
            //col *= smoothstep(1., .7, yy)*smoothstep(.0, .3, yy);
            v3 = 0.5 + 0.5*cos(iTime-1.2+uv.xyx+vec3(0,2,4));
            col += vec3(.8*yy)*.3*v3;
            col += vec3(.2*(1.-yy))*.3*v3;
        `, "isDisCard-bool-bool-false", "541410onvjjr", "speed-number-float-0.05", "circleSpeed-number-float-0.01", "290622GMLpAR", "MAX_ITER-number-int-5", "diff-color-vec3-0.0,0.0,1.0", "水波纹", "174680lDaZpj", "wave_color", "1449173iWRpSP", "intensity-number-float-1", "20167xuRvAX", "high-number-float-0.5", "TAU-number-float-6.28318530718", `
            mat2 rot(float a) {
                float c = cos(a), s = sin(a);
                return mat2(c,s,-s,c);
            }
            const float pi = acos(-1.0);
            const float pi2 = pi*2.0;
            vec2 pmod(vec2 p, float r) {
                float a = atan(p.x, p.y) + pi/r;
                float n = pi2 / r;
                a = floor(a/n)*n;
                return p*rot(-a);
            }
            float box( vec3 p, vec3 b ) {
                vec3 d = abs(p) - b;
                return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
            }
            float ifsBox(vec3 p) {
                for (int i=0; i<5; i++) {
                    p = abs(p) - 1.0;
                    p.xy *= rot(iTime*0.3);
                    p.xz *= rot(iTime*0.1);
                }
                p.xz *= rot(iTime);
                return box(p, vec3(0.4,0.8,0.3));
            }
            float mapSnow(vec3 p, vec3 cPos) {
                vec3 p1 = p;
                p1.x = mod(p1.x-5., 10.) - 5.;
                p1.y = mod(p1.y-5., 10.) - 5.;
                p1.z = mod(p1.z, 16.)-8.;
                p1.xy = pmod(p1.xy, 5.0);
                return ifsBox(p1);
            }  
            <SPLIT_PLACEHOLDER>
            vec2 p = (gl_FragCoord.xy * 2.0  - iResolution.xy) / min(iResolution.x, iResolution.y);
            vec2 uv = p;
            <UV_PLACEHOLDER>
            p = uv;
            vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);
            vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));
            vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);
            vec3 cSide = cross(cDir, cUp);
            vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);
            float acc = 0.0;
            float acc2 = 0.0;
            float t = 0.0;
            for (int i = 0; i < 99; i++) {
                vec3 pos = cPos + ray * t;
                float dist = mapSnow(pos, cPos);
                dist = max(abs(dist), 0.02);
                float a = exp(-dist*3.0);
                if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {
                    a *= 2.0;
                    acc2 += a;
                }
                acc += a;
                t += dist * 0.5;
            }
            vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.002, acc * 0.012+ acc2*0.005);
        `, "circleMax-number-float-2", "5729490Etyxed", "6HAbtLA", "density-number-float-5", "光线叠加", "6614868cpqchh"];
  return (bv = function() {
    return i;
  })();
}
(function(i, e) {
  for (var t = xv, n = bv(); ; )
    try {
      if (-parseInt(t(515)) / 1 + parseInt(t(509)) / 2 * (-parseInt(t(479)) / 3) + parseInt(t(482)) / 4 + -parseInt(t(506)) / 5 + parseInt(t(491)) / 6 * (parseInt(t(473)) / 7) + parseInt(t(513)) / 8 * (-parseInt(t(486)) / 9) + -parseInt(t(478)) / 10 === 902003)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const qS = [{ name: He(489), commonUniforms: !0, vertex: "vUv-material", fragment: `
            vec3 c;
            float l,z=iTime;
            for(int i=0;i<3;i++) {
                vec2 uv,p=gl_FragCoord.xy/iResolution/2.0;
                uv=p;
                p-=.3;
                <UV_PLACEHOLDER>
                z+=.07;
                l=length(p);
                uv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z-z));
                c[i]=.01/length(mod(uv,1.)-.5);
            }
        `, commonFinish: !0, key: "c", isParticle: !0, render: "iTime+speed" }, { name: He(512), commonUniforms: !0, customUniforms: [He(475), He(510)], vertex: He(483), fragment: `
            float time = iTime * .5+23.0;
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            <UV_PLACEHOLDER>
            #ifdef SHOW_TILING
                vec2 p = mod(uv*TAU*2.0, TAU)-250.0;
            #else
                vec2 p = mod(uv*TAU, TAU)-250.0;
            #endif
            vec2 i = vec2(p);
            float c = 1.0;
            float inten = .005;
            for (int n = 0; n < MAX_ITER; n++) 
            {
                float t = time * (1.0 - (3.5 / float(n+1)));
                i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
                c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));
            }
            c /= float(MAX_ITER);
            c = 1.17-pow(c, 1.4);
            vec3 colour = vec3(pow(abs(c), 8.0));
            colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);
            #ifdef SHOW_TILING
            // Flash tile borders...
            vec2 pixel = 2.0 / iResolution.xy;
            uv *= 2.0;
            float f = floor(mod(iTime*.5, 2.0)); 	// Flash value.
            vec2 first = step(pixel, uv) * f;		   	// Rule out first screen pixels and flash.
            uv  = step(fract(uv), pixel);				// Add one line of pixels per tile.
            colour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line
            #endif
        `, commonFinish: !0, key: "colour", isParticle: !0, render: "iTime+speed" }, { name: He(497), commonUniforms: !1, customUniforms: ["innerCircleWidth-number-float-1", He(484), He(477), He(501), "reverseOpacity-bool-bool-true", He(508), He(511), He(485), He(493), He(516), He(505)], vertex: "vUv-material,vPosition", fragment: `
            float dis = length(vPosition - center);
            vec4 diffuseColor;
            if(dis < (innerCircleWidth + circleWidth) && dis > innerCircleWidth) {
                float r = (dis - innerCircleWidth) / circleWidth;
                float cOpacity = reverseOpacity ? (innerCircleWidth / circleMax) : 1. - ( innerCircleWidth / circleMax );
                #ifdef USE_MAP
                    vec3 textureColor = texture2D(map, vUv).rgb;
                    if(isDisCard && textureColor.r < 0.1 && textureColor.g < 0.1  && textureColor.b < 0.1 ) discard;
                #endif
                diffuseColor = vec4( mix(diff, color3, r) * vec3(intensity, intensity, intensity)  , opacity * cOpacity * opacityScale);
            }
            else {
                if(isDisCard)  discard ;
                else diffuseColor = vec4( diffuse, opacity );
            }
        `, commonFinish: !1, render: He(496) }, { name: He(492), commonUniforms: !0, vertex: "vUv-material", key: He(502), fragment: He(488), commonFinish: !0, isParticle: !0, render: "iTime+speed" }, { name: "流光围栏", commonUniforms: !1, customUniforms: [He(495), He(507), He(499), He(480), "mixColor-color-vec3-1.0,1.0,1.0", He(474), He(498)], vertex: He(483), fragment: He(500), commonFinish: !1, render: He(487) }, { name: He(503), commonUniforms: !0, customUniforms: !1, vertex: He(490), fragment: He(476), commonFinish: !0, key: He(502), isParticle: !0, render: He(487) }, { name: He(481), commonUniforms: !0, customUniforms: !1, vertex: He(483), fragment: `
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            vec3 wave_color = vec3(0.0);
            float wave_width = 0.0;
            uv  = -3.0 + 2.0 * uv;
            uv.y += 0.0;
            <UV_PLACEHOLDER>
            for(float i = 0.0; i <= 28.0; i++) {
                uv.y += (0.2+(0.9*sin(iTime*0.4) * sin(uv.x + i/3.0 + 3.0 *iTime )));
                uv.x += 1.7* sin(iTime*0.4);
                wave_width = abs(1.0 / (200.0*abs(cos(iTime)) * uv.y));
                wave_color += vec3(wave_width *( 0.4+((i+1.0)/18.0)), wave_width * (i / 9.0), wave_width * ((i+1.0)/ 8.0) * 1.9);
        }`, commonFinish: !0, key: He(514), isParticle: !0, render: He(487) }, { name: He(494), commonUniforms: !0, customUniforms: !1, vertex: "vUv-material", fragment: He(504), commonFinish: !0, key: He(502), isParticle: !0, render: He(487) }];
var et = wv;
function Mv() {
  var i = ["光晕泛光", "vUv-material", `
            vec2 uv = iResolution;
            <UV_PLACEHOLDER>
            float scale = (uv.x + uv.y)/2.;
            vec4 fragColor = vec4(0.0,0.0,0.0,1.0);
            int bubs = 4;
            for( int i=0; i<bubs; i++ )
            {
                vec2 bubbleCenter = uv.xy/2.0;
                bubbleCenter.y = uv.y/2.*(sin(float(i)*3.7+iTime/19.*float(i+1))+1.);
                float radius = scale/(1.+float(bubs)/7.);
                bubbleCenter.x = uv.x/2.*(sin(float(i)*7.3+iTime/17.*float(i+1))+1.);
                float dis = length( gl_FragCoord.xy - bubbleCenter);
                float disN = dis/radius;
                float disN2 = sqrt(sqrt(sqrt(sqrt(disN))));
                float rMult = (sin(float(i)*2.17)+1.)/2.;
                float gMult = .5;//float(i)/(float(bubs)+7.)+.2;
                float bMult = 1.-rMult;
                rMult = (rMult + .5)/2.;
                rMult = (rMult + .5)/2.;
                bMult = (bMult + .5)/2.;
                bMult = (bMult + .5)/2.;
                if (dis < radius) {
                    fragColor.x += (1.-disN2)*rMult;
                    fragColor.y += (1.-disN2)*gMult;
                    fragColor.z += (1.-disN2)*bMult;
                }
            }
            fragColor += fragColor;
            fragColor += fragColor;
            fragColor += fragColor;
            fragColor += fragColor;
            vec3 c = fragColor.rgb;
        `, "uvY-number-float-1", "seaColor", "16611637UzYBXv", "exponent-number-float-0.6", "火焰燃烧", "offset-number-float-400", "2544768MiaXLT", "ITER_GEOMETRY-number-int-2", "HEAT_MAX-number-float-10", "流光栅格", "360588DDbqtq", "topColor-color-vec3-0x0077ff", "isDiscard-bool-bool-false", "iTime+speed", "EPSILON-number-float-0.001", "SEA_CHOPPY-number-float-3.0", "uvX-number-float-1", "5259565Allsce", `
            float hash11(float p)
            {
                p = fract(p * .1031);
                p *= p + 33.33;
                p *= p + p;
                return fract(p);
            }
            float hash12(vec2 p)
            {
                vec3 p3 = fract(vec3(p.xyx) * .1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.x + p3.y) * p3.z);
            }
            mat2 rotate2d(float theta)
            {
                float c = cos(theta);
                float s = sin(theta);
                return mat2(
                    c, -s,
                    s, c
                );
            }
            float noise(vec2 p)
            {
                vec2 ip = floor(p);
                vec2 fp = fract(p);
                float a = hash12(ip);
                float b = hash12(ip + vec2(1, 0));
                float c = hash12(ip + vec2(0, 1));
                float d = hash12(ip + vec2(1, 1));
                
                vec2 t = smoothstep(0.0, 1.0, fp);
                return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);
            }
            float fbm(vec2 p)
            {
                float value = 0.0;
                float amplitude = 0.5;
                for (int i = 0; i < 8; ++i)
                {
                    value += amplitude * noise(p);
                    p *= rotate2d(0.45);
                    p *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = gl_FragCoord.xy / iResolution.xy; 
            <UV_PLACEHOLDER>
            uv = 2.0 * uv - 1.0;
            uv.x *= iResolution.x / iResolution.y;
            uv += 2.0 * fbm(uv+0.8*iTime) - 1.0;
            float dist = abs(uv.x);
            vec3 col = vec3(0.2, 0.3, 0.8) * pow(mix(0.0, 0.07, hash11(iTime)) / dist, 1.0);
            col = pow(col, vec3(1.0));  
        `, "2807052PWAcrQ", "160426KINyzV", "PointRadius-number-float-0.42", `
            vec3 gradient(float w, vec2 uv) {
                w = pow(clamp(w, 0., 1.) * 3.14159 * .5, .9);
                return vec3(sin(w), sin(w * 2.), cos(w))* 1.1 + mix(c1, c2, w) * 1.1; 
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = (2. * gl_FragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);
            <UV_PLACEHOLDER>
            uv.xy *= vec2(uvX, uvY);
            float d = 0.;
            for (int i = 0; i < PointsCount; i++) {
                vec3 v = Points[i];
                float intensity = v.z / HEAT_MAX;
                float pd = (1. - length(uv - v.xy) / PointRadius) * intensity;
                d += pow(max(0., pd), 2.);
            }
            vec3 c = gradient(d, uv);
        `, `
            float h = normalize( vWorldPosition + offset ).y;
            vec4 diffuseColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );
        `, "热力图", `
            vec3 palette( float t ) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.263,0.416,0.557);
                return a + b*cos( 6.28318*(c*t+d) );
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
            <UV_PLACEHOLDER>
            vec2 vv0 = uv;
            vec3 finalColor = vec3(0.0);
            for (float i = 0.0; i < 4.0; i++) {
                uv = fract(uv * 1.5) - 0.5;
                float d = length(uv) * exp(-length(vv0));
                vec3 col = palette(length(vv0) + i*.4 + iTime*.4);
                d = sin(d*8. + iTime)/8.;
                d = abs(d);
                d = pow(0.01 / d, 1.2);
                finalColor += col * d;
            }
        `, "SEA_WATER_COLOR-color-vec3-0.55,0.9,0.7", "c1-color-vec3-0,0,0", "finalColor", "NUM_STEPS-number-int-6", `
            const vec3 c = vec3(1, 0, -1);
            const mat2 m = .4 * mat2(4, 3, -3, 4);
            float hash12(vec2 p)
            {
                vec3 p3  = fract(vec3(p.xyx) * .1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract(dot(p3.xy, p3.zz));
            }
            float lfnoise(vec2 t)
            {
                vec2 i = floor(t);
                t = c.xx * smoothstep(0., 1., fract(t));
                vec2 v1 = 2. * mix(vec2(hash12(i), hash12(i + c.xy)), vec2(hash12(i + c.yx), hash12(i + c.xx)), t.y) - 1.;
                return mix(v1.x, v1.y, t.x);
            }
            float fbm(vec2 uv)
            {
                vec2 uv0 = uv;
                uv = uv * vec2(5., 2.) - vec2(-2., -.25) - 3.1 * iTime * c.yx;
                float f = 1.,
                    a = .5,
                    c = 2.5;
                
                for(int i = 0; i < 5; ++i) {
                    uv.x -= .15 * clamp(1. - pow(uv0.y, 4.), 0., 1.) * lfnoise(c * (uv + float(i) * .612 + iTime));
                    c *= 2.;
                    f += a * lfnoise(uv + float(i) * .415);
                    a /= 2.;
                    uv *= m;
                }
                return f / 2.;
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = gl_FragCoord.xy / iResolution.xy; 
            <UV_PLACEHOLDER>
            vec3 col = clamp(1.5 * pow(clamp(pow(fbm(uv), 1. + 4. * clamp(uv.y * uv.y, 0., 1.)) * 1.5, 0., 1.) * c.xxx, vec3(1, 3, 6)), 0., 1.);
            if(isDiscard && col.r < 0.1 && col.g < 0.1  && col.b < 0.1 ) discard;
        `, "ITER_FRAGMENT-number-int-5", "Points-vec3[]-vec3[]-0,0,10", "1311300dZOVFM", "着色天空"];
  return (Mv = function() {
    return i;
  })();
}
function wv(i, e) {
  var t = Mv();
  return (wv = function(n, r) {
    return t[n -= 176];
  })(i, e);
}
(function(i, e) {
  for (var t = wv, n = Mv(); ; )
    try {
      if (-parseInt(t(212)) / 1 + parseInt(t(202)) / 2 + -parseInt(t(198)) / 3 + -parseInt(t(187)) / 4 + -parseInt(t(209)) / 5 + parseInt(t(211)) / 6 + parseInt(t(194)) / 7 === 632807)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const YS = [{ name: "流光闪电", commonUniforms: !0, vertex: et(190), fragment: et(210), commonFinish: !0, key: "col", isParticle: !0, render: et(205) }, { name: et(196), commonUniforms: !0, customUniforms: [et(204)], vertex: et(190), fragment: et(184), commonFinish: !0, key: "col", isParticle: !0, render: et(205) }, { name: et(201), commonUniforms: !0, vertex: "vUv-material", fragment: et(179), commonFinish: !0, key: et(182), isParticle: !0, render: "iTime+speed" }, { name: "水面着色", commonUniforms: !0, customUniforms: [et(206), "SEA_BASE-color-vec3-0.11,0.19,0.22", et(180), et(183), et(199), et(185), "SEA_HEIGHT-number-float-0.5", et(207), "SEA_SPEED-number-float-1.9", "SEA_FREQ-number-float-0.24"], vertex: et(190), fragment: `
            #define  EPSILON_NRM (1. / iResolution.x)
            #define SEA_TIME (iTime * SEA_SPEED)
            mat2 octave_m = mat2(1.7,1.2,-1.2,1.4);
            const float KEY_SP    = 32.5/256.0;
            vec3 rgb2hsv(vec3 c)
            {
                vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }
            vec3 hsv2rgb(vec3 c)
            {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            mat3 fromEuler(vec3 ang) {
                vec2 a1 = vec2(sin(ang.x),cos(ang.x));
                vec2 a2 = vec2(sin(ang.y),cos(ang.y));
                vec2 a3 = vec2(sin(ang.z),cos(ang.z));
                mat3 m;
                m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);
                m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);
                m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);
                return m;
            }
            float hash( vec2 p ) {
                float h = dot(p,vec2(127.1,311.7));	
                return fract(sin(h)*83758.5453123);
            }
            
            float noise( in vec2 p ) {
                vec2 i = floor( p );
                vec2 f = fract( p );	
                vec2 u = f*f*(3.0-2.0*f);
                return -1.0+2.0*mix( 
                            mix( hash( i + vec2(0.0,0.0) ), 
                                hash( i + vec2(1.0,0.0) ), 
                                    u.x),
                            mix( hash( i + vec2(0.0,1.0) ), 
                                hash( i + vec2(1.0,1.0) ), 
                                    u.x), 
                            u.y);
            }
            float diffuseL(vec3 n,vec3 l,float p) {
                return pow(dot(n,l) * 0.4 + 0.6,p);
            }
            float specularS(vec3 n,vec3 l,vec3 e,float s) {    
                float nrm = (s + 8.0) / (3.1415 * 8.0);
                return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
            }
            
            float sea_octave(vec2 uv, float choppy) {
                uv += noise(uv);
                vec2 wv = 1.0-abs(sin(uv)); 
                vec2 swv = abs(cos(uv));  
                wv = mix(wv,swv,wv);
                return pow(1.0-pow(wv.x * wv.y,0.65),choppy);
            }
            float mapL(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75;
                float d, h = 0.0;    
                for(int i = 0; i < ITER_GEOMETRY; i++) {
                    d = sea_octave((uv+iTime)*freq,choppy);
                    h += d * amp; 
                    uv *=  octave_m;   
                    freq *= 1.9; 
                    amp *= 0.22;
                    choppy = mix(choppy,1.0,0.2);
                }
                return p.y - h;
            }
            float map_detailed(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75;
                float d, h = 0.0;    
                for(int i = 0; i < ITER_FRAGMENT; i++) {
                    d = sea_octave((uv+iTime)*freq,choppy);
                    d += sea_octave((uv-iTime)*freq,choppy);
                    h += d * amp; 
                    uv *= octave_m/1.2;
                    freq *= 1.9;
                    amp *= 0.22;
                    choppy = mix(choppy,1.0,0.2);
                }
                return p.y - h;
            }
            vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
                float fresnel = 1.0 - max(dot(n,-eye),0.0);
                fresnel = pow(fresnel,3.0) * 0.45;
                vec3 refracted = SEA_BASE + diffuseL(n,l,80.0) * SEA_WATER_COLOR * 0.27; 
                vec3 color = refracted;
                float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
                color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.15 * atten;
                color += vec3(specularS(n,l,eye,90.0))*0.5;
                return color;
            }
            vec3 getNormal(vec3 p, float eps) {
                vec3 n;
                n.y = map_detailed(p);
                n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; 
                n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
                n.y = eps; 
                return normalize(n);
            }
            float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
                float tm = 0.0;
                float tx = 500.0; 
                float hx = mapL(ori + dir * tx);
                if(hx > 0.0) return tx;   
                float hm = mapL(ori + dir * tm); 
                float tmid = 0.0;
                for(int i = 0; i < NUM_STEPS; i++) { 
                    tmid = mix(tm,tx, hm/(hm-hx));
                    p = ori + dir * tmid; 
                            
                    float hmid = mapL(p); 
                    if(hmid < 0.0) { 
                        tx = tmid;
                        hx = hmid;
                    } else {
                        tm = tmid;
                        hm = hmid;
                    }
                }
                return tmid;
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            uv.y -= 2.0;
            <UV_PLACEHOLDER>
            float time = iTime * 0.0;
            float roll = PI + sin(iTime)/14.0 + cos(iTime/2.0)/14.0 ;
            float pitch = PI*1.021 + (sin(iTime/2.0)+ cos(iTime))/40.0 
                + (1./iResolution.y - .8)*PI/3.0  ;
            float yaw = 1./iResolution.x * PI * 4.0;
            vec3 ang = vec3(roll,pitch,yaw);
            vec3 ori = vec3(0.0,3.5,time*3.0);
            vec3 dir = normalize(vec3(uv.xy,-1.6)); 
            dir = normalize(dir) * fromEuler(ang);
            vec3 p;
            heightMapTracing(ori,dir,p);
            vec3 dist = p - ori;
            vec3 n = getNormal(p,  dot(dist,dist)  * EPSILON_NRM  );
            vec3 light = normalize(vec3(0.0,1.0,0.8)); 
            vec3 seaColor = getSeaColor(p,n,light,dir,dist);
        `, commonFinish: !0, key: et(193), render: "iTime+speed" }, { name: et(188), customUniforms: [et(203), "bottomColor-color-vec3-aliceblue", et(197), et(195)], vertex: "vWorldPosition", fragment: et(177), render: "" }, { name: et(178), commonUniforms: !0, customUniforms: ["PointsCount-number-int-1", et(181), "c2-color-vec3-0,0,0", et(213), et(200), et(186), et(208), et(192)], vertex: "vUv-material", fragment: et(176), commonFinish: !0, key: "c", render: et(205) }, { name: et(189), commonUniforms: !0, vertex: "vUv-material", fragment: et(191), key: "c", commonFinish: !0, render: et(205) }], Uo = Tv;
function Sv() {
  const i = ["isParticle", "5yrmjDL", "2869326tISkSP", "reduce", "330057gQvdEG", "1usUqpj", "250130hotQOQ", "48LvSzFa", "name", "concat", "16681106ooCYrd", "4842975eBckBG", "3161174OcccsE", "4EcCtGs", "253bLegFh", "filter", "9WsrIFN", "388088DHcloH"];
  return (Sv = function() {
    return i;
  })();
}
(function(i, e) {
  const t = Tv, n = Sv();
  for (; ; )
    try {
      if (parseInt(t(497)) / 1 * (-parseInt(t(486)) / 2) + parseInt(t(485)) / 3 * (-parseInt(t(487)) / 4) + -parseInt(t(493)) / 5 * (parseInt(t(494)) / 6) + parseInt(t(496)) / 7 + -parseInt(t(491)) / 8 * (parseInt(t(490)) / 9) + parseInt(t(498)) / 10 * (-parseInt(t(488)) / 11) + -parseInt(t(499)) / 12 * (-parseInt(t(502)) / 13) === 882856)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const WC = qS[Uo(501)](YS);
function Tv(i, e) {
  const t = Sv();
  return (Tv = function(n, r) {
    return t[n -= 485];
  })(i, e);
}
const ZS = qS[Uo(501)](YS)[Uo(489)]((i) => i[Uo(492)])[Uo(495)]((i, e) => (i[e[Uo(500)]] = e, i), {});
function Ev(i, e) {
  const t = Av();
  return (Ev = function(n, r) {
    return t[n -= 226];
  })(i, e);
}
const Rb = Ev;
function Av() {
  const i = [`varying vec2 vUv; 
 `, "vUv-material", "1790004kxnMOk", "418031RJbvmk", "2ilkvaP", "58608539CNpJwd", "split", `varying vec3 vPosition; 
 `, `void main() { 
`, "reverse", `varying vec3 vWorldPosition; 
 `, "10hDxaxf", "includes", "2007327JdOtRd", "precision", "54yYexUx", "vPosition", "vUv", `vPosition = position; 
`, "15DRyZKw", "vWorldPosition", "4343736EupcKO", "precision ", "forEach", "1393408LHVJqq", "2279580pHkmwO"];
  return (Av = function() {
    return i;
  })();
}
function Pb(i = Rb(243)) {
  const e = Rb;
  let t = e(250);
  return i[e(248)](",")[e(251)]()[e(239)]((n) => {
    const r = e;
    if (n[r(228)](r(233))) {
      const [s, a] = n.split("-");
      t = r(242) + t + XS[a] + `
`;
    } else if (n[r(228)](r(232)))
      t = r(249) + t + r(234);
    else if (n.includes(r(236)))
      t = r(226) + t + "vWorldPosition = (modelMatrix * vec4( position, 1.0 )).xyz;";
    else if (n[r(228)](r(230))) {
      const [s, a] = n[r(248)]("-");
      t = r(238) + a + ` float; 
` + t;
    }
  }), t;
}
(function(i, e) {
  const t = Ev, n = Av();
  for (; ; )
    try {
      if (-parseInt(t(245)) / 1 * (parseInt(t(246)) / 2) + -parseInt(t(237)) / 3 + parseInt(t(244)) / 4 * (-parseInt(t(235)) / 5) + -parseInt(t(241)) / 6 + parseInt(t(229)) / 7 + -parseInt(t(240)) / 8 * (parseInt(t(231)) / 9) + -parseInt(t(227)) / 10 * (-parseInt(t(247)) / 11) === 981378)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const Wo = Iv;
function Iv(i, e) {
  const t = Cv();
  return (Iv = function(n, r) {
    return t[n -= 414];
  })(i, e);
}
(function(i, e) {
  const t = Iv, n = Cv();
  for (; ; )
    try {
      if (-parseInt(t(444)) / 1 * (parseInt(t(427)) / 2) + -parseInt(t(424)) / 3 * (parseInt(t(433)) / 4) + parseInt(t(426)) / 5 * (-parseInt(t(438)) / 6) + -parseInt(t(443)) / 7 + parseInt(t(417)) / 8 * (-parseInt(t(425)) / 9) + -parseInt(t(429)) / 10 + parseInt(t(431)) / 11 === 392486)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const XC = ["iResolution-dom-vec2-0,0", Wo(428), Wo(439), Wo(430), "mixRatio-number-float-0.95", "mixColor-color-vec3-0xffffff", Wo(422)];
function Cv() {
  const i = ["1893szQtjZ", "18wdqZZE", "1475NgGPNk", "1012956iZykCi", "iTime-number-float-1.0", "1249100VLZLIy", "intensity-number-float-1", "38221117khlABj", "dom", "4136rVJUtx", "forEach", "map", "load", "join", "8886UwpbHy", "speed-number-float-0.01", "includes", "length", "Vector3", "4261236CCrwPN", "1UssAkZ", "slice", "bool", "Color", "3010704NixmWW", "color", "split", "clientHeight", "filter", "hasUv-bool-bool-true", "texture"];
  return (Cv = function() {
    return i;
  })();
}
function qC(i, e, t) {
  const n = Wo;
  return e === n(432) ? new Y(i.clientWidth, i[n(420)]) : e === "position" ? new S(...t[n(419)](",")[n(435)]((r) => Number(r))) : e === n(418) ? t.startsWith("0x") ? new W[n(416)](Number(t)) : t[n(440)](",") ? new W[n(416)](...t.split(",")[n(435)]((r) => Number(r))) : new ce(t) : e === n(415) ? t === "true" : e === "vec3[]" ? t[n(419)](",").map((r, s, a) => s % 3 == 0 && new W[n(442)](Number(r), Number(a[s + 1]), Number(a[s + 2])))[n(421)]((r) => r) : e === n(423) ? t ? new Va()[n(436)](t) : null : Number(t);
}
function Lp(i, e) {
  const t = Wo, n = {};
  return e[t(434)]((r) => {
    const s = t, a = r[s(419)]("-"), [o, l, c] = a, h = a[s(441)] > 4 ? a[s(414)](3)[s(437)]("-") : a[3];
    n[o] = { type: l, unit: c, value: qC(i, l, h) };
  }), n;
}
function yf(i, e) {
  const t = Rv();
  return (yf = function(n, r) {
    return t[n -= 356];
  })(i, e);
}
function Rv() {
  const i = ["11212UOzpzn", "12qTHTze", "uniform ", "3714lpJWBj", "40cgRVhI", "525cUlaUP", "3188853MlnEQh", "map", "151244vxyBMA", "length", "unit", `varying vec2 vUv; 
`, "value", "vUv", "11TfRflq", "includes", "vec4 diffuseColor = vec4( mix(diffuse, ", "7193767SBPLFM", "keys", "13070960gmIFbW", "2165dWegtl", "replace", "vWorldPosition", "13645808znOhjW"];
  return (Rv = function() {
    return i;
  })();
}
function Lb(i, e) {
  const t = yf;
  let n = Object[t(362)](i)[t(375)]((r) => {
    const s = t;
    return i[r][s(378)].includes("[]") ? s(370) + i[r][s(378)][s(365)]("[]", "") + " " + r + "[" + i[r][s(356)][s(377)] + "];" : "uniform " + i[r].unit + " " + r + ";";
  }).join(`
`);
  return e && (e[t(359)](t(357)) && (n += t(379)), e[t(359)]("vPosition") && (n += `varying vec3 vPosition; 
`), e[t(359)](t(366)) && (n += `varying vec3 vWorldPosition; 
`)), n;
}
function _f(i, e) {
  const t = Pv();
  return (_f = function(n, r) {
    return t[n -= 107];
  })(i, e);
}
(function(i, e) {
  const t = yf, n = Rv();
  for (; ; )
    try {
      if (parseInt(t(358)) / 1 * (parseInt(t(376)) / 2) + -parseInt(t(373)) / 3 * (-parseInt(t(368)) / 4) + -parseInt(t(364)) / 5 * (-parseInt(t(371)) / 6) + parseInt(t(361)) / 7 + parseInt(t(372)) / 8 * (-parseInt(t(374)) / 9) + parseInt(t(363)) / 10 + parseInt(t(367)) / 11 * (-parseInt(t(369)) / 12) === 913058)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const Co = _f;
function Pv() {
  const i = ["fragmentFunc", "vertexHeader", "setUniformsRender", "254310FUzPLp", "<UV_PLACEHOLDER>", "9234120RIRWlI", "bind", "2KLEgpP", "171uRQaWQ", "44rSbYwJ", "updateFragmentHead", "replace", "fragmentHeader", "3145670vNVFhE", "fragmentBody", "value", "split", "shaderAnimateRender", "2968062cvMHxw", "setVertexFormUV", "<SPLIT_PLACEHOLDER>", "453688IStkic", "fragmentEnd", "354737wUUjGV", "UniformsUtils", "render", "iTime", "iTime+speed", "uniforms", "130359XKSaWt", "vertex", "assign", "if(hasUv) uv=vUv;", "speed"];
  return (Pv = function() {
    return i;
  })();
}
(function(i, e) {
  const t = _f, n = Pv();
  for (; ; )
    try {
      if (parseInt(t(135)) / 1 * (parseInt(t(119)) / 2) + parseInt(t(107)) / 3 * (parseInt(t(121)) / 4) + -parseInt(t(125)) / 5 + parseInt(t(130)) / 6 + parseInt(t(115)) / 7 + parseInt(t(133)) / 8 * (-parseInt(t(120)) / 9) + parseInt(t(117)) / 10 === 580496)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
class YC {
  constructor(e, t) {
    const n = _f, { name: r, commonUniforms: s, customUniforms: a, vertex: o, key: l, fragment: c, commonFinish: h, render: u } = t;
    if (Object[n(109)](this, { uniforms: {}, vertexHeader: Pb(o), fragmentHeader: "", fragmentFunc: "", fragmentBody: "", fragmentEnd: "", vertex: o, render: u, shaderProgramsCodeName: r }), s && Object[n(109)](this[n(140)], Lp(e, XC)), a && Object.assign(this.uniforms, Lp(e, a)), this[n(124)] = Lb(this.uniforms, o), c.search("<SPLIT_PLACEHOLDER>") !== -1) {
      const [p, f] = c[n(128)](n(132));
      this[n(112)] = p, this[n(126)] = f[n(123)](n(116), n(110));
    } else
      this[n(126)] = c[n(123)](n(116), "if(hasUv) uv=vUv;");
    var d;
    h && (this[n(134)] = (d = l, yf(360) + d + " * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );"));
  }
  [Co(114)](e) {
    const t = Co;
    e[t(140)] = W[t(136)].clone(this[t(140)]), this[t(137)] === t(139) ? e.shaderAnimateRender = () => e[t(140)][t(138)][t(127)] += e[t(140)][t(111)][t(127)] : e[t(129)] = new Function(this[t(137)])[t(118)](e.uniforms);
  }
  [Co(131)](e) {
    const t = Co;
    this[t(108)] = this[t(108)].replace(/vUv-\w+/, "vUv-" + e), this[t(113)] = Pb(this.vertex);
  }
  [Co(122)](e) {
    this[Co(124)] = Lb(e, this.vertex);
  }
}
function xf(i) {
  const e = Or;
  let t = [];
  return i[e(267)]((n) => {
    const r = e;
    n[r(264)] && (Array[r(258)](n[r(251)]) ? n[r(251)][r(261)]((s) => t[r(260)](s)) : t[r(260)](n[r(251)]));
  }), [...new Set(t)];
}
function Or(i, e) {
  const t = Lv();
  return (Or = function(n, r) {
    return t[n -= 243];
  })(i, e);
}
function CL(i, e) {
  e && (i[Or(264)] ? function(t, n) {
    const r = Or;
    Array[r(258)](t[r(251)]) ? t[r(251)][r(261)]((s) => ag(s, n)) : ag(t.material, n), t[r(254)] = () => {
      const s = r;
      Array.isArray(t.material) ? t.material[s(261)]((a) => a[s(254)]()) : t[s(251)][s(254)]();
    };
  }(i, e) : function(t, n) {
    const r = Or;
    let s = [];
    t[r(267)]((a) => a.isMesh && !s[r(253)](a[r(251)]) && s[r(260)](a[r(251)])), s[r(261)]((a) => ag(a, n)), t[r(254)] = () => s.forEach((a) => a[r(254)]());
  }(i, e));
}
function RL(i) {
  const e = Or;
  i[e(267)]((t) => {
    const n = e;
    t.isCloneMaterial = !0, t[n(264)] && (t[n(248)] = t.material, Array[n(258)](t.material) ? t.material = t[n(251)][n(250)]((r) => r.clone()) : t.material = t[n(251)][n(262)]());
  });
}
function Lv() {
  const i = ["forEach", "clone", "27745vArBKf", "isMesh", "getHex", "11552022GLeLUf", "traverse", "2zVIoTE", "930717RofLvC", "810953NDNOGF", "36HLdsfF", "8GLcWqM", "originMaterial", "50IdYZSG", "map", "material", "255465dAZHet", "includes", "revertMaterial", "53337300FjggoR", "color", "1578VUkzMn", "isArray", "10399053GGtfms", "push"];
  return (Lv = function() {
    return i;
  })();
}
function ag(i, e = {}) {
  const t = Or, n = Db(i, e);
  return i[t(254)] = () => Db(i, n), i;
}
function Db(i, e = {}) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    const r = Or;
    n === r(256) || n === "emissive" ? (t[n] = i[n][r(265)](), i[n].set(e[n])) : (t[n] = i[n], i[n] = e[n]);
  }), i.needsUpdate = !0, t;
}
function bf(i, e) {
  const t = Dv();
  return (bf = function(n, r) {
    return t[n -= 472];
  })(i, e);
}
function Wc(i, e) {
  const t = bf;
  let n;
  return n = i[t(485)] ? i[t(485)] : i[t(476)] ? Array[t(481)](i.material) ? i[t(476)] : [i[t(476)]] : xf(i), n[t(495)]((r) => Nb(r, i[t(489)], e)), i[t(473)] = () => {
    const r = t;
    e.updateFragmentHead(i.uniforms), n[r(495)]((s) => Nb(s, i[r(489)], e));
  }, i[t(493)] = () => {
    const r = t;
    n[r(495)]((s) => {
      const a = r;
      s.onBeforeCompile = () => {
      }, s[a(484)]();
    }), delete i.shaderAnimateRender, delete i[r(493)];
  }, !0;
}
function Dv() {
  const i = ["2dPORqu", "48xMEeSE", "8UEuJxR", "updateShaderProgram", "1453077oliGpA", "fragmentShader", "material", "178446JjIvsU", "replace", "30bychlr", "163698Iscspx", "isArray", "2205AjZUVW", "vertexShader", "dispose", "RootMaterials", "vec4 diffuseColor = vec4( diffuse, opacity );", "74179hqFdic", "452fOnRjA", "uniforms", `
#include <common>
`, "keys", "713735ETqdhC", "destroyShaderProgram", "2753988jgsspp", "forEach"];
  return (Dv = function() {
    return i;
  })();
}
function Nb(i, e, t) {
  const n = bf, { vertexHeader: r, fragmentHeader: s, fragmentFunc: a, fragmentBody: o, fragmentEnd: l } = t;
  i[n(484)](), i.onBeforeCompile = (c) => {
    const h = n;
    Object[h(491)](e)[h(495)]((u) => c.uniforms[u] = e[u]), c[h(483)] = c.vertexShader[h(478)]("void main() {", r), c[h(475)] = c[h(475)][h(478)](/#include <common>/, s + h(490) + a), c.fragmentShader = c[h(475)][h(478)](h(486), o + l);
  };
}
function Nv() {
  const i = ["opacity", "47570nApHtK", "forEach", "404553nvCGqY", "24iGNEcp", "max", "type", "2173192LIgQXs", "position", "1165095BnvtIh", "number", "color", "set", "includes", "min", "3404142TGzVkE", "keys", "has", "8184376caHfuo", "add", "value", "7084062daFXfo", "name", "40rGogUG", "bool", "addHexColor"];
  return (Nv = function() {
    return i;
  })();
}
function Xh(i, e) {
  const t = Nv();
  return (Xh = function(n, r) {
    return t[n -= 373];
  })(i, e);
}
function KS(i) {
  const e = Xh;
  if (i)
    return Object[e(385)](i).filter((t) => [e(380), "position", e(395), "number", e(393)][e(382)](i[t][e(375)])).reduce((t, n) => Qt(Ee({}, t), { [n]: i[n][e(389)] }), {});
}
function QS(i, e) {
  const t = Xh;
  e && Object[t(385)](e)[t(397)]((n) => {
    const r = t;
    if (i[n])
      switch (i[n][r(375)]) {
        case r(380):
          i[n][r(389)][r(381)](e[n]);
          break;
        case r(379):
        case r(395):
          i[n][r(389)] = e[n];
          break;
        case "position":
          i[n].value.set(e[n].x, e[n].y, e[n].z);
          break;
        case r(393):
          i[n][r(389)] = e[n];
      }
  });
}
function np(i, e) {
  const t = Xh;
  return Object[t(385)](i)[t(397)]((n) => {
    const r = t;
    switch (i[n][r(375)]) {
      case r(379):
        const s = e.add(i[n], "value")[r(391)](n);
        Reflect[r(386)](i[n], r(383)) && s[r(383)](i[n][r(383)]), Reflect.has(i[n], r(374)) && s[r(374)](i[n][r(374)]);
        break;
      case "color":
        e[r(394)](i[n][r(389)])[r(391)](n);
        break;
      case "opacity":
        e[r(388)](i[n], r(389)).min(0)[r(374)](1)[r(391)](n);
        break;
      case r(377):
        ["x", "y", "z"].forEach((a) => e.add(i[n].value, a)[r(391)](n + "-" + a));
        break;
      case r(393):
        e.add(i[n], r(389)).name(n);
    }
  }), e;
}
function qa(i, e) {
  const t = Ov();
  return (qa = function(n, r) {
    return t[n -= 195];
  })(i, e);
}
function Ov() {
  const i = ["onChange", "blendShaderPrograms", "destroyShaderProgram", "77915pfGQro", "1377KzQCkh", "7NCeGIW", "12CVfBzM", "120SFoXvQ", "setUniformsRender", "name", "shaderLibrary", "uuid", "105540DNhqAo", "add", "DOM", "open", "2095317fywLYj", "着色标码", "24670FssSfM", "material", "6051078PXXYpv", "addFolder", "isBlendShaderPrograms", "uvType", "reduce", "splice", "includes", "shaderProgramsCodeName", "4541946vqLnUG", "setVertexFormUV", "removeFolder", "keys", "uniforms", "findIndex", "UV类型", "1930504Nvobnh", "push"];
  return (Ov = function() {
    return i;
  })();
}
function Uv(i, e = {}) {
  const t = qa;
  i[t(204)] = { shaderProgramsCodeName: e.shaderProgramsCodeName || "", isBlendShaderPrograms: e[t(225)] || !1, uvType: e.uvType || t(222) };
}
function ZC(i, e) {
  const t = qa, n = function(s) {
    const a = qa;
    return new Proxy(WC[a(227)]((o, l) => (o[l[a(212)]] = l, o), {}), { get(o, l) {
      const c = a;
      return !o[l][c(198)] && (o[l] = new YC(s, o[l])), o[l];
    } });
  }(e);
  i[t(217)] = e, i[t(213)] = n;
  const { shaderFrames: r } = i;
  return { shaderLibrary: n, setObjectBlendShader: function(s, a = "水波纹", o = "material") {
    const l = t;
    Uv(s, { shaderProgramsCodeName: a, uvType: o, isBlendShaderPrograms: !0 });
    const c = n[a];
    if (c)
      return c[l(211)](s), c[l(195)](o), Wc(s, c), r[l(229)](s) || r.push(s), s;
  } };
}
function KC(i) {
  const { blendShaderPrograms: e } = i;
  if (e)
    return Qt(Ee({}, e), { uniforms: KS(i.uniforms) });
}
function JS(i, e) {
  const t = qa;
  e[t(218)]();
  const { shaderFrames: n, shaderLibrary: r } = wl(i);
  let s = null;
  i.blendShaderPrograms || Uv(i);
  const { blendShaderPrograms: a } = i;
  a[t(225)] && (s = np(i[t(198)], e[t(224)](i.blendShaderPrograms[t(230)] + "配置"))), e.add(a, "uvType", jC)[t(212)](t(200)).onChange(() => {
    const o = t;
    if (!a.shaderProgramsCodeName || !a[o(225)])
      return;
    const l = r[a[o(230)]];
    l[o(195)](a[o(226)]), Wc(i, l);
  }), e[t(216)](a, "shaderProgramsCodeName", Object[t(197)](r))[t(212)](t(220))[t(203)](() => {
    const o = t;
    if (a[o(225)]) {
      const l = r[a[o(230)]];
      l[o(211)](i), l[o(195)](a[o(226)]), Wc(i, l), s && (e[o(196)](s), s = np(i[o(198)], e[o(224)](a[o(230)] + "配置")));
    }
  }), e[t(216)](a, t(225))[t(212)]("混合着色器")[t(203)]((o) => {
    const l = t;
    if (o) {
      if (a[l(230)]) {
        const c = r[a[l(230)]];
        c[l(211)](i), c[l(195)](a[l(226)]), Wc(i, c) && n[l(202)](i), s = np(i[l(198)], e[l(224)](a[l(230)] + "配置"));
      }
    } else {
      const c = n[l(199)]((h) => h[l(214)] == i[l(214)]);
      c !== -1 && (n[l(228)](c, 1), i[l(205)](), s && (e[l(196)](s), s = null));
    }
  });
}
function kv() {
  const i = ["map", "89030HEwDGx", "22938UhiUlz", "enable", "5569080JDdFwk", "900141zdqZjI", "join", "add", "mask", "maskString", "49eQKaYe", "filter", "232425almEuc", "split", "1052740DxjcJl", "forEach", "onChange", "315180bDxpyc"];
  return (kv = function() {
    return i;
  })();
}
function Fv(i) {
  return { mask: i[Sl(145)] };
}
function Sl(i, e) {
  const t = kv();
  return (Sl = function(n, r) {
    return t[n -= 131];
  })(i, e);
}
function Bv(i, e) {
  const t = Sl;
  e && (i[t(145)] = e[t(145)]);
}
function zv(i, e) {
  const t = Sl;
  i[t(146)] = function(n) {
    const r = Sl;
    return Array.from({ length: 32 })[r(137)]((s, a) => {
      if (n & 1 << a)
        return a;
    })[r(148)]((s) => s !== void 0);
  }(i[t(145)])[t(143)](","), e[t(144)](i, t(146)).name("图层")[t(135)]((n) => {
    const r = t;
    i.disableAll(), [...new Set(n[r(132)](","))][r(137)]((s) => parseInt(s))[r(148)]((s) => s >= 0 && s < 32)[r(134)]((s) => i[r(140)](s));
  });
}
function Mf(i, e) {
  const t = Hv();
  return (Mf = function(n, r) {
    return t[n -= 490];
  })(i, e);
}
function Ja(i) {
  const { name: e, visible: t, castShadow: n, receiveShadow: r, position: s, rotation: a, scale: o, renderOrder: l, layers: c, transformAnimationList: h, isSsr: u } = i;
  return { name: e, visible: t, renderOrder: l, castShadow: n, receiveShadow: r, position: { x: s.x, y: s.y, z: s.z }, rotation: { x: a.x, y: a.y, z: a.z }, scale: { x: o.x, y: o.y, z: o.z }, layers: Fv(c), blendShaderPrograms: KC(i), transformAnimationList: h, isSsr: u };
}
function Hv() {
  const i = ["90030XNKKFa", "rotation", "visible", "step", "has", "519WgyhTw", "forEach", "9123900AeIito", "isSsr", "layers", "513kJqJlY", "push", "170992neyyRm", "add", "56IIdOXO", "receiveShadow", "5937958MTofEN", "11076RrxDeT", "168uzomuO", "name", "indexOf", "renderOrder", "set", "产生阴影", "scale", "渲染顺序", "17OnTYHI", "transformAnimationList", "接收阴影", "position", "167590rchSwp", "11HfjXsX", "25ppkgDO", "模型名字", "ssrList", "onChange", "343422OGiRri", "castShadow"];
  return (Hv = function() {
    return i;
  })();
}
function $a(i, e) {
  const t = Mf;
  if (!e)
    return;
  const { name: n, visible: r, castShadow: s, receiveShadow: a, position: o, rotation: l, scale: c, renderOrder: h, layers: u, blendShaderPrograms: d, transformAnimationList: p, isSsr: f } = e;
  i[t(509)] = n, i.visible = r, i[t(511)] = h, i[t(527)] = s, i[t(505)] = a, i[t(519)][t(512)](o.x, o.y, o.z), i[t(491)][t(512)](l.x, l.y, l.z), i[t(514)][t(512)](c.x, c.y, c.z), Bv(i[t(499)], u), function(v, m) {
    const y = qa;
    if (!m)
      return;
    const g = wl(v);
    if (!g)
      return;
    Uv(v, m);
    const { shaderProgramsCodeName: _, isBlendShaderPrograms: x, uvType: M, uniforms: b } = m;
    if (!x)
      return;
    const { shaderLibrary: w, shaderFrames: T } = g, A = w[_];
    A.setUniformsRender(v), A[y(195)](M), Wc(v, A) && T.push(v), QS(v.uniforms, b);
  }(i, d), i[t(517)] = p, f && (i[t(498)] = f, wl(i).ssrList.push(i));
}
function Gr(i, e) {
  const t = Mf;
  e[t(503)](i, t(509)).name(t(523)), e[t(503)](i, t(492)).name("显示"), Reflect[t(494)](i, "isSsr") || (i[t(498)] = !1), e[t(503)](i, t(498))[t(509)]("SSR")[t(525)]((n) => {
    const r = t, s = wl(i);
    if (n)
      s.ssrList[r(501)](i);
    else {
      const a = s[r(524)][r(510)](i);
      a !== -1 && s[r(524)].splice(a, 1);
    }
  }), zv(i.layers, e), e[t(503)](i, t(511))[t(509)](t(515))[t(493)](1), e.add(i, t(527)).name(t(513)), e.add(i, t(505))[t(509)](t(518)), ["x", "y", "z"][t(496)]((n) => e[t(503)](i[t(519)], n)[t(509)]("位置" + n)), ["x", "y", "z"][t(496)]((n) => e[t(503)](i.rotation, n)[t(509)]("旋转" + n)), ["x", "y", "z"].forEach((n) => e.add(i.scale, n)[t(509)]("缩放" + n));
}
(function(i, e) {
  const t = Or, n = Lv();
  for (; ; )
    try {
      if (parseInt(t(244)) / 1 * (parseInt(t(243)) / 2) + parseInt(t(252)) / 3 * (-parseInt(t(246)) / 4) + parseInt(t(263)) / 5 * (-parseInt(t(257)) / 6) + -parseInt(t(259)) / 7 + -parseInt(t(247)) / 8 * (parseInt(t(266)) / 9) + parseInt(t(249)) / 10 * (parseInt(t(245)) / 11) + parseInt(t(255)) / 12 === 749188)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = bf, n = Dv();
  for (; ; )
    try {
      if (parseInt(t(480)) / 1 + -parseInt(t(496)) / 2 * (-parseInt(t(477)) / 3) + parseInt(t(488)) / 4 * (-parseInt(t(482)) / 5) + parseInt(t(497)) / 6 * (parseInt(t(487)) / 7) + -parseInt(t(472)) / 8 * (parseInt(t(474)) / 9) + -parseInt(t(479)) / 10 * (parseInt(t(492)) / 11) + parseInt(t(494)) / 12 === 131514)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Xh, n = Nv();
  for (; ; )
    try {
      if (parseInt(t(392)) / 1 * (-parseInt(t(396)) / 2) + -parseInt(t(398)) / 3 * (parseInt(t(373)) / 4) + parseInt(t(378)) / 5 + parseInt(t(390)) / 6 + parseInt(t(376)) / 7 + parseInt(t(387)) / 8 + -parseInt(t(384)) / 9 === 608455)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = qa, n = Ov();
  for (; ; )
    try {
      if (parseInt(t(206)) / 1 * (-parseInt(t(209)) / 2) + parseInt(t(219)) / 3 + parseInt(t(210)) / 4 * (parseInt(t(215)) / 5) + parseInt(t(231)) / 6 * (-parseInt(t(208)) / 7) + parseInt(t(201)) / 8 + -parseInt(t(207)) / 9 * (parseInt(t(221)) / 10) + parseInt(t(223)) / 11 === 521158)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Sl, n = kv();
  for (; ; )
    try {
      if (parseInt(t(131)) / 1 + parseInt(t(138)) / 2 + parseInt(t(142)) / 3 + parseInt(t(136)) / 4 + parseInt(t(133)) / 5 + -parseInt(t(139)) / 6 * (-parseInt(t(147)) / 7) + -parseInt(t(141)) / 8 === 196956)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Mf, n = Hv();
  for (; ; )
    try {
      if (parseInt(t(516)) / 1 * (parseInt(t(490)) / 2) + parseInt(t(495)) / 3 * (-parseInt(t(507)) / 4) + parseInt(t(522)) / 5 * (-parseInt(t(526)) / 6) + parseInt(t(508)) / 7 * (parseInt(t(502)) / 8) + parseInt(t(500)) / 9 * (-parseInt(t(520)) / 10) + parseInt(t(521)) / 11 * (-parseInt(t(497)) / 12) + parseInt(t(506)) / 13 * (parseInt(t(504)) / 14) === 624485)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const og = Dl;
function Dl(i, e) {
  const t = Gv();
  return (Dl = function(n, r) {
    return t[n -= 114];
  })(i, e);
}
function Gv() {
  const i = ["987pERJEz", "TextureLoader", "addFn", "load", "13296xwPJjl", "material", "5602817kHmAZt", "add", "基础配置", "117932gmLmoZ", "立方体", "Mesh", "isInnerMesh", "60CNzCUg", "url", "113990QFpEpm", "243vshNhV", "12nMryqM", "name", "materialType", "addFolder", "8557ADsUXa", "1867218aFlJnR", "removeFolder", "几何体", "基础材质", "1270530KWUBBI", "3IviTVN", "parameters", "map"];
  return (Gv = function() {
    return i;
  })();
}
function Ob(i, e, t) {
  const n = Dl;
  Gr(e, t[n(132)](n(120))), function(r, s) {
    const a = Pp, { geometry: o } = r, { parameters: l } = o, c = () => {
      const h = Pp;
      o[h(422)](), r[h(413)] = pf(o[h(387)], l);
    };
    switch (o.geometryType) {
      case a(389):
        s.add(l, a(399), 0)[a(391)]("宽度")[a(412)](c), s[a(414)](l, a(379), 0)[a(391)]("高度").onChange(c), s[a(414)](l, a(401), 0)[a(391)]("深度")[a(412)](c), s[a(414)](l, a(381), 0)[a(391)](a(380)).onChange(c)[a(385)](1), s[a(414)](l, a(419), 0).name(a(420))[a(412)](c)[a(385)](1), s[a(414)](l, "depthSegments", 0).name(a(394)).onChange(c)[a(385)](1);
        break;
      case "球体":
        s[a(414)](l, a(423), 0)[a(391)]("半径")[a(412)](c), s[a(414)](l, "widthSegments", 0).name(a(380))[a(412)](c), s.add(l, a(419), 0)[a(391)]("高度分段")[a(412)](c);
        break;
      case "平面":
        s.add(l, a(399), 0)[a(391)]("宽度").onChange(c), s[a(414)](l, a(379), 0)[a(391)]("高度")[a(412)](c), s[a(414)](l, a(381), 0)[a(391)](a(380))[a(412)](c), s[a(414)](l, a(419), 0)[a(391)](a(420))[a(412)](c);
        break;
      case "胶囊":
        s[a(414)](l, a(423), 0)[a(391)]("半径")[a(412)](c), s[a(414)](l, a(392), 0)[a(391)]("高度")[a(412)](c), s[a(414)](l, "capSegments", 0)[a(391)]("顶部分段")[a(412)](c), s.add(l, a(397), 0)[a(391)](a(416)).onChange(c);
        break;
      case "圆锥":
        s[a(414)](l, "radius", 0)[a(391)]("半径").onChange(c), s[a(414)](l, a(379), 0)[a(391)]("高度").onChange(c), s[a(414)](l, a(397), 0)[a(391)](a(416))[a(412)](c);
        break;
      case "圆面":
        s[a(414)](l, a(423), 0).name("半径").onChange(c), s.add(l, a(383), 0)[a(391)](a(403))[a(412)](c), s[a(414)](l, a(388), 0, 2 * Math.PI).name(a(426)).onChange(c);
        break;
      case "圆柱":
        s[a(414)](l, a(405), 0).name(a(398))[a(412)](c), s[a(414)](l, "radiusBottom", 0)[a(391)](a(409)).onChange(c), s[a(414)](l, a(379), 0)[a(391)]("高度")[a(412)](c), s[a(414)](l, a(397), 0)[a(391)](a(416))[a(412)](c);
        break;
      case "圆环":
        s.add(l, a(423), 0)[a(391)]("半径").onChange(c), s[a(414)](l, a(378), 0).name(a(382)).onChange(c), s[a(414)](l, "radialSegments", 0)[a(391)](a(416))[a(412)](c), s[a(414)](l, a(421), 0)[a(391)](a(386))[a(412)](c), s[a(414)](l, a(411), 0, 2 * Math.PI).name("弧度")[a(412)](c);
        break;
      case "环面":
        s[a(414)](l, a(390), 0).name(a(384)).onChange(c), s[a(414)](l, a(424), 0)[a(391)](a(425))[a(412)](c), s[a(414)](l, a(407), 0)[a(391)](a(393))[a(412)](c), s.add(l, a(415), 0)[a(391)](a(386)).onChange(c), s[a(414)](l, a(383), 0)[a(391)](a(403))[a(412)](c), s.add(l, a(388), 0, 2 * Math.PI)[a(391)](a(426))[a(412)](c);
    }
  }(e, t[n(132)](n(136))), vf(i, e[n(117)], t[n(132)]("材质")), t[n(114)](() => {
    const r = n;
    i.remove(e), t.parent[r(135)](t);
  })[n(130)]("删除");
}
function PL(i = { type: og(122) }, e = { type: og(137) }, t = { type: "图片" }) {
  const n = og, r = pf(i.type, i[n(140)]), s = Si(e.type, e[n(140)]);
  t[n(126)] && (t.type === "视频" ? s[n(141)] = jS(t[n(126)]) : s.map = new W[n(143)]()[n(115)](t.url));
  const a = new W[n(123)](r, s);
  return a.isInnerMesh = !0, a;
}
function wf(i, e) {
  const t = Vv();
  return (wf = function(n, r) {
    return t[n -= 254];
  })(i, e);
}
function Vv() {
  const i = ["80EkvSRY", "forEach", "set", "5098671lSDqGD", "revertTransform", "8343830ssZeVC", "1741704uyziSG", "6269OyapXy", "253626YJbREn", "rotation", "2305404rduzBW", "60EOpCvs", "672301CdWlQa", "keys", "33vyUSXD", "scale", "25SSPgmg"];
  return (Vv = function() {
    return i;
  })();
}
function Xo(i) {
  const { position: e, rotation: t, scale: n } = i;
  return { position: { x: e.x, y: e.y, z: e.z }, rotation: { x: t.x, y: t.y, z: t.z }, scale: { x: n.x, y: n.y, z: n.z } };
}
function Dp(i, e) {
  const t = wf;
  if (!e)
    return;
  const { position: n, rotation: r, scale: s } = e;
  i.position[t(258)](n.x, n.y, n.z), i[t(265)][t(258)](r.x, r.y, r.z), i[t(254)][t(258)](s.x, s.y, s.z);
}
function LL(i, e = {}) {
  const t = wf, n = {};
  return Object.keys(e)[t(257)]((r) => {
    const s = t;
    n[r] = { x: i[r].x, y: i[r].y, z: i[r].z }, i[r][s(258)](e[r].x, e[r].y, e[r].z);
  }), i[t(260)] = () => Object[t(269)](n)[t(257)]((r) => i[r][t(258)](n[r].x, n[r].y, n[r].z)), i;
}
function Sf(i, e) {
  const t = jv();
  return (Sf = function(n, r) {
    return t[n -= 494];
  })(i, e);
}
function jv() {
  const i = ["7001875BdmimP", "position", "8609652nTHvNm", "24afbBUG", "rotation", "none", "map", "816442lMcsNw", "72777JHpPGb", "scale", "all", "2306367MgNULr", "25087720AIMsAS", "5278568AnbyfL"];
  return (jv = function() {
    return i;
  })();
}
function Np(i, e, t = null) {
  const n = Sf;
  return Z1.to(i, Ee(Qt(Ee({}, e), { duration: 2, ease: n(496), repeat: 0, yoyo: !1, yoyoEase: !0 }), t));
}
function $S(i, e, t, n) {
  const r = Sf, { mode: s, query: a } = n;
  Dp(i, e);
  const o = [r(506), r(495), r(500)][r(497)]((l) => new Promise((c) => {
    Z1[s](i[l], Qt(Ee({ x: t[l].x, y: t[l].y, z: t[l].z }, a), { onComplete: c }));
  }));
  return Promise[r(501)](o);
}
function Tf(i, e) {
  const t = Wv();
  return (Tf = function(n, r) {
    return t[n -= 395];
  })(i, e);
}
function DL(i) {
  const e = Tf, t = QC(i), n = new W[e(399)](t), r = new Kp({ map: n }), s = new W[e(419)](r);
  return s[e(420)][e(408)](t.width / t[e(400)], 1, 1), s;
}
function QC(i) {
  const e = Tf, { devicePixelRatio: t, fontSize: n, color: r, fontFamily: s, text: a } = Ee({ devicePixelRatio: 2 * window[e(410)], fontSize: 20, color: e(416), fontFamily: "serif" }, i), o = document[e(409)](e(398)), l = o[e(422)]("2d");
  l[e(395)] = r, l[e(413)] = n + e(401) + s;
  const c = l[e(404)](a);
  o[e(396)] = c.width * t;
  const h = c[e(417)] + c[e(403)];
  o.height = h * t, l[e(420)](t, t), l[e(395)] = r, l[e(413)] = n + e(401) + s;
  const u = (o.height / t - h) / 2 + c[e(417)];
  return l[e(397)](a, 0, u), o;
}
function Wv() {
  const i = ["devicePixelRatio", "3833guFvrN", "1313545dGVzAY", "font", "8929818vMfIOt", "20331210cxKpwP", "black", "actualBoundingBoxAscent", "18kZAFsl", "Sprite", "scale", "2694958nnENmY", "getContext", "fillStyle", "width", "fillText", "canvas", "CanvasTexture", "height", "px ", "9759dLPVjk", "actualBoundingBoxDescent", "measureText", "10078616saPZfD", "268weklzW", "662DlldOe", "set", "createElement"];
  return (Wv = function() {
    return i;
  })();
}
function qh(i, e) {
  var t = Xv();
  return (qh = function(n, r) {
    return t[n -= 168];
  })(i, e);
}
function e4(i) {
  var e = qh;
  if (i[e(186)][e(174)] === 0)
    return i.resetEnv();
  i.children[e(180)]((t) => {
    i[e(188)](t), t4(t);
  }), e4(i);
}
function t4(i) {
  var e = qh;
  i[e(179)]((t) => {
    var n;
    t instanceof W[e(178)] ? ip(t) : (n = t.dispose) == null || n.call(t);
  });
}
function ip(i) {
  var t;
  var e = qh;
  i.geometry[e(168)](), Array[e(173)](i[e(172)]) ? i.material[e(180)]((n) => {
    var s;
    var r = e;
    n[r(168)](), (s = n[r(189)]) == null || s[r(168)]();
  }) : (i.material[e(168)](), (t = i[e(172)][e(189)]) == null || t[e(168)]());
}
function Xv() {
  var i = ["2FpBQPC", "36lPbPys", "material", "isArray", "length", "91sYeAdm", "5096691AxBOid", "6912790vKqpvh", "Mesh", "traverse", "forEach", "348wJFQrf", "31493PjdOOZ", "38045nCsjlP", "176934XDFpog", "409569TcHOnp", "children", "6701717QfuYcY", "remove", "map", "dispose", "8SXaKqS"];
  return (Xv = function() {
    return i;
  })();
}
(function(i, e) {
  const t = Dl, n = Gv();
  for (; ; )
    try {
      if (-parseInt(t(133)) / 1 * (-parseInt(t(125)) / 2) + parseInt(t(139)) / 3 * (parseInt(t(121)) / 4) + -parseInt(t(138)) / 5 + -parseInt(t(134)) / 6 + parseInt(t(142)) / 7 * (parseInt(t(116)) / 8) + parseInt(t(128)) / 9 * (-parseInt(t(127)) / 10) + -parseInt(t(118)) / 11 * (-parseInt(t(129)) / 12) === 156800)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = wf, n = Vv();
  for (; ; )
    try {
      if (-parseInt(t(263)) / 1 * (parseInt(t(267)) / 2) + -parseInt(t(266)) / 3 + -parseInt(t(262)) / 4 + parseInt(t(255)) / 5 * (-parseInt(t(264)) / 6) + parseInt(t(268)) / 7 * (-parseInt(t(256)) / 8) + parseInt(t(259)) / 9 + parseInt(t(261)) / 10 * (parseInt(t(270)) / 11) === 505919)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Sf, n = jv();
  for (; ; )
    try {
      if (-parseInt(t(498)) / 1 + parseInt(t(494)) / 2 * (-parseInt(t(499)) / 3) + parseInt(t(504)) / 4 + -parseInt(t(505)) / 5 + -parseInt(t(507)) / 6 + parseInt(t(502)) / 7 + parseInt(t(503)) / 8 === 842221)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Tf, n = Wv();
  for (; ; )
    try {
      if (-parseInt(t(411)) / 1 * (-parseInt(t(407)) / 2) + parseInt(t(402)) / 3 * (parseInt(t(406)) / 4) + parseInt(t(412)) / 5 * (-parseInt(t(418)) / 6) + parseInt(t(421)) / 7 + -parseInt(t(405)) / 8 + -parseInt(t(414)) / 9 + parseInt(t(415)) / 10 === 864633)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = qh, n = Xv(); ; )
    try {
      if (parseInt(t(182)) / 1 + parseInt(t(170)) / 2 * (-parseInt(t(185)) / 3) + -parseInt(t(181)) / 4 * (-parseInt(t(183)) / 5) + -parseInt(t(184)) / 6 * (-parseInt(t(175)) / 7) + -parseInt(t(169)) / 8 * (-parseInt(t(176)) / 9) + parseInt(t(177)) / 10 + -parseInt(t(187)) / 11 * (parseInt(t(171)) / 12) === 370147)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
let Xc, qc, vi, xa, Rd, Da, ds = Object.getPrototypeOf, n4 = { isConnected: 1 }, Ub = {}, JC = ds(n4), i4 = ds(ds), r4 = (i, e, t, n) => (i != null ? i : (setTimeout(t, n), /* @__PURE__ */ new Set())).add(e), s4 = (i, e, t) => {
  let n = vi;
  vi = e;
  try {
    return i(t);
  } catch (r) {
    return console.error(r), t;
  } finally {
    vi = n;
  }
}, Op = (i) => i.filter((e) => {
  var t;
  return (t = e._dom) == null ? void 0 : t.isConnected;
}), a4 = (i) => Rd = r4(Rd, i, () => {
  for (let e of Rd)
    e._bindings = Op(e._bindings), e._listeners = Op(e._listeners);
  Rd = Da;
}, 1e3), Up = { get val() {
  var i;
  return (i = vi == null ? void 0 : vi._getters) == null || i.add(this), this.rawVal;
}, get oldVal() {
  var i;
  return (i = vi == null ? void 0 : vi._getters) == null || i.add(this), this._oldVal;
}, set val(i) {
  var e;
  (e = vi == null ? void 0 : vi._setters) == null || e.add(this), i !== this.rawVal && (this.rawVal = i, this._bindings.length + this._listeners.length ? (qc == null || qc.add(this), Xc = r4(Xc, this, eR)) : this._oldVal = i);
} }, o4 = (i) => ({ __proto__: Up, rawVal: i, _oldVal: i, _bindings: [], _listeners: [] }), Ch = (i, e) => {
  let t = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, n = { f: i }, r = xa;
  xa = [];
  let s = s4(i, t, e);
  s = (s != null ? s : document).nodeType ? s : new Text(s);
  for (let a of t._getters)
    t._setters.has(a) || (a4(a), a._bindings.push(n));
  for (let a of xa)
    a._dom = s;
  return xa = r, n._dom = s;
}, qv = (i, e = o4(), t) => {
  var s;
  let n = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, r = { f: i, s: e };
  r._dom = (s = t != null ? t : xa == null ? void 0 : xa.push(r)) != null ? s : n4, e.val = s4(i, n, e.rawVal);
  for (let a of n._getters)
    n._setters.has(a) || (a4(a), a._listeners.push(r));
  return e;
}, l4 = (i, ...e) => {
  for (let t of e.flat(1 / 0)) {
    let n = ds(t != null ? t : 0), r = n === Up ? Ch(() => t.val) : n === i4 ? Ch(t) : t;
    r != Da && i.append(r);
  }
  return i;
}, c4 = (i, e, ...t) => {
  var a, o, l, c;
  let [n, ...r] = ds((a = t[0]) != null ? a : 0) === JC ? t : [{}, ...t], s = i ? document.createElementNS(i, e) : document.createElement(e);
  for (let [h, u] of Object.entries(n)) {
    let d = (y) => {
      var g;
      return y ? (g = Object.getOwnPropertyDescriptor(y, h)) != null ? g : d(ds(y)) : Da;
    }, p = e + "," + h, f = (c = Ub[p]) != null ? c : Ub[p] = (l = (o = d(ds(s))) == null ? void 0 : o.set) != null ? l : 0, v = h.startsWith("on") ? (y, g) => {
      let _ = h.slice(2);
      s.removeEventListener(_, g), s.addEventListener(_, y);
    } : f ? f.bind(s) : s.setAttribute.bind(s, h), m = ds(u != null ? u : 0);
    h.startsWith("on") || m === i4 && (u = qv(u), m = Up), m === Up ? Ch(() => (v(u.val, u._oldVal), s)) : v(u);
  }
  return l4(s, ...r);
}, kb = (i) => ({ get: (e, t) => c4.bind(Da, i, t) }), $C = new Proxy((i) => new Proxy(c4, kb(i)), kb()), h4 = (i, e) => e ? e !== i && i.replaceWith(e) : i.remove(), eR = () => {
  let i = 0, e = [...Xc].filter((n) => n.rawVal !== n._oldVal);
  do {
    qc = /* @__PURE__ */ new Set();
    for (let n of new Set(e.flatMap((r) => r._listeners = Op(r._listeners))))
      qv(n.f, n.s, n._dom), n._dom = Da;
  } while (++i < 100 && (e = [...qc]).length);
  let t = [...Xc].filter((n) => n.rawVal !== n._oldVal);
  Xc = Da;
  for (let n of new Set(t.flatMap((r) => r._bindings = Op(r._bindings))))
    h4(n._dom, Ch(n.f, n._dom)), n._dom = Da;
  for (let n of t)
    n._oldVal = n.rawVal;
};
const Ye = { add: l4, tags: $C, state: o4, derive: qv, hydrate: (i, e) => h4(i, Ch(e, i)) }, { button: tR, div: Tr, header: nR, input: NL, label: OL, span: iR, style: rR } = Ye.tags, is = (i) => Object.entries(i).map(([e, t]) => `${e}: ${t};`).join(""), sR = Object.getPrototypeOf(Ye.state(null)), Mc = (i) => Object.getPrototypeOf(i != null ? i : 0) === sR ? i : Ye.state(i);
let aR = 0;
const oR = ({ activeTab: i, resultClass: e = "", style: t = "", tabButtonRowColor: n = "#f1f1f1", tabButtonBorderStyle: r = "1px solid #000", tabButtonHoverColor: s = "#ddd", tabButtonActiveColor: a = "#ccc", transitionSec: o = 0.3, tabButtonRowClass: l = "", tabButtonRowStyleOverrides: c = {}, tabButtonClass: h = "", tabButtonStyleOverrides: u = {}, tabContentClass: d = "", tabContentStyleOverrides: p = {} }, f) => {
  const v = i != null ? i : Ye.state(Object.keys(f)[0]), m = is(Ee({ overflow: "hidden", "background-color": n }, c)), y = is(Ee({ float: "left", border: "none", "border-right": r, outline: "none", cursor: "pointer", padding: "8px 16px", transition: `background-color ${o}s` }, u)), g = is(Ee({ padding: "6px 12px", "border-top": "none" }, p)), _ = "vanui-tabs-" + ++aR;
  return document.head.appendChild(Ye.tags.style(`#${_} .vanui-tab-button { background-color: inherit }
#${_} .vanui-tab-button:hover { background-color: ${s} }
#${_} .vanui-tab-button.active { background-color: ${a} }`)), Tr({ id: _, class: e, style: t }, Tr({ class: l, style: m }, Object.keys(f).map((x) => tR({ class: () => ["vanui-tab-button"].concat(h || [], x === v.val ? "active" : []).join(" "), style: y, onclick: () => v.val = x }, x))), Object.entries(f).map(([x, M]) => Tr({ class: d, style: () => `display: ${x === v.val ? "block" : "none"}; ${g}` }, M)));
};
let lR = 0;
const j0 = () => ++lR, kp = ({ title: i, closed: e = Ye.state(!1), x: t = 100, y: n = 100, width: r = 300, height: s = 200, closeCross: a = "×", customStacking: o = !1, zIndex: l = 1, disableMove: c = !1, disableResize: h = !1, headerColor: u = "lightgray", windowClass: d = "", windowStyleOverrides: p = {}, headerClass: f = "", headerStyleOverrides: v = {}, childrenContainerClass: m = "", childrenContainerStyleOverrides: y = {}, crossClass: g = "", crossStyleOverrides: _ = {}, crossHoverClass: x = "", crossHoverStyleOverrides: M = {} }, ...b) => {
  const w = Mc(t), T = Mc(n), A = Mc(r), L = Mc(s), I = Mc(l);
  o || (I.val = j0());
  const P = Ye.state(!1), N = Ye.state(null), F = Ye.state(0), z = Ye.state(0), q = Ye.state(0), re = Ye.state(0), ie = x || Object.keys(M) ? Ye.state(!1) : null, me = (he) => {
    he.button === 0 && (P.val = !0, F.val = he.clientX, z.val = he.clientY, document.body.style.userSelect = "none");
  }, Se = (he) => (ae) => {
    N.val = he, F.val = ae.clientX, z.val = ae.clientY, q.val = A.val, re.val = L.val, document.body.style.userSelect = "none";
  };
  document.addEventListener("mousemove", (he) => {
    if (P.val)
      w.val += he.clientX - F.val, T.val += he.clientY - z.val, F.val = he.clientX, z.val = he.clientY;
    else if (N.val) {
      const ae = he.clientX - F.val, D = he.clientY - z.val;
      N.val.includes("right") && (A.val = q.val + ae), N.val.includes("bottom") && (L.val = re.val + D);
    }
  }), document.addEventListener("mouseup", () => {
    P.val = !1, N.val = null, document.body.style.userSelect = "";
  });
  const te = "transparent";
  if (!document.getElementById("vanui-window-style")) {
    const he = rR({ type: "text/css", id: "vanui-window-style" }, (se = { ".vanui-window": { position: "fixed", "background-color": "white", border: "1px solid black", "border-radius": "0.5rem", overflow: "hidden" }, ".vanui-window-dragarea": { cursor: "move", position: "absolute", left: "0", top: "0", width: "100%", height: "1rem" }, ".vanui-window-resize-right": { cursor: "e-resize", position: "absolute", right: "0", top: "0", width: "10px", height: "100%", "background-color": te }, ".vanui-window-resize-bottom": { cursor: "s-resize", position: "absolute", left: "0", bottom: "0", width: "100%", height: "10px", "background-color": te }, ".vanui-window-resize-rightbottom": { cursor: "se-resize", position: "absolute", right: "0", bottom: "0", width: "10px", height: "10px", "background-color": te }, ".vanui-window-header": { cursor: "move", "user-select": "none", display: "flex", "justify-content": "space-between", "align-items": "center", padding: "0.5rem" }, ".vanui-window-cross": { cursor: "pointer", "font-family": "Arial", transition: "background-color 0.3s, color 0.3s", "border-radius": "50%", width: "24px", height: "24px", display: "flex", "align-items": "center", "justify-content": "center" }, ".vanui-window-cross:hover": { "background-color": "red", color: "white" }, ".vanui-window-children": { padding: "0.5rem" } }, Object.entries(se).map(([ae, D]) => `${ae} { ${is(D)} }`).join(`
`)));
    document.head.appendChild(he);
  }
  var se;
  return () => e.val ? null : Tr(Ee({ class: ["vanui-window"].concat(d || []).join(" "), style: () => is(Ee({ left: `${w.val}px`, top: `${T.val}px`, width: `${A.val}px`, height: `${L.val}px`, "z-index": I.val }, p)) }, o ? {} : { onmousedown: () => I.val = j0() }), i ? nR(Ee({ class: ["vanui-window-header"].concat(f || []).join(" "), style: is(Ee(Ee({ "background-color": u }, c ? { cursor: "auto" } : {}), v)) }, c ? {} : { onmousedown: me }), i, a ? iR(Ee({ class: () => ["vanui-window-cross"].concat(g || []).concat(x && ie.val ? x : []).join(" "), style: () => is(Ee(Ee({}, _), Object.keys(M).length && ie.val ? M : {})), onclick: () => e.val = !0 }, ie ? { onmouseenter: () => ie.val = !0, onmouseleave: () => ie.val = !1 } : {}), a) : null) : c ? null : Tr({ class: "vanui-window-dragarea", onmousedown: me }), h ? [] : [Tr({ class: "vanui-window-resize-right", onmousedown: Se("right") }), Tr({ class: "vanui-window-resize-bottom", onmousedown: Se("bottom") }), Tr({ class: "vanui-window-resize-rightbottom", onmousedown: Se("rightbottom") })], Tr({ class: ["vanui-window-children"].concat(m || []).join(" "), style: is(y) }, b));
}, u4 = Yv;
function Yv(i, e) {
  const t = Zv();
  return (Yv = function(n, r) {
    return t[n -= 430];
  })(i, e);
}
(function(i, e) {
  const t = Yv, n = Zv();
  for (; ; )
    try {
      if (parseInt(t(446)) / 1 + -parseInt(t(441)) / 2 + parseInt(t(465)) / 3 * (parseInt(t(444)) / 4) + parseInt(t(436)) / 5 * (parseInt(t(437)) / 6) + -parseInt(t(467)) / 7 + -parseInt(t(464)) / 8 + -parseInt(t(457)) / 9 * (-parseInt(t(440)) / 10) === 807624)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const { div: Fb } = Ye[u4(442)];
function Zv() {
  const i = ["8197385uhByUJ", "body", "open", "max-width: 500px;", "folder", "auto", "innerHeight", "panels", "384045pYNbzV", "12iWesAN", "closed", "innerWidth", "318750MOUOWN", "1850630RLTQYx", "tags", "name", "1336988vfnIXa", `
            
                border: 1px solid rgba(255, 255, 255, 0.2);
                
                border-radius: 3px;

                padding: 5px 0px 5px 0px;
            
            `, "1599722gJpcFC", "3D-配置", "reduce", "folders", "state", "__folders", "flex", "black", "parse", "0.4em 0.8em", "val", "351dVNoIS", "none", "threeEditor_Panel", "stringify", "getItem", "forEach", "load", "3413744wkDFbs", "3fncoLw", "add"];
  return (Zv = function() {
    return i;
  })();
}
function Kv() {
  const i = ["class", "__folders", "24542410mMmhSX", "random", "6856Zwfzxb", "folders", "1278WlQnCK", "11Ttcwlg", "name", "735IoNVzb", "1011zeUasH", "open", "load", "1064601OZZSFM", "domElement", "appendChild", "2075678PbLCGV", "add", "body", "state", "height", "1346232VyQUeJ", "30880BXVDJg", "auto", "updateDisplay", "tags", "width", "105464sBoaBW", "val", "div"];
  return (Kv = function() {
    return i;
  })();
}
function Qv(i, e) {
  const t = Kv();
  return (Qv = function(n, r) {
    return t[n -= 305];
  })(i, e);
}
function Jv() {
  const i = ["height", "118742AliuNt", "152fIODeF", "van-div-datgui", "3031330QmERHk", "3098097PLJkau", "state", "auto", "width", "now", "321097yQxqxz", "176lZerkw", "20JNeWkb", "div", "3258948HPYQXY", "appendChild", "5439822AvmUHs", "val", "tags", "8073nWCPdS"];
  return (Jv = function() {
    return i;
  })();
}
function $v(i, e) {
  const t = Jv();
  return ($v = function(n, r) {
    return t[n -= 205];
  })(i, e);
}
(function(i, e) {
  const t = Qv, n = Kv();
  for (; ; )
    try {
      if (-parseInt(t(308)) / 1 + -parseInt(t(333)) / 2 + parseInt(t(327)) / 3 * (parseInt(t(321)) / 4) + parseInt(t(309)) / 5 * (parseInt(t(323)) / 6) + -parseInt(t(326)) / 7 * (parseInt(t(314)) / 8) + parseInt(t(330)) / 9 + -parseInt(t(319)) / 10 * (-parseInt(t(324)) / 11) === 697350)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = $v, n = Jv();
  for (; ; )
    try {
      if (parseInt(t(211)) / 1 + parseInt(t(221)) / 2 * (-parseInt(t(209)) / 3) + parseInt(t(224)) / 4 + parseInt(t(214)) / 5 + -parseInt(t(206)) / 6 + parseInt(t(220)) / 7 * (parseInt(t(212)) / 8) + -parseInt(t(215)) / 9 * (parseInt(t(222)) / 10) === 579383)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
let lg = null;
function ey(i, e) {
  const t = ty();
  return (ey = function(n, r) {
    return t[n -= 206];
  })(i, e);
}
function ty() {
  const i = ["3932952FqYAvH", "2243838cAldcI", "load", "1CrsWiQ", "updateDisplay", "10tFYEDY", "body", "4583646mTQUDw", "1017935DTaUdx", "state", "appendChild", "random", "width", "5026140KqOStD", "van-div-datgui", "height", "folders", "1401698ACoYyZ", "77JNASnd", "619976VSxCQn", "val", "name"];
  return (ty = function() {
    return i;
  })();
}
(function(i, e) {
  const t = ey, n = ty();
  for (; ; )
    try {
      if (-parseInt(t(215)) / 1 * (-parseInt(t(207)) / 2) + parseInt(t(212)) / 3 + -parseInt(t(225)) / 4 + parseInt(t(220)) / 5 + -parseInt(t(213)) / 6 + -parseInt(t(208)) / 7 * (-parseInt(t(209)) / 8) + parseInt(t(219)) / 9 * (-parseInt(t(217)) / 10) === 928085)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const Bi = iy;
function ny() {
  const i = ["1525315dkApHp", "#2c2c2c", "2692696NxnZFB", "3px 5px", "head", "appendChild", "2070998NpOuAP", "fill", "1536475vltSwY", "9703536rxjVMQ", "1LNcdus", "45uLAhpO", "forEach", "13px", "3189948zgQGth", "#1a1a1a", "1px solid #6f6f6f", "100OCrstU", "9jnfann", "7gpuVZs", "#ffffff", "tags", "353516EwINzh"];
  return (ny = function() {
    return i;
  })();
}
function iy(i, e) {
  const t = ny();
  return (iy = function(n, r) {
    return t[n -= 243];
  })(i, e);
}
(function(i, e) {
  const t = iy, n = ny();
  for (; ; )
    try {
      if (parseInt(t(257)) / 1 * (-parseInt(t(253)) / 2) + parseInt(t(258)) / 3 * (parseInt(t(246)) / 4) + parseInt(t(255)) / 5 + -parseInt(t(256)) / 6 * (parseInt(t(243)) / 7) + -parseInt(t(249)) / 8 * (-parseInt(t(265)) / 9) + -parseInt(t(264)) / 10 * (-parseInt(t(247)) / 11) + parseInt(t(261)) / 12 === 969291)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), Array(100)[Bi(254)]()[Bi(259)](() => j0());
const { style: cR } = Ye[Bi(245)];
document[Bi(251)][Bi(252)](cR(`.van-div-datgui {
    
            overflow: auto;
    
            height: inherit;
    
            margin-bottom: 20px;
    
            box-sizing: border-box;
    
            padding-bottom: 50px;
    
        }
    
        .van-div-datgui::-webkit-scrollbar {
    
            width: 0px;
    
            height: 0px;
            
        }`));
const Rh = { windowStyleOverrides: { "background-color": Bi(262), border: Bi(263), "border-radius": "3px", "user-select": "none" }, childrenContainerStyleOverrides: { height: "inherit" }, headerStyleOverrides: { background: Bi(248), padding: Bi(250), color: Bi(244), "font-size": Bi(260) }, crossStyleOverrides: { transition: "all 0.6s" }, crossHoverStyleOverrides: { "background-color": "#ffc6c6" } };
function Yh(i, e) {
  const t = ry();
  return (Yh = function(n, r) {
    return t[n -= 285];
  })(i, e);
}
function ry() {
  const i = ["1245960SeiORZ", "onChange", "roughness", "metalness", "visible", "金属度", "整体透明", "整体金属度", "set", "4097274KtdFYq", "351971qREXOM", "1226384hmSZLB", "2193960QuioTG", "max", "wireframe", "addColor", "needsUpdate", "透明度", "min", "整体线框", "addFn", "未变化手动更新", "name", "forEach", "add", "5ooRBty", "opacity", "3RTDXAT", "31743EJSpyr", "addHexColor", "整体粗糙度", "transparent", "整体透明度", "2330rpUkxm", "color", "6427799LkeCrD"];
  return (ry = function() {
    return i;
  })();
}
function sy(i) {
  const { visible: e, color: t, opacity: n, transparent: r, wireframe: s, metalness: a, roughness: o } = i;
  return { visible: e, color: t, opacity: n, transparent: r, wireframe: s, metalness: a, roughness: o };
}
function ay(i, e) {
  const t = Yh;
  if (!e)
    return;
  const { visible: n, color: r, opacity: s, transparent: a, wireframe: o, metalness: l, roughness: c } = e;
  i[t(288)] = n, i[t(298)] = o, i[t(315)] = a, i[t(310)] = s, i.color[t(292)](r), i.metalness != null && (i.metalness = l), i[t(286)] != null && (i[t(286)] = c);
}
function hR(i, e) {
  var t = Ef;
  Gr(i, e[t(485)](t(468))), function(n, r) {
    const s = Yh;
    r[s(308)]({ transparent: !1 }, s(315)).name(s(290))[s(285)]((a) => n[s(307)]((o) => o.transparent = a)), r[s(308)]({ opacity: 1 }, s(310))[s(302)](0).max(1)[s(306)](s(316))[s(285)]((a) => n[s(307)]((o) => o[s(310)] = a)), r[s(308)]({ wireframe: !1 }, "wireframe")[s(306)](s(303))[s(285)]((a) => n.forEach((o) => o.wireframe = a)), r[s(299)]({ color: 16777215 }, "color")[s(306)]("整体颜色")[s(285)]((a) => n[s(307)]((o) => o[s(318)].set(a))), r[s(308)]({ metalness: 0 }, s(287))[s(302)](0).max(1)[s(306)](s(291)).onChange((a) => n[s(307)]((o) => o[s(287)] != null && (o[s(287)] = a))), r[s(308)]({ roughness: 0 }, s(286))[s(302)](0)[s(297)](1).name(s(314))[s(285)]((a) => n[s(307)]((o) => o[s(286)] != null && (o[s(286)] = a))), r[s(304)](() => n[s(307)]((a) => a[s(300)] = !0)).name("未变化手动更新");
  }(i[t(478)], e[t(485)](t(473))), JS(i, e[t(485)]("着色器配置"));
}
function Ef(i, e) {
  var t = oy();
  return (Ef = function(n, r) {
    return t[n -= 467];
  })(i, e);
}
function oy() {
  var i = ["ShaderMaterial", "isArray", "type", "RootMaterials", "forEach", "map", "2370715NGXYZE", "贴图配置", "材质配置", "贴图动画", "addFolder", "589800lRiSzZ", "13749vZUStn", "22727520Aadlll", "1679912ATdvWS", "基础配置", "5418756kzkMHp", "material", "着色器配置", "5715684RhSQVl", "整体材质配置", "3eMtSNF"];
  return (oy = function() {
    return i;
  })();
}
function uR(i, e, t) {
  var n = Ef;
  function r(s, a, o = "") {
    var l = n;
    a[l(477)] !== l(475) && (function(c, h) {
      const u = Yh;
      h[u(308)](c, u(306))[u(306)]("名称"), h[u(308)](c, u(288))[u(306)]("显示"), h[u(308)](c, u(298))[u(306)]("线框"), h[u(308)](c, u(315))[u(306)]("透明"), h[u(308)](c, u(310), 0, 1)[u(306)](u(301)), h[u(313)](c[u(318)])[u(306)]("颜色"), c[u(287)] != null && h[u(308)](c, u(287), 0, 1)[u(306)](u(289)), c[u(286)] != null && h[u(308)](c, u(286), 0, 1)[u(306)]("粗糙度"), h[u(304)](() => c.needsUpdate = !0)[u(306)](u(305));
    }(a, s[l(485)](l(483) + o)), a.isCustomTexture && a.map && (function(c, h) {
      const u = Xa;
      h[u(273)](c, u(252), [W[u(288)], In, Fa])[u(250)](u(281))[u(274)]((d) => c[u(286)] = !0), h[u(273)](c, u(248), [W[u(288)], W[u(268)], W[u(258)]])[u(250)](u(264))[u(274)]((d) => c[u(286)] = !0), h[u(273)](c, u(278))[u(250)]("旋转").min(0)[u(280)](2 * Math.PI), h[u(273)](c.repeat, "x").name("x重复"), h[u(273)](c[u(247)], "y").name("y重复"), h.add(c[u(284)], "x")[u(250)](u(262))[u(287)](0)[u(280)](1), h[u(273)](c[u(284)], "y")[u(250)]("y偏移")[u(287)](0)[u(280)](1), h[u(273)](c[u(249)], "x")[u(250)](u(292))[u(287)](0)[u(280)](1), h[u(273)](c[u(249)], "y")[u(250)](u(290))[u(287)](0)[u(280)](1);
    }(a.map, s.addFolder(l(482) + o)), function(c, h, u) {
      const d = Xa;
      !Reflect[d(255)](h, d(259)) && (h.textureAnimation = { isTextureAnimation: !1, offset: { x: 0, y: 0 }, rotation: 0 }), u[d(273)](h[d(259)], d(293))[d(250)](d(283))[d(274)]((p) => {
        const f = d;
        if (p)
          h[f(260)] = function() {
            const v = f;
            h[v(284)].x += h[v(259)][v(284)].x, h[v(284)].y += h[v(259)][v(284)].y, h[v(278)] += h[v(259)][v(278)];
          }, c[f(251)](h);
        else {
          delete h[f(260)];
          const v = c[f(276)]((m) => m.uuid == h.uuid);
          v > -1 && c[f(279)](v, 1);
        }
      }), u[d(273)](h[d(259)], d(278))[d(250)](d(269)), u[d(273)](h.textureAnimation[d(284)], "x")[d(250)](d(289)), u[d(273)](h.textureAnimation.offset, "y")[d(250)]("y偏移速度");
    }(i, a[l(480)], s[l(485)](l(484) + o))));
  }
  Gr(e, t.addFolder("基础配置")), Array[n(476)](e.material) ? e[n(470)][n(479)]((s, a) => r(t, s, a)) : r(t, e[n(470)]), e.disBlendShader || JS(e, t[n(485)](n(471)));
}
function ly() {
  const i = ["RootMaterials", "347384RtpQXN", "276283Abllvl", "addFolder", "98QduMJa", "open", "6NLMqHN", "2085660YqlLsy", "commonFrames", "10XKCjqq", "removeCall", "2547245OqYeSa", "45bYeLEk", "removeFolder", "isMesh", "324wcdBQQ", "282bVIMgs", "310409JZDEtp", "1496007fbRBpG", "createSelectPanel", "name"];
  return (ly = function() {
    return i;
  })();
}
function cy(i, e) {
  const t = ly();
  return (cy = function(n, r) {
    return t[n -= 485];
  })(i, e);
}
function dR(i, e) {
  const t = cy;
  let n = null;
  i[t(494)] = (s) => {
    n === s && (e.removeFolder(r), r = null);
  };
  let r = null;
  e[t(503)] = (s) => {
    const a = t;
    n = s, r && (e[a(497)](r), r = null), r = e[a(487)]((s[a(498)] ? "[#]:" : "[$]:") + s[a(504)] + "配置"), r[a(489)](), s[a(505)] ? hR(s, r) : s[a(498)] && uR(i[a(492)], s, r), function(o, l = {}) {
      const c = $v;
      if (lg && !lg[c(207)])
        return;
      const h = Ye[c(208)][c(223)]({ class: c(213) });
      o.open();
      const u = "[" + Date[c(219)]() + "]";
      h[c(205)](o.domElement);
      const d = Ye[c(216)](l[c(218)] || c(217)), p = Ye.state(l[c(210)] || 500), f = Ye[c(216)](!1);
      lg = f;
      const v = kp(Ee({ title: u, closed: f, x: 100, y: 80, width: d, height: p }, Rh), h);
      Ye.add(document.body, v);
    }(e);
  };
}
function hy(i, e) {
  const t = uy();
  return (hy = function(n, r) {
    return t[n -= 275];
  })(i, e);
}
function uy() {
  const i = ["vanFloatWindow", "21MBhYDh", "addDateFolder", "prototype", "getHex", "101xnfmLI", "now", "addColor", "18178qJGHXU", "add", "572944Cmxgwi", "addDragFolder", "TEXT_CLOSED", "5193672coWJaj", "GUI", "color", "2943yDUvcL", "addFolder", "展开场景配置", "4705lagnmr", "remove", "addHexColor", "4554eyzJSs", "1210YLGkGQ", "set", "TEXT_OPEN", "收起场景配置", "onChange", "11052800BCtnQU", "1523067TPwwoB"];
  return (uy = function() {
    return i;
  })();
}
function pR() {
  var t;
  const i = hy;
  To[i(280)][i(278)] = i(292), Tp[i(291)] = i(284), To[i(280)][i(299)][i(298)] = function(n) {
    const r = i;
    return this[r(283)](n + "[" + Date[r(302)]() + "]");
  }, To[i(280)][i(299)][i(277)] = function(n, ...r) {
    const s = i, a = this[s(283)](n + "[" + Date.now() + "]");
    return a[s(296)] = function(o, l = {}, c = () => {
    }) {
      const h = Qv, u = Ye[h(312)][h(316)]({ class: l[h(317)] });
      o[h(328)]();
      const d = o.name;
      o[h(325)] = "属性", u[h(332)](o[h(331)]);
      const p = Ye[h(306)](l[h(313)] || h(310)), f = Ye[h(306)](l[h(307)] || h(310)), v = Ye.state(!1);
      Ye.derive(() => {
        const y = h;
        if (v[y(315)]) {
          const { parent: g } = o;
          delete g[y(318)][d], g.load && g[y(329)][y(322)] && g[y(329)][y(322)][d] && delete g[y(329)][y(322)][d], g[y(311)](), c();
        }
      });
      const m = kp(Ee({ title: d, closed: v, x: 100 + 600 * Math[h(320)](), y: 50 + 400 * Math.random(), width: p, height: f }, Rh), u);
      return Ye[h(334)](document[h(305)], m), { floatingWindow: m, el: u };
    }(a, ...r), a;
  }, To[i(280)][i(299)].addCoreDragFolder = function(n, ...r) {
    const s = i, a = this[s(283)](n + "[" + Date[s(302)]() + "]");
    return a[s(296)] = function(o, l = {}) {
      const c = ey, h = Ye.tags.div({ class: c(226) });
      o.open();
      const u = o.name;
      o[c(211)] = "管理", h[c(222)](o.domElement);
      const d = Ye.state(l[c(224)] || 280), p = Ye[c(221)](l[c(227)] || 450), f = Ye[c(221)](!1);
      Ye.derive(() => {
        const m = c;
        if (f[m(210)]) {
          const { parent: y } = o;
          delete y.__folders[u], y[m(214)] && y[m(214)].folders && y.load[m(206)][u] && delete y[m(214)][m(206)][u], y[m(216)]();
        }
      });
      const v = kp(Ee({ title: u, closed: f, x: 60 + 400 * Math.random(), y: 90 * Math[c(223)](), width: d, height: p }, Rh), h);
      return Ye.add(document[c(218)], v), { floatingWindow: v, el: h };
    }(a, ...r), a;
  }, To[i(280)].prototype.addFn = function(n, ...r) {
    return this[i(275)]({ fn: n }, "fn", ...r);
  }, To[i(280)][i(299)][i(287)] = function(n) {
    const r = i;
    return this[r(303)]({ color: n[r(300)]() }, r(281))[r(293)]((s) => n[r(290)](s));
  };
  const e = new Tp({ autoPlace: !1 });
  return (t = e.__closeButton) == null || t[i(286)](), e;
}
function dy() {
  const i = ["clipPlaneSize", "2076956leoJed", "15438236reYFhY", "Vector3", "helper", "85911KkbRsj", "1801135TbQvrA", "347188BDuIpD", "showHelper", "36ZINikp", "normal", "109736DiIIba", "name", "6NMzdFT", "filter", "removeFolder", "addFn", "PlaneHelper", "remove", "parent", "10BSiPIU", "765728UvnVzT", "add", "16wDRcXV", "random"];
  return (dy = function() {
    return i;
  })();
}
function Zh(i, e) {
  const t = dy();
  return (Zh = function(n, r) {
    return t[n -= 415];
  })(i, e);
}
function d4() {
  return new Fi(new W[Zh(427)](0, -1, 0), -0.1);
}
function p4(i, e = 20) {
  const t = Zh;
  return i.helper = new W[t(416)](i, e, 16777215 * Math[t(423)]()), i[t(428)];
}
function Bb(i, e, t, n, r) {
  const s = Zh;
  return r[s(421)](n, "constant")[s(436)]("偏移"), r.add(n[s(434)], "x", -1, 1), r[s(421)](n[s(434)], "y", -1, 1), r[s(421)](n[s(434)], "z", -1, 1), r[s(421)]({ showHelper: !!n.helper }, s(432))[s(436)]("显示辅助线").onChange((a) => {
    const o = s;
    a ? (!n[o(428)] && p4(n, t[o(424)]), i[o(421)](n.helper)) : n[o(428)] && i[o(417)](n.helper);
  }), r[s(415)](() => {
    const a = s;
    n[a(428)] && i[a(417)](n[a(428)]), e.clippingPlanes = e.clippingPlanes[a(438)]((o) => o !== n), r[a(418)][a(439)](r);
  }).name("删除"), r;
}
function Kh(i, e) {
  const t = py();
  return (Kh = function(n, r) {
    return t[n -= 489];
  })(i, e);
}
function fR(i) {
  const e = Kh;
  return i.clippingPlanes[e(498)]((t) => {
    const n = e;
    return { normal: { x: t.normal.x, y: t[n(509)].y, z: t[n(509)].z }, constant: t[n(490)] };
  });
}
function py() {
  const i = ["823816nnYqpY", "normal", "1121087WURiAz", "open", "clippingPlanes", "6595MqVizm", "addFn", "4128UgsGyp", "全局裁剪列表", "constant", "1550jyWydA", "push", "70DdlHzP", "229625OiYqsK", "4863uGnhoV", "clipPlaneSize", "add", "map", "addFolder", "addDateFolder", "set", "forEach", "7117200FbVlvO", "3652HphBiE", "helper", "1587244Oexgat", "裁剪辅助面大小"];
  return (py = function() {
    return i;
  })();
}
(function(i, e) {
  const t = Yh, n = ry();
  for (; ; )
    try {
      if (parseInt(t(294)) / 1 + -parseInt(t(320)) / 2 + parseInt(t(311)) / 3 * (-parseInt(t(295)) / 4) + -parseInt(t(309)) / 5 * (-parseInt(t(293)) / 6) + parseInt(t(319)) / 7 + parseInt(t(296)) / 8 + -parseInt(t(312)) / 9 * (parseInt(t(317)) / 10) === 475985)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  for (var t = Ef, n = oy(); ; )
    try {
      if (-parseInt(t(487)) / 1 + -parseInt(t(467)) / 2 * (parseInt(t(474)) / 3) + -parseInt(t(472)) / 4 + -parseInt(t(481)) / 5 + -parseInt(t(486)) / 6 + parseInt(t(469)) / 7 + parseInt(t(488)) / 8 === 759979)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = cy, n = ly();
  for (; ; )
    try {
      if (-parseInt(t(486)) / 1 + parseInt(t(500)) / 2 * (parseInt(t(496)) / 3) + parseInt(t(491)) / 4 + parseInt(t(495)) / 5 * (parseInt(t(490)) / 6) + -parseInt(t(488)) / 7 * (-parseInt(t(485)) / 8) + -parseInt(t(502)) / 9 * (parseInt(t(493)) / 10) + -parseInt(t(501)) / 11 * (parseInt(t(499)) / 12) === 436482)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = hy, n = uy();
  for (; ; )
    try {
      if (-parseInt(t(301)) / 1 * (-parseInt(t(304)) / 2) + parseInt(t(295)) / 3 + -parseInt(t(279)) / 4 + -parseInt(t(285)) / 5 * (parseInt(t(288)) / 6) + parseInt(t(297)) / 7 * (parseInt(t(276)) / 8) + -parseInt(t(282)) / 9 * (-parseInt(t(289)) / 10) + parseInt(t(294)) / 11 === 672262)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Zh, n = dy();
  for (; ; )
    try {
      if (-parseInt(t(435)) / 1 + -parseInt(t(431)) / 2 + parseInt(t(429)) / 3 * (parseInt(t(422)) / 4) + -parseInt(t(430)) / 5 + parseInt(t(437)) / 6 * (-parseInt(t(425)) / 7) + -parseInt(t(420)) / 8 * (parseInt(t(433)) / 9) + parseInt(t(419)) / 10 * (parseInt(t(426)) / 11) === 194895)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Kh, n = py();
  for (; ; )
    try {
      if (parseInt(t(510)) / 1 + parseInt(t(506)) / 2 + parseInt(t(495)) / 3 * (-parseInt(t(504)) / 4) + parseInt(t(513)) / 5 * (-parseInt(t(515)) / 6) + parseInt(t(493)) / 7 * (-parseInt(t(508)) / 8) + -parseInt(t(503)) / 9 + parseInt(t(491)) / 10 * (parseInt(t(494)) / 11) === 942319)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const ti = fy;
function fy(i, e) {
  const t = my();
  return (fy = function(n, r) {
    return t[n -= 127];
  })(i, e);
}
(function(i, e) {
  const t = fy, n = my();
  for (; ; )
    try {
      if (-parseInt(t(132)) / 1 + -parseInt(t(167)) / 2 + -parseInt(t(141)) / 3 * (-parseInt(t(130)) / 4) + -parseInt(t(149)) / 5 * (-parseInt(t(150)) / 6) + -parseInt(t(159)) / 7 + parseInt(t(162)) / 8 + -parseInt(t(143)) / 9 * (-parseInt(t(128)) / 10) === 496483)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const mR = { No: W[ti(158)], Linear: W[ti(174)], Reinhard: W[ti(133)], Cineon: W[ti(145)], ACESFilmic: W[ti(127)], AgX: W[ti(171)], Custom: W[ti(131)] }, gR = { Basic: W[ti(163)], PCF: W[ti(156)], PCFSoft: $0, VSM: W[ti(142)] };
function my() {
  const i = ["ACESFilmicToneMapping", "14090KfXXRX", "clippingPlanes", "710596GraKuD", "CustomToneMapping", "586292jlTyra", "ReinhardToneMapping", "shadowMap", "toneMapping", "name", "onChange", "localClippingEnabled", "sortObjects", "排序对象", "15yqUGBl", "VSMShadowMap", "1341PdUloi", "setClearColor", "CineonToneMapping", "outputColorSpace", "setClearAlpha", "阴影贴图", "399005HmIdcP", "30sKOmWg", "min", "Color", "getHex", "渲染器背景色", "渲染器背景透明度", "PCFShadowMap", "色调映射", "NoToneMapping", "3102596RpmvHX", "getClearColor", "阴影贴图类型", "7107136wmqTIR", "BasicShadowMap", "渲染器输出编码", "max", "color", "1719160bwulHo", "add", "type", "toneMappingExposure", "AgXToneMapping", "getClearAlpha", "LinearSRGBColorSpace", "LinearToneMapping"];
  return (my = function() {
    return i;
  })();
}
function vR(i) {
  const e = ti;
  return { outputColorSpace: i.outputColorSpace, toneMapping: i[e(135)], toneMappingExposure: i[e(170)], shadowMap: { enabled: i[e(134)].enabled, type: i[e(134)].type }, color: i[e(160)](new W[e(152)]())[e(153)](), opacity: i.getClearAlpha(), sortObjects: i[e(139)], localClippingEnabled: i[e(138)], clippingPlanes: fR(i) };
}
function yR(i, e) {
  const t = ti;
  e && (i[t(146)] = e[t(146)], i[t(135)] = e.toneMapping, i[t(170)] = e[t(170)], i.shadowMap.enabled = e.shadowMap.enabled, i[t(134)].type = e.shadowMap[t(169)], i[t(144)](e.color, e.opacity), i[t(139)] = e[t(139)], i[t(138)] = e.localClippingEnabled, function(n, r) {
    const s = Kh;
    r && (n[s(512)] = r[s(498)]((a) => {
      const o = s, l = d4();
      return l[o(509)][o(501)](a[o(509)].x, a.normal.y, a[o(509)].z), l[o(490)] = a[o(490)], l;
    }));
  }(i, e[t(129)]));
}
function Qh(i, e) {
  var t = gy();
  return (Qh = function(n, r) {
    return t[n -= 226];
  })(i, e);
}
function _R(i) {
  if (i)
    return { colorSpace: i[Qh(232)] };
}
function gy() {
  var i = ["514467wBkqeG", "24940pmiUBG", "140URbkCm", "200mnqQKL", "add", "onChange", "2854124MEVjDE", "SRGBColorSpace", "色彩空间", "needsUpdate", "LinearSRGBColorSpace", "328752dpvxEE", "1485258ISSlUv", "409307XUVgFJ", "643437TjLhXJ", "name", "dispose", "colorSpace"];
  return (gy = function() {
    return i;
  })();
}
function vy() {
  const i = ["3428110qQRYiq", "near", "55zinZcr", "128346QJVNts", "4082168CsfJLv", "Fog", "5GGPZBW", "exp2", "type", "add", "196637xbKIsm", "name", "102963OsgDHh", "雾类型", "6709770cNsgjz", "启用雾", "far", "density", "open", "58MCgZLY", "fog", "color", "48uGSzuf", "linear", "FogExp2", "addHexColor", "getHex", "enable", "12447080uQFOIH", "onChange", "removeFolder"];
  return (vy = function() {
    return i;
  })();
}
function Nl(i, e) {
  const t = vy();
  return (Nl = function(n, r) {
    return t[n -= 467];
  })(i, e);
}
function xR(i) {
  const e = Nl;
  if (i)
    return { name: i[e(496)], type: i instanceof W[e(490)] ? e(477) : e(492), density: i[e(471)], color: i[e(475)][e(480)](), near: i[e(486)], far: i[e(470)] };
}
function W0(i, ...e) {
  const t = Nl;
  return i === t(477) ? new ah(...e) : new W[t(478)](...e);
}
function Jh(i, e) {
  const t = yy();
  return (Jh = function(n, r) {
    return t[n -= 193];
  })(i, e);
}
function bR(i) {
  const e = Jh, { background: t } = i;
  return { backgroundBlurriness: i[e(219)], backgroundIntensity: i[e(194)], backgroundUrls: i[e(201)] && i[e(200)], envBackgroundUrls: i.envBackground && i[e(220)], fog: xR(i.fog), environmentEnabled: i[e(217)], background: _R(t) };
}
function yy() {
  const i = ["environmentEnabled", "10765820HWTUlW", "backgroundBlurriness", "envBackgroundUrls", "4432lbSMxe", "environment", "backgroundIntensity", "fog", "83QHoyPZ", "3054792OouZPG", "addFn", "5769XCWFRM", "backgroundUrls", "background", "addFolder", "973374Imlhtv", "背景模糊度", "setEnvBackground", "25012kRCzLU", "背景强度", "add", "背景配置", "5182256GRfxZw", "全局环境贴图", "2482730JUTHtF", "envBackground", "56JcVlyY", "onChange", "name"];
  return (yy = function() {
    return i;
  })();
}
function MR(i, e) {
  const t = Jh;
  e && (i[t(219)] = e[t(219)], i[t(194)] = e[t(194)], function(n, r) {
    const s = Nl;
    if (!r)
      return;
    const a = W0(r.type);
    a[s(496)] = r.name, a[s(475)].set(r.color), r.type === s(477) ? (a[s(486)] = r[s(486)], a[s(470)] = r.far) : a[s(471)] = r[s(471)], n[s(474)] = a;
  }(i, e[t(195)]), i[t(217)] = e[t(217)], e.backgroundUrls && (i.backgroundLoadCallback = (n) => {
    return r = n, s = e[t(201)], a = Qh, void (s && (r[a(232)] = s[a(232)]));
    var r, s, a;
  }, i.setSceneBackground(e[t(200)])), e[t(220)] && i[t(205)](e[t(220)]));
}
function wR(i, e) {
  const t = Jh;
  if (!e)
    return;
  (function(r, s) {
    const a = Nl;
    s[a(472)]();
    let o = null;
    const l = { type: r[a(474)] instanceof W[a(478)] ? a(492) : a(477), enable: !!r[a(474)] };
    function c(h) {
      const u = a;
      o && (s[u(484)](o), o = null), r[u(474)] && (o = s.addFolder(h + "雾"), o[u(479)](r.fog[u(475)])[u(496)]("颜色"), h === u(477) ? (o[u(494)](r[u(474)], u(486))[u(496)]("近点"), o[u(494)](r[u(474)], u(470))[u(496)]("远点")) : o[u(494)](r[u(474)], u(471))[u(496)]("密度"));
    }
    s[a(494)](l, a(493), [a(477), a(492)])[a(496)](a(467))[a(483)]((h) => {
      var d;
      const u = a;
      r.fog = W0(h, (d = r[u(474)]) == null ? void 0 : d[u(475)]), c(h);
    }), s[a(494)](l, a(481))[a(496)](a(469)).onChange((h) => {
      const u = a;
      r[u(474)] = h ? W0(l[u(493)]) : null, c(l[u(493)]);
    }), l[a(481)] && c(l[a(493)]);
  })(i, e[t(202)]("雾配置")), e[t(208)](i, t(217)).name(t(211))[t(215)]((r) => i[t(193)] = r ? i[t(213)] : null), e.add(i, t(219), 0, 1).name(t(204)), e[t(208)](i, t(194), 0)[t(216)](t(207));
  let n = null;
  return e[t(198)](() => {
    const r = t;
    n || (n = function(s, a) {
      var o = Qh;
      if (a.open(), s)
        return a[o(237)](s, o(232), [W[o(240)], W[o(243)]])[o(230)](o(241))[o(238)](() => {
          var l = o;
          s[l(231)](), s[l(242)] = !0;
        }), a;
    }(i[r(201)], e[r(202)](r(209))));
  })[t(216)]("加载背景参数"), e;
}
function $h(i, e) {
  const t = _y();
  return ($h = function(n, r) {
    return t[n -= 184];
  })(i, e);
}
function SR(i) {
  const e = $h;
  return { fov: i[e(206)], near: i[e(207)], far: i[e(185)], zoom: i[e(204)], layers: Fv(i[e(203)]), position: { x: i[e(187)].x, y: i[e(187)].y, z: i[e(187)].z } };
}
function _y() {
  const i = ["3wmpUIY", "position", "8AfCdGA", "9590iNQEfM", "5709ROKdVg", "add", "min", "name", "相机位置y", "4781CqgEJT", "onChange", "829854rVRnDQ", "168326IRaVSl", "updateProjectionMatrix", "646025SIpUOG", "2046vYgJGX", "相机位置z", "layers", "zoom", "相机位置x", "fov", "near", "6886368qaFbRP", "8zxlZxo", "193307cRsFpI", "far"];
  return (_y = function() {
    return i;
  })();
}
function eu(i, e) {
  var t = xy();
  return (eu = function(n, r) {
    return t[n -= 157];
  })(i, e);
}
function xy() {
  var i = ["7363975MmxGRL", "58vUYKPa", "autoRotateSpeed", "enableDamping", "131529WdQESs", "181555lBrSBz", "minDistance", "update", "16951086kYzRPT", "viewAngleList", "dampingFactor", "7ZpSAeX", "283188Auoyel", "name", "add", "panSpeed", "zoomSpeed", "6874878KTNHWY", "最大仰角", "自动旋转速度", "自动旋转", "maxDistance", "20LWydTA", "目标位置x", "set", "autoRotate", "最小距离", "rotateSpeed", "12336088GGjgTk", "maxPolarAngle", "平移速度", "target", "阻尼系数", "目标位置z", "最大距离"];
  return (xy = function() {
    return i;
  })();
}
function tu(i, e) {
  var t = by();
  return (tu = function(n, r) {
    return t[n -= 291];
  })(i, e);
}
function by() {
  var i = ["size", "local", "8qCpZLc", "6207492rZzaTE", "name", "showZ", "showX", "1305280IPeaxi", "1518416nwwgzz", "坐标系", "2524249mcVZgL", "292UwSpVG", "rotate", "显示Z", "translationSnap", "mode", "showY", "22202946EigrFj", "scaleSnap", "space", "add", "显示X", "rotationSnap", "旋转步长", "50628FxkApx", "translate", "缩放步长", "world", "3662490XxlSIx"];
  return (by = function() {
    return i;
  })();
}
function nu(i, e) {
  var t = My();
  return (nu = function(n, r) {
    return t[n -= 195];
  })(i, e);
}
function My() {
  var i = ["min", "51BbmVur", "20634757kevycR", "136540lKhZBj", "686SuCiCr", "name", "216YQJmvx", "214873eRQBWC", "max", "radius", "3787265jEdPrI", "threshold", "strength", "enabled", "泛光半径", "26008zjkglT", "4608GuYxYH", "5800986lWJocd", "泛光强度", "6lzYPMr", "add"];
  return (My = function() {
    return i;
  })();
}
function TR(i, e) {
  var t = As;
  e && (i[t(118)] = e[t(118)], i.edgeStrength = e[t(144)], i[t(153)] = e[t(153)], i.edgeThickness = e.edgeThickness, i[t(124)] = e[t(124)], i.usePatternTexture = e[t(148)], i[t(137)].setHex(e[t(137)]), i[t(126)][t(128)](e.hiddenEdgeColor), function(n, r) {
    var s = As;
    r && (n.blending = r[s(155)], n.blendEquation = r[s(135)], n[s(141)] = r.blendSrc, n[s(132)] = r[s(132)]);
  }(i[t(123)], e.overlayMaterial));
}
function ER(i, e) {
  var t, n, r, s = As;
  return e[s(152)](i, s(118)).name(s(146)), e[s(152)](i, s(144))[s(117)]("轮廓光强度"), e.add(i, "edgeGlow").name(s(131)), e[s(152)](i, s(136))[s(117)](s(120)), e[s(152)](i, s(124))[s(159)](0)[s(143)](5)[s(117)]("轮廓光脉冲周期"), e[s(152)](i, s(148))[s(117)](s(156)), e[s(129)](i[s(137)])[s(117)]("轮廓光颜色"), e.addHexColor(i.hiddenEdgeColor)[s(117)](s(138)), t = i.overlayMaterial, n = e[s(160)](s(157)), r = As, n.open(), n.add(t, r(155), fv)[r(117)]("混合模式")[r(140)]((a) => t[r(155)] = Number(a)), n.add(t, r(135), kC)[r(117)]("混合方程式")[r(140)]((a) => t[r(125)] = Number(a)), n[r(152)](t, r(141), FC)[r(117)](r(142))[r(140)]((a) => t[r(149)] = Number(a)), n[r(152)](t, r(132), BC)[r(117)](r(127))[r(140)]((a) => t[r(119)] = Number(a)), e;
}
function wy() {
  var i = ["enabled", "blendingDst", "轮廓光厚度", "20KMgTqe", "1107600uFANTX", "overlayMaterial", "pulsePeriod", "blendingEquation", "hiddenEdgeColor", "混合目标", "setHex", "addHexColor", "273810npfjGq", "轮廓光辉度", "blendDst", "329028MUivIO", "599517svxlnC", "blendEquation", "edgeThickness", "visibleEdgeColor", "轮廓光隐藏颜色", "6670rNTnxk", "onChange", "blendSrc", "混合源", "max", "edgeStrength", "130453ewGYYg", "轮廓光开启", "332905eSHqou", "usePatternTexture", "blendingSrc", "18GauxRQ", "getHex", "add", "edgeGlow", "35jUlGoy", "blending", "轮廓光纹理开启", "边缘混合", "20702YJufml", "min", "addFolder", "name"];
  return (wy = function() {
    return i;
  })();
}
function As(i, e) {
  var t = wy();
  return (As = function(n, r) {
    return t[n -= 117];
  })(i, e);
}
function iu(i, e) {
  var t = Sy();
  return (iu = function(n, r) {
    return t[n -= 280];
  })(i, e);
}
function Sy() {
  var i = ["11490tpNATT", "275EqMRlt", "resize", "106916UpIDZD", "30460KHVvFi", "name", "1JYvmuI", "18135NcfOLU", "add", "7234887FgCKwr", "1680192ademGe", "multPixel", "1270cPVktO", "1303449kkQuWr", "像素倍数", "81RFgUOj", "enabled"];
  return (Sy = function() {
    return i;
  })();
}
function AR(i) {
  const e = ru;
  if (!i)
    return;
  const { uniforms: t } = i;
  return { enabled: i.enabled, intensity: t[e(162)].value, maskColor: t[e(160)][e(157)][e(166)](), R: t.R[e(157)], sr: t.sr[e(157)] };
}
function ru(i, e) {
  const t = Ty();
  return (ru = function(n, r) {
    return t[n -= 156];
  })(i, e);
}
function Ty() {
  const i = ["3809595EEVXdw", "52144IQRrwR", "354pxyElP", "add", "sr参数", "name", "1688766xsfQhZ", "value", "7WntQHM", "9295614UgsFtf", "maskColor", "2152806edUzkD", "intensity", "14502440ETeRBg", "101872YyeGSw", "1MzEtAP", "getHex", "enabled"];
  return (Ty = function() {
    return i;
  })();
}
function su(i, e) {
  var t = Ey();
  return (su = function(n, r) {
    return t[n -= 495];
  })(i, e);
}
function Ey() {
  var i = ["1000044plNBHQ", "saoBlurDepthCutoff", "2207675tGMjdd", "saoKernelRadius", "params", "saoBlur", "10818968TkZWmM", "saoBlurStdDev", "1sckYYQ", "add", "模糊标准差", "最小分辨率", "908559IkDQhx", "13508HHsPTK", "28fDUtiQ", "10USKrev", "name", "2307178YBGfsp", "15yXrpgV", "saoBlurRadius", "9528jMNokE", "saoScale", "1446306FbFoNc", "saoBias", "saoMinResolution", "enabled", "saoIntensity"];
  return (Ey = function() {
    return i;
  })();
}
function au(i, e) {
  var t = Ay();
  return (au = function(n, r) {
    return t[n -= 322];
  })(i, e);
}
function Ay() {
  var i = ["opacity", "bouncing", "131272OFOqEH", "infiniteThick", "fresnel", "3258vOVWAK", "thickness", "558qgfVJT", "distanceAttenuation", "开启屏幕空间反射", "4MCauVw", "enabled", "37369ayrYGg", "add", "透明度", "1736000YzuXqC", "距离衰减", "无限厚度", "2LJpBcy", "1882833UrXOXZ", "12kvEmlx", "name", "maxDistance", "6440StpGYF", "33140415qlPwqi", "2339965HvoHSt"];
  return (Ay = function() {
    return i;
  })();
}
function IR(i) {
  const e = ou, { saoPass: t, unrealBloomPass: n, ssrPass: r, outlinePass: s, fxaaPass: a, screenMaskPass: o } = i[e(151)];
  return { renderWay: i[e(169)], saoPass: (g = t, _ = su, { enabled: g[_(501)], saoBias: g[_(507)][_(499)], saoIntensity: g[_(507)].saoIntensity, saoScale: g[_(507)].saoScale, saoKernelRadius: g[_(507)][_(506)], saoMinResolution: g[_(507)].saoMinResolution, saoBlur: g[_(507)][_(508)], saoBlurRadius: g[_(507)][_(495)], saoBlurStdDev: g[_(507)][_(510)], saoBlurDepthCutoff: g.params.saoBlurDepthCutoff }), unrealBloomPass: (m = n, y = nu, { enabled: m[y(195)], strength: m.strength, radius: m[y(212)], threshold: m[y(214)] }), ssrPass: (f = r, v = au, { enabled: f[v(337)], maxDistance: f[v(322)], distanceAttenuation: f.distanceAttenuation, opacity: f[v(326)], thickness: f.thickness, fresnel: f.fresnel, infiniteThick: f[v(329)], bouncing: f[v(327)] }), outlinePass: (h = s, p = As, { enabled: h.enabled, edgeStrength: h[p(144)], edgeGlow: h[p(153)], edgeThickness: h[p(136)], pulsePeriod: h[p(124)], usePatternTexture: h[p(148)], visibleEdgeColor: h[p(137)].getHex(), hiddenEdgeColor: h[p(126)][p(151)](), overlayMaterial: (u = h.overlayMaterial, d = As, { blending: u[d(155)], blendEquation: u[d(135)], blendSrc: u[d(141)], blendDst: u[d(132)] }) }), fxaaPass: (l = a, c = iu, { enabled: l[c(281)], multPixel: l[c(293)] }), screenMaskPass: AR(o) };
  var l, c, h, u, d, p, f, v, m, y, g, _;
}
function CR(i, e) {
  const t = ou;
  if (!e)
    return;
  const { saoPass: n, unrealBloomPass: r, ssrPass: s, outlinePass: a, fxaaPass: o, screenMaskPass: l } = i[t(151)];
  var c, h, u, d, p, f, v, m, y, g, _, x;
  i[t(178)](e[t(169)]), g = n, _ = e.saoPass, x = su, _ && (g[x(501)] = _[x(501)], g[x(507)][x(499)] = _[x(499)], g[x(507)][x(502)] = _[x(502)], g[x(507)][x(497)] = _[x(497)], g.params[x(506)] = _.saoKernelRadius, g[x(507)][x(500)] = _[x(500)], g[x(507)].saoBlur = _[x(508)], g[x(507)][x(495)] = _[x(495)], g[x(507)][x(510)] = _[x(510)], g.params.saoBlurDepthCutoff = _[x(504)]), v = r, m = e[t(161)], y = nu, m && (v[y(195)] = m[y(195)], v[y(215)] = m[y(215)], v[y(212)] = m[y(212)], v[y(214)] = m[y(214)]), d = s, p = e[t(167)], f = au, p && (d[f(337)] = p[f(337)], d[f(322)] = p[f(322)], d[f(334)] = p.distanceAttenuation, d[f(326)] = p[f(326)], d.thickness = p[f(332)], d[f(330)] = p[f(330)], d[f(329)] = p[f(329)], d[f(327)] = p[f(327)]), TR(a, e.outlinePass), c = o, h = e.fxaaPass, u = iu, h && (c[u(281)] = h[u(281)], c[u(293)] != h[u(293)] && (c[u(293)] = h[u(293)], c[u(284)]())), function(M, b) {
    const w = ru;
    if (!M)
      return;
    const { uniforms: T } = M;
    b && (M.enabled = b[w(167)], T[w(162)][w(157)] = b[w(162)], T.maskColor.value.set(b[w(160)]), T.R[w(157)] = b.R, T.sr[w(157)] = b.sr);
  }(l, e[t(164)]);
}
function ou(i, e) {
  const t = Iy();
  return (ou = function(n, r) {
    return t[n -= 151];
  })(i, e);
}
function Iy() {
  const i = ["屏幕遮罩配置", "12RDHhyh", "screenMaskPass", "2393860pAcZyk", "5SxraTR", "ssrPass", "3028475jbqkEt", "renderWay", "add", "泛光配置", "轮廓光配置", "15039ViVCxB", "抗锯齿配置", "name", "屏幕空间反射配置", "效果渲染", "setRenderWay", "effectPass", "渲染方式", "环境光遮蔽配置", "10336830uhdwhS", "panels", "5151559RWNWTu", "addDragFolder", "5016rgrLgG", "552842aQxVOP", "3516120EGxKrd", "unrealBloomPass"];
  return (Iy = function() {
    return i;
  })();
}
function RR(i, e) {
  const t = ou, { saoPass: n, unrealBloomPass: r, ssrPass: s, outlinePass: a, fxaaPass: o, screenMaskPass: l } = i[t(151)];
  e[t(170)](i, t(169), ["源渲染", t(177)])[t(175)](t(152)).onChange((h) => i[t(178)](h));
  const c = { 环境光遮蔽配置: () => {
    return h = n, (u = e[t(157)](t(153)))[(d = su)(512)](h, d(501))[d(519)]("启用"), u[d(512)](h.params, d(499))[d(519)]("偏移"), u[d(512)](h[d(507)], d(502))[d(519)]("强度"), u[d(512)](h[d(507)], d(497), 0)[d(519)]("缩放"), u.add(h[d(507)], d(506), 0)[d(519)]("半径"), u[d(512)](h[d(507)], d(500), 0).name(d(514)), u.add(h[d(507)], "saoBlur")[d(519)]("模糊"), u[d(512)](h[d(507)], d(495), 0)[d(519)]("模糊半径"), u[d(512)](h[d(507)], "saoBlurStdDev")[d(519)](d(513)), u[d(512)](h[d(507)], "saoBlurDepthCutoff")[d(519)]("模糊深度截断"), u;
    var h, u, d;
  }, 泛光配置: () => {
    return h = r, u = e.addDragFolder(t(171)), d = nu, u.add(h, d(195))[d(208)]("泛光开启"), u[d(202)](h, d(215))[d(203)](0)[d(211)](3).name(d(200)), u.add(h, d(212))[d(203)](0)[d(211)](1)[d(208)](d(196)), u.add(h, d(214))[d(203)](0)[d(211)](1)[d(208)]("泛光阈值"), u;
    var h, u, d;
  }, 屏幕空间反射配置: () => {
    return h = s, (u = e[t(157)](t(176)))[(d = au)(339)](h, "enabled")[d(347)](d(335)), u[d(339)](h, d(322))[d(347)]("最大距离"), u[d(339)](h, "distanceAttenuation").name(d(342)), u[d(339)](h, d(326)).name(d(340)), u.add(h, d(332))[d(347)]("厚度"), u.add(h, d(330))[d(347)]("菲涅尔"), u.add(h, d(329))[d(347)](d(343)), u[d(339)](h, d(327))[d(347)]("反弹"), u;
    var h, u, d;
  }, 轮廓光配置: () => ER(a, e[t(157)](t(172))), 抗锯齿配置: () => {
    return h = o, (u = e[t(157)](t(174)))[(d = iu)(290)](h, d(281))[d(287)]("开启"), u[d(290)](h, d(293))[d(287)](d(296)).onChange(h[d(284)]), u;
    var h, u, d;
  }, 屏幕遮罩配置: () => function(h, u) {
    const d = ru, { uniforms: p } = h;
    return u[d(171)](h, d(167)).name("启用"), u.addHexColor(p[d(160)][d(157)])[d(173)]("颜色"), u.add(p[d(162)], "value").name("强度"), u.add(p.R, "value")[d(173)]("半径"), u.add(p.sr, d(157)).name(d(172)), u;
  }(l, e.addDragFolder(t(162))) };
  for (const h in c)
    e[t(170)](c, h);
  return e[t(155)] = c, e;
}
function Af(i, e) {
  const t = Cy();
  return (Af = function(n, r) {
    return t[n -= 153];
  })(i, e);
}
function Cy() {
  const i = ["后期处理", "33QSmMjD", "50336Jfdgtq", "webglRenderer", "39gczZpC", "addDragFolder", "环境配置", "2372040MCwNzN", "6cHSXAr", "1404bGJKMJ", "effectComposer", "43644yrVaBx", "相机配置", "1798370ZQdxss", "7694tfhOOI", "orbitControls", "233115gnUxNd", "496601QBMhgP", "perspectiveCamera", "transformControls", "9fpbCgg", "8wRxfUP"];
  return (Cy = function() {
    return i;
  })();
}
function PR(i, e, t, n, r, s) {
  return { scene: bR(i), perspectiveCamera: SR(e), webglRenderer: vR(t), orbitControls: (l = n, c = eu, { maxPolarAngle: l[c(174)], autoRotate: l.autoRotate, autoRotateSpeed: l[c(182)], rotateSpeed: l[c(172)], panSpeed: l[c(160)], zoomSpeed: l[c(161)], enableDamping: l.enableDamping, dampingFactor: l.dampingFactor, minDistance: l.minDistance, maxDistance: l[c(166)], target: { x: l[c(176)].x, y: l[c(176)].y, z: l[c(176)].z }, viewAngleList: l[c(189)] }), transformControls: (a = r, o = tu, { mode: a[o(299)], space: a.space, size: a[o(313)], showX: a[o(319)], showY: a[o(300)], showZ: a[o(318)], translationSnap: a[o(298)], rotationSnap: a[o(306)], scaleSnap: a[o(302)] }), effectComposer: IR(s) };
  var a, o, l, c;
}
function LR(i, e, t, n, r, s, a) {
  const o = Af;
  var l, c, h, u, d, p;
  a && (yR(t, a[o(160)]), CR(s, a[o(167)]), MR(i, a.scene), function(f, v) {
    const m = $h;
    v && (f[m(206)] = v.fov, f.near = v[m(207)], f.far = v.far, f.zoom = v[m(204)], f[m(187)].set(v[m(187)].x, v[m(187)].y, v[m(187)].z), Bv(f[m(203)], v[m(203)]), f[m(199)]());
  }(e, a[o(153)]), u = n, d = a[o(172)], p = eu, d && (u[p(174)] = d.maxPolarAngle, u.autoRotate = d[p(170)], u[p(182)] = d[p(182)], u[p(172)] = d[p(172)], u[p(160)] = d[p(160)], u[p(161)] = d[p(161)], u[p(183)] = d[p(183)], u[p(190)] = d[p(190)], u[p(186)] = d[p(186)], u[p(166)] = d[p(166)], u.target[p(169)](d.target.x, d[p(176)].y, d.target.z), u[p(189)] = d[p(189)], u[p(187)]()), l = r, c = a[o(154)], h = tu, c && (l[h(299)] = c[h(299)], l[h(303)] = c[h(303)], l[h(313)] = c.size, l.showX = c.showX, l[h(300)] = c[h(300)], l.showZ = c.showZ, l[h(298)] = c[h(298)], l[h(306)] = c[h(306)], l[h(302)] = c[h(302)]));
}
function DR(i, e, t, n, r, s, a) {
  const o = Af, l = { 渲染配置: () => function(c, h) {
    const u = ti;
    return h.addColor({ color: c.getClearColor(new W[u(152)]())[u(153)]() }, u(166))[u(137)]((d) => c[u(144)](d, c[u(172)]())).name(u(154)), h[u(168)]({ opacity: c[u(172)]() }, "opacity")[u(151)](0).max(1)[u(137)]((d) => c[u(147)](d))[u(136)](u(155)), h[u(168)](c, u(146), [yt, W[u(173)]])[u(136)](u(164)), h[u(168)](c, u(135), mR)[u(136)](u(157))[u(137)]((d) => c[u(135)] = Number(d)), h[u(168)](c, "toneMappingExposure").min(0)[u(165)](50)[u(136)]("色调映射曝光度"), h[u(168)](c.shadowMap, "enabled")[u(136)](u(148)), h[u(168)](c[u(134)], u(169), gR)[u(136)](u(161))[u(137)]((d) => c[u(134)][u(169)] = Number(d)), h[u(168)](c, u(139))[u(136)](u(140)), h[u(168)](c, u(138))[u(136)]("裁剪"), h;
  }(t, a[o(162)]("渲染配置")), 相机配置: () => function(c, h) {
    const u = $h, d = () => c[u(199)]();
    return zv(c[u(203)], h), h[u(191)](c, "fov")[u(192)](0)[u(193)]("视角")[u(196)](d), h[u(191)](c, u(207))[u(192)](1e-3)[u(193)]("近平面")[u(196)](d), h[u(191)](c, "far")[u(192)](0).name("远平面")[u(196)](d), h[u(191)](c, "zoom")[u(192)](0).name("缩放")[u(196)](d), h[u(191)](c[u(187)], "x").name(u(205)), h.add(c[u(187)], "y").name(u(194)), h[u(191)](c[u(187)], "z")[u(193)](u(202)), h;
  }(e, a.addDragFolder(o(169))), 轨道配置: () => {
    return c = n, h = a[o(162)]("轨道配置"), u = eu, h.add(c, u(170)).name(u(165)), h[u(159)](c, u(182), 0, 10).name(u(164)), h[u(159)](c, u(183)).name("阻尼"), h[u(159)](c, u(190), 0, 1).name(u(177)), h[u(159)](c, u(186), 0)[u(158)](u(171)), h[u(159)](c, "maxDistance", 0)[u(158)](u(179)), h[u(159)](c, u(174), 0, 2 * Math.PI)[u(158)](u(163)), h.add(c, u(172))[u(158)]("旋转速度"), h.add(c, u(160))[u(158)](u(175)), h[u(159)](c, u(161))[u(158)]("缩放速度"), h[u(159)](c[u(176)], "x")[u(158)](u(168)), h.add(c[u(176)], "y")[u(158)]("目标位置y"), h[u(159)](c[u(176)], "z")[u(158)](u(178)), h;
    var c, h, u;
  }, 变换配置: () => {
    return c = r, h = a[o(162)]("变换配置"), u = tu, h.add(c, u(299), { 平移: u(309), 旋转: u(296), 缩放: "scale" })[u(317)]("模式"), h[u(304)](c, "space", { 局部: u(314), 世界: u(311) })[u(317)](u(293)), h.add(c, u(313))[u(317)]("大小"), h[u(304)](c, u(319))[u(317)](u(305)), h[u(304)](c, u(300)).name("显示Y"), h[u(304)](c, u(318))[u(317)](u(297)), !c[u(306)] && (c.rotationSnap = 0), !c[u(298)] && (c[u(298)] = 0), !c[u(302)] && (c.scaleSnap = 0), h[u(304)](c, u(298))[u(317)]("平移步长"), h[u(304)](c, u(306))[u(317)](u(307)), h.add(c, "scaleSnap")[u(317)](u(310)), h;
    var c, h, u;
  }, 环境配置: () => wR(i, a[o(162)](o(163))), 后期处理: () => RR(s, a[o(162)](o(157))) };
  for (const c in l)
    a.add(l, c);
  return { folder: a, panels: l };
}
function Ry(i, e) {
  const t = Py();
  return (Ry = function(n, r) {
    return t[n -= 298];
  })(i, e);
}
function Py() {
  const i = ["__controllers", "addFolder", "syncTransformList", "removeFolder", "setFn", "recordModel", "axies", "108200hiFxFx", "onChange", "11pqoLDK", "resetFn", "21102850IIOEvy", "7573692pjVCYH", "step", "rotation", "copy", "模型id", "position", "set", "currentInfo", "#记录根选择模型信息", "add", "同步变换列表", "length", "scale", "4BnoOjI", "686714UdhceN", "forEach", "oldPosition", "333uPcxTS", "列表变换同步操作", "visible", "oldRotation", "选中模型旋转与记录同步", "splice", "1199431jmiesm", "记录信息", "7558195UjPJyK", "4293594kAixBd", "旋转控制", "syncTransformFn", "push", "name", "旋转轴", "indexOf", "7xZOSYt", "recordFn", "open", "旋转角度", "#加入同步变换列表", "currentRootModel", "addFn"];
  return (Py = function() {
    return i;
  })();
}
function If(i, e) {
  const t = Ly();
  return (If = function(n, r) {
    return t[n -= 189];
  })(i, e);
}
function Ly() {
  const i = ["18tLdWKV", "object", "drag_change_callback", "469737XCWcaZ", "400090kjOjfR", "transform", "32bhFnjS", "index", "4933bbDnmD", "246FCOTxg", "9186740cNVfdH", "push", "935466KEDbUV", "269184hNApNL", "2618488OkurzN"];
  return (Ly = function() {
    return i;
  })();
}
function zb(i, e) {
  const t = If, { list: n, reList: r, index: s } = i;
  if (e === "z") {
    const a = n.at(s);
    a && (Dp(a[t(193)], a[t(197)]), i[t(199)] -= 1);
  } else if (e === "y") {
    if (s === -1)
      return;
    const a = r.at(s + 1);
    a && (Dp(a.object, a[t(197)]), i.index += 1);
  }
}
function Ph(i, e) {
  const t = Dy();
  return (Ph = function(n, r) {
    return t[n -= 140];
  })(i, e);
}
function Dy() {
  const i = ["Delete", "79125PSKWXH", "remove", "selectedObjects", "rotate", "805KWgrTx", "local", "2542200nvSFOV", "scale", "setMode", "9yrMCIR", "keyDownCallback", "场景绘制", "77vXyAWL", "tagName", "visible", "detach", "handlerHistory", "Escape", "ctrlKey", "INPUT", "isTransformChildren", "208YUBmIy", "world", "translate", "根选择", "Scene", "parent", "1186188KLETCE", "position", "outlinePass", "Tab", "3035hnkvla", "key", "target", "attach", "object", "currentModel", "preventDefault", "currentInfo", "shiftKey", "点击信息", "currentRootModel", "1698LelmCJ", "3HujDll", "3284020mjdGmo", "transformControls", "mode", "type", "rotation", "149092cPzUij"];
  return (Dy = function() {
    return i;
  })();
}
function cg(i, e, t) {
  const n = Ph;
  if (!i[n(150)] || i[n(158)] !== "变换")
    return;
  const { object: r } = i[n(157)];
  r[n(160)][e] += t * Math.PI / 180;
}
function Ya(i, e) {
  const t = Ny();
  return (Ya = function(n, r) {
    return t[n -= 425];
  })(i, e);
}
function NR(i) {
  const e = Ya;
  return { showAxes: i[e(449)], axesLength: i[e(429)] };
}
function Lh(i, e) {
  const t = Ya;
  e[t(443)] && (i[t(427)](e[t(443)]), e.axesHelper[t(431)][t(441)](), e[t(443)][t(426)][t(441)](), e[t(443)] = null), e[t(449)] && (e[t(443)] = function(n = 1e3) {
    const r = Ya, s = new W[r(425)](n);
    return s[r(444)] = r(425), s;
  }(e[t(429)]), i[t(448)](e[t(443)]));
}
function Ny() {
  const i = ["49YgKzRe", "37197hIUARK", "2231220oqyRiw", "226055efsXur", "15233OsWdoZ", "onChange", "dispose", "24652TeyBTF", "axesHelper", "name", "825JuWVXn", "onFinishChange", "908418ylRQkx", "add", "showAxes", "AxesHelper", "material", "remove", "142pBBJAy", "axesLength", "608Qnfuaz", "geometry", "listen", "79410CNwPdF", "519txULPr"];
  return (Ny = function() {
    return i;
  })();
}
function OR(i) {
  const e = Za;
  return { showGrid: i[e(453)], size: i[e(461)], divisions: i.divisions, colorCenterLine: i[e(445)], colorGrid: i[e(443)] };
}
function rs(i, e) {
  const t = Za;
  e[t(451)] && (i.remove(e[t(451)]), e[t(451)][t(456)][t(454)](), e[t(451)][t(448)].dispose(), e[t(451)] = null), e[t(453)] && (e[t(451)] = function(n = 1e3, r = 15, s = 4473924, a = 8947848) {
    const o = Za, l = new W[o(471)](n, r, s, a);
    return l[o(465)] = "GridHelper", l;
  }(e[t(461)], e[t(444)], e.colorCenterLine, e.colorGrid), i[t(472)](e[t(451)]));
}
function Za(i, e) {
  const t = Oy();
  return (Za = function(n, r) {
    return t[n -= 443];
  })(i, e);
}
function Oy() {
  const i = ["onFinishChange", "addColor", "material", "57GYfrCn", "1628368JBAVWk", "gridHelper", "3495024iiXggL", "showGrid", "dispose", "listen", "geometry", "12712qQXiGN", "min", "368279TWrUfK", "5753055rFxuSr", "size", "onChange", "显示网格", "6072032gFzBcO", "name", "2414025XsbFiA", "27CGvKmR", "中心线颜色", "分割数", "网格颜色", "GridHelper", "add", "open", "colorGrid", "divisions", "colorCenterLine"];
  return (Oy = function() {
    return i;
  })();
}
function Uy() {
  const i = ["useBox3", "object", "27744CQZNUs", "remove", "2222024mQhAsl", "2lqMFwi", "box3Helper", "dispose", "321OsmTrE", "visible", "open", "setFromObject", "onFinishChange", "addColor", "369505lQOBzL", "geometry", "使用Box3", "7RWCghf", "5977014rfYdxt", "color", "box", "1754990sFOPqF", "Box3", "6439302zUaTga", "Box3Helper", "onChange", "49987630EBSLTR", "name"];
  return (Uy = function() {
    return i;
  })();
}
function Tl(i, e) {
  const t = Uy();
  return (Tl = function(n, r) {
    return t[n -= 230];
  })(i, e);
}
function X0(i, e, t) {
  const n = Tl;
  e.box3Helper && (i[n(248)](e[n(251)]), e[n(251)][n(232)][n(252)](), e.box3Helper.material[n(252)](), e.box3Helper = null), t.useBox3 && (e[n(251)] = function(r = 16776960) {
    const s = Tl, a = new W[s(239)](), o = new _w(a, r);
    return o[s(244)] = s(241), o[s(254)] = !1, o;
  }(t.color), i.add(e[n(251)]), e[n(246)] && (e.box3Helper[n(237)] = new W[n(239)]()[n(256)](e[n(246)]), e[n(251)][n(254)] = !0));
}
function UR(i) {
  const e = lu;
  return { axes: NR(i[e(325)]), grid: OR(i[e(314)]), box3: (t = i[e(327)], { useBox3: t.useBox3, color: t.color }) };
  var t;
}
function kR(i, e, t, n) {
  const r = lu;
  n && (function(s, a, o) {
    const l = Ya;
    o && (a[l(449)] = o[l(449)], a[l(429)] = o[l(429)], Lh(s, a));
  }(i, t[r(325)], n.axes), function(s, a, o) {
    const l = Za;
    o && (a.showGrid = o.showGrid, a[l(461)] = o[l(461)], a[l(444)] = o[l(444)], a.colorCenterLine = o.colorCenterLine, a.colorGrid = o.colorGrid, rs(s, a));
  }(i, t[r(314)], n[r(314)]), function(s, a, o, l) {
    const c = Tl;
    l && (o[c(245)] = l[c(245)], o[c(236)] = l[c(236)], X0(s, a, o));
  }(i, e, t[r(327)], n[r(327)]));
}
function ky() {
  const i = ["2qBcsMp", "axes", "219933FzuxMe", "box3", "addFolder", "grid", "坐标轴", "4HNtNEe", "10iOodYj", "815312OELpfr", "2860OXjcKm", "332646VnYCUi", "93380zhamcl", "339831lGPlvI", "781743KbwtlT"];
  return (ky = function() {
    return i;
  })();
}
function lu(i, e) {
  const t = ky();
  return (lu = function(n, r) {
    return t[n -= 314];
  })(i, e);
}
function FR(i, e, t, n) {
  const r = lu, { axes: s, grid: a, box3: o } = t;
  return function(l, c, h, u) {
    const d = Tl;
    u[d(255)](), u.add(h, "useBox3")[d(244)](d(233)).listen()[d(242)](() => X0(l, c, h)), u[d(230)](h, d(236)).name("颜色")[d(257)](() => X0(l, c, h));
  }(i, e, o, n[r(328)]("Box3")), function(l, c, h) {
    const u = Za;
    h[u(473)](), h[u(472)](c, u(453))[u(465)](u(463))[u(455)]()[u(462)](() => rs(l, c)), h[u(472)](c, u(461))[u(465)]("大小")[u(446)](() => rs(l, c))[u(458)](1), h[u(472)](c, "divisions").name(u(469))[u(446)](() => rs(l, c)).min(1), h[u(447)](c, u(445)).name(u(468))[u(446)](() => rs(l, c)), h.addColor(c, u(443))[u(465)](u(470))[u(446)](() => rs(l, c));
  }(i, a, n[r(328)]("网格")), function(l, c, h) {
    const u = Ya;
    h.open(), h[u(448)](c, u(449))[u(444)]("显示坐标轴")[u(432)]()[u(440)](() => Lh(l, c)), h.add(c, u(429))[u(444)]("长度")[u(446)](() => Lh(l, c));
  }(i, s, n.addFolder(r(315))), n;
}
function BR(i) {
  const { showStats: e, statsMode: t } = i;
  return { showStats: e, statsMode: t };
}
function Fy() {
  const i = ["470CcTLmq", "547723zXCPVf", "listen", "190HRPKGs", "add", "statsMode", "98IspQIT", "created", "763452ojGFbI", "setMode", "7eppKiN", "onChange", "654cIJvLb", "name", "2360952yuKGXg", "11733eQhzBz", "105719eKsBDe", "showStats", "2843235cCbZil"];
  return (Fy = function() {
    return i;
  })();
}
function cu(i, e) {
  const t = Fy();
  return (cu = function(n, r) {
    return t[n -= 367];
  })(i, e);
}
function Fp(i) {
  const e = cu;
  i[e(375)] ? (i[e(384)](), i[e(367)](Number(i[e(382)]))) : i.destroy();
}
function By() {
  const i = ["grid", "辅助工具", "add", "handlerHistory", "386721PJgMDR", "selectPanelEnable", "keyDown", "7860740yMpOqc", "addDragFolder", "性能监控", "transformControls", "listen", "730skDBej", "1580892JjkpNB", "2476lCNSoa", "1541428vWKfUH", "showAxes", "showGrid", "根选择", "stats", "showStats", "helpers", "子变换", "6495JFNbDT", "同步控制", "keydown", "axes", "isTransformChildren", "name", "openKey", "6161304RDhiVq", "setHandlerOption", "mode", "outlinePass", "8KLEdhZ", "2776mayzQl", "点击信息"];
  return (By = function() {
    return i;
  })();
}
function eo(i, e) {
  const t = By();
  return (eo = function(n, r) {
    return t[n -= 370];
  })(i, e);
}
function zR() {
  const i = eo;
  return { mode: "选择", openKey: !1, selectPanelEnable: !1, keyDown: null, keyDownCallback: null, modeList: ["选择", i(376), "变换", "场景绘制", i(394)], isTransformChildren: !1, handlerHistory: null, helpers: { axes: { showAxes: !0, axesLength: 1e3, axesHelper: null }, grid: { showGrid: !0, size: 1e3, divisions: 15, colorCenterLine: 4473924, colorGrid: 8947848, gridHelper: null }, box3: { useBox3: !0, color: 16776960 } } };
}
function HR(i, e, t, n, r) {
  const s = eo;
  t[s(405)] = n, t[s(391)] = r, t.stats = e, t.keyDown = /* @__PURE__ */ function(a, o) {
    function l(c, h) {
      const u = Ph;
      if (!o[u(147)])
        return;
      const d = o[u(147)];
      switch (o[u(158)]) {
        case u(186):
          d[u(140)][c] += h;
          break;
        case u(170):
          d[u(170)][c] += 1e-3 * h * d[u(170)][c];
          break;
        case u(166):
          d[u(160)][c] += h * Math.PI / 360;
      }
    }
    return function(c) {
      var u, d, p;
      const h = Ph;
      if (c[h(145)][h(176)] !== h(182) && !c[h(181)]) {
        switch (c[h(144)]) {
          case "1":
            a[h(158)] = "选择";
            break;
          case "2":
            a[h(158)] = h(187);
            break;
          case "3":
            a.mode = "变换";
            break;
          case "4":
            a[h(158)] = h(174);
            break;
          case "5":
            a[h(158)] = h(152);
            break;
          case h(142):
            const { currentInfo: f } = a;
            f && (a[h(158)] === "选择" ? o.attach(f[h(148)]) : a.mode === "根选择" ? o[h(146)](f[h(153)]) : a[h(158)] === "变换" && (c[h(149)](), c[h(151)] ? o.setSpace(o.space === h(168) ? h(185) : h(168)) : (a[h(183)] = !a[h(183)], o[h(178)]())));
            break;
          case h(162):
            if (!a[h(150)])
              break;
            const { currentModel: v, currentRootModel: m } = a.currentInfo;
            if (a.mode === "选择" && v)
              (v == null ? void 0 : v.parent[h(159)]) === h(188) ? v[h(189)][h(164)](v) : v[h(177)] = !1;
            else if (a[h(158)] === h(187) && m)
              (u = m[h(189)]) == null || u[h(164)](m);
            else if (a.mode === "变换" && m && !a[h(183)]) {
              const y = o[h(147)] || m;
              (d = y[h(189)]) == null || d[h(164)](y);
            } else
              a[h(158)] === "变换" && v && a[h(183)] && (v[h(177)] = !1);
            break;
          case "g":
            o[h(171)](h(186));
            break;
          case "t":
            o[h(171)]("scale");
            break;
          case "r":
            o.setMode("rotate");
            break;
          case "w":
            l("y", 1);
            break;
          case "s":
            l("y", -1);
            break;
          case "a":
            l("x", -1);
            break;
          case "d":
            l("x", 1);
            break;
          case "q":
            l("z", 1);
            break;
          case "e":
            l("z", -1);
            break;
          case "z":
            zb(a[h(179)], "z");
            break;
          case "y":
            zb(a[h(179)], "y");
            break;
          case "X":
            cg(a, "x", 90);
            break;
          case "Y":
            cg(a, "y", 90);
            break;
          case "Z":
            cg(a, "z", 90);
            break;
          case h(180):
            a[h(141)][h(165)] = [];
        }
        (p = a[h(173)]) == null || p.call(a, c.key);
      }
    };
  }(t, n), Lh(i, t[s(379)][s(384)]), rs(i, t[s(379)].grid), t.keyDownCallback = () => {
  }, t[s(389)] = (a, o) => {
    const l = s;
    switch (a) {
      case l(377):
        e[l(378)] = o, Fp(e);
        break;
      case l(384):
        t[l(379)][l(384)][l(374)] = o, Lh(i, t[l(379)][l(384)]);
        break;
      case l(395):
        t[l(379)][l(395)][l(375)] = o, rs(i, t[l(379)][l(395)]);
        break;
      case "openKey":
        t[l(387)] = o, zy(t[l(401)], o);
    }
  }, t[s(398)] = function(a) {
    const o = If, l = { list: [], reList: [], index: -1 };
    return a[o(194)] = function(c) {
      const h = o;
      l[h(199)] = -1;
      const { list: u, reList: d } = l, { object: p } = a;
      c ? u[h(203)]({ object: p, transform: Xo(p) }) : d[h(203)]({ object: p, transform: Xo(p) });
    }, l;
  }(n);
}
function GR(i) {
  const { mode: e, openKey: t, selectPanelEnable: n, isTransformChildren: r, stats: s, helpers: a } = i;
  return { mode: e, openKey: t, selectPanelEnable: n, isTransformChildren: r, stats: BR(s), helpers: UR(a) };
}
function VR(i, e, t, n, r) {
  const s = eo;
  r && (n[s(390)] = r[s(390)], n.openKey = r[s(387)], n[s(400)] = r[s(400)], r.openKey && zy(n[s(401)], r[s(387)]), n.isTransformChildren = r[s(385)], function(a, o) {
    const l = cu;
    if (!o)
      return;
    const { showStats: c, statsMode: h } = o;
    a[l(375)] = c, a[l(382)] = h, Fp(a);
  }(t, r[s(377)]), kR(i, e, n[s(379)], r[s(379)]));
}
function jR(i, e, t, n, r) {
  const s = eo, { helpers: a } = n;
  r.add(n, s(390), n.modeList)[s(386)]("模式")[s(406)](), r[s(397)](n, s(385))[s(386)](s(380))[s(406)](), r[s(397)](n, s(400))[s(386)]("选择弹窗").listen(), r[s(397)](n, s(387))[s(386)]("开启按键")[s(406)]().onChange((l) => zy(n[s(401)], l));
  const o = { 同步控制: () => function(l, c) {
    const h = Ry, u = c.addFolder(h(310));
    u[h(318)]();
    const d = { axies: "x", rotation: 0, resetFn() {
      var _, x, M;
      const g = h;
      (M = (x = (_ = l[g(342)]) == null ? void 0 : _[g(321)]) == null ? void 0 : x.rotation) == null || M[g(341)](0, 0, 0);
    }, setFn() {
      var _;
      const g = h;
      (_ = l.currentInfo) != null && _[g(321)] && (l.currentInfo[g(321)][g(337)][this[g(329)]] += this[g(337)] / 180 * Math.PI);
    } };
    u[h(344)](d, h(329), ["x", "y", "z"])[h(313)](h(314)), u[h(344)](d, h(337))[h(313)](h(319)), u[h(344)](d, h(333)).name("旋转归零"), u[h(344)](d, h(327)).name("应用");
    const p = c.addFolder(h(307)), f = { recordModel: null, recordFn() {
      var _;
      const g = h;
      for (this[g(328)] = (_ = l[g(342)]) == null ? void 0 : _[g(321)]; p[g(323)][g(346)] > 0; )
        p[g(323)][0].remove();
      this[g(328)] && (p[g(318)](), p[g(344)](this[g(328)], g(302))[g(313)]("显示"), p[g(344)](this.recordModel, g(313))[g(313)]("模型名称"), p[g(344)](this[g(328)], "id")[g(313)](g(339)), p[g(322)](() => {
        var x;
        return (x = l[g(342)]) == null ? void 0 : x.currentRootModel[g(340)][g(338)](this[g(328)][g(340)]);
      }).name("选中模型位置与记录同步"), p[g(322)](() => {
        var x;
        return (x = l[g(342)]) == null ? void 0 : x[g(321)][g(337)][g(338)](this.recordModel[g(337)]);
      }).name(g(304)), p[g(322)](() => {
        var x;
        return (x = l[g(342)]) == null ? void 0 : x[g(321)].scale[g(338)](this.recordModel[g(347)]);
      })[g(313)]("选中模型缩放与记录同步"));
    }, syncTransformList: [], syncTransformFn() {
      var _;
      const g = h;
      if ((_ = l[g(342)]) != null && _[g(321)] && this[g(325)][g(315)](l.currentInfo.currentRootModel) === -1) {
        v[g(318)]();
        const x = l.currentInfo[g(321)];
        this.syncTransformList[g(312)](x);
        const M = v.addDateFolder(x.id);
        M.add(x, "visible")[g(313)]("显示"), M[g(322)](() => {
          const b = g, w = this[b(325)][b(315)](x);
          w > -1 && this[b(325)][b(305)](w, 1), v[b(326)](M);
        }).name("移除同步变换列表");
      }
    } };
    c[h(344)](f, h(317))[h(313)](h(343));
    const v = c.addFolder(h(345));
    c.add(f, h(311))[h(313)](h(320));
    const m = v[h(324)](h(301)), y = { position: { x: 0, y: 0, z: 0 }, rotation: { x: 0, y: 0, z: 0 }, scale: { x: 0, y: 0, z: 0 }, oldPosition: { x: 0, y: 0, z: 0 }, oldRotation: { x: 0, y: 0, z: 0 }, oldScale: { x: 0, y: 0, z: 0 } };
    return ["x", "y", "z"].forEach((g) => m[h(344)](y[h(340)], g)[h(313)]("位置" + g)[h(331)]((_) => {
      const x = h;
      f.syncTransformList[x(298)]((M) => M[x(340)][g] += _ - y.oldPosition[g]), y[x(299)][g] = _;
    })), ["x", "y", "z"][h(298)]((g) => m[h(344)](y[h(337)], g, -2 * Math.PI, 2 * Math.PI)[h(313)]("旋转" + g)[h(331)]((_) => {
      const x = h;
      f[x(325)][x(298)]((M) => M[x(337)][g] += _ - y[x(303)][g]), y[x(303)][g] = _;
    })), ["x", "y", "z"][h(298)]((g) => m[h(344)](y[h(347)], g)[h(336)](0.01)[h(313)]("缩放" + g)[h(331)]((_) => {
      const x = h;
      f.syncTransformList[x(298)]((M) => M[x(347)][g] += M[x(347)][g] * (_ - y.oldScale[g])), y.oldScale[g] = _;
    })), c;
  }(n, r[s(403)](s(382))), 性能监控: () => function(l, c) {
    const h = cu;
    return c[h(381)](l, h(375))[h(371)]("开启").listen()[h(369)](() => Fp(l)), c[h(381)](l, h(382), { fps: 0, ms: 1, mb: 2 })[h(371)]("模式")[h(379)]()[h(369)](() => Fp(l)), c;
  }(t, r.addDragFolder(s(404))), 辅助工具: () => FR(i, e, a, r[s(403)](s(396))) };
  for (const l in o)
    r[s(397)](o, l);
  return { folder: r, panels: o };
}
function zy(i, e) {
  const t = eo;
  e ? document.addEventListener(t(383), i) : document.removeEventListener(t(383), i);
}
function hu(i, e) {
  const t = Hy();
  return (hu = function(n, r) {
    return t[n -= 339];
  })(i, e);
}
function WR(i) {
  const e = hu;
  if (!i)
    return;
  const { camera: t } = i;
  return { bias: i[e(349)], radius: i[e(347)], mapSize: i.mapSize, normalBias: i.normalBias, camera: t ? { near: t[e(355)], far: t[e(363)], fov: t[e(342)], left: t[e(344)], right: t.right, top: t[e(352)], bottom: t[e(368)] } : null };
}
function Hy() {
  const i = ["3880413jYqlVB", "12403413hlvJNj", "右平面", "远平面", "name", "法线偏移", "add", "far", "onChange", "height", "keys", "forEach", "bottom", "right", "4CvuyEX", "近平面", "1167610dPtHNH", "阴影贴图宽度", "camera", "mapSize", "24DvWSWU", "投影相机", "下平面", "3298795wNfEqM", "normalBias", "fov", "578535ZuAsLV", "left", "10oAoHMd", "3562206LYjOPW", "radius", "3428658iuJSGm", "bias", "updateProjectionMatrix", "阴影贴图高度", "top", "14JUrwSV", "set", "near"];
  return (Hy = function() {
    return i;
  })();
}
function XR(i) {
  var e = uu;
  switch (i[e(380)]) {
    case e(385):
      return { target: { x: i[e(367)].position.x, y: i[e(367)][e(370)].y, z: i[e(367)].position.z } };
    case e(383):
      return { distance: i[e(395)], decay: i[e(393)], power: i.power };
    case e(404):
      return { distance: i[e(395)], decay: i[e(393)], power: i.power, angle: i[e(399)], penumbra: i.penumbra };
    case "HemisphereLight":
      return { groundColor: i.groundColor };
    case e(401):
      return { width: i[e(394)], height: i[e(371)], rotation: { x: i[e(373)].x, y: i.rotation.y, z: i[e(373)].z } };
  }
}
function Gy() {
  var i = ["angle", "2401QfDEae", "RectAreaLight", "5Ustqtp", "penumbra", "SpotLight", "addHexColor", "max", "旋转z", "18464200biJquX", "target", "min", "1270660BzvDft", "position", "height", "set", "rotation", "1lHPNmd", "目标Z", "3247461mueHau", "目标Y", "7448kBtkKj", "listen", "type", "旋转X", "4587144hqcygq", "PointLight", "attach", "DirectionalLight", "HemisphereLight", "add", "3049342sZtXNP", "power", "name", "groundColor", "旋转y", "decay", "width", "distance", "目标X", "addFn", "2261457LrFyyo"];
  return (Gy = function() {
    return i;
  })();
}
function uu(i, e) {
  var t = Gy();
  return (uu = function(n, r) {
    return t[n -= 366];
  })(i, e);
}
function Er(i, e) {
  const t = jy();
  return (Er = function(n, r) {
    return t[n -= 186];
  })(i, e);
}
function Vy(i, e = {}) {
  const t = Er;
  let n = null;
  switch (i) {
    case t(205):
      n = Hb(e);
      break;
    case t(187):
      n = function(r = {}) {
        const s = Er;
        return new ph(r[s(207)] || 16777215, r[s(203)] || 1);
      }(e);
      break;
    case t(201):
      n = function(r = {}) {
        const s = Er;
        return new vl(r.color || 16777215, r.intensity || 1, r[s(198)] || 0, r[s(195)] || 0);
      }(e);
      break;
    case t(193):
      n = function(r = {}) {
        const s = Er;
        return new dh(r[s(207)] || 16777215, r.intensity || 1, r[s(198)] || 0, r[s(189)] || Math.PI / 3, r.penumbra || 0, r[s(195)] || 0);
      }(e);
      break;
    case t(188):
      n = function(r = {}) {
        const s = Er;
        return new W[s(188)](r[s(207)] || 16777215, r[s(204)] || 0, r[s(203)] || 1);
      }(e);
      break;
    case t(206):
      n = function(r = {}) {
        const s = Er;
        return new W[s(206)](r[s(207)] || 16777215, r[s(203)] || 1, r.width || 100, r[s(196)] || 100);
      }(e);
      break;
    default:
      n = Hb(e);
  }
  return n;
}
function Hb(i = {}) {
  return new W[Er(205)](i.color || 16777215, i.intensity || 1);
}
function jy() {
  const i = ["1068165DgwUCt", "PointLight", "235530CFhLgZ", "intensity", "groundColor", "AmbientLight", "RectAreaLight", "color", "185kmWeuz", "DirectionalLight", "HemisphereLight", "angle", "6963075OvXFzl", "9152024fXdSkK", "1520296TxhNFJ", "SpotLight", "41IcNTHD", "decay", "height", "5399517COJsRM", "distance", "48054tulWJB"];
  return (jy = function() {
    return i;
  })();
}
function Cf(i, e) {
  const t = Wy();
  return (Cf = function(n, r) {
    return t[n -= 447];
  })(i, e);
}
function Wy() {
  const i = ["696322Ffayce", "layers", "shadow", "位置y", "addFolder", "target", "position", "2550340gALKqL", "914060OeFSbZ", "13727656fRweOI", "name", "removeFolder", "color", "set", "可见性", "parent", "位置X", "1584852GIsOti", "位置z", "拖拽控制", "阴影配置", "castShadow", "特定配置", "addFn", "dispose", "5WkPDwh", "5401816iTiYUn", "add", "remove", "1766631fkCQoM", "visible", "addHexColor", "attach"];
  return (Wy = function() {
    return i;
  })();
}
function qR(i, e) {
  const t = Cf;
  e && (i[t(456)] = e[t(456)], i[t(476)] = e[t(476)], i[t(458)][t(459)](e.color), i.intensity = e.intensity, i[t(467)] = e[t(467)], i[t(452)].set(e[t(452)].x, e[t(452)].y, e[t(452)].z), Bv(i[t(447)], e[t(447)]), function(n, r) {
    const s = hu;
    if (!r)
      return;
    n[s(349)] = r[s(349)], n[s(347)] = r.radius, n[s(375)][s(354)](r[s(375)].x, r[s(375)].y), n[s(341)] = r[s(341)];
    const { camera: a } = r;
    a && n.camera && (Object[s(366)](a)[s(367)]((o) => n[s(374)][o] = a[o]), n[s(374)][s(350)]());
  }(i.shadow, e[t(448)]), function(n, r) {
    var s = uu;
    if (r)
      switch (n[s(380)]) {
        case s(385):
          n[s(367)][s(370)][s(372)](r[s(367)].x, r[s(367)].y, r[s(367)].z);
          break;
        case s(383):
          n[s(395)] = r.distance, n[s(393)] = r[s(393)], n.power = r[s(389)];
          break;
        case "SpotLight":
          n[s(395)] = r[s(395)], n[s(393)] = r[s(393)], n[s(389)] = r[s(389)], n[s(399)] = r.angle, n[s(403)] = r[s(403)];
          break;
        case s(386):
          n[s(391)][s(372)](r.groundColor);
          break;
        case s(401):
          n[s(394)] = r[s(394)], n[s(371)] = r[s(371)], n[s(373)][s(372)](r.rotation.x, r[s(373)].y, r[s(373)].z);
      }
  }(i, e));
}
function Gb(i, e, t) {
  const n = Cf;
  if (e[n(473)](i, n(476))[n(456)](n(460)), e.add(i, "name")[n(456)]("名称"), e[n(477)](i.color)[n(456)]("颜色"), e[n(473)](i, "intensity")[n(456)]("强度"), zv(i[n(447)], e), e[n(469)](() => t[n(478)](i)).name(n(465)), e[n(469)](() => {
    const a = n, o = i[a(461)];
    i[a(451)] && o[a(474)](i[a(451)]), o[a(474)](i), i[a(470)](), e[a(461)][a(457)](e);
  })[n(456)]("删除"), i[n(448)]) {
    e.add(i, n(467)).name("投影");
    const a = e[n(450)](n(466));
    (function(o, l) {
      const c = hu;
      l[c(362)](o, "bias")[c(360)]("偏移"), l[c(362)](o, "radius")[c(360)]("半径"), l[c(362)](o, "normalBias").name(c(361)), l[c(362)](o[c(375)], "width")[c(360)](c(373)), l[c(362)](o[c(375)], c(365))[c(360)](c(351));
      const h = l.addFolder(c(377)), u = () => o[c(374)][c(350)]();
      h.add(o.camera, c(355)).name(c(371))[c(364)](u), h[c(362)](o[c(374)], c(363))[c(360)](c(359))[c(364)](u), o.camera.isOrthographicCamera ? (h[c(362)](o[c(374)], c(344))[c(360)]("左平面")[c(364)](u), h.add(o[c(374)], c(369))[c(360)](c(358))[c(364)](u), h.add(o.camera, c(352))[c(360)]("上平面")[c(364)](u), h.add(o[c(374)], c(368))[c(360)](c(339))[c(364)](u)) : h[c(362)](o.camera, c(342)).name("视角").onChange(u);
    })(i.shadow, a);
  }
  const r = e[n(450)]("变换配置");
  r.add(i[n(452)], "x")[n(456)](n(462)), r[n(473)](i[n(452)], "y")[n(456)](n(449)), r[n(473)](i[n(452)], "z").name(n(464));
  const s = e.addFolder(n(468));
  (function(a, o, l) {
    var c = uu;
    switch (o[c(380)]) {
      case c(385):
        l[c(387)](o[c(367)].position, "x").name(c(396)).listen(), l[c(387)](o[c(367)][c(370)], "y")[c(390)](c(377))[c(379)](), l[c(387)](o[c(367)][c(370)], "z")[c(390)](c(375)).listen(), l[c(397)](() => a[c(384)](o[c(367)]))[c(390)]("拖拽目标");
        break;
      case c(383):
        l.add(o, "distance")[c(390)]("距离"), l.add(o, c(393))[c(390)]("衰减"), l[c(387)](o, "power").name("功率");
        break;
      case "SpotLight":
        l.add(o, c(395))[c(390)]("距离"), l[c(387)](o, c(393))[c(390)]("衰减"), l[c(387)](o, c(389)).name("功率"), l.add(o, "angle")[c(390)]("角度"), l.add(o, "penumbra")[c(390)]("边缘");
        break;
      case "HemisphereLight":
        l[c(405)](o.groundColor).name("基色");
        break;
      case c(401):
        l[c(387)](o[c(373)], "x").name(c(381))[c(368)](-Math.PI / 2).max(Math.PI / 2), l[c(387)](o.rotation, "y")[c(390)](c(392))[c(368)](-Math.PI / 2)[c(406)](Math.PI / 2), l.add(o.rotation, "z")[c(390)](c(407)).min(-Math.PI / 2)[c(406)](Math.PI / 2), l.add(o, "width")[c(390)]("宽度"), l[c(387)](o, c(371))[c(390)]("高度");
    }
  })(t, i, s);
}
function du(i, e) {
  const t = Xy();
  return (du = function(n, r) {
    return t[n -= 324];
  })(i, e);
}
function Xy() {
  const i = ["type", "name", "addFolder", "113546JbzHuZ", "1GerYfR", "9VPSNBG", "SpotLight", "lightType", "attach_add", "2613WsdzTB", "232350ORrsCD", "4079172EGWwZL", "transformControls", "33IVNxcp", "target", "findKey", "光源类型", "RectAreaLight", "map", "1268ANQCBs", "6316320KXaIyf", "add", "find", "9762370NfQnPy", "lightList", "Light", "1177068xDCSMO", "HemisphereLight", "forEach", "35SzOmNP", "keys", "点击添加光源", "AmbientLight", "addFn"];
  return (Xy = function() {
    return i;
  })();
}
function YR(i) {
  return i[du(331)]((e) => function(t) {
    const { name: n, type: r, visible: s, position: a, color: o, intensity: l, castShadow: c, layers: h, shadow: u } = t;
    return Ee({ name: n, type: r, visible: s, position: a, color: o, intensity: l, castShadow: c, layers: Fv(h), shadow: WR(u) }, XR(t));
  }(e));
}
(function(i, e) {
  for (var t = Qh, n = gy(); ; )
    try {
      if (-parseInt(t(228)) / 1 + -parseInt(t(226)) / 2 + -parseInt(t(233)) / 3 + parseInt(t(235)) / 4 * (-parseInt(t(234)) / 5) + -parseInt(t(227)) / 6 + -parseInt(t(239)) / 7 + parseInt(t(236)) / 8 * (parseInt(t(229)) / 9) === 212298)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = Nl, n = vy();
  for (; ; )
    try {
      if (-parseInt(t(497)) / 1 + parseInt(t(473)) / 2 * (-parseInt(t(488)) / 3) + parseInt(t(489)) / 4 * (parseInt(t(491)) / 5) + parseInt(t(476)) / 6 * (parseInt(t(495)) / 7) + -parseInt(t(482)) / 8 + parseInt(t(468)) / 9 + -parseInt(t(485)) / 10 * (-parseInt(t(487)) / 11) === 805329)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Jh, n = yy();
  for (; ; )
    try {
      if (parseInt(t(196)) / 1 * (-parseInt(t(206)) / 2) + -parseInt(t(197)) / 3 + parseInt(t(210)) / 4 + -parseInt(t(212)) / 5 + parseInt(t(203)) / 6 * (parseInt(t(214)) / 7) + -parseInt(t(221)) / 8 * (parseInt(t(199)) / 9) + parseInt(t(218)) / 10 === 762056)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = $h, n = _y();
  for (; ; )
    try {
      if (parseInt(t(184)) / 1 + parseInt(t(198)) / 2 * (parseInt(t(186)) / 3) + parseInt(t(209)) / 4 * (-parseInt(t(200)) / 5) + -parseInt(t(201)) / 6 * (-parseInt(t(195)) / 7) + parseInt(t(188)) / 8 * (parseInt(t(197)) / 9) + parseInt(t(189)) / 10 * (parseInt(t(190)) / 11) + -parseInt(t(208)) / 12 === 268026)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = eu, n = xy(); ; )
    try {
      if (parseInt(t(185)) / 1 + parseInt(t(181)) / 2 * (parseInt(t(184)) / 3) + -parseInt(t(157)) / 4 + -parseInt(t(180)) / 5 + -parseInt(t(162)) / 6 + -parseInt(t(191)) / 7 * (parseInt(t(173)) / 8) + parseInt(t(188)) / 9 * (parseInt(t(167)) / 10) === 988494)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = tu, n = by(); ; )
    try {
      if (parseInt(t(291)) / 1 + parseInt(t(292)) / 2 + parseInt(t(308)) / 3 * (parseInt(t(295)) / 4) + -parseInt(t(312)) / 5 + parseInt(t(316)) / 6 + -parseInt(t(294)) / 7 + parseInt(t(315)) / 8 * (-parseInt(t(301)) / 9) === 770919)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = nu, n = My(); ; )
    try {
      if (-parseInt(t(210)) / 1 * (-parseInt(t(201)) / 2) + -parseInt(t(204)) / 3 * (parseInt(t(198)) / 4) + -parseInt(t(213)) / 5 + -parseInt(t(199)) / 6 + parseInt(t(207)) / 7 * (-parseInt(t(197)) / 8) + parseInt(t(209)) / 9 * (parseInt(t(206)) / 10) + parseInt(t(205)) / 11 === 785736)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = As, n = wy(); ; )
    try {
      if (parseInt(t(145)) / 1 + -parseInt(t(133)) / 2 + -parseInt(t(134)) / 3 + -parseInt(t(121)) / 4 * (parseInt(t(147)) / 5) + -parseInt(t(130)) / 6 * (parseInt(t(154)) / 7) + parseInt(t(122)) / 8 * (-parseInt(t(150)) / 9) + parseInt(t(139)) / 10 * (parseInt(t(158)) / 11) === 183414)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = iu, n = Sy(); ; )
    try {
      if (-parseInt(t(288)) / 1 * (parseInt(t(285)) / 2) + parseInt(t(280)) / 3 * (-parseInt(t(286)) / 4) + -parseInt(t(283)) / 5 * (parseInt(t(282)) / 6) + -parseInt(t(295)) / 7 + -parseInt(t(292)) / 8 + -parseInt(t(289)) / 9 * (-parseInt(t(294)) / 10) + parseInt(t(291)) / 11 === 153003)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = ru, n = Ty();
  for (; ; )
    try {
      if (-parseInt(t(165)) / 1 * (-parseInt(t(156)) / 2) + parseInt(t(170)) / 3 * (-parseInt(t(169)) / 4) + parseInt(t(168)) / 5 + parseInt(t(161)) / 6 + -parseInt(t(158)) / 7 * (parseInt(t(164)) / 8) + -parseInt(t(159)) / 9 + parseInt(t(163)) / 10 === 831519)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = su, n = Ey(); ; )
    try {
      if (-parseInt(t(511)) / 1 * (parseInt(t(520)) / 2) + parseInt(t(521)) / 3 * (parseInt(t(503)) / 4) + -parseInt(t(505)) / 5 + -parseInt(t(498)) / 6 * (parseInt(t(517)) / 7) + parseInt(t(509)) / 8 + parseInt(t(515)) / 9 * (-parseInt(t(518)) / 10) + parseInt(t(516)) / 11 * (parseInt(t(496)) / 12) === 917179)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = au, n = Ay(); ; )
    try {
      if (parseInt(t(338)) / 1 * (parseInt(t(344)) / 2) + -parseInt(t(345)) / 3 + parseInt(t(336)) / 4 * (-parseInt(t(325)) / 5) + parseInt(t(331)) / 6 * (-parseInt(t(323)) / 7) + parseInt(t(328)) / 8 * (-parseInt(t(333)) / 9) + parseInt(t(341)) / 10 + -parseInt(t(324)) / 11 * (-parseInt(t(346)) / 12) === 611212)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = ou, n = Iy();
  for (; ; )
    try {
      if (-parseInt(t(166)) / 1 * (parseInt(t(159)) / 2) + -parseInt(t(160)) / 3 + parseInt(t(165)) / 4 + -parseInt(t(168)) / 5 + -parseInt(t(163)) / 6 * (-parseInt(t(156)) / 7) + parseInt(t(158)) / 8 * (parseInt(t(173)) / 9) + parseInt(t(154)) / 10 === 991899)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Af, n = Cy();
  for (; ; )
    try {
      if (parseInt(t(161)) / 1 * (parseInt(t(171)) / 2) + -parseInt(t(158)) / 3 * (parseInt(t(159)) / 4) + -parseInt(t(173)) / 5 * (-parseInt(t(165)) / 6) + -parseInt(t(174)) / 7 * (-parseInt(t(156)) / 8) + -parseInt(t(155)) / 9 * (-parseInt(t(170)) / 10) + parseInt(t(164)) / 11 + parseInt(t(168)) / 12 * (-parseInt(t(166)) / 13) === 131856)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Ry, n = Py();
  for (; ; )
    try {
      if (parseInt(t(306)) / 1 + -parseInt(t(349)) / 2 + -parseInt(t(309)) / 3 + -parseInt(t(348)) / 4 * (parseInt(t(308)) / 5) + -parseInt(t(335)) / 6 * (-parseInt(t(316)) / 7) + -parseInt(t(330)) / 8 * (parseInt(t(300)) / 9) + -parseInt(t(334)) / 10 * (-parseInt(t(332)) / 11) === 785379)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = If, n = Ly();
  for (; ; )
    try {
      if (parseInt(t(200)) / 1 * (parseInt(t(201)) / 2) + -parseInt(t(190)) / 3 * (parseInt(t(198)) / 4) + -parseInt(t(196)) / 5 * (parseInt(t(192)) / 6) + parseInt(t(189)) / 7 + -parseInt(t(191)) / 8 + parseInt(t(195)) / 9 + parseInt(t(202)) / 10 === 426075)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Ph, n = Dy();
  for (; ; )
    try {
      if (parseInt(t(163)) / 1 + -parseInt(t(161)) / 2 * (-parseInt(t(155)) / 3) + -parseInt(t(184)) / 4 * (-parseInt(t(143)) / 5) + -parseInt(t(154)) / 6 * (-parseInt(t(167)) / 7) + parseInt(t(169)) / 8 + parseInt(t(172)) / 9 * (parseInt(t(156)) / 10) + parseInt(t(175)) / 11 * (-parseInt(t(190)) / 12) === 172014)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Ya, n = Ny();
  for (; ; )
    try {
      if (parseInt(t(439)) / 1 * (parseInt(t(428)) / 2) + -parseInt(t(434)) / 3 * (parseInt(t(442)) / 4) + -parseInt(t(438)) / 5 + parseInt(t(447)) / 6 * (parseInt(t(435)) / 7) + -parseInt(t(430)) / 8 * (-parseInt(t(436)) / 9) + parseInt(t(433)) / 10 * (-parseInt(t(445)) / 11) + -parseInt(t(437)) / 12 === 562552)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Za, n = Oy();
  for (; ; )
    try {
      if (-parseInt(t(459)) / 1 + parseInt(t(450)) / 2 + parseInt(t(449)) / 3 * (-parseInt(t(457)) / 4) + -parseInt(t(466)) / 5 + -parseInt(t(452)) / 6 + -parseInt(t(460)) / 7 + -parseInt(t(464)) / 8 * (-parseInt(t(467)) / 9) === 775361)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Tl, n = Uy();
  for (; ; )
    try {
      if (-parseInt(t(250)) / 1 * (parseInt(t(238)) / 2) + -parseInt(t(253)) / 3 * (parseInt(t(247)) / 4) + -parseInt(t(231)) / 5 + parseInt(t(235)) / 6 * (-parseInt(t(234)) / 7) + parseInt(t(249)) / 8 + -parseInt(t(240)) / 9 + parseInt(t(243)) / 10 === 993826)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = lu, n = ky();
  for (; ; )
    try {
      if (-parseInt(t(321)) / 1 + parseInt(t(324)) / 2 * (parseInt(t(323)) / 3) + -parseInt(t(316)) / 4 * (parseInt(t(319)) / 5) + parseInt(t(320)) / 6 + parseInt(t(326)) / 7 + -parseInt(t(318)) / 8 + parseInt(t(322)) / 9 * (parseInt(t(317)) / 10) === 189334)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = cu, n = Fy();
  for (; ; )
    try {
      if (parseInt(t(374)) / 1 + -parseInt(t(383)) / 2 * (-parseInt(t(373)) / 3) + parseInt(t(385)) / 4 + -parseInt(t(377)) / 5 * (-parseInt(t(370)) / 6) + parseInt(t(368)) / 7 * (parseInt(t(372)) / 8) + parseInt(t(376)) / 9 + -parseInt(t(380)) / 10 * (parseInt(t(378)) / 11) === 163434)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = eo, n = By();
  for (; ; )
    try {
      if (parseInt(t(372)) / 1 * (parseInt(t(370)) / 2) + parseInt(t(371)) / 3 + parseInt(t(393)) / 4 * (-parseInt(t(381)) / 5) + -parseInt(t(388)) / 6 + parseInt(t(373)) / 7 + -parseInt(t(392)) / 8 * (-parseInt(t(399)) / 9) + parseInt(t(402)) / 10 === 551561)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = hu, n = Hy();
  for (; ; )
    try {
      if (parseInt(t(343)) / 1 + parseInt(t(372)) / 2 + -parseInt(t(348)) / 3 + -parseInt(t(370)) / 4 * (parseInt(t(340)) / 5) + -parseInt(t(346)) / 6 * (-parseInt(t(353)) / 7) + parseInt(t(376)) / 8 * (parseInt(t(356)) / 9) + -parseInt(t(345)) / 10 * (parseInt(t(357)) / 11) === 712985)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = uu, n = Gy(); ; )
    try {
      if (-parseInt(t(374)) / 1 * (parseInt(t(388)) / 2) + parseInt(t(376)) / 3 + parseInt(t(369)) / 4 * (-parseInt(t(402)) / 5) + -parseInt(t(382)) / 6 + -parseInt(t(400)) / 7 * (-parseInt(t(378)) / 8) + parseInt(t(398)) / 9 + parseInt(t(366)) / 10 === 892653)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Er, n = jy();
  for (; ; )
    try {
      if (parseInt(t(194)) / 1 * (parseInt(t(199)) / 2) + -parseInt(t(197)) / 3 + parseInt(t(192)) / 4 + parseInt(t(186)) / 5 * (parseInt(t(202)) / 6) + parseInt(t(190)) / 7 + -parseInt(t(191)) / 8 + parseInt(t(200)) / 9 === 987184)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Cf, n = Wy();
  for (; ; )
    try {
      if (-parseInt(t(479)) / 1 + parseInt(t(454)) / 2 + parseInt(t(475)) / 3 + parseInt(t(453)) / 4 * (-parseInt(t(471)) / 5) + -parseInt(t(463)) / 6 + -parseInt(t(472)) / 7 + parseInt(t(455)) / 8 === 392127)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = du, n = Xy();
  for (; ; )
    try {
      if (-parseInt(t(351)) / 1 * (parseInt(t(350)) / 2) + -parseInt(t(356)) / 3 * (-parseInt(t(332)) / 4) + parseInt(t(357)) / 5 + parseInt(t(339)) / 6 * (parseInt(t(342)) / 7) + -parseInt(t(333)) / 8 + -parseInt(t(352)) / 9 * (parseInt(t(336)) / 10) + -parseInt(t(326)) / 11 * (-parseInt(t(324)) / 12) === 500710)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
var bi = Uint8Array, qo = Uint16Array, ZR = Int32Array, f4 = new bi([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), m4 = new bi([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), KR = new bi([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), g4 = function(i, e) {
  for (var t = new qo(31), n = 0; n < 31; ++n)
    t[n] = e += 1 << i[n - 1];
  var r = new ZR(t[30]);
  for (n = 1; n < 30; ++n)
    for (var s = t[n]; s < t[n + 1]; ++s)
      r[s] = s - t[n] << 5 | n;
  return { b: t, r };
}, v4 = g4(f4, 2), y4 = v4.b, QR = v4.r;
y4[28] = 258, QR[258] = 28;
for (var JR = g4(m4, 0).b, q0 = new qo(32768), _t = 0; _t < 32768; ++_t) {
  var $s = (43690 & _t) >> 1 | (21845 & _t) << 1;
  $s = (61680 & ($s = (52428 & $s) >> 2 | (13107 & $s) << 2)) >> 4 | (3855 & $s) << 4, q0[_t] = ((65280 & $s) >> 8 | (255 & $s) << 8) >> 1;
}
var Yc = function(i, e, t) {
  for (var n = i.length, r = 0, s = new qo(e); r < n; ++r)
    i[r] && ++s[i[r] - 1];
  var a, o = new qo(e);
  for (r = 1; r < e; ++r)
    o[r] = o[r - 1] + s[r - 1] << 1;
  if (t) {
    a = new qo(1 << e);
    var l = 15 - e;
    for (r = 0; r < n; ++r)
      if (i[r])
        for (var c = r << 4 | i[r], h = e - i[r], u = o[i[r] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u)
          a[q0[u] >> l] = c;
  } else
    for (a = new qo(n), r = 0; r < n; ++r)
      i[r] && (a[r] = q0[o[i[r] - 1]++] >> 15 - i[r]);
  return a;
}, pu = new bi(288);
for (_t = 0; _t < 144; ++_t)
  pu[_t] = 8;
for (_t = 144; _t < 256; ++_t)
  pu[_t] = 9;
for (_t = 256; _t < 280; ++_t)
  pu[_t] = 7;
for (_t = 280; _t < 288; ++_t)
  pu[_t] = 8;
var _4 = new bi(32);
for (_t = 0; _t < 32; ++_t)
  _4[_t] = 5;
var $R = Yc(pu, 9, 1), eP = Yc(_4, 5, 1), hg = function(i) {
  for (var e = i[0], t = 1; t < i.length; ++t)
    i[t] > e && (e = i[t]);
  return e;
}, Ni = function(i, e, t) {
  var n = e / 8 | 0;
  return (i[n] | i[n + 1] << 8) >> (7 & e) & t;
}, ug = function(i, e) {
  var t = e / 8 | 0;
  return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) >> (7 & e);
}, tP = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], ki = function(i, e, t) {
  var n = new Error(e || tP[i]);
  if (n.code = i, Error.captureStackTrace && Error.captureStackTrace(n, ki), !t)
    throw n;
  return n;
}, nP = function(i, e, t, n) {
  var r = i.length;
  if (!r || e.f && !e.l)
    return t || new bi(0);
  var s = !t, a = s || e.i != 2, o = e.i;
  s && (t = new bi(3 * r));
  var l = function(k) {
    var E = t.length;
    if (k > E) {
      var U = new bi(Math.max(2 * E, k));
      U.set(t), t = U;
    }
  }, c = e.f || 0, h = e.p || 0, u = e.b || 0, d = e.l, p = e.d, f = e.m, v = e.n, m = 8 * r;
  do {
    if (!d) {
      c = Ni(i, h, 1);
      var y = Ni(i, h + 1, 3);
      if (h += 3, !y) {
        var g = i[(N = 4 + ((h + 7) / 8 | 0)) - 4] | i[N - 3] << 8, _ = N + g;
        if (_ > r) {
          o && ki(0);
          break;
        }
        a && l(u + g), t.set(i.subarray(N, _), u), e.b = u += g, e.p = h = 8 * _, e.f = c;
        continue;
      }
      if (y == 1)
        d = $R, p = eP, f = 9, v = 5;
      else if (y == 2) {
        var x = Ni(i, h, 31) + 257, M = Ni(i, h + 10, 15) + 4, b = x + Ni(i, h + 5, 31) + 1;
        h += 14;
        for (var w = new bi(b), T = new bi(19), A = 0; A < M; ++A)
          T[KR[A]] = Ni(i, h + 3 * A, 7);
        h += 3 * M;
        var L = hg(T), I = (1 << L) - 1, P = Yc(T, L, 1);
        for (A = 0; A < b; ) {
          var N, F = P[Ni(i, h, I)];
          if (h += 15 & F, (N = F >> 4) < 16)
            w[A++] = N;
          else {
            var z = 0, q = 0;
            for (N == 16 ? (q = 3 + Ni(i, h, 3), h += 2, z = w[A - 1]) : N == 17 ? (q = 3 + Ni(i, h, 7), h += 3) : N == 18 && (q = 11 + Ni(i, h, 127), h += 7); q--; )
              w[A++] = z;
          }
        }
        var re = w.subarray(0, x), ie = w.subarray(x);
        f = hg(re), v = hg(ie), d = Yc(re, f, 1), p = Yc(ie, v, 1);
      } else
        ki(1);
      if (h > m) {
        o && ki(0);
        break;
      }
    }
    a && l(u + 131072);
    for (var me = (1 << f) - 1, Se = (1 << v) - 1, te = h; ; te = h) {
      var se = (z = d[ug(i, h) & me]) >> 4;
      if ((h += 15 & z) > m) {
        o && ki(0);
        break;
      }
      if (z || ki(2), se < 256)
        t[u++] = se;
      else {
        if (se == 256) {
          te = h, d = null;
          break;
        }
        var he = se - 254;
        if (se > 264) {
          var ae = f4[A = se - 257];
          he = Ni(i, h, (1 << ae) - 1) + y4[A], h += ae;
        }
        var D = p[ug(i, h) & Se], R = D >> 4;
        if (D || ki(3), h += 15 & D, ie = JR[R], R > 3 && (ae = m4[R], ie += ug(i, h) & (1 << ae) - 1, h += ae), h > m) {
          o && ki(0);
          break;
        }
        a && l(u + 131072);
        var X = u + he;
        if (u < ie) {
          var Q = 0 - ie, O = Math.min(ie, X);
          for (Q + u < 0 && ki(3); u < O; ++u)
            t[u] = n[Q + u];
        }
        for (; u < X; ++u)
          t[u] = t[u - ie];
      }
    }
    e.l = d, e.p = te, e.b = u, e.f = c, d && (c = 1, e.m = f, e.d = p, e.n = v);
  } while (!c);
  return u != t.length && s ? function(k, E, U) {
    return (U == null || U > k.length) && (U = k.length), new bi(k.subarray(E, U));
  }(t, 0, u) : t.subarray(0, u);
}, iP = new bi(0);
function rP(i, e) {
  return nP(i.subarray((n = e, ((15 & (t = i)[0]) != 8 || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31) && ki(6, "invalid zlib data"), (t[1] >> 5 & 1) == +!n && ki(6, "invalid zlib data: " + (32 & t[1] ? "need" : "unexpected") + " dictionary"), 2 + (t[1] >> 3 & 4)), -4), { i: 2 }, e, e);
  var t, n;
}
var sP = typeof TextDecoder != "undefined" && new TextDecoder();
try {
  sP.decode(iP, { stream: !0 });
} catch (i) {
}
function x4(i, e, t) {
  const n = t.length - i - 1;
  if (e >= t[n])
    return n - 1;
  if (e <= t[i])
    return i;
  let r = i, s = n, a = Math.floor((r + s) / 2);
  for (; e < t[a] || e >= t[a + 1]; )
    e < t[a] ? s = a : r = a, a = Math.floor((r + s) / 2);
  return a;
}
function aP(i, e) {
  let t = 1;
  for (let r = 2; r <= i; ++r)
    t *= r;
  let n = 1;
  for (let r = 2; r <= e; ++r)
    n *= r;
  for (let r = 2; r <= i - e; ++r)
    n *= r;
  return t / n;
}
function oP(i, e, t, n, r) {
  const s = function(a, o, l, c, h) {
    const u = h < a ? h : a, d = [], p = x4(a, c, o), f = function(m, y, g, _, x) {
      const M = [];
      for (let I = 0; I <= g; ++I)
        M[I] = 0;
      const b = [];
      for (let I = 0; I <= _; ++I)
        b[I] = M.slice(0);
      const w = [];
      for (let I = 0; I <= g; ++I)
        w[I] = M.slice(0);
      w[0][0] = 1;
      const T = M.slice(0), A = M.slice(0);
      for (let I = 1; I <= g; ++I) {
        T[I] = y - x[m + 1 - I], A[I] = x[m + I] - y;
        let P = 0;
        for (let N = 0; N < I; ++N) {
          const F = A[N + 1], z = T[I - N];
          w[I][N] = F + z;
          const q = w[N][I - 1] / w[I][N];
          w[N][I] = P + F * q, P = z * q;
        }
        w[I][I] = P;
      }
      for (let I = 0; I <= g; ++I)
        b[0][I] = w[I][g];
      for (let I = 0; I <= g; ++I) {
        let P = 0, N = 1;
        const F = [];
        for (let z = 0; z <= g; ++z)
          F[z] = M.slice(0);
        F[0][0] = 1;
        for (let z = 1; z <= _; ++z) {
          let q = 0;
          const re = I - z, ie = g - z;
          I >= z && (F[N][0] = F[P][0] / w[ie + 1][re], q = F[N][0] * w[re][ie]);
          const me = I - 1 <= ie ? z - 1 : g - I;
          for (let te = re >= -1 ? 1 : -re; te <= me; ++te)
            F[N][te] = (F[P][te] - F[P][te - 1]) / w[ie + 1][re + te], q += F[N][te] * w[re + te][ie];
          I <= ie && (F[N][z] = -F[P][z - 1] / w[ie + 1][I], q += F[N][z] * w[I][ie]), b[z][I] = q;
          const Se = P;
          P = N, N = Se;
        }
      }
      let L = g;
      for (let I = 1; I <= _; ++I) {
        for (let P = 0; P <= g; ++P)
          b[I][P] *= L;
        L *= g - I;
      }
      return b;
    }(p, c, a, u, o), v = [];
    for (let m = 0; m < l.length; ++m) {
      const y = l[m].clone(), g = y.w;
      y.x *= g, y.y *= g, y.z *= g, v[m] = y;
    }
    for (let m = 0; m <= u; ++m) {
      const y = v[p - a].clone().multiplyScalar(f[m][0]);
      for (let g = 1; g <= a; ++g)
        y.add(v[p - a + g].clone().multiplyScalar(f[m][g]));
      d[m] = y;
    }
    for (let m = u + 1; m <= h + 1; ++m)
      d[m] = new je(0, 0, 0);
    return d;
  }(i, e, t, n, r);
  return function(a) {
    const o = a.length, l = [], c = [];
    for (let u = 0; u < o; ++u) {
      const d = a[u];
      l[u] = new S(d.x, d.y, d.z), c[u] = d.w;
    }
    const h = [];
    for (let u = 0; u < o; ++u) {
      const d = l[u].clone();
      for (let p = 1; p <= u; ++p)
        d.sub(h[u - p].clone().multiplyScalar(aP(u, p) * c[p]));
      h[u] = d.divideScalar(c[0]);
    }
    return h;
  }(s);
}
class lP extends Ei {
  constructor(e, t, n, r, s) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = r || 0, this.endKnot = s || this.knots.length - 1;
    for (let a = 0; a < n.length; ++a) {
      const o = n[a];
      this.controlPoints[a] = new je(o.x, o.y, o.z, o.w);
    }
  }
  getPoint(e, t = new S()) {
    const n = t, r = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), s = function(a, o, l, c) {
      const h = x4(a, c, o), u = function(p, f, v, m) {
        const y = [], g = [], _ = [];
        y[0] = 1;
        for (let x = 1; x <= v; ++x) {
          g[x] = f - m[p + 1 - x], _[x] = m[p + x] - f;
          let M = 0;
          for (let b = 0; b < x; ++b) {
            const w = _[b + 1], T = g[x - b], A = y[b] / (w + T);
            y[b] = M + w * A, M = T * A;
          }
          y[x] = M;
        }
        return y;
      }(h, c, a, o), d = new je(0, 0, 0, 0);
      for (let p = 0; p <= a; ++p) {
        const f = l[h - a + p], v = u[p], m = f.w * v;
        d.x += f.x * m, d.y += f.y * m, d.z += f.z * m, d.w += f.w * v;
      }
      return d;
    }(this.degree, this.knots, this.controlPoints, r);
    return s.w !== 1 && s.divideScalar(s.w), n.set(s.x, s.y, s.z);
  }
  getTangent(e, t = new S()) {
    const n = t, r = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), s = oP(this.degree, this.knots, this.controlPoints, r, 1);
    return n.copy(s[1]).normalize(), n;
  }
}
let qe, Bt, Pn;
class cP extends Lt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, a = s.path === "" ? cr.extractUrlBase(e) : s.path, o = new xn(this.manager);
    o.setPath(s.path), o.setResponseType("arraybuffer"), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(l) {
      try {
        t(s.parse(l, a));
      } catch (c) {
        r ? r(c) : console.error(c), s.manager.itemError(e);
      }
    }, n, r);
  }
  parse(e, t) {
    if (function(r) {
      const s = "Kaydara FBX Binary  \0";
      return r.byteLength >= s.length && s === Wb(r, 0, s.length);
    }(e))
      qe = new fP().parse(e);
    else {
      const r = Wb(e);
      if (!function(s) {
        const a = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
        let o = 0;
        function l(c) {
          const h = s[c - 1];
          return s = s.slice(o + c), o++, h;
        }
        for (let c = 0; c < a.length; ++c)
          if (l(1) === a[c])
            return !1;
        return !0;
      }(r))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (jb(r) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + jb(r));
      qe = new pP().parse(r);
    }
    const n = new Va(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new hP(n, this.manager).parse(qe);
  }
}
class hP {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    Bt = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), r = this.parseDeformers(), s = new uP().parse(r);
    return this.parseScene(r, s, n), Pn;
  }
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in qe && qe.Connections.connections.forEach(function(t) {
      const n = t[0], r = t[1], s = t[2];
      e.has(n) || e.set(n, { parents: [], children: [] });
      const a = { ID: r, relationship: s };
      e.get(n).parents.push(a), e.has(r) || e.set(r, { parents: [], children: [] });
      const o = { ID: n, relationship: s };
      e.get(r).children.push(o);
    }), e;
  }
  parseImages() {
    const e = {}, t = {};
    if ("Video" in qe.Objects) {
      const n = qe.Objects.Video;
      for (const r in n) {
        const s = n[r];
        if (e[parseInt(r)] = s.RelativeFilename || s.Filename, "Content" in s) {
          const a = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0, o = typeof s.Content == "string" && s.Content !== "";
          if (a || o) {
            const l = this.parseImage(n[r]);
            t[s.RelativeFilename || s.Filename] = l;
          }
        }
      }
    }
    for (const n in e) {
      const r = e[n];
      t[r] !== void 0 ? e[n] = t[r] : e[n] = e[n].split("\\").pop();
    }
    return e;
  }
  parseImage(e) {
    const t = e.Content, n = e.RelativeFilename || e.Filename, r = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
    let s;
    switch (r) {
      case "bmp":
        s = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        s = "image/jpeg";
        break;
      case "png":
        s = "image/png";
        break;
      case "tif":
        s = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n), s = "image/tga";
        break;
      default:
        return void console.warn('FBXLoader: Image type "' + r + '" is not supported.');
    }
    if (typeof t == "string")
      return "data:" + s + ";base64," + t;
    {
      const a = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([a], { type: s }));
    }
  }
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in qe.Objects) {
      const n = qe.Objects.Texture;
      for (const r in n) {
        const s = this.parseTexture(n[r], e);
        t.set(parseInt(r), s);
      }
    }
    return t;
  }
  parseTexture(e, t) {
    const n = this.loadTexture(e, t);
    n.ID = e.id, n.name = e.attrName;
    const r = e.WrapModeU, s = e.WrapModeV, a = r !== void 0 ? r.value : 0, o = s !== void 0 ? s.value : 0;
    if (n.wrapS = a === 0 ? In : ri, n.wrapT = o === 0 ? In : ri, "Scaling" in e) {
      const l = e.Scaling.value;
      n.repeat.x = l[0], n.repeat.y = l[1];
    }
    if ("Translation" in e) {
      const l = e.Translation.value;
      n.offset.x = l[0], n.offset.y = l[1];
    }
    return n;
  }
  loadTexture(e, t) {
    let n;
    const r = this.textureLoader.path, s = Bt.get(e.id).children;
    let a;
    s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (n = t[s[0].ID], n.indexOf("blob:") !== 0 && n.indexOf("data:") !== 0 || this.textureLoader.setPath(void 0));
    const o = e.FileName.slice(-3).toLowerCase();
    if (o === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), a = new vt()) : (l.setPath(this.textureLoader.path), a = l.load(n));
    } else if (o === "dds") {
      const l = this.manager.getHandler(".dds");
      l === null ? (console.warn("FBXLoader: DDS loader not found, creating placeholder texture for", e.RelativeFilename), a = new vt()) : (l.setPath(this.textureLoader.path), a = l.load(n));
    } else
      o === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), a = new vt()) : a = this.textureLoader.load(n);
    return this.textureLoader.setPath(r), a;
  }
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in qe.Objects) {
      const n = qe.Objects.Material;
      for (const r in n) {
        const s = this.parseMaterial(n[r], e);
        s !== null && t.set(parseInt(r), s);
      }
    }
    return t;
  }
  parseMaterial(e, t) {
    const n = e.id, r = e.attrName;
    let s = e.ShadingModel;
    if (typeof s == "object" && (s = s.value), !Bt.has(n))
      return null;
    const a = this.parseParameters(e, t, n);
    let o;
    switch (s.toLowerCase()) {
      case "phong":
        o = new Ea();
        break;
      case "lambert":
        o = new T1();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), o = new Ea();
    }
    return o.setValues(a), o.name = r, o;
  }
  parseParameters(e, t, n) {
    const r = {};
    e.BumpFactor && (r.bumpScale = e.BumpFactor.value), e.Diffuse ? r.color = new ce().fromArray(e.Diffuse.value).convertSRGBToLinear() : !e.DiffuseColor || e.DiffuseColor.type !== "Color" && e.DiffuseColor.type !== "ColorRGB" || (r.color = new ce().fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (r.displacementScale = e.DisplacementFactor.value), e.Emissive ? r.emissive = new ce().fromArray(e.Emissive.value).convertSRGBToLinear() : !e.EmissiveColor || e.EmissiveColor.type !== "Color" && e.EmissiveColor.type !== "ColorRGB" || (r.emissive = new ce().fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (r.opacity = parseFloat(e.Opacity.value)), r.opacity < 1 && (r.transparent = !0), e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value), e.Shininess && (r.shininess = e.Shininess.value), e.Specular ? r.specular = new ce().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (r.specular = new ce().fromArray(e.SpecularColor.value).convertSRGBToLinear());
    const s = this;
    return Bt.get(n).children.forEach(function(a) {
      const o = a.relationship;
      switch (o) {
        case "Bump":
          r.bumpMap = s.getTexture(t, a.ID);
          break;
        case "Maya|TEX_ao_map":
          r.aoMap = s.getTexture(t, a.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          r.map = s.getTexture(t, a.ID), r.map !== void 0 && (r.map.colorSpace = yt);
          break;
        case "DisplacementColor":
          r.displacementMap = s.getTexture(t, a.ID);
          break;
        case "EmissiveColor":
          r.emissiveMap = s.getTexture(t, a.ID), r.emissiveMap !== void 0 && (r.emissiveMap.colorSpace = yt);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          r.normalMap = s.getTexture(t, a.ID);
          break;
        case "ReflectionColor":
          r.envMap = s.getTexture(t, a.ID), r.envMap !== void 0 && (r.envMap.mapping = ol, r.envMap.colorSpace = yt);
          break;
        case "SpecularColor":
          r.specularMap = s.getTexture(t, a.ID), r.specularMap !== void 0 && (r.specularMap.colorSpace = yt);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          r.alphaMap = s.getTexture(t, a.ID), r.transparent = !0;
          break;
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", o);
      }
    }), r;
  }
  getTexture(e, t) {
    return "LayeredTexture" in qe.Objects && t in qe.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Bt.get(t).children[0].ID), e.get(t);
  }
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in qe.Objects) {
      const n = qe.Objects.Deformer;
      for (const r in n) {
        const s = n[r], a = Bt.get(parseInt(r));
        if (s.attrType === "Skin") {
          const o = this.parseSkeleton(a, n);
          o.ID = r, a.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), o.geometryID = a.parents[0].ID, e[r] = o;
        } else if (s.attrType === "BlendShape") {
          const o = { id: r };
          o.rawTargets = this.parseMorphTargets(a, n), o.id = r, a.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[r] = o;
        }
      }
    }
    return { skeletons: e, morphTargets: t };
  }
  parseSkeleton(e, t) {
    const n = [];
    return e.children.forEach(function(r) {
      const s = t[r.ID];
      if (s.attrType !== "Cluster")
        return;
      const a = { ID: r.ID, indices: [], weights: [], transformLink: new fe().fromArray(s.TransformLink.a) };
      "Indexes" in s && (a.indices = s.Indexes.a, a.weights = s.Weights.a), n.push(a);
    }), { rawBones: n, bones: [] };
  }
  parseMorphTargets(e, t) {
    const n = [];
    for (let r = 0; r < e.children.length; r++) {
      const s = e.children[r], a = t[s.ID], o = { name: a.attrName, initialWeight: a.DeformPercent, id: a.id, fullWeights: a.FullWeights.a };
      if (a.attrType !== "BlendShapeChannel")
        return;
      o.geoID = Bt.get(parseInt(s.ID)).children.filter(function(l) {
        return l.relationship === void 0;
      })[0].ID, n.push(o);
    }
    return n;
  }
  parseScene(e, t, n) {
    Pn = new oi();
    const r = this.parseModels(e.skeletons, t, n), s = qe.Objects.Model, a = this;
    r.forEach(function(l) {
      const c = s[l.ID];
      a.setLookAtProperties(l, c), Bt.get(l.ID).parents.forEach(function(h) {
        const u = r.get(h.ID);
        u !== void 0 && u.add(l);
      }), l.parent === null && Pn.add(l);
    }), this.bindSkeleton(e.skeletons, t, r), this.addGlobalSceneSettings(), Pn.traverse(function(l) {
      if (l.userData.transformData) {
        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
        const c = M4(l.userData.transformData);
        l.applyMatrix4(c), l.updateWorldMatrix();
      }
    });
    const o = new dP().parse();
    Pn.children.length === 1 && Pn.children[0].isGroup && (Pn.children[0].animations = o, Pn = Pn.children[0]), Pn.animations = o;
  }
  parseModels(e, t, n) {
    const r = /* @__PURE__ */ new Map(), s = qe.Objects.Model;
    for (const a in s) {
      const o = parseInt(a), l = s[a], c = Bt.get(o);
      let h = this.buildSkeleton(c, e, o, l.attrName);
      if (!h) {
        switch (l.attrType) {
          case "Camera":
            h = this.createCamera(c);
            break;
          case "Light":
            h = this.createLight(c);
            break;
          case "Mesh":
            h = this.createMesh(c, t, n);
            break;
          case "NurbsCurve":
            h = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            h = new fl();
            break;
          default:
            h = new oi();
        }
        h.name = l.attrName ? Ze.sanitizeNodeName(l.attrName) : "", h.userData.originalName = l.attrName, h.ID = o;
      }
      this.getTransformData(h, l), r.set(o, h);
    }
    return r;
  }
  buildSkeleton(e, t, n, r) {
    let s = null;
    return e.parents.forEach(function(a) {
      for (const o in t) {
        const l = t[o];
        l.rawBones.forEach(function(c, h) {
          if (c.ID === a.ID) {
            const u = s;
            s = new fl(), s.matrixWorld.copy(c.transformLink), s.name = r ? Ze.sanitizeNodeName(r) : "", s.userData.originalName = r, s.ID = n, l.bones[h] = s, u !== null && s.add(u);
          }
        });
      }
    }), s;
  }
  createCamera(e) {
    let t, n;
    if (e.children.forEach(function(r) {
      const s = qe.Objects.NodeAttribute[r.ID];
      s !== void 0 && (n = s);
    }), n === void 0)
      t = new Fe();
    else {
      let r = 0;
      n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (r = 1);
      let s = 1;
      n.NearPlane !== void 0 && (s = n.NearPlane.value / 1e3);
      let a = 1e3;
      n.FarPlane !== void 0 && (a = n.FarPlane.value / 1e3);
      let o = window.innerWidth, l = window.innerHeight;
      n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (o = n.AspectWidth.value, l = n.AspectHeight.value);
      const c = o / l;
      let h = 45;
      n.FieldOfView !== void 0 && (h = n.FieldOfView.value);
      const u = n.FocalLength ? n.FocalLength.value : null;
      switch (r) {
        case 0:
          t = new jt(h, c, s, a), u !== null && t.setFocalLength(u);
          break;
        case 1:
          t = new Ha(-o / 2, o / 2, l / 2, -l / 2, s, a);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + r + "."), t = new Fe();
      }
    }
    return t;
  }
  createLight(e) {
    let t, n;
    if (e.children.forEach(function(r) {
      const s = qe.Objects.NodeAttribute[r.ID];
      s !== void 0 && (n = s);
    }), n === void 0)
      t = new Fe();
    else {
      let r;
      r = n.LightType === void 0 ? 0 : n.LightType.value;
      let s = 16777215;
      n.Color !== void 0 && (s = new ce().fromArray(n.Color.value).convertSRGBToLinear());
      let a = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
      n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (a = 0);
      let o = 0;
      n.FarAttenuationEnd !== void 0 && (o = n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? 0 : n.FarAttenuationEnd.value);
      const l = 1;
      switch (r) {
        case 0:
          t = new vl(s, a, o, l);
          break;
        case 1:
          t = new ph(s, a);
          break;
        case 2:
          let c = Math.PI / 3;
          n.InnerAngle !== void 0 && (c = en.degToRad(n.InnerAngle.value));
          let h = 0;
          n.OuterAngle !== void 0 && (h = en.degToRad(n.OuterAngle.value), h = Math.max(h, 1)), t = new dh(s, a, o, c, h, l);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new vl(s, a);
      }
      n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, n) {
    let r, s = null, a = null;
    const o = [];
    return e.children.forEach(function(l) {
      t.has(l.ID) && (s = t.get(l.ID)), n.has(l.ID) && o.push(n.get(l.ID));
    }), o.length > 1 ? a = o : o.length > 0 ? a = o[0] : (a = new Ea({ name: Lt.DEFAULT_MATERIAL_NAME, color: 13421772 }), o.push(a)), "color" in s.attributes && o.forEach(function(l) {
      l.vertexColors = !0;
    }), s.FBX_Deformer ? (r = new hp(s, a), r.normalizeSkinWeights()) : r = new ve(s, a), r;
  }
  createCurve(e, t) {
    const n = e.children.reduce(function(s, a) {
      return t.has(a.ID) && (s = t.get(a.ID)), s;
    }, null), r = new zt({ name: Lt.DEFAULT_MATERIAL_NAME, color: 3342591, linewidth: 1 });
    return new dn(n, r);
  }
  getTransformData(e, t) {
    const n = {};
    "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), n.eulerOrder = "RotationOrder" in t ? w4(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && Bt.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const r = qe.Objects.Model[n.ID];
        if ("Lcl_Translation" in r) {
          const s = r.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(s), Pn.add(e.target)) : e.lookAt(new S().fromArray(s));
        }
      }
    });
  }
  bindSkeleton(e, t, n) {
    const r = this.parsePoseNodes();
    for (const s in e) {
      const a = e[s];
      Bt.get(parseInt(a.ID)).parents.forEach(function(o) {
        if (t.has(o.ID)) {
          const l = o.ID;
          Bt.get(l).parents.forEach(function(c) {
            n.has(c.ID) && n.get(c.ID).bind(new ml(a.bones), r[c.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in qe.Objects) {
      const t = qe.Objects.Pose;
      for (const n in t)
        if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
          const r = t[n].PoseNode;
          Array.isArray(r) ? r.forEach(function(s) {
            e[s.Node] = new fe().fromArray(s.Matrix.a);
          }) : e[r.Node] = new fe().fromArray(r.Matrix.a);
        }
    }
    return e;
  }
  addGlobalSceneSettings() {
    if ("GlobalSettings" in qe) {
      if ("AmbientColor" in qe.GlobalSettings) {
        const e = qe.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], r = e[2];
        if (t !== 0 || n !== 0 || r !== 0) {
          const s = new ce(t, n, r).convertSRGBToLinear();
          Pn.add(new _0(s, 1));
        }
      }
      "UnitScaleFactor" in qe.GlobalSettings && (Pn.userData.unitScaleFactor = qe.GlobalSettings.UnitScaleFactor.value);
    }
  }
}
class uP {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in qe.Objects) {
      const n = qe.Objects.Geometry;
      for (const r in n) {
        const s = Bt.get(parseInt(r)), a = this.parseGeometry(s, n[r], e);
        t.set(parseInt(r), a);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  parseGeometry(e, t, n) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, n);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  parseMeshGeometry(e, t, n) {
    const r = n.skeletons, s = [], a = e.parents.map(function(u) {
      return qe.Objects.Model[u.ID];
    });
    if (a.length === 0)
      return;
    const o = e.children.reduce(function(u, d) {
      return r[d.ID] !== void 0 && (u = r[d.ID]), u;
    }, null);
    e.children.forEach(function(u) {
      n.morphTargets[u.ID] !== void 0 && s.push(n.morphTargets[u.ID]);
    });
    const l = a[0], c = {};
    "RotationOrder" in l && (c.eulerOrder = w4(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
    const h = M4(c);
    return this.genGeometry(t, o, s, h);
  }
  genGeometry(e, t, n, r) {
    const s = new Re();
    e.attrName && (s.name = e.attrName);
    const a = this.parseGeoNode(e, t), o = this.genBuffers(a), l = new ye(o.vertex, 3);
    if (l.applyMatrix4(r), s.setAttribute("position", l), o.colors.length > 0 && s.setAttribute("color", new ye(o.colors, 3)), t && (s.setAttribute("skinIndex", new Xp(o.weightsIndices, 4)), s.setAttribute("skinWeight", new ye(o.vertexWeights, 4)), s.FBX_Deformer = t), o.normal.length > 0) {
      const c = new Ue().getNormalMatrix(r), h = new ye(o.normal, 3);
      h.applyNormalMatrix(c), s.setAttribute("normal", h);
    }
    if (o.uvs.forEach(function(c, h) {
      const u = h === 0 ? "uv" : `uv${h}`;
      s.setAttribute(u, new ye(o.uvs[h], 2));
    }), a.material && a.material.mappingType !== "AllSame") {
      let c = o.materialIndex[0], h = 0;
      if (o.materialIndex.forEach(function(u, d) {
        u !== c && (s.addGroup(h, d - h, c), c = u, h = d);
      }), s.groups.length > 0) {
        const u = s.groups[s.groups.length - 1], d = u.start + u.count;
        d !== o.materialIndex.length && s.addGroup(d, o.materialIndex.length - d, c);
      }
      s.groups.length === 0 && s.addGroup(0, o.materialIndex.length, o.materialIndex[0]);
    }
    return this.addMorphTargets(s, e, n, r), s;
  }
  parseGeoNode(e, t) {
    const n = {};
    if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      n.uv = [];
      let r = 0;
      for (; e.LayerElementUV[r]; )
        e.LayerElementUV[r].UV && n.uv.push(this.parseUVs(e.LayerElementUV[r])), r++;
    }
    return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(r, s) {
      r.indices.forEach(function(a, o) {
        n.weightTable[a] === void 0 && (n.weightTable[a] = []), n.weightTable[a].push({ id: s, weight: r.weights[o] });
      });
    })), n;
  }
  genBuffers(e) {
    const t = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] };
    let n = 0, r = 0, s = !1, a = [], o = [], l = [], c = [], h = [], u = [];
    const d = this;
    return e.vertexIndices.forEach(function(p, f) {
      let v, m = !1;
      p < 0 && (p = ~p, m = !0);
      let y = [], g = [];
      if (a.push(3 * p, 3 * p + 1, 3 * p + 2), e.color) {
        const _ = Pd(f, n, p, e.color);
        l.push(_[0], _[1], _[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[p] !== void 0 && e.weightTable[p].forEach(function(_) {
          g.push(_.weight), y.push(_.id);
        }), g.length > 4) {
          s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), s = !0);
          const _ = [0, 0, 0, 0], x = [0, 0, 0, 0];
          g.forEach(function(M, b) {
            let w = M, T = y[b];
            x.forEach(function(A, L, I) {
              if (w > A) {
                I[L] = w, w = A;
                const P = _[L];
                _[L] = T, T = P;
              }
            });
          }), y = _, g = x;
        }
        for (; g.length < 4; )
          g.push(0), y.push(0);
        for (let _ = 0; _ < 4; ++_)
          h.push(g[_]), u.push(y[_]);
      }
      if (e.normal) {
        const _ = Pd(f, n, p, e.normal);
        o.push(_[0], _[1], _[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (v = Pd(f, n, p, e.material)[0], v < 0 && (d.negativeMaterialIndices = !0, v = 0)), e.uv && e.uv.forEach(function(_, x) {
        const M = Pd(f, n, p, _);
        c[x] === void 0 && (c[x] = []), c[x].push(M[0]), c[x].push(M[1]);
      }), r++, m && (d.genFace(t, e, a, v, o, l, c, h, u, r), n++, r = 0, a = [], o = [], l = [], c = [], h = [], u = []);
    }), t;
  }
  getNormalNewell(e) {
    const t = new S(0, 0, 0);
    for (let n = 0; n < e.length; n++) {
      const r = e[n], s = e[(n + 1) % e.length];
      t.x += (r.y - s.y) * (r.z + s.z), t.y += (r.z - s.z) * (r.x + s.x), t.z += (r.x - s.x) * (r.y + s.y);
    }
    return t.normalize(), t;
  }
  getNormalTangentAndBitangent(e) {
    const t = this.getNormalNewell(e), n = (Math.abs(t.z) > 0.5 ? new S(0, 1, 0) : new S(0, 0, 1)).cross(t).normalize(), r = t.clone().cross(n).normalize();
    return { normal: t, tangent: n, bitangent: r };
  }
  flattenVertex(e, t, n) {
    return new Y(e.dot(t), e.dot(n));
  }
  genFace(e, t, n, r, s, a, o, l, c, h) {
    let u;
    if (h > 3) {
      const d = [], p = t.baseVertexPositions || t.vertexPositions;
      for (let y = 0; y < n.length; y += 3)
        d.push(new S(p[n[y]], p[n[y + 1]], p[n[y + 2]]));
      const { tangent: f, bitangent: v } = this.getNormalTangentAndBitangent(d), m = [];
      for (const y of d)
        m.push(this.flattenVertex(y, f, v));
      u = Vi.triangulateShape(m, []);
    } else
      u = [[0, 1, 2]];
    for (const [d, p, f] of u)
      e.vertex.push(t.vertexPositions[n[3 * d]]), e.vertex.push(t.vertexPositions[n[3 * d + 1]]), e.vertex.push(t.vertexPositions[n[3 * d + 2]]), e.vertex.push(t.vertexPositions[n[3 * p]]), e.vertex.push(t.vertexPositions[n[3 * p + 1]]), e.vertex.push(t.vertexPositions[n[3 * p + 2]]), e.vertex.push(t.vertexPositions[n[3 * f]]), e.vertex.push(t.vertexPositions[n[3 * f + 1]]), e.vertex.push(t.vertexPositions[n[3 * f + 2]]), t.skeleton && (e.vertexWeights.push(l[4 * d]), e.vertexWeights.push(l[4 * d + 1]), e.vertexWeights.push(l[4 * d + 2]), e.vertexWeights.push(l[4 * d + 3]), e.vertexWeights.push(l[4 * p]), e.vertexWeights.push(l[4 * p + 1]), e.vertexWeights.push(l[4 * p + 2]), e.vertexWeights.push(l[4 * p + 3]), e.vertexWeights.push(l[4 * f]), e.vertexWeights.push(l[4 * f + 1]), e.vertexWeights.push(l[4 * f + 2]), e.vertexWeights.push(l[4 * f + 3]), e.weightsIndices.push(c[4 * d]), e.weightsIndices.push(c[4 * d + 1]), e.weightsIndices.push(c[4 * d + 2]), e.weightsIndices.push(c[4 * d + 3]), e.weightsIndices.push(c[4 * p]), e.weightsIndices.push(c[4 * p + 1]), e.weightsIndices.push(c[4 * p + 2]), e.weightsIndices.push(c[4 * p + 3]), e.weightsIndices.push(c[4 * f]), e.weightsIndices.push(c[4 * f + 1]), e.weightsIndices.push(c[4 * f + 2]), e.weightsIndices.push(c[4 * f + 3])), t.color && (e.colors.push(a[3 * d]), e.colors.push(a[3 * d + 1]), e.colors.push(a[3 * d + 2]), e.colors.push(a[3 * p]), e.colors.push(a[3 * p + 1]), e.colors.push(a[3 * p + 2]), e.colors.push(a[3 * f]), e.colors.push(a[3 * f + 1]), e.colors.push(a[3 * f + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(r), e.materialIndex.push(r), e.materialIndex.push(r)), t.normal && (e.normal.push(s[3 * d]), e.normal.push(s[3 * d + 1]), e.normal.push(s[3 * d + 2]), e.normal.push(s[3 * p]), e.normal.push(s[3 * p + 1]), e.normal.push(s[3 * p + 2]), e.normal.push(s[3 * f]), e.normal.push(s[3 * f + 1]), e.normal.push(s[3 * f + 2])), t.uv && t.uv.forEach(function(v, m) {
        e.uvs[m] === void 0 && (e.uvs[m] = []), e.uvs[m].push(o[m][2 * d]), e.uvs[m].push(o[m][2 * d + 1]), e.uvs[m].push(o[m][2 * p]), e.uvs[m].push(o[m][2 * p + 1]), e.uvs[m].push(o[m][2 * f]), e.uvs[m].push(o[m][2 * f + 1]);
      });
  }
  addMorphTargets(e, t, n, r) {
    if (n.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const s = this;
    n.forEach(function(a) {
      a.rawTargets.forEach(function(o) {
        const l = qe.Objects.Geometry[o.geoID];
        l !== void 0 && s.genMorphGeometry(e, t, l, r, o.name);
      });
    });
  }
  genMorphGeometry(e, t, n, r, s) {
    const a = t.Vertices !== void 0 ? t.Vertices.a : [], o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], l = n.Vertices !== void 0 ? n.Vertices.a : [], c = n.Indexes !== void 0 ? n.Indexes.a : [], h = 3 * e.attributes.position.count, u = new Float32Array(h);
    for (let v = 0; v < c.length; v++) {
      const m = 3 * c[v];
      u[m] = l[3 * v], u[m + 1] = l[3 * v + 1], u[m + 2] = l[3 * v + 2];
    }
    const d = { vertexIndices: o, vertexPositions: u, baseVertexPositions: a }, p = this.genBuffers(d), f = new ye(p.vertex, 3);
    f.name = s || n.attrName, f.applyMatrix4(r), e.morphAttributes.position.push(f);
  }
  parseNormals(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, r = e.Normals.a;
    let s = [];
    return n === "IndexToDirect" && ("NormalIndex" in e ? s = e.NormalIndex.a : "NormalsIndex" in e && (s = e.NormalsIndex.a)), { dataSize: 3, buffer: r, indices: s, mappingType: t, referenceType: n };
  }
  parseUVs(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, r = e.UV.a;
    let s = [];
    return n === "IndexToDirect" && (s = e.UVIndex.a), { dataSize: 2, buffer: r, indices: s, mappingType: t, referenceType: n };
  }
  parseVertexColors(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, r = e.Colors.a;
    let s = [];
    n === "IndexToDirect" && (s = e.ColorIndex.a);
    for (let a = 0, o = new ce(); a < r.length; a += 4)
      o.fromArray(r, a).convertSRGBToLinear().toArray(r, a);
    return { dataSize: 4, buffer: r, indices: s, mappingType: t, referenceType: n };
  }
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: n };
    const r = e.Materials.a, s = [];
    for (let a = 0; a < r.length; ++a)
      s.push(a);
    return { dataSize: 1, buffer: r, indices: s, mappingType: t, referenceType: n };
  }
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Re();
    const n = t - 1, r = e.KnotVector.a, s = [], a = e.Points.a;
    for (let h = 0, u = a.length; h < u; h += 4)
      s.push(new je().fromArray(a, h));
    let o, l;
    if (e.Form === "Closed")
      s.push(s[0]);
    else if (e.Form === "Periodic") {
      o = n, l = r.length - 1 - o;
      for (let h = 0; h < n; ++h)
        s.push(s[h]);
    }
    const c = new lP(n, r, s, o, l).getPoints(12 * s.length);
    return new Re().setFromPoints(c);
  }
}
class dP {
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const n in t) {
        const r = t[n], s = this.addClip(r);
        e.push(s);
      }
    return e;
  }
  parseClips() {
    if (qe.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  parseAnimationCurveNodes() {
    const e = qe.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const n in e) {
      const r = e[n];
      if (r.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const s = { id: r.id, attr: r.attrName, curves: {} };
        t.set(s.id, s);
      }
    }
    return t;
  }
  parseAnimationCurves(e) {
    const t = qe.Objects.AnimationCurve;
    for (const n in t) {
      const r = { id: t[n].id, times: t[n].KeyTime.a.map(mP), values: t[n].KeyValueFloat.a }, s = Bt.get(r.id);
      if (s !== void 0) {
        const a = s.parents[0].ID, o = s.parents[0].relationship;
        o.match(/X/) ? e.get(a).curves.x = r : o.match(/Y/) ? e.get(a).curves.y = r : o.match(/Z/) ? e.get(a).curves.z = r : o.match(/DeformPercent/) && e.has(a) && (e.get(a).curves.morph = r);
      }
    }
  }
  parseAnimationLayers(e) {
    const t = qe.Objects.AnimationLayer, n = /* @__PURE__ */ new Map();
    for (const r in t) {
      const s = [], a = Bt.get(parseInt(r));
      a !== void 0 && (a.children.forEach(function(o, l) {
        if (e.has(o.ID)) {
          const c = e.get(o.ID);
          if (c.curves.x !== void 0 || c.curves.y !== void 0 || c.curves.z !== void 0) {
            if (s[l] === void 0) {
              const h = Bt.get(o.ID).parents.filter(function(u) {
                return u.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const u = qe.Objects.Model[h.toString()];
                if (u === void 0)
                  return void console.warn("THREE.FBXLoader: Encountered a unused curve.", o);
                const d = { modelName: u.attrName ? Ze.sanitizeNodeName(u.attrName) : "", ID: u.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] };
                Pn.traverse(function(p) {
                  p.ID === u.id && (d.transform = p.matrix, p.userData.transformData && (d.eulerOrder = p.userData.transformData.eulerOrder));
                }), d.transform || (d.transform = new fe()), "PreRotation" in u && (d.preRotation = u.PreRotation.value), "PostRotation" in u && (d.postRotation = u.PostRotation.value), s[l] = d;
              }
            }
            s[l] && (s[l][c.attr] = c);
          } else if (c.curves.morph !== void 0) {
            if (s[l] === void 0) {
              const h = Bt.get(o.ID).parents.filter(function(m) {
                return m.relationship !== void 0;
              })[0].ID, u = Bt.get(h).parents[0].ID, d = Bt.get(u).parents[0].ID, p = Bt.get(d).parents[0].ID, f = qe.Objects.Model[p], v = { modelName: f.attrName ? Ze.sanitizeNodeName(f.attrName) : "", morphName: qe.Objects.Deformer[h].attrName };
              s[l] = v;
            }
            s[l][c.attr] = c;
          }
        }
      }), n.set(parseInt(r), s));
    }
    return n;
  }
  parseAnimStacks(e) {
    const t = qe.Objects.AnimationStack, n = {};
    for (const r in t) {
      const s = Bt.get(parseInt(r)).children;
      s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const a = e.get(s[0].ID);
      n[r] = { name: t[r].attrName, layer: a };
    }
    return n;
  }
  addClip(e) {
    let t = [];
    const n = this;
    return e.layer.forEach(function(r) {
      t = t.concat(n.generateTracks(r));
    }), new da(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let n = new S(), r = new S();
    if (e.transform && e.transform.decompose(n, new Qe(), r), n = n.toArray(), r = r.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const s = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
      s !== void 0 && t.push(s);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const s = this.generateRotationTrack(e.modelName, e.R.curves, e.preRotation, e.postRotation, e.eulerOrder);
      s !== void 0 && t.push(s);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const s = this.generateVectorTrack(e.modelName, e.S.curves, r, "scale");
      s !== void 0 && t.push(s);
    }
    if (e.DeformPercent !== void 0) {
      const s = this.generateMorphTrack(e);
      s !== void 0 && t.push(s);
    }
    return t;
  }
  generateVectorTrack(e, t, n, r) {
    const s = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(s, t, n);
    return new Ms(e + "." + r, s, a);
  }
  generateRotationTrack(e, t, n, r, s) {
    let a, o;
    if (t.x !== void 0 && t.y !== void 0 && t.z !== void 0) {
      const u = this.interpolateRotations(t.x, t.y, t.z, s);
      a = u[0], o = u[1];
    }
    n !== void 0 && ((n = n.map(en.degToRad)).push(s), n = new bt().fromArray(n), n = new Qe().setFromEuler(n)), r !== void 0 && ((r = r.map(en.degToRad)).push(s), r = new bt().fromArray(r), r = new Qe().setFromEuler(r).invert());
    const l = new Qe(), c = new bt(), h = [];
    if (!o || !a)
      return new Br(e + ".quaternion", [0], [0]);
    for (let u = 0; u < o.length; u += 3)
      c.set(o[u], o[u + 1], o[u + 2], s), l.setFromEuler(c), n !== void 0 && l.premultiply(n), r !== void 0 && l.multiply(r), u > 2 && new Qe().fromArray(h, (u - 3) / 3 * 4).dot(l) < 0 && l.set(-l.x, -l.y, -l.z, -l.w), l.toArray(h, u / 3 * 4);
    return new Br(e + ".quaternion", a, h);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, n = t.values.map(function(s) {
      return s / 100;
    }), r = Pn.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new bs(e.modelName + ".morphTargetInfluences[" + r + "]", t.times, n);
  }
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, r) {
      return n - r;
    }), t.length > 1) {
      let n = 1, r = t[0];
      for (let s = 1; s < t.length; s++) {
        const a = t[s];
        a !== r && (t[n] = a, r = a, n++);
      }
      t = t.slice(0, n);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, n) {
    const r = n, s = [];
    let a = -1, o = -1, l = -1;
    return e.forEach(function(c) {
      if (t.x && (a = t.x.times.indexOf(c)), t.y && (o = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), a !== -1) {
        const h = t.x.values[a];
        s.push(h), r[0] = h;
      } else
        s.push(r[0]);
      if (o !== -1) {
        const h = t.y.values[o];
        s.push(h), r[1] = h;
      } else
        s.push(r[1]);
      if (l !== -1) {
        const h = t.z.values[l];
        s.push(h), r[2] = h;
      } else
        s.push(r[2]);
    }), s;
  }
  interpolateRotations(e, t, n, r) {
    const s = [], a = [];
    s.push(e.times[0]), a.push(en.degToRad(e.values[0])), a.push(en.degToRad(t.values[0])), a.push(en.degToRad(n.values[0]));
    for (let o = 1; o < e.values.length; o++) {
      const l = [e.values[o - 1], t.values[o - 1], n.values[o - 1]];
      if (isNaN(l[0]) || isNaN(l[1]) || isNaN(l[2]))
        continue;
      const c = l.map(en.degToRad), h = [e.values[o], t.values[o], n.values[o]];
      if (isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2]))
        continue;
      const u = h.map(en.degToRad), d = [h[0] - l[0], h[1] - l[1], h[2] - l[2]], p = [Math.abs(d[0]), Math.abs(d[1]), Math.abs(d[2])];
      if (p[0] >= 180 || p[1] >= 180 || p[2] >= 180) {
        const f = Math.max(...p) / 180, v = new bt(...c, r), m = new bt(...u, r), y = new Qe().setFromEuler(v), g = new Qe().setFromEuler(m);
        y.dot(g) && g.set(-g.x, -g.y, -g.z, -g.w);
        const _ = e.times[o - 1], x = e.times[o] - _, M = new Qe(), b = new bt();
        for (let w = 0; w < 1; w += 1 / f)
          M.copy(y.clone().slerp(g.clone(), w)), s.push(_ + w * x), b.setFromQuaternion(M, r), a.push(b.x), a.push(b.y), a.push(b.z);
      } else
        s.push(e.times[o]), a.push(en.degToRad(e.values[o])), a.push(en.degToRad(t.values[o])), a.push(en.degToRad(n.values[o]));
    }
    return [s, a];
  }
}
class pP {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new b4(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, n = e.split(/[\r\n]+/);
    return n.forEach(function(r, s) {
      const a = r.match(/^[\s\t]*;/), o = r.match(/^[\s\t]*$/);
      if (a || o)
        return;
      const l = r.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = r.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), h = r.match("^\\t{" + (t.currentIndent - 1) + "}}");
      l ? t.parseNodeBegin(r, l) : c ? t.parseNodeProperty(r, c, n[++s]) : h ? t.popStack() : r.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(r);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""), r = t[2].split(",").map(function(l) {
      return l.trim().replace(/^"/, "").replace(/"$/, "");
    }), s = { name: n }, a = this.parseNodeAttr(r), o = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(n, s) : n in o ? (n === "PoseNode" ? o.PoseNode.push(s) : o[n].id !== void 0 && (o[n] = {}, o[n][o[n].id] = o[n]), a.id !== "" && (o[n][a.id] = s)) : typeof a.id == "number" ? (o[n] = {}, o[n][a.id] = s) : n !== "Properties70" && (o[n] = n === "PoseNode" ? [s] : s), typeof a.id == "number" && (s.id = a.id), a.name !== "" && (s.attrName = a.name), a.type !== "" && (s.attrType = a.type), this.pushStack(s);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let n = "", r = "";
    return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), r = e[2]), { id: t, name: n, type: r };
  }
  parseNodeProperty(e, t, n) {
    let r = t[1].replace(/^"/, "").replace(/"$/, "").trim(), s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    r === "Content" && s === "," && (s = n.replace(/"/g, "").replace(/,$/, "").trim());
    const a = this.getCurrentNode();
    if (a.name !== "Properties70") {
      if (r === "C") {
        const o = s.split(",").slice(1), l = parseInt(o[0]), c = parseInt(o[1]);
        let h = s.split(",").slice(3);
        h = h.map(function(u) {
          return u.trim().replace(/^"/, "");
        }), r = "connections", s = [l, c], function(u, d) {
          for (let p = 0, f = u.length, v = d.length; p < v; p++, f++)
            u[f] = d[p];
        }(s, h), a[r] === void 0 && (a[r] = []);
      }
      r === "Node" && (a.id = s), r in a && Array.isArray(a[r]) ? a[r].push(s) : r !== "a" ? a[r] = s : a.a = s, this.setCurrentProp(a, r), r === "a" && s.slice(-1) !== "," && (a.a = pg(s));
    } else
      this.parseNodeSpecialProperty(e, r, s);
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = pg(t.a));
  }
  parseNodeSpecialProperty(e, t, n) {
    const r = n.split('",').map(function(h) {
      return h.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), s = r[0], a = r[1], o = r[2], l = r[3];
    let c = r[4];
    switch (a) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = pg(c);
    }
    this.getPrevNode()[s] = { type: a, type2: o, flag: l, value: c }, this.setCurrentProp(this.getPrevNode(), s);
  }
}
class fP {
  parse(e) {
    const t = new Vb(e);
    t.skip(23);
    const n = t.getUint32();
    if (n < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
    const r = new b4();
    for (; !this.endOfContent(t); ) {
      const s = this.parseNode(t, n);
      s !== null && r.add(s.name, s);
    }
    return r;
  }
  endOfContent(e) {
    return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  parseNode(e, t) {
    const n = {}, r = t >= 7500 ? e.getUint64() : e.getUint32(), s = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const a = e.getUint8(), o = e.getString(a);
    if (r === 0)
      return null;
    const l = [];
    for (let d = 0; d < s; d++)
      l.push(this.parseProperty(e));
    const c = l.length > 0 ? l[0] : "", h = l.length > 1 ? l[1] : "", u = l.length > 2 ? l[2] : "";
    for (n.singleProperty = s === 1 && e.getOffset() === r; r > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(o, n, d);
    }
    return n.propertyList = l, typeof c == "number" && (n.id = c), h !== "" && (n.attrName = h), u !== "" && (n.attrType = u), o !== "" && (n.name = o), n;
  }
  parseSubNode(e, t, n) {
    if (n.singleProperty === !0) {
      const r = n.propertyList[0];
      Array.isArray(r) ? (t[n.name] = n, n.a = r) : t[n.name] = r;
    } else if (e === "Connections" && n.name === "C") {
      const r = [];
      n.propertyList.forEach(function(s, a) {
        a !== 0 && r.push(s);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(r);
    } else if (n.name === "Properties70")
      Object.keys(n).forEach(function(r) {
        t[r] = n[r];
      });
    else if (e === "Properties70" && n.name === "P") {
      let r = n.propertyList[0], s = n.propertyList[1];
      const a = n.propertyList[2], o = n.propertyList[3];
      let l;
      r.indexOf("Lcl ") === 0 && (r = r.replace("Lcl ", "Lcl_")), s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), l = s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], t[r] = { type: s, type2: a, flag: o, value: l };
    } else
      t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let n;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return n = e.getUint32(), e.getArrayBuffer(n);
      case "S":
        return n = e.getUint32(), e.getString(n);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const r = e.getUint32(), s = e.getUint32(), a = e.getUint32();
        if (s === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(r);
            case "d":
              return e.getFloat64Array(r);
            case "f":
              return e.getFloat32Array(r);
            case "i":
              return e.getInt32Array(r);
            case "l":
              return e.getInt64Array(r);
          }
        const o = rP(new Uint8Array(e.getArrayBuffer(a))), l = new Vb(o.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(r);
          case "d":
            return l.getFloat64Array(r);
          case "f":
            return l.getFloat32Array(r);
          case "i":
            return l.getInt32Array(r);
          case "l":
            return l.getInt64Array(r);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class Vb {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t === void 0 || t, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  getBoolean() {
    return !(1 & ~this.getUint8());
  }
  getBooleanArray(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, e = 4294967295 & ~e, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(4294967296 * t + e)) : 4294967296 * t + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt64());
    return t;
  }
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let n = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const r = n.indexOf(0);
    return r >= 0 && (n = new Uint8Array(this.dv.buffer, t, r)), this._textDecoder.decode(n);
  }
}
class b4 {
  add(e, t) {
    this[e] = t;
  }
}
function jb(i) {
  const e = i.match(/FBXVersion: (\d+)/);
  if (e)
    return parseInt(e[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function mP(i) {
  return i / 46186158e3;
}
const gP = [];
function Pd(i, e, t, n) {
  let r;
  switch (n.mappingType) {
    case "ByPolygonVertex":
      r = i;
      break;
    case "ByPolygon":
      r = e;
      break;
    case "ByVertice":
      r = t;
      break;
    case "AllSame":
      r = n.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType);
  }
  n.referenceType === "IndexToDirect" && (r = n.indices[r]);
  const s = r * n.dataSize, a = s + n.dataSize;
  return function(o, l, c, h) {
    for (let u = c, d = 0; u < h; u++, d++)
      o[d] = l[u];
    return o;
  }(gP, n.buffer, s, a);
}
const dg = new bt(), Ro = new S();
function M4(i) {
  const e = new fe(), t = new fe(), n = new fe(), r = new fe(), s = new fe(), a = new fe(), o = new fe(), l = new fe(), c = new fe(), h = new fe(), u = new fe(), d = new fe(), p = i.inheritType ? i.inheritType : 0;
  if (i.translation && e.setPosition(Ro.fromArray(i.translation)), i.preRotation) {
    const L = i.preRotation.map(en.degToRad);
    L.push(i.eulerOrder || bt.DEFAULT_ORDER), t.makeRotationFromEuler(dg.fromArray(L));
  }
  if (i.rotation) {
    const L = i.rotation.map(en.degToRad);
    L.push(i.eulerOrder || bt.DEFAULT_ORDER), n.makeRotationFromEuler(dg.fromArray(L));
  }
  if (i.postRotation) {
    const L = i.postRotation.map(en.degToRad);
    L.push(i.eulerOrder || bt.DEFAULT_ORDER), r.makeRotationFromEuler(dg.fromArray(L)), r.invert();
  }
  i.scale && s.scale(Ro.fromArray(i.scale)), i.scalingOffset && o.setPosition(Ro.fromArray(i.scalingOffset)), i.scalingPivot && a.setPosition(Ro.fromArray(i.scalingPivot)), i.rotationOffset && l.setPosition(Ro.fromArray(i.rotationOffset)), i.rotationPivot && c.setPosition(Ro.fromArray(i.rotationPivot)), i.parentMatrixWorld && (u.copy(i.parentMatrix), h.copy(i.parentMatrixWorld));
  const f = t.clone().multiply(n).multiply(r), v = new fe();
  v.extractRotation(h);
  const m = new fe();
  m.copyPosition(h);
  const y = m.clone().invert().multiply(h), g = v.clone().invert().multiply(y), _ = s, x = new fe();
  if (p === 0)
    x.copy(v).multiply(f).multiply(g).multiply(_);
  else if (p === 1)
    x.copy(v).multiply(g).multiply(f).multiply(_);
  else {
    const L = new fe().scale(new S().setFromMatrixScale(u)).clone().invert(), I = g.clone().multiply(L);
    x.copy(v).multiply(f).multiply(I).multiply(_);
  }
  const M = c.clone().invert(), b = a.clone().invert();
  let w = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(r).multiply(M).multiply(o).multiply(a).multiply(s).multiply(b);
  const T = new fe().copyPosition(w), A = h.clone().multiply(T);
  return d.copyPosition(A), w = d.clone().multiply(x), w.premultiply(h.invert()), w;
}
function w4(i) {
  const e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
  return (i = i || 0) === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[i];
}
function pg(i) {
  return i.split(",").map(function(e) {
    return parseFloat(e);
  });
}
function Wb(i, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = i.byteLength), new TextDecoder().decode(new Uint8Array(i, e, t));
}
function Xb(i, e) {
  if (e === 0)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), i;
  if (e === 2 || e === 1) {
    let t = i.getIndex();
    if (t === null) {
      const a = [], o = i.getAttribute("position");
      if (o === void 0)
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i;
      for (let l = 0; l < o.count; l++)
        a.push(l);
      i.setIndex(a), t = i.getIndex();
    }
    const n = t.count - 2, r = [];
    if (e === 2)
      for (let a = 1; a <= n; a++)
        r.push(t.getX(0)), r.push(t.getX(a)), r.push(t.getX(a + 1));
    else
      for (let a = 0; a < n; a++)
        a % 2 == 0 ? (r.push(t.getX(a)), r.push(t.getX(a + 1)), r.push(t.getX(a + 2))) : (r.push(t.getX(a + 2)), r.push(t.getX(a + 1)), r.push(t.getX(a)));
    r.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = i.clone();
    return s.setIndex(r), s.clearGroups(), s;
  }
  return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), i;
}
class vP extends Lt {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new MP(t);
    }), this.register(function(t) {
      return new wP(t);
    }), this.register(function(t) {
      return new LP(t);
    }), this.register(function(t) {
      return new DP(t);
    }), this.register(function(t) {
      return new NP(t);
    }), this.register(function(t) {
      return new TP(t);
    }), this.register(function(t) {
      return new EP(t);
    }), this.register(function(t) {
      return new AP(t);
    }), this.register(function(t) {
      return new IP(t);
    }), this.register(function(t) {
      return new bP(t);
    }), this.register(function(t) {
      return new CP(t);
    }), this.register(function(t) {
      return new SP(t);
    }), this.register(function(t) {
      return new PP(t);
    }), this.register(function(t) {
      return new RP(t);
    }), this.register(function(t) {
      return new _P(t);
    }), this.register(function(t) {
      return new OP(t);
    }), this.register(function(t) {
      return new UP(t);
    });
  }
  load(e, t, n, r) {
    const s = this;
    let a;
    if (this.resourcePath !== "")
      a = this.resourcePath;
    else if (this.path !== "") {
      const c = cr.extractUrlBase(e);
      a = cr.resolveURL(c, this.path);
    } else
      a = cr.extractUrlBase(e);
    this.manager.itemStart(e);
    const o = function(c) {
      r ? r(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e);
    }, l = new xn(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        s.parse(c, a, function(h) {
          t(h), s.manager.itemEnd(e);
        }, o);
      } catch (h) {
        o(h);
      }
    }, n, o);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, r) {
    let s;
    const a = {}, o = {}, l = new TextDecoder();
    if (typeof e == "string")
      s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === S4) {
        try {
          a[Je.KHR_BINARY_GLTF] = new BP(e);
        } catch (h) {
          return void (r && r(h));
        }
        s = JSON.parse(a[Je.KHR_BINARY_GLTF].content);
      } else
        s = JSON.parse(l.decode(e));
    else
      s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2)
      return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
    const c = new JP(s, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const u = this.pluginCallbacks[h](c);
      u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[u.name] = u, a[u.name] = !0;
    }
    if (s.extensionsUsed)
      for (let h = 0; h < s.extensionsUsed.length; ++h) {
        const u = s.extensionsUsed[h], d = s.extensionsRequired || [];
        switch (u) {
          case Je.KHR_MATERIALS_UNLIT:
            a[u] = new xP();
            break;
          case Je.KHR_DRACO_MESH_COMPRESSION:
            a[u] = new zP(s, this.dracoLoader);
            break;
          case Je.KHR_TEXTURE_TRANSFORM:
            a[u] = new HP();
            break;
          case Je.KHR_MESH_QUANTIZATION:
            a[u] = new GP();
            break;
          default:
            d.indexOf(u) >= 0 && o[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    c.setExtensions(a), c.setPlugins(o), c.parse(n, r);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(r, s) {
      n.parse(e, t, r, s);
    });
  }
}
function yP() {
  let i = {};
  return { get: function(e) {
    return i[e];
  }, add: function(e, t) {
    i[e] = t;
  }, remove: function(e) {
    delete i[e];
  }, removeAll: function() {
    i = {};
  } };
}
const Je = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_MATERIALS_BUMP: "EXT_materials_bump", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" };
class _P {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let r = t.cache.get(n);
    if (r)
      return r;
    const s = t.json, a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
    let o;
    const l = new ce(16777215);
    a.color !== void 0 && l.setRGB(a.color[0], a.color[1], a.color[2], on);
    const c = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        o = new ph(l), o.target.position.set(0, 0, -1), o.add(o.target);
        break;
      case "point":
        o = new vl(l), o.distance = c;
        break;
      case "spot":
        o = new dh(l), o.distance = c, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, o.angle = a.spot.outerConeAngle, o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return o.position.set(0, 0, 0), o.decay = 2, wr(o, a), a.intensity !== void 0 && (o.intensity = a.intensity), o.name = t.createUniqueName(a.name || "light_" + e), r = Promise.resolve(o), t.cache.add(n, r), r;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, r = n.json.nodes[e], s = (r.extensions && r.extensions[this.name] || {}).light;
    return s === void 0 ? null : this._loadLight(s).then(function(a) {
      return n._getNodeRef(t.cache, s, a);
    });
  }
}
class xP {
  constructor() {
    this.name = Je.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return nn;
  }
  extendParams(e, t, n) {
    const r = [];
    e.color = new ce(1, 1, 1), e.opacity = 1;
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const a = s.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], on), e.opacity = a[3];
      }
      s.baseColorTexture !== void 0 && r.push(n.assignTexture(e, "map", s.baseColorTexture, yt));
    }
    return Promise.all(r);
  }
}
class bP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = n.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class MP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, r = n.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Y(o, o);
    }
    return Promise.all(s);
  }
}
class wP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = n.extensions[this.name];
    return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
  }
}
class SP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, r = n.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(s);
  }
}
class TP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, r = n.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [];
    t.sheenColor = new ce(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const a = r.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const o = a.sheenColorFactor;
      t.sheenColor.setRGB(o[0], o[1], o[2], on);
    }
    return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && s.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, yt)), a.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s);
  }
}
class EP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, r = n.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && s.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(s);
  }
}
class AP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, r = n.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && s.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
    const o = a.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new ce().setRGB(o[0], o[1], o[2], on), Promise.all(s);
  }
}
class IP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = n.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}
class CP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, r = n.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && s.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return t.specularColor = new ce().setRGB(o[0], o[1], o[2], on), a.specularColorTexture !== void 0 && s.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, yt)), Promise.all(s);
  }
}
class RP {
  constructor(e) {
    this.parser = e, this.name = Je.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, r = n.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && s.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(s);
  }
}
class PP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Ai : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, r = n.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && s.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(s);
  }
}
class LP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, r = n.textures[e];
    if (!r.extensions || !r.extensions[this.name])
      return null;
    const s = r.extensions[this.name], a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, s.source, a);
  }
}
class DP {
  constructor(e) {
    this.parser = e, this.name = Je.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, r = n.json, s = r.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const a = s.extensions[t], o = r.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, a.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class NP {
  constructor(e) {
    this.parser = e, this.name = Je.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, r = n.json, s = r.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const a = s.extensions[t], o = r.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, a.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class OP {
  constructor(e) {
    this.name = Je.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const r = n.extensions[this.name], s = this.parser.getDependency("buffer", r.buffer), a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return s.then(function(o) {
        const l = r.byteOffset || 0, c = r.byteLength || 0, h = r.count, u = r.byteStride, d = new Uint8Array(o, l, c);
        return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(h, u, d, r.mode, r.filter).then(function(p) {
          return p.buffer;
        }) : a.ready.then(function() {
          const p = new ArrayBuffer(h * u);
          return a.decodeGltfBuffer(new Uint8Array(p), h, u, d, r.mode, r.filter), p;
        });
      });
    }
    return null;
  }
}
class UP {
  constructor(e) {
    this.name = Je.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const r = t.meshes[n.mesh];
    for (const l of r.primitives)
      if (l.mode !== yi.TRIANGLES && l.mode !== yi.TRIANGLE_STRIP && l.mode !== yi.TRIANGLE_FAN && l.mode !== void 0)
        return null;
    const s = n.extensions[this.name].attributes, a = [], o = {};
    for (const l in s)
      a.push(this.parser.getDependency("accessor", s[l]).then((c) => (o[l] = c, o[l])));
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((l) => {
      const c = l.pop(), h = c.isGroup ? c.children : [c], u = l[0].count, d = [];
      for (const p of h) {
        const f = new fe(), v = new S(), m = new Qe(), y = new S(1, 1, 1), g = new u0(p.geometry, p.material, u);
        for (let _ = 0; _ < u; _++)
          o.TRANSLATION && v.fromBufferAttribute(o.TRANSLATION, _), o.ROTATION && m.fromBufferAttribute(o.ROTATION, _), o.SCALE && y.fromBufferAttribute(o.SCALE, _), g.setMatrixAt(_, f.compose(v, m, y));
        for (const _ in o)
          if (_ === "_COLOR_0") {
            const x = o[_];
            g.instanceColor = new Sa(x.array, x.itemSize, x.normalized);
          } else
            _ !== "TRANSLATION" && _ !== "ROTATION" && _ !== "SCALE" && p.geometry.setAttribute(_, o[_]);
        Fe.prototype.copy.call(g, p), this.parser.assignFinalMaterial(g), d.push(g);
      }
      return c.isGroup ? (c.clear(), c.add(...d), c) : d[0];
    }));
  }
}
const S4 = "glTF", kP = 1313821514, FP = 5130562;
class BP {
  constructor(e) {
    this.name = Je.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, 12), n = new TextDecoder();
    if (this.header = { magic: n.decode(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== S4)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const r = this.header.length - 12, s = new DataView(e, 12);
    let a = 0;
    for (; a < r; ) {
      const o = s.getUint32(a, !0);
      a += 4;
      const l = s.getUint32(a, !0);
      if (a += 4, l === kP) {
        const c = new Uint8Array(e, 12 + a, o);
        this.content = n.decode(c);
      } else if (l === FP) {
        const c = 12 + a;
        this.body = e.slice(c, c + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class zP {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Je.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, r = this.dracoLoader, s = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, c = {};
    for (const h in a) {
      const u = Y0[h] || h.toLowerCase();
      o[u] = a[h];
    }
    for (const h in e.attributes) {
      const u = Y0[h] || h.toLowerCase();
      if (a[h] !== void 0) {
        const d = n.accessors[e.attributes[h]], p = sl[d.componentType];
        c[u] = p.name, l[u] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", s).then(function(h) {
      return new Promise(function(u, d) {
        r.decodeDracoFile(h, function(p) {
          for (const f in p.attributes) {
            const v = p.attributes[f], m = l[f];
            m !== void 0 && (v.normalized = m);
          }
          u(p);
        }, o, c, on, d);
      });
    });
  }
}
class HP {
  constructor() {
    this.name = Je.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord !== void 0 && t.texCoord !== e.channel || t.offset !== void 0 || t.rotation !== void 0 || t.scale !== void 0) && (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class GP {
  constructor() {
    this.name = Je.KHR_MESH_QUANTIZATION;
  }
}
class T4 extends Rl {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = e * r * 3 + r;
    for (let a = 0; a !== r; a++)
      t[a] = n[s + a];
    return t;
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = 2 * o, c = 3 * o, h = r - t, u = (n - t) / h, d = u * u, p = d * u, f = e * c, v = f - c, m = -2 * p + 3 * d, y = p - d, g = 1 - m, _ = y - d + u;
    for (let x = 0; x !== o; x++) {
      const M = a[v + x + o], b = a[v + x + l] * h, w = a[f + x + o], T = a[f + x] * h;
      s[x] = g * M + _ * b + m * w + y * T;
    }
    return s;
  }
}
const VP = new Qe();
class jP extends T4 {
  interpolate_(e, t, n, r) {
    const s = super.interpolate_(e, t, n, r);
    return VP.fromArray(s).normalize().toArray(s), s;
  }
}
const yi = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, sl = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, qb = { 9728: lt, 9729: Gt, 9984: jp, 9985: Zo, 9986: ma, 9987: zi }, Yb = { 33071: ri, 33648: Fa, 10497: In }, fg = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, Y0 = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, $r = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, WP = { CUBICSPLINE: void 0, LINEAR: ul, STEP: hl }, XP = "OPAQUE", qP = "MASK", YP = "BLEND";
function ea(i, e, t) {
  for (const n in t.extensions)
    i[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function wr(i, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(i.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function ZP(i, e) {
  if (i.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      i.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (i.morphTargetInfluences.length === t.length) {
      i.morphTargetDictionary = {};
      for (let n = 0, r = t.length; n < r; n++)
        i.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function KP(i) {
  let e;
  const t = i.extensions && i.extensions[Je.KHR_DRACO_MESH_COMPRESSION];
  if (e = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + mg(t.attributes) : i.indices + ":" + mg(i.attributes) + ":" + i.mode, i.targets !== void 0)
    for (let n = 0, r = i.targets.length; n < r; n++)
      e += ":" + mg(i.targets[n]);
  return e;
}
function mg(i) {
  let e = "";
  const t = Object.keys(i).sort();
  for (let n = 0, r = t.length; n < r; n++)
    e += t[n] + ":" + i[t[n]] + ";";
  return e;
}
function Z0(i) {
  switch (i) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
const QP = new fe();
class JP {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new yP(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, r = !1, s = -1;
    typeof navigator != "undefined" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, r = navigator.userAgent.indexOf("Firefox") > -1, s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap == "undefined" || n || r && s < 98 ? this.textureLoader = new Va(this.options.manager) : this.textureLoader = new gw(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new xn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, r = this.json, s = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
      return a._markDefs && a._markDefs();
    }), Promise.all(this._invokeAll(function(a) {
      return a.beforeRoot && a.beforeRoot();
    })).then(function() {
      return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]);
    }).then(function(a) {
      const o = { scene: a[0][r.scene || 0], scenes: a[0], animations: a[1], cameras: a[2], asset: r.asset, parser: n, userData: {} };
      return ea(s, o, r), wr(o, r), Promise.all(n._invokeAll(function(l) {
        return l.afterRoot && l.afterRoot(o);
      })).then(function() {
        for (const l of o.scenes)
          l.updateMatrixWorld();
        e(o);
      });
    }).catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let r = 0, s = t.length; r < s; r++) {
      const a = t[r].joints;
      for (let o = 0, l = a.length; o < l; o++)
        e[a[o]].isBone = !0;
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const a = e[r];
      a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1)
      return n;
    const r = n.clone(), s = (a, o) => {
      const l = this.associations.get(a);
      l != null && this.associations.set(o, l);
      for (const [c, h] of a.children.entries())
        s(h, o.children[c]);
    };
    return s(n, r), r.name += "_instance_" + e.uses[t]++, r;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const r = e(t[n]);
      if (r)
        return r;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r]);
      s && n.push(s);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let r = this.cache.get(n);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this._invokeOne(function(s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          r = this._invokeOne(function(s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this._invokeOne(function(s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this._invokeOne(function(s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          r = this._invokeOne(function(s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this._invokeOne(function(s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          if (r = this._invokeOne(function(s) {
            return s != this && s.getDependency && s.getDependency(e, t);
          }), !r)
            throw new Error("Unknown type: " + e);
      }
      this.cache.add(n, r);
    }
    return r;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(r.map(function(s, a) {
        return n.getDependency(e, a);
      })), this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Je.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function(s, a) {
      n.load(cr.resolveURL(t.uri, r.path), s, void 0, function() {
        a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const r = t.byteLength || 0, s = t.byteOffset || 0;
      return n.slice(s, s + r);
    });
  }
  loadAccessor(e) {
    const t = this, n = this.json, r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const a = fg[r.type], o = sl[r.componentType], l = r.normalized === !0, c = new o(r.count * a);
      return Promise.resolve(new it(c, a, l));
    }
    const s = [];
    return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function(a) {
      const o = a[0], l = fg[r.type], c = sl[r.componentType], h = c.BYTES_PER_ELEMENT, u = h * l, d = r.byteOffset || 0, p = r.bufferView !== void 0 ? n.bufferViews[r.bufferView].byteStride : void 0, f = r.normalized === !0;
      let v, m;
      if (p && p !== u) {
        const y = Math.floor(d / p), g = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + y + ":" + r.count;
        let _ = t.cache.get(g);
        _ || (v = new c(o, y * p, r.count * p / h), _ = new zh(v, p / h), t.cache.add(g, _)), m = new Gn(_, l, d % p / h, f);
      } else
        v = o === null ? new c(r.count * l) : new c(o, d, r.count * l), m = new it(v, l, f);
      if (r.sparse !== void 0) {
        const y = fg.SCALAR, g = sl[r.sparse.indices.componentType], _ = r.sparse.indices.byteOffset || 0, x = r.sparse.values.byteOffset || 0, M = new g(a[1], _, r.sparse.count * y), b = new c(a[2], x, r.sparse.count * l);
        o !== null && (m = new it(m.array.slice(), m.itemSize, m.normalized));
        for (let w = 0, T = M.length; w < T; w++) {
          const A = M[w];
          if (m.setX(A, b[w * l]), l >= 2 && m.setY(A, b[w * l + 1]), l >= 3 && m.setZ(A, b[w * l + 2]), l >= 4 && m.setW(A, b[w * l + 3]), l >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return m;
    });
  }
  loadTexture(e) {
    const t = this.json, n = this.options, r = t.textures[e].source, s = t.images[r];
    let a = this.textureLoader;
    if (s.uri) {
      const o = n.manager.getHandler(s.uri);
      o !== null && (a = o);
    }
    return this.loadTextureImage(e, r, a);
  }
  loadTextureImage(e, t, n) {
    const r = this, s = this.json, a = s.textures[e], o = s.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, n).then(function(h) {
      h.flipY = !1, h.name = a.name || o.name || "", h.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (h.name = o.uri);
      const u = (s.samplers || {})[a.sampler] || {};
      return h.magFilter = qb[u.magFilter] || Gt, h.minFilter = qb[u.minFilter] || zi, h.wrapS = Yb[u.wrapS] || In, h.wrapT = Yb[u.wrapT] || In, r.associations.set(h, { textures: e }), h;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const n = this, r = this.json, s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((u) => u.clone());
    const a = r.images[e], o = self.URL || self.webkitURL;
    let l = a.uri || "", c = !1;
    if (a.bufferView !== void 0)
      l = n.getDependency("bufferView", a.bufferView).then(function(u) {
        c = !0;
        const d = new Blob([u], { type: a.mimeType });
        return l = o.createObjectURL(d), l;
      });
    else if (a.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const h = Promise.resolve(l).then(function(u) {
      return new Promise(function(d, p) {
        let f = d;
        t.isImageBitmapLoader === !0 && (f = function(v) {
          const m = new vt(v);
          m.needsUpdate = !0, d(m);
        }), t.load(cr.resolveURL(u, s.path), f, void 0, p);
      });
    }).then(function(u) {
      var d;
      return c === !0 && o.revokeObjectURL(l), wr(u, a), u.userData.mimeType = a.mimeType || ((d = a.uri).search(/\.jpe?g($|\?)/i) > 0 || d.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : d.search(/\.webp($|\?)/i) > 0 || d.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"), u;
    }).catch(function(u) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), u;
    });
    return this.sourceCache[e] = h, h;
  }
  assignTexture(e, t, n, r) {
    const s = this;
    return this.getDependency("texture", n.index).then(function(a) {
      if (!a)
        return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && ((a = a.clone()).channel = n.texCoord), s.extensions[Je.KHR_TEXTURE_TRANSFORM]) {
        const o = n.extensions !== void 0 ? n.extensions[Je.KHR_TEXTURE_TRANSFORM] : void 0;
        if (o) {
          const l = s.associations.get(a);
          a = s.extensions[Je.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), s.associations.set(a, l);
        }
      }
      return r !== void 0 && (a.colorSpace = r), e[t] = a, a;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const r = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l || (l = new ss(), Wt.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(o, l)), n = l;
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l || (l = new zt(), Wt.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(o, l)), n = l;
    }
    if (r || s || a) {
      let o = "ClonedMaterial:" + n.uuid + ":";
      r && (o += "derivative-tangents:"), s && (o += "vertex-colors:"), a && (o += "flat-shading:");
      let l = this.cache.get(o);
      l || (l = n.clone(), s && (l.vertexColors = !0), a && (l.flatShading = !0), r && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(n))), n = l;
    }
    e.material = n;
  }
  getMaterialType() {
    return uh;
  }
  loadMaterial(e) {
    const t = this, n = this.json, r = this.extensions, s = n.materials[e];
    let a;
    const o = {}, l = [];
    if ((s.extensions || {})[Je.KHR_MATERIALS_UNLIT]) {
      const h = r[Je.KHR_MATERIALS_UNLIT];
      a = h.getMaterialType(), l.push(h.extendParams(o, s, t));
    } else {
      const h = s.pbrMetallicRoughness || {};
      if (o.color = new ce(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const u = h.baseColorFactor;
        o.color.setRGB(u[0], u[1], u[2], on), o.opacity = u[3];
      }
      h.baseColorTexture !== void 0 && l.push(t.assignTexture(o, "map", h.baseColorTexture, yt)), o.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, o.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), l.push(t.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), a = this._invokeOne(function(u) {
        return u.getMaterialType && u.getMaterialType(e);
      }), l.push(Promise.all(this._invokeAll(function(u) {
        return u.extendMaterialParams && u.extendMaterialParams(e, o);
      })));
    }
    s.doubleSided === !0 && (o.side = tn);
    const c = s.alphaMode || XP;
    if (c === YP ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, c === qP && (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && a !== nn && (l.push(t.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new Y(1, 1), s.normalTexture.scale !== void 0)) {
      const h = s.normalTexture.scale;
      o.normalScale.set(h, h);
    }
    if (s.occlusionTexture !== void 0 && a !== nn && (l.push(t.assignTexture(o, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && a !== nn) {
      const h = s.emissiveFactor;
      o.emissive = new ce().setRGB(h[0], h[1], h[2], on);
    }
    return s.emissiveTexture !== void 0 && a !== nn && l.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, yt)), Promise.all(l).then(function() {
      const h = new a(o);
      return s.name && (h.name = s.name), wr(h, s), t.associations.set(h, { materials: e }), s.extensions && ea(r, h, s), h;
    });
  }
  createUniqueName(e) {
    const t = Ze.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  loadGeometries(e) {
    const t = this, n = this.extensions, r = this.primitiveCache;
    function s(o) {
      return n[Je.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
        return Zb(l, o, t);
      });
    }
    const a = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], h = KP(c), u = r[h];
      if (u)
        a.push(u.promise);
      else {
        let d;
        d = c.extensions && c.extensions[Je.KHR_DRACO_MESH_COMPRESSION] ? s(c) : Zb(new Re(), c, t), r[h] = { primitive: c, promise: d }, a.push(d);
      }
    }
    return Promise.all(a);
  }
  loadMesh(e) {
    const t = this, n = this.json, r = this.extensions, s = n.meshes[e], a = s.primitives, o = [];
    for (let c = 0, h = a.length; c < h; c++) {
      const u = a[c].material === void 0 ? ((l = this.cache).DefaultMaterial === void 0 && (l.DefaultMaterial = new uh({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: Gi })), l.DefaultMaterial) : this.getDependency("material", a[c].material);
      o.push(u);
    }
    var l;
    return o.push(t.loadGeometries(a)), Promise.all(o).then(function(c) {
      const h = c.slice(0, c.length - 1), u = c[c.length - 1], d = [];
      for (let f = 0, v = u.length; f < v; f++) {
        const m = u[f], y = a[f];
        let g;
        const _ = h[f];
        if (y.mode === yi.TRIANGLES || y.mode === yi.TRIANGLE_STRIP || y.mode === yi.TRIANGLE_FAN || y.mode === void 0)
          g = s.isSkinnedMesh === !0 ? new hp(m, _) : new ve(m, _), g.isSkinnedMesh === !0 && g.normalizeSkinWeights(), y.mode === yi.TRIANGLE_STRIP ? g.geometry = Xb(g.geometry, 1) : y.mode === yi.TRIANGLE_FAN && (g.geometry = Xb(g.geometry, 2));
        else if (y.mode === yi.LINES)
          g = new Qn(m, _);
        else if (y.mode === yi.LINE_STRIP)
          g = new dn(m, _);
        else if (y.mode === yi.LINE_LOOP)
          g = new d0(m, _);
        else {
          if (y.mode !== yi.POINTS)
            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + y.mode);
          g = new Qo(m, _);
        }
        Object.keys(g.geometry.morphAttributes).length > 0 && ZP(g, s), g.name = t.createUniqueName(s.name || "mesh_" + e), wr(g, s), y.extensions && ea(r, g, y), t.assignFinalMaterial(g), d.push(g);
      }
      for (let f = 0, v = d.length; f < v; f++)
        t.associations.set(d[f], { meshes: e, primitives: f });
      if (d.length === 1)
        return s.extensions && ea(r, d[0], s), d[0];
      const p = new oi();
      s.extensions && ea(r, p, s), t.associations.set(p, { meshes: e });
      for (let f = 0, v = d.length; f < v; f++)
        p.add(d[f]);
      return p;
    });
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], r = n[n.type];
    if (r)
      return n.type === "perspective" ? t = new jt(en.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : n.type === "orthographic" && (t = new Ha(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), wr(t, n), Promise.resolve(t);
    console.warn("THREE.GLTFLoader: Missing camera parameters.");
  }
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let r = 0, s = t.joints.length; r < s; r++)
      n.push(this._loadNodeShallow(t.joints[r]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(r) {
      const s = r.pop(), a = r, o = [], l = [];
      for (let c = 0, h = a.length; c < h; c++) {
        const u = a[c];
        if (u) {
          o.push(u);
          const d = new fe();
          s !== null && d.fromArray(s.array, 16 * c), l.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new ml(o, l);
    });
  }
  loadAnimation(e) {
    const t = this.json, n = this, r = t.animations[e], s = r.name ? r.name : "animation_" + e, a = [], o = [], l = [], c = [], h = [];
    for (let u = 0, d = r.channels.length; u < d; u++) {
      const p = r.channels[u], f = r.samplers[p.sampler], v = p.target, m = v.node, y = r.parameters !== void 0 ? r.parameters[f.input] : f.input, g = r.parameters !== void 0 ? r.parameters[f.output] : f.output;
      v.node !== void 0 && (a.push(this.getDependency("node", m)), o.push(this.getDependency("accessor", y)), l.push(this.getDependency("accessor", g)), c.push(f), h.push(v));
    }
    return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l), Promise.all(c), Promise.all(h)]).then(function(u) {
      const d = u[0], p = u[1], f = u[2], v = u[3], m = u[4], y = [];
      for (let g = 0, _ = d.length; g < _; g++) {
        const x = d[g], M = p[g], b = f[g], w = v[g], T = m[g];
        if (x === void 0)
          continue;
        x.updateMatrix && x.updateMatrix();
        const A = n._createAnimationTracks(x, M, b, w, T);
        if (A)
          for (let L = 0; L < A.length; L++)
            y.push(A[L]);
      }
      return new da(s, void 0, y);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, r = t.nodes[e];
    return r.mesh === void 0 ? null : n.getDependency("mesh", r.mesh).then(function(s) {
      const a = n._getNodeRef(n.meshCache, r.mesh, s);
      return r.weights !== void 0 && a.traverse(function(o) {
        if (o.isMesh)
          for (let l = 0, c = r.weights.length; l < c; l++)
            o.morphTargetInfluences[l] = r.weights[l];
      }), a;
    });
  }
  loadNode(e) {
    const t = this, n = this.json.nodes[e], r = t._loadNodeShallow(e), s = [], a = n.children || [];
    for (let l = 0, c = a.length; l < c; l++)
      s.push(t.getDependency("node", a[l]));
    const o = n.skin === void 0 ? Promise.resolve(null) : t.getDependency("skin", n.skin);
    return Promise.all([r, Promise.all(s), o]).then(function(l) {
      const c = l[0], h = l[1], u = l[2];
      u !== null && c.traverse(function(d) {
        d.isSkinnedMesh && d.bind(u, QP);
      });
      for (let d = 0, p = h.length; d < p; d++)
        c.add(h[d]);
      return c;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, r = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const s = t.nodes[e], a = s.name ? r.createUniqueName(s.name) : "", o = [], l = r._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && o.push(l), s.camera !== void 0 && o.push(r.getDependency("camera", s.camera).then(function(c) {
      return r._getNodeRef(r.cameraCache, s.camera, c);
    })), r._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      o.push(c);
    }), this.nodeCache[e] = Promise.all(o).then(function(c) {
      let h;
      if (h = s.isBone === !0 ? new fl() : c.length > 1 ? new oi() : c.length === 1 ? c[0] : new Fe(), h !== c[0])
        for (let u = 0, d = c.length; u < d; u++)
          h.add(c[u]);
      if (s.name && (h.userData.name = s.name, h.name = a), wr(h, s), s.extensions && ea(n, h, s), s.matrix !== void 0) {
        const u = new fe();
        u.fromArray(s.matrix), h.applyMatrix4(u);
      } else
        s.translation !== void 0 && h.position.fromArray(s.translation), s.rotation !== void 0 && h.quaternion.fromArray(s.rotation), s.scale !== void 0 && h.scale.fromArray(s.scale);
      return r.associations.has(h) || r.associations.set(h, {}), r.associations.get(h).nodes = e, h;
    }), this.nodeCache[e];
  }
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], r = this, s = new oi();
    n.name && (s.name = r.createUniqueName(n.name)), wr(s, n), n.extensions && ea(t, s, n);
    const a = n.nodes || [], o = [];
    for (let l = 0, c = a.length; l < c; l++)
      o.push(r.getDependency("node", a[l]));
    return Promise.all(o).then(function(l) {
      for (let c = 0, h = l.length; c < h; c++)
        s.add(l[c]);
      return r.associations = ((c) => {
        const h = /* @__PURE__ */ new Map();
        for (const [u, d] of r.associations)
          (u instanceof Wt || u instanceof vt) && h.set(u, d);
        return c.traverse((u) => {
          const d = r.associations.get(u);
          d != null && h.set(u, d);
        }), h;
      })(s), s;
    });
  }
  _createAnimationTracks(e, t, n, r, s) {
    const a = [], o = e.name ? e.name : e.uuid, l = [];
    let c;
    switch ($r[s.path] === $r.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
    }) : l.push(o), $r[s.path]) {
      case $r.weights:
        c = bs;
        break;
      case $r.rotation:
        c = Br;
        break;
      case $r.position:
      case $r.scale:
        c = Ms;
        break;
      default:
        n.itemSize === 1 ? c = bs : c = Ms;
    }
    const h = r.interpolation !== void 0 ? WP[r.interpolation] : ul, u = this._getArrayFromAccessor(n);
    for (let d = 0, p = l.length; d < p; d++) {
      const f = new c(l[d] + "." + $r[s.path], t.array, u, h);
      r.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(f), a.push(f);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = Z0(t.constructor), r = new Float32Array(t.length);
      for (let s = 0, a = t.length; s < a; s++)
        r[s] = t[s] * n;
      t = r;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(t) {
      return new (this instanceof Br ? jP : T4)(this.times, this.values, this.getValueSize() / 3, t);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function Zb(i, e, t) {
  const n = e.attributes, r = [];
  function s(a, o) {
    return t.getDependency("accessor", a).then(function(l) {
      i.setAttribute(o, l);
    });
  }
  for (const a in n) {
    const o = Y0[a] || a.toLowerCase();
    o in i.attributes || r.push(s(n[a], o));
  }
  if (e.indices !== void 0 && !i.index) {
    const a = t.getDependency("accessor", e.indices).then(function(o) {
      i.setIndex(o);
    });
    r.push(a);
  }
  return rt.workingColorSpace !== on && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${rt.workingColorSpace}" not supported.`), wr(i, e), function(a, o, l) {
    const c = o.attributes, h = new sn();
    if (c.POSITION === void 0)
      return;
    {
      const p = l.json.accessors[c.POSITION], f = p.min, v = p.max;
      if (f === void 0 || v === void 0)
        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      if (h.set(new S(f[0], f[1], f[2]), new S(v[0], v[1], v[2])), p.normalized) {
        const m = Z0(sl[p.componentType]);
        h.min.multiplyScalar(m), h.max.multiplyScalar(m);
      }
    }
    const u = o.targets;
    if (u !== void 0) {
      const p = new S(), f = new S();
      for (let v = 0, m = u.length; v < m; v++) {
        const y = u[v];
        if (y.POSITION !== void 0) {
          const g = l.json.accessors[y.POSITION], _ = g.min, x = g.max;
          if (_ !== void 0 && x !== void 0) {
            if (f.setX(Math.max(Math.abs(_[0]), Math.abs(x[0]))), f.setY(Math.max(Math.abs(_[1]), Math.abs(x[1]))), f.setZ(Math.max(Math.abs(_[2]), Math.abs(x[2]))), g.normalized) {
              const M = Z0(sl[g.componentType]);
              f.multiplyScalar(M);
            }
            p.max(f);
          } else
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
      h.expandByVector(p);
    }
    a.boundingBox = h;
    const d = new an();
    h.getCenter(d.center), d.radius = h.min.distanceTo(h.max) / 2, a.boundingSphere = d;
  }(i, e, t), Promise.all(r).then(function() {
    return e.targets !== void 0 ? function(a, o, l) {
      let c = !1, h = !1, u = !1;
      for (let v = 0, m = o.length; v < m; v++) {
        const y = o[v];
        if (y.POSITION !== void 0 && (c = !0), y.NORMAL !== void 0 && (h = !0), y.COLOR_0 !== void 0 && (u = !0), c && h && u)
          break;
      }
      if (!c && !h && !u)
        return Promise.resolve(a);
      const d = [], p = [], f = [];
      for (let v = 0, m = o.length; v < m; v++) {
        const y = o[v];
        if (c) {
          const g = y.POSITION !== void 0 ? l.getDependency("accessor", y.POSITION) : a.attributes.position;
          d.push(g);
        }
        if (h) {
          const g = y.NORMAL !== void 0 ? l.getDependency("accessor", y.NORMAL) : a.attributes.normal;
          p.push(g);
        }
        if (u) {
          const g = y.COLOR_0 !== void 0 ? l.getDependency("accessor", y.COLOR_0) : a.attributes.color;
          f.push(g);
        }
      }
      return Promise.all([Promise.all(d), Promise.all(p), Promise.all(f)]).then(function(v) {
        const m = v[0], y = v[1], g = v[2];
        return c && (a.morphAttributes.position = m), h && (a.morphAttributes.normal = y), u && (a.morphAttributes.color = g), a.morphTargetsRelative = !0, a;
      });
    }(i, e.targets, t) : i;
  });
}
const gg = /* @__PURE__ */ new WeakMap();
class $P extends Lt {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, r) {
    const s = new xn(this.manager);
    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (a) => {
      this.parse(a, t, r);
    }, n, r);
  }
  parse(e, t, n = () => {
  }) {
    this.decodeDracoFile(e, t, null, null, yt, n).catch(n);
  }
  decodeDracoFile(e, t, n, r, s = on, a = () => {
  }) {
    const o = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!n, vertexColorSpace: s };
    return this.decodeGeometry(e, o).then(t).catch(a);
  }
  decodeGeometry(e, t) {
    const n = JSON.stringify(t);
    if (gg.has(e)) {
      const l = gg.get(e);
      if (l.key === n)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
    }
    let r;
    const s = this.workerNextTaskID++, a = e.byteLength, o = this._getWorker(s, a).then((l) => (r = l, new Promise((c, h) => {
      r._callbacks[s] = { resolve: c, reject: h }, r.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return o.catch(() => !0).then(() => {
      r && s && this._releaseTask(r, s);
    }), gg.set(e, { key: n, promise: o }), o;
  }
  _createGeometry(e) {
    const t = new Re();
    e.index && t.setIndex(new it(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const r = e.attributes[n], s = r.name, a = r.array, o = r.itemSize, l = new it(a, o);
      s === "color" && (this._assignVertexColorSpace(l, r.vertexColorSpace), l.normalized = !(a instanceof Float32Array)), t.setAttribute(s, l);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== yt)
      return;
    const n = new ce();
    for (let r = 0, s = e.count; r < s; r++)
      n.fromBufferAttribute(e, r).convertSRGBToLinear(), e.setXYZ(r, n.r, n.g, n.b);
  }
  _loadLibrary(e, t) {
    const n = new xn(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((r, s) => {
      n.load(e, r, void 0, s);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const r = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const s = e6.toString(), a = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([a]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const r = new Worker(this.workerSourceURL);
        r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({ type: "init", decoderConfig: this.decoderConfig }), r.onmessage = function(s) {
          const a = s.data;
          switch (a.type) {
            case "decode":
              r._callbacks[a.id].resolve(a);
              break;
            case "error":
              r._callbacks[a.id].reject(a);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + a.type + '"');
          }
        }, this.workerPool.push(r);
      } else
        this.workerPool.sort(function(r, s) {
          return r._taskLoad > s._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function e6() {
  let i, e;
  function t(n, r, s, a, o, l) {
    const c = l.num_components(), h = s.num_points() * c, u = h * o.BYTES_PER_ELEMENT, d = function(v, m) {
      switch (m) {
        case Float32Array:
          return v.DT_FLOAT32;
        case Int8Array:
          return v.DT_INT8;
        case Int16Array:
          return v.DT_INT16;
        case Int32Array:
          return v.DT_INT32;
        case Uint8Array:
          return v.DT_UINT8;
        case Uint16Array:
          return v.DT_UINT16;
        case Uint32Array:
          return v.DT_UINT32;
      }
    }(n, o), p = n._malloc(u);
    r.GetAttributeDataArrayForAllPoints(s, l, d, u, p);
    const f = new o(n.HEAPF32.buffer, p, h).slice();
    return n._free(p), { name: a, array: f, itemSize: c };
  }
  onmessage = function(n) {
    const r = n.data;
    switch (r.type) {
      case "init":
        i = r.decoderConfig, e = new Promise(function(o) {
          i.onModuleLoaded = function(l) {
            o({ draco: l });
          }, DracoDecoderModule(i);
        });
        break;
      case "decode":
        const s = r.buffer, a = r.taskConfig;
        e.then((o) => {
          const l = o.draco, c = new l.Decoder();
          try {
            const h = function(d, p, f, v) {
              const m = v.attributeIDs, y = v.attributeTypes;
              let g, _;
              const x = p.GetEncodedGeometryType(f);
              if (x === d.TRIANGULAR_MESH)
                g = new d.Mesh(), _ = p.DecodeArrayToMesh(f, f.byteLength, g);
              else {
                if (x !== d.POINT_CLOUD)
                  throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                g = new d.PointCloud(), _ = p.DecodeArrayToPointCloud(f, f.byteLength, g);
              }
              if (!_.ok() || g.ptr === 0)
                throw new Error("THREE.DRACOLoader: Decoding failed: " + _.error_msg());
              const M = { index: null, attributes: [] };
              for (const b in m) {
                const w = self[y[b]];
                let T, A;
                if (v.useUniqueIDs)
                  A = m[b], T = p.GetAttributeByUniqueId(g, A);
                else {
                  if (A = p.GetAttributeId(g, d[m[b]]), A === -1)
                    continue;
                  T = p.GetAttribute(g, A);
                }
                const L = t(d, p, g, b, w, T);
                b === "color" && (L.vertexColorSpace = v.vertexColorSpace), M.attributes.push(L);
              }
              return x === d.TRIANGULAR_MESH && (M.index = function(b, w, T) {
                const A = T.num_faces(), L = 3 * A, I = 4 * L, P = b._malloc(I);
                w.GetTrianglesUInt32Array(T, I, P);
                const N = new Uint32Array(b.HEAPF32.buffer, P, L).slice();
                return b._free(P), { array: N, itemSize: 1 };
              }(d, p, g)), d.destroy(g), M;
            }(l, c, new Int8Array(s), a), u = h.attributes.map((d) => d.array.buffer);
            h.index && u.push(h.index.array.buffer), self.postMessage({ type: "decode", id: r.id, geometry: h }, u);
          } catch (h) {
            console.error(h), self.postMessage({ type: "error", id: r.id, error: h.message });
          } finally {
            l.destroy(c);
          }
        });
    }
  };
}
const t6 = /^[og]\s*(.+)?/, n6 = /^mtllib /, i6 = /^usemtl /, r6 = /^usemap /, Kb = /\s+/, Qb = new S(), vg = new S(), Jb = new S(), $b = new S(), fi = new S(), Ld = new ce();
function s6() {
  const i = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materials: {}, materialLibraries: [], startObject: function(e, t) {
    if (this.object && this.object.fromDeclaration === !1)
      return this.object.name = e, void (this.object.fromDeclaration = t !== !1);
    const n = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
    if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = { name: e || "", fromDeclaration: t !== !1, geometry: { vertices: [], normals: [], colors: [], uvs: [], hasUVIndices: !1 }, materials: [], smooth: !0, startMaterial: function(r, s) {
      const a = this._finalize(!1);
      a && (a.inherited || a.groupCount <= 0) && this.materials.splice(a.index, 1);
      const o = { index: this.materials.length, name: r || "", mtllib: Array.isArray(s) && s.length > 0 ? s[s.length - 1] : "", smooth: a !== void 0 ? a.smooth : this.smooth, groupStart: a !== void 0 ? a.groupEnd : 0, groupEnd: -1, groupCount: -1, inherited: !1, clone: function(l) {
        const c = { index: typeof l == "number" ? l : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: !1 };
        return c.clone = this.clone.bind(c), c;
      } };
      return this.materials.push(o), o;
    }, currentMaterial: function() {
      return this.materials.length > 0 ? this.materials[this.materials.length - 1] : void 0;
    }, _finalize: function(r) {
      const s = this.currentMaterial();
      if (s && s.groupEnd === -1 && (s.groupEnd = this.geometry.vertices.length / 3, s.groupCount = s.groupEnd - s.groupStart, s.inherited = !1), r && this.materials.length > 1)
        for (let a = this.materials.length - 1; a >= 0; a--)
          this.materials[a].groupCount <= 0 && this.materials.splice(a, 1);
      return r && this.materials.length === 0 && this.materials.push({ name: "", smooth: this.smooth }), s;
    } }, n && n.name && typeof n.clone == "function") {
      const r = n.clone(0);
      r.inherited = !0, this.object.materials.push(r);
    }
    this.objects.push(this.object);
  }, finalize: function() {
    this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
  }, parseVertexIndex: function(e, t) {
    const n = parseInt(e, 10);
    return 3 * (n >= 0 ? n - 1 : n + t / 3);
  }, parseNormalIndex: function(e, t) {
    const n = parseInt(e, 10);
    return 3 * (n >= 0 ? n - 1 : n + t / 3);
  }, parseUVIndex: function(e, t) {
    const n = parseInt(e, 10);
    return 2 * (n >= 0 ? n - 1 : n + t / 2);
  }, addVertex: function(e, t, n) {
    const r = this.vertices, s = this.object.geometry.vertices;
    s.push(r[e + 0], r[e + 1], r[e + 2]), s.push(r[t + 0], r[t + 1], r[t + 2]), s.push(r[n + 0], r[n + 1], r[n + 2]);
  }, addVertexPoint: function(e) {
    const t = this.vertices;
    this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
  }, addVertexLine: function(e) {
    const t = this.vertices;
    this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
  }, addNormal: function(e, t, n) {
    const r = this.normals, s = this.object.geometry.normals;
    s.push(r[e + 0], r[e + 1], r[e + 2]), s.push(r[t + 0], r[t + 1], r[t + 2]), s.push(r[n + 0], r[n + 1], r[n + 2]);
  }, addFaceNormal: function(e, t, n) {
    const r = this.vertices, s = this.object.geometry.normals;
    Qb.fromArray(r, e), vg.fromArray(r, t), Jb.fromArray(r, n), fi.subVectors(Jb, vg), $b.subVectors(Qb, vg), fi.cross($b), fi.normalize(), s.push(fi.x, fi.y, fi.z), s.push(fi.x, fi.y, fi.z), s.push(fi.x, fi.y, fi.z);
  }, addColor: function(e, t, n) {
    const r = this.colors, s = this.object.geometry.colors;
    r[e] !== void 0 && s.push(r[e + 0], r[e + 1], r[e + 2]), r[t] !== void 0 && s.push(r[t + 0], r[t + 1], r[t + 2]), r[n] !== void 0 && s.push(r[n + 0], r[n + 1], r[n + 2]);
  }, addUV: function(e, t, n) {
    const r = this.uvs, s = this.object.geometry.uvs;
    s.push(r[e + 0], r[e + 1]), s.push(r[t + 0], r[t + 1]), s.push(r[n + 0], r[n + 1]);
  }, addDefaultUV: function() {
    const e = this.object.geometry.uvs;
    e.push(0, 0), e.push(0, 0), e.push(0, 0);
  }, addUVLine: function(e) {
    const t = this.uvs;
    this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
  }, addFace: function(e, t, n, r, s, a, o, l, c) {
    const h = this.vertices.length;
    let u = this.parseVertexIndex(e, h), d = this.parseVertexIndex(t, h), p = this.parseVertexIndex(n, h);
    if (this.addVertex(u, d, p), this.addColor(u, d, p), o !== void 0 && o !== "") {
      const f = this.normals.length;
      u = this.parseNormalIndex(o, f), d = this.parseNormalIndex(l, f), p = this.parseNormalIndex(c, f), this.addNormal(u, d, p);
    } else
      this.addFaceNormal(u, d, p);
    if (r !== void 0 && r !== "") {
      const f = this.uvs.length;
      u = this.parseUVIndex(r, f), d = this.parseUVIndex(s, f), p = this.parseUVIndex(a, f), this.addUV(u, d, p), this.object.geometry.hasUVIndices = !0;
    } else
      this.addDefaultUV();
  }, addPointGeometry: function(e) {
    this.object.geometry.type = "Points";
    const t = this.vertices.length;
    for (let n = 0, r = e.length; n < r; n++) {
      const s = this.parseVertexIndex(e[n], t);
      this.addVertexPoint(s), this.addColor(s);
    }
  }, addLineGeometry: function(e, t) {
    this.object.geometry.type = "Line";
    const n = this.vertices.length, r = this.uvs.length;
    for (let s = 0, a = e.length; s < a; s++)
      this.addVertexLine(this.parseVertexIndex(e[s], n));
    for (let s = 0, a = t.length; s < a; s++)
      this.addUVLine(this.parseUVIndex(t[s], r));
  } };
  return i.startObject("", !1), i;
}
class a6 extends Lt {
  constructor(e) {
    super(e), this.materials = null;
  }
  load(e, t, n, r) {
    const s = this, a = new xn(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      try {
        t(s.parse(o));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(e);
      }
    }, n, r);
  }
  setMaterials(e) {
    return this.materials = e, this;
  }
  parse(e) {
    const t = new s6();
    e.indexOf(`\r
`) !== -1 && (e = e.replace(/\r\n/g, `
`)), e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
    const n = e.split(`
`);
    let r = [];
    for (let a = 0, o = n.length; a < o; a++) {
      const l = n[a].trimStart();
      if (l.length === 0)
        continue;
      const c = l.charAt(0);
      if (c !== "#")
        if (c === "v") {
          const h = l.split(Kb);
          switch (h[0]) {
            case "v":
              t.vertices.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3])), h.length >= 7 ? (Ld.setRGB(parseFloat(h[4]), parseFloat(h[5]), parseFloat(h[6])).convertSRGBToLinear(), t.colors.push(Ld.r, Ld.g, Ld.b)) : t.colors.push(void 0, void 0, void 0);
              break;
            case "vn":
              t.normals.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3]));
              break;
            case "vt":
              t.uvs.push(parseFloat(h[1]), parseFloat(h[2]));
          }
        } else if (c === "f") {
          const h = l.slice(1).trim().split(Kb), u = [];
          for (let p = 0, f = h.length; p < f; p++) {
            const v = h[p];
            if (v.length > 0) {
              const m = v.split("/");
              u.push(m);
            }
          }
          const d = u[0];
          for (let p = 1, f = u.length - 1; p < f; p++) {
            const v = u[p], m = u[p + 1];
            t.addFace(d[0], v[0], m[0], d[1], v[1], m[1], d[2], v[2], m[2]);
          }
        } else if (c === "l") {
          const h = l.substring(1).trim().split(" ");
          let u = [];
          const d = [];
          if (l.indexOf("/") === -1)
            u = h;
          else
            for (let p = 0, f = h.length; p < f; p++) {
              const v = h[p].split("/");
              v[0] !== "" && u.push(v[0]), v[1] !== "" && d.push(v[1]);
            }
          t.addLineGeometry(u, d);
        } else if (c === "p") {
          const h = l.slice(1).trim().split(" ");
          t.addPointGeometry(h);
        } else if ((r = t6.exec(l)) !== null) {
          const h = (" " + r[0].slice(1).trim()).slice(1);
          t.startObject(h);
        } else if (i6.test(l))
          t.object.startMaterial(l.substring(7).trim(), t.materialLibraries);
        else if (n6.test(l))
          t.materialLibraries.push(l.substring(7).trim());
        else if (r6.test(l))
          console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
        else if (c === "s") {
          if (r = l.split(" "), r.length > 1) {
            const u = r[1].trim().toLowerCase();
            t.object.smooth = u !== "0" && u !== "off";
          } else
            t.object.smooth = !0;
          const h = t.object.currentMaterial();
          h && (h.smooth = t.object.smooth);
        } else {
          if (l === "\0")
            continue;
          console.warn('THREE.OBJLoader: Unexpected line: "' + l + '"');
        }
    }
    t.finalize();
    const s = new oi();
    if (s.materialLibraries = [].concat(t.materialLibraries), t.objects.length === 1 && t.objects[0].geometry.vertices.length === 0) {
      if (t.vertices.length > 0) {
        const a = new ss({ size: 1, sizeAttenuation: !1 }), o = new Re();
        o.setAttribute("position", new ye(t.vertices, 3)), t.colors.length > 0 && t.colors[0] !== void 0 && (o.setAttribute("color", new ye(t.colors, 3)), a.vertexColors = !0);
        const l = new Qo(o, a);
        s.add(l);
      }
    } else
      for (let a = 0, o = t.objects.length; a < o; a++) {
        const l = t.objects[a], c = l.geometry, h = l.materials, u = c.type === "Line", d = c.type === "Points";
        let p = !1;
        if (c.vertices.length === 0)
          continue;
        const f = new Re();
        f.setAttribute("position", new ye(c.vertices, 3)), c.normals.length > 0 && f.setAttribute("normal", new ye(c.normals, 3)), c.colors.length > 0 && (p = !0, f.setAttribute("color", new ye(c.colors, 3))), c.hasUVIndices === !0 && f.setAttribute("uv", new ye(c.uvs, 2));
        const v = [];
        for (let y = 0, g = h.length; y < g; y++) {
          const _ = h[y], x = _.name + "_" + _.smooth + "_" + p;
          let M = t.materials[x];
          if (this.materials !== null)
            if (M = this.materials.create(_.name), !u || !M || M instanceof zt) {
              if (d && M && !(M instanceof ss)) {
                const b = new ss({ size: 10, sizeAttenuation: !1 });
                Wt.prototype.copy.call(b, M), b.color.copy(M.color), b.map = M.map, M = b;
              }
            } else {
              const b = new zt();
              Wt.prototype.copy.call(b, M), b.color.copy(M.color), M = b;
            }
          M === void 0 && (M = u ? new zt() : d ? new ss({ size: 1, sizeAttenuation: !1 }) : new Ea(), M.name = _.name, M.flatShading = !_.smooth, M.vertexColors = p, t.materials[x] = M), v.push(M);
        }
        let m;
        if (v.length > 1) {
          for (let y = 0, g = h.length; y < g; y++) {
            const _ = h[y];
            f.addGroup(_.groupStart, _.groupCount, y);
          }
          m = u ? new Qn(f, v) : d ? new Qo(f, v) : new ve(f, v);
        } else
          m = u ? new Qn(f, v[0]) : d ? new Qo(f, v[0]) : new ve(f, v[0]);
        m.name = l.name, s.add(m);
      }
    return s;
  }
}
class o6 extends Lt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, a = this.path === "" ? cr.extractUrlBase(e) : this.path, o = new xn(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      try {
        t(s.parse(l, a));
      } catch (c) {
        r ? r(c) : console.error(c), s.manager.itemError(e);
      }
    }, n, r);
  }
  setMaterialOptions(e) {
    return this.materialOptions = e, this;
  }
  parse(e, t) {
    const n = e.split(`
`);
    let r = {};
    const s = /\s+/, a = {};
    for (let l = 0; l < n.length; l++) {
      let c = n[l];
      if (c = c.trim(), c.length === 0 || c.charAt(0) === "#")
        continue;
      const h = c.indexOf(" ");
      let u = h >= 0 ? c.substring(0, h) : c;
      u = u.toLowerCase();
      let d = h >= 0 ? c.substring(h + 1) : "";
      if (d = d.trim(), u === "newmtl")
        r = { name: d }, a[d] = r;
      else if (u === "ka" || u === "kd" || u === "ks" || u === "ke") {
        const p = d.split(s, 3);
        r[u] = [parseFloat(p[0]), parseFloat(p[1]), parseFloat(p[2])];
      } else
        r[u] = d;
    }
    const o = new l6(this.resourcePath || t, this.materialOptions);
    return o.setCrossOrigin(this.crossOrigin), o.setManager(this.manager), o.setMaterials(a), o;
  }
}
class l6 {
  constructor(e = "", t = {}) {
    this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = this.options.side !== void 0 ? this.options.side : Gi, this.wrap = this.options.wrap !== void 0 ? this.options.wrap : In;
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setManager(e) {
    this.manager = e;
  }
  setMaterials(e) {
    this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
  }
  convert(e) {
    if (!this.options)
      return e;
    const t = {};
    for (const n in e) {
      const r = e[n], s = {};
      t[n] = s;
      for (const a in r) {
        let o = !0, l = r[a];
        const c = a.toLowerCase();
        switch (c) {
          case "kd":
          case "ka":
          case "ks":
            this.options && this.options.normalizeRGB && (l = [l[0] / 255, l[1] / 255, l[2] / 255]), this.options && this.options.ignoreZeroRGBs && l[0] === 0 && l[1] === 0 && l[2] === 0 && (o = !1);
        }
        o && (s[c] = l);
      }
    }
    return t;
  }
  preload() {
    for (const e in this.materialsInfo)
      this.create(e);
  }
  getIndex(e) {
    return this.nameLookup[e];
  }
  getAsArray() {
    let e = 0;
    for (const t in this.materialsInfo)
      this.materialsArray[e] = this.create(t), this.nameLookup[t] = e, e++;
    return this.materialsArray;
  }
  create(e) {
    return this.materials[e] === void 0 && this.createMaterial_(e), this.materials[e];
  }
  createMaterial_(e) {
    const t = this, n = this.materialsInfo[e], r = { name: e, side: this.side };
    function s(a, o) {
      if (r[a])
        return;
      const l = t.getTextureParams(o, r), c = t.loadTexture((h = t.baseUrl, typeof (u = l.url) != "string" || u === "" ? "" : /^https?:\/\//i.test(u) ? u : h + u));
      var h, u;
      c.repeat.copy(l.scale), c.offset.copy(l.offset), c.wrapS = t.wrap, c.wrapT = t.wrap, a !== "map" && a !== "emissiveMap" || (c.colorSpace = yt), r[a] = c;
    }
    for (const a in n) {
      const o = n[a];
      let l;
      if (o !== "")
        switch (a.toLowerCase()) {
          case "kd":
            r.color = new ce().fromArray(o).convertSRGBToLinear();
            break;
          case "ks":
            r.specular = new ce().fromArray(o).convertSRGBToLinear();
            break;
          case "ke":
            r.emissive = new ce().fromArray(o).convertSRGBToLinear();
            break;
          case "map_kd":
            s("map", o);
            break;
          case "map_ks":
            s("specularMap", o);
            break;
          case "map_ke":
            s("emissiveMap", o);
            break;
          case "norm":
            s("normalMap", o);
            break;
          case "map_bump":
          case "bump":
            s("bumpMap", o);
            break;
          case "map_d":
            s("alphaMap", o), r.transparent = !0;
            break;
          case "ns":
            r.shininess = parseFloat(o);
            break;
          case "d":
            l = parseFloat(o), l < 1 && (r.opacity = l, r.transparent = !0);
            break;
          case "tr":
            l = parseFloat(o), this.options && this.options.invertTrProperty && (l = 1 - l), l > 0 && (r.opacity = 1 - l, r.transparent = !0);
        }
    }
    return this.materials[e] = new Ea(r), this.materials[e];
  }
  getTextureParams(e, t) {
    const n = { scale: new Y(1, 1), offset: new Y(0, 0) }, r = e.split(/\s+/);
    let s;
    return s = r.indexOf("-bm"), s >= 0 && (t.bumpScale = parseFloat(r[s + 1]), r.splice(s, 2)), s = r.indexOf("-s"), s >= 0 && (n.scale.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), s = r.indexOf("-o"), s >= 0 && (n.offset.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), n.url = r.join(" ").trim(), n;
  }
  loadTexture(e, t, n, r, s) {
    const a = this.manager !== void 0 ? this.manager : I1;
    let o = a.getHandler(e);
    o === null && (o = new Va(a)), o.setCrossOrigin && o.setCrossOrigin(this.crossOrigin);
    const l = o.load(e, n, r, s);
    return t !== void 0 && (l.mapping = t), l;
  }
}
const yg = Rf;
function qy() {
  const i = ["23216352GOxeLm", "setDRACOLoader", "1457955ZhCVaO", "total", "setDecoderPath", "808632FwYUZL", "progress", "loaded", "load", "/draco/", "replace", "setMaterials", "4ClKMmo", "1868907TMzljH", "complete", "animations", "10886463clmvhu", "3978015NYzXAV", "scene", ".mtl", "1258200rMXpnN", "preload"];
  return (qy = function() {
    return i;
  })();
}
function Rf(i, e) {
  const t = qy();
  return (Rf = function(n, r) {
    return t[n -= 218];
  })(i, e);
}
function Yy(i, e) {
  var t = Zy();
  return (Yy = function(n, r) {
    return t[n -= 300];
  })(i, e);
}
function c6(i, e, t = () => {
}) {
  var n = Yy;
  switch (e) {
    case n(315):
    case "GLB":
    case "gltf":
    case n(304):
      return function(r = "", s = yg(219), a = () => {
      }) {
        const o = yg, l = new vP(), c = { progress: () => {
        }, complete: () => {
        } };
        return l[o(233)](new $P()[o(236)](s)), l[o(218)](r, (h) => {
          const u = o;
          h[u(228)][u(225)] = h[u(225)], a(h.scene), c[u(224)](h[u(228)]);
        }, (h) => c[o(238)](h.loaded / h.total, h), (h) => {
        }), c;
      }(i, Q0[n(313)], (r) => t(r));
    case n(302):
    case n(314):
      return function(r = "", s) {
        const a = yg, o = new cP(), l = { progress: () => {
        }, complete: () => {
        } };
        return o[a(218)](r, (c) => {
          const h = a;
          s(c), l[h(224)](c);
        }, (c) => l[a(238)](c.loaded / c[a(235)], c)), l;
      }(i, (r) => t(r));
    case n(316):
    case n(319):
      return function(r = "", s = () => {
      }) {
        const a = Rf, o = new a6(), l = new o6(), c = { progress: () => {
        }, complete: () => {
        } };
        return l.load(r[a(220)](".obj", a(229)), (h) => {
          const u = a;
          h[u(231)](), o[u(221)](h), o[u(218)](r, (d) => {
            s(d), c.complete(d);
          }, (d) => c[u(238)](d[u(239)] / d.total, d), (d) => {
          });
        }), c;
      }(i, (r) => t(r));
  }
}
function Zy() {
  var i = ["2RALSCJ", "2930dqNwtf", "208szVbDe", "9HQdEND", "dracoPath", "fbx", "GLTF", "OBJ", "6xvozCv", "4477965IAmkZg", "obj", "2168328KakPps", "2027688HXUYKm", "FBX", "2159764ZmZNAq", "glb", "3399564LkxOUv", "151217hwWcDT", "3vdlfGm", "6479MuHVqD"];
  return (Zy = function() {
    return i;
  })();
}
(function(i, e) {
  const t = Rf, n = qy();
  for (; ; )
    try {
      if (-parseInt(t(234)) / 1 + -parseInt(t(230)) / 2 + -parseInt(t(223)) / 3 * (parseInt(t(222)) / 4) + -parseInt(t(227)) / 5 + -parseInt(t(237)) / 6 + parseInt(t(226)) / 7 + parseInt(t(232)) / 8 === 816854)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  for (var t = Yy, n = Zy(); ; )
    try {
      if (-parseInt(t(306)) / 1 * (-parseInt(t(309)) / 2) + parseInt(t(307)) / 3 * (-parseInt(t(303)) / 4) + -parseInt(t(318)) / 5 + parseInt(t(317)) / 6 * (-parseInt(t(305)) / 7) + parseInt(t(300)) / 8 * (-parseInt(t(312)) / 9) + -parseInt(t(310)) / 10 * (parseInt(t(308)) / 11) + parseInt(t(301)) / 12 * (parseInt(t(311)) / 13) === 489997)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Pf, n = Jy();
  for (; ; )
    try {
      if (-parseInt(t(454)) / 1 + parseInt(t(450)) / 2 * (parseInt(t(451)) / 3) + -parseInt(t(447)) / 4 * (parseInt(t(448)) / 5) + -parseInt(t(452)) / 6 + parseInt(t(449)) / 7 * (-parseInt(t(445)) / 8) + parseInt(t(444)) / 9 * (-parseInt(t(441)) / 10) + parseInt(t(442)) / 11 === 189176)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const Ky = Ja, Qy = $a;
function Jy() {
  const i = ["length", "292970PijKcK", "8436054gXZXFD", "forEach", "45paqCZF", "1905096rvriLZ", "map", "1276zMDPhL", "395lNMwOP", "7cOwtjs", "678LDIQDU", "1455TsFghD", "1908498YfycGs", "children", "14247AEXbzo"];
  return (Jy = function() {
    return i;
  })();
}
const E4 = Gr;
function Pf(i, e) {
  const t = Jy();
  return (Pf = function(n, r) {
    return t[n -= 440];
  })(i, e);
}
function Lf(i) {
  const e = Pf;
  return i[e(446)]((t) => {
    const n = e;
    return Qt(Ee({}, Ky(t)), { children: Lf(t[n(453)]) });
  });
}
function Df(i, e) {
  const t = Pf;
  i.length === e[t(440)] && i[t(443)]((n, r) => {
    const s = t;
    Qy(n, e[r]), n[s(453)] && Df(n[s(453)], e[r][s(453)]);
  });
}
function h6(i, e) {
  const t = vs;
  i[t(516)] = e;
  const { mesh: n, material: r } = e;
  e.useGlobalShadow && function(s, a) {
    const o = vs;
    s[o(504)]((l) => {
      const c = o;
      l.castShadow = a[c(506)], l[c(524)] = a[c(524)];
    });
  }(i, n), e[t(515)] && function(s, a) {
    const o = vs;
    s[o(500)][o(539)]((l) => {
      const c = o;
      l[c(501)] = a[c(501)], l[c(528)] = a[c(528)], a[c(512)] && (l[c(512)] = s[c(509)].envBackground), a[c(502)] === !1 && (l[c(530)] = l[c(519)], l.map = null), l[c(518)] = !0;
    }), a[o(512)] && s.parent[o(531)][o(503)](() => s[o(500)][o(539)]((l) => l[o(512)] = s[o(509)][o(543)]));
  }(i, r);
}
function u6(i, e) {
  const t = vs;
  e[t(510)](i[t(516)], t(536))[t(540)](t(508)), e[t(510)](i[t(516)], t(545))[t(540)]("单材质更改存储"), e[t(546)](() => i[t(504)]((n) => n[t(525)] = !0)).name(t(538)), function(n, r) {
    const s = vs;
    r[s(510)](n.globalConfig, s(541))[s(540)](s(526)), r[s(510)](n.globalConfig[s(533)], "castShadow")[s(540)](s(517)).onChange((a) => n[s(504)]((o) => o[s(506)] = a)), r.add(n[s(516)][s(533)], s(524))[s(540)](s(511))[s(542)]((a) => n[s(504)]((o) => o[s(524)] = a));
  }(i, e[t(532)](t(535))), function(n, r) {
    const s = vs;
    r[s(510)](n[s(516)], s(515))[s(540)](s(526)), r[s(510)](n.globalConfig[s(527)], "envMap").name(s(520)).onChange((a) => n.RootMaterials[s(539)]((o) => o.envMap = a ? n[s(509)][s(543)] : null)), r[s(510)](n[s(516)].material, "envMapIntensity").name("环境贴图强度")[s(542)]((a) => n[s(500)][s(539)]((o) => o[s(501)] = a))[s(534)]((a) => n[s(500)][s(539)]((o) => o[s(518)] = !0)), r[s(510)](n[s(516)][s(527)], s(528), 0, 1)[s(540)]("反射强度")[s(542)]((a) => n[s(500)].forEach((o) => o[s(528)] = a)).onFinishChange((a) => n[s(500)][s(539)]((o) => o[s(518)] = !0)), r.add(n[s(516)][s(527)], s(502))[s(540)](s(523)).onChange((a) => {
      const o = s;
      n[o(500)].forEach((l) => {
        const c = o;
        a ? (l[c(519)] = l.recordMap, l.needsUpdate = !0) : (l[c(530)] = l[c(519)], l[c(519)] = null, l.needsUpdate = !0);
      });
    })[s(534)]((a) => n[s(500)][s(539)]((o) => o[s(518)] = !0));
  }(i, e[t(532)]("(全局)材质配置"));
}
function vs(i, e) {
  const t = $y();
  return (vs = function(n, r) {
    return t[n -= 500];
  })(i, e);
}
function $y() {
  const i = ["isSaveChildren", "115242WlmVvJ", "显示全部子项", "forEach", "name", "useGlobalShadow", "onChange", "envBackground", "3724120UpNTRR", "isSaveMaterials", "addFn", "RootMaterials", "envMapIntensity", "isGlobalMap", "push", "traverse", "857405QNizsh", "castShadow", "627858MGtPue", "子物体更改存储", "parent", "add", "接收阴影", "envMap", "790728VuVgtq", "1068BAioXC", "useGlobalMaterial", "globalConfig", "产生阴影", "needsUpdate", "map", "环境贴图", "50981ynEavY", "357397dtfznr", "全局贴图", "receiveShadow", "visible", "存储全局配置", "material", "reflectivity", "45yqQwGM", "recordMap", "envMapChangeUseList", "addFolder", "mesh", "onFinishChange", "(全局)阴影配置"];
  return ($y = function() {
    return i;
  })();
}
function Dh(i, e) {
  const t = e_();
  return (Dh = function(n, r) {
    return t[n -= 223];
  })(i, e);
}
function e_() {
  const i = ["end", "mixerAnimateRender", "loop", "43371LnRWQa", "55928FRrHUV", "9hSTrfU", "destroy", "148064mXMkvM", "speed", "AnimationMixer", "push", "clampWhenFinished", "curve", "frameCallback", "214720qnWTlm", "start", "time", "timeScale", "15038wbhJBQ", "1532524xFgtDZ", "Clock", "indexOf", "now", "pause", "45BFNmja", "LoopRepeat", "20FemHZA", "20292cToxNw", "getDelta"];
  return (e_ = function() {
    return i;
  })();
}
function fu(i, e) {
  const t = t_();
  return (fu = function(n, r) {
    return t[n -= 312];
  })(i, e);
}
function t_() {
  const i = ["toFixed", "initPlay", "speed", "startTime", "播放列表", "map", "初始加载播放", "actionIndexs", "1695516VItKEI", "addFolder", "name", "播放选择动作", "addFn", "2XVOJzC", "add", "loop", "1551635mWwYxA", "animations", "6HgOmEN", "animationPlayParams", "min", "385488dszFEI", "循环播放", "filter", "249552pNPeJN", "158355TjZezQ", "find", "开始时间", "push", "21EkYaRB", "1369640xoAEhI", "frameCallback", "11nUCvyG", "287570cCReTP"];
  return (t_ = function() {
    return i;
  })();
}
function n_(i, e) {
  const t = fu, { mixerFrames: n } = wl(i), r = function(a, o = () => {
  }) {
    const l = Dh, c = new W[l(243)](), h = new W[l(232)](a);
    return a[l(224)] = () => {
      const u = c[l(251)]();
      o(), h.update(u);
    }, h;
  }(i, () => e[t(323)]), s = e[t(333)].map((a, o) => a && function(l, c, h = 1, u = 0, d = !0) {
    const p = Dh, f = l.clipAction(c);
    return f[p(225)] = d ? W[p(248)] : c1, f[p(239)] = u, f[p(240)] = h, f[p(234)] = !0, f;
  }(r, i.animations[o], e.speed, e[t(329)], e[t(341)]).play())[t(315)]((a) => a);
  return !n[t(318)]((a) => a === i) && n[t(320)](i), { actions: s, mixer: r };
}
function Ol(i, e) {
  const t = i_();
  return (Ol = function(n, r) {
    return t[n -= 425];
  })(i, e);
}
function d6(i, e) {
  const t = Ol;
  e && (Qy(i, e), h6(i, e[t(459)]), i[t(459)].isSaveChildren && Df(i.children, e[t(427)]), i.globalConfig[t(456)] && i[t(441)][t(442)]((n, r) => ay(n, e.RootMaterials[r])), function(n, r) {
    const s = fu;
    r && (n[s(345)] = r, r[s(327)] && n_(n, r));
  }(i, e[t(447)]));
}
function i_() {
  const i = ["outlinePass", "name", "children", "map", "8468cXHdTS", "1672434xNhmbR", "5229515vgPnAw", "动画配置", "addFn", "isSaveChildren", "length", "object", "selectedObjects", "parent", "fov", "fill", "RootMaterials", "forEach", "1665OyzbQP", "6uQtzcC", "1094522NnQxir", "1261663VqRtbP", "animationPlayParams", "animations", "全局和子项控制", "removeFolder", "13531pjYmVo", "定位物体", "attach", "2152mfAPyj", "remove", "isSaveMaterials", "2637054YeKXKL", "addFolder", "globalConfig", "effectPass", "330uWfYrj", "target"];
  return (i_ = function() {
    return i;
  })();
}
function A4(i, e, t, n, r) {
  const s = Ol;
  return E4(n, r[s(458)]("物体控制")), u6(n, r[s(458)](s(449))), function(a, o) {
    const l = fu;
    if (!a.animationPlayParams)
      return;
    o.add(a[l(345)], l(327))[l(336)](l(332)), o[l(340)](a[l(345)], l(328))[l(312)](-10).max(10).name("播放速度"), o.add(a[l(345)], l(329)).name(l(319)), o[l(340)](a[l(345)], l(341))[l(336)](l(314));
    const c = o[l(335)](l(330));
    a[l(343)][l(331)]((h, u) => c[l(340)](a.animationPlayParams[l(333)], u)[l(336)](h.name + ":" + h.duration[l(326)](2) + "s")), c[l(338)](() => n_(a, a[l(345)]))[l(336)](l(337));
  }(n, r[s(458)](s(432))), r[s(433)](() => e[s(453)](n))[s(426)]("选中"), r[s(433)](() => {
    const a = s, { frontView: o, target: l } = NC(n, i[a(436)][a(439)]);
    Np(i[a(436)].position, o), Np(i[a(462)], l), t[a(460)][a(425)][a(437)] = [n];
  })[s(426)](s(452)), r.addFn(() => {
    const a = s;
    n[a(438)][a(455)](n), r[a(438)][a(450)](r);
  }).name("删除"), r;
}
function Nf(i, e) {
  const t = r_();
  return (Nf = function(n, r) {
    return t[n -= 171];
  })(i, e);
}
function r_() {
  const i = ["1818YWtDOO", "893454oWamEV", "vanui-window", "167067noxQAa", "parentNode", "9482SBFztC", "...", "getElementsByClassName", "removeChild", "name", "875119kDvtKo", "44ayqPcZ", "length", "107276TWyFXE", "2223120CRcXxO", "16hDSIMH", "715eUexuE"];
  return (r_ = function() {
    return i;
  })();
}
function Jn(i) {
  const e = Nf;
  let t = "";
  return i[e(171)] || (t = "-"), i[e(171)][e(174)] > 10 ? t += i[e(171)].slice(0, 10) + e(185) : t += i[e(171)], t += " " + i.id + " ", t;
}
function p6(i, e, t, n, r) {
  const s = Is;
  Object[s(494)](i, { scene: e, controls: t, transformControls: n, effectComposer: r }), i[s(497)] = function(a, o) {
    const { url: l, type: c } = a;
    return { loaderService: c6(l, c, (h) => {
      const u = Is;
      if (e[u(491)](function(p) {
        var v;
        const f = Ol;
        return p[f(459)] = { useGlobalShadow: !1, useGlobalMaterial: !1, isSaveChildren: !0, isSaveMaterials: !0, mesh: { castShadow: !1, receiveShadow: !1 }, material: { envMap: !1, envMapIntensity: 1, reflectivity: 0.98, isGlobalMap: !0 } }, p.RootMaterials = xf(p), ((v = p[f(448)]) == null ? void 0 : v.length) > 0 && (p.animationPlayParams = { initPlay: !1, speed: 0.5, actionIndexs: new Array(p.animations[f(435)])[f(440)](!1), startTime: 0, loop: !1, frameCallback: () => {
        } }), p;
      }(h)), h[u(492)] = a, d6(h, o), !i.rootFolder)
        return;
      const d = i[u(467)][u(488)](Jn(h));
      A4(t, n, r, h, d);
    }), rootInfo: a, params: o };
  };
}
function f6(i) {
  return i[Is(471)]((e) => function(t) {
    const n = Ol, { animationPlayParams: r, children: s, RootMaterials: a, rootInfo: o } = t;
    return { group: Qt(Ee({}, Ky(t)), { globalConfig: t[n(459)], animationPlayParams: r, RootMaterials: t.globalConfig[n(456)] ? a[n(428)]((l) => sy(l)) : void 0, children: t[n(459)][n(434)] ? Lf(s) : void 0 }), rootInfo: o };
  }(e));
}
function Is(i, e) {
  const t = s_();
  return (Is = function(n, r) {
    return t[n -= 466];
  })(i, e);
}
function s_() {
  const i = ["GLB", "8764504vJTarD", "4038fDNjNW", "scene", "826pDYtWR", "模型地址", "transformControls", "group", "effectComposer", "OBJ", "includes", "893200ODwrdk", "addFolder", "url", "progressList", "add", "rootInfo", "GLTF", "assign", "name", "2086668XSXaEe", "insertModel", "addFn", "controls", "rootFolder", "pop", "3490410sXbpeY", "toUpperCase", "map", "57830tbRSyX", "1370199tOIfZt", "FBX", "split"];
  return (s_ = function() {
    return i;
  })();
}
function m6(i, e) {
  const t = Is;
  return i[t(467)] = e, e[t(491)](i, t(489))[t(495)](t(481)), e[t(498)](() => {
    const n = t, r = function(s) {
      const a = Is;
      if (!s)
        return;
      const o = s[a(475)](".")[a(468)]()[a(470)]();
      if (o && [a(474), a(476), a(493), a(485)][a(486)](o))
        return { url: s, type: o === a(476) ? a(493) : o };
    }(i.url);
    r && i[n(497)](r);
  })[t(495)]("添加模型"), i[t(479)].children.forEach((n) => {
    const r = t;
    n.rootInfo && A4(i[r(466)], i[r(482)], i[r(484)], n, e[r(488)](Jn(n)));
  }), e;
}
function a_() {
  const i = ["forEach", "geometryType", "name", "59390GYjjRH", "add", "materialType", "attach_add", "328DyzozU", "标准材质", "36609SDJqNk", "isInnerMesh", "240910SSbRtf", "geometry", "addFn", "addFolder", "map", "3123360lELXWa", "352yYxXTa", "879164wSZGBy", "162uasWJr", "8pCikas", "6559cMbUxW", "几何体", "84231VOPMyq"];
  return (a_ = function() {
    return i;
  })();
}
function Ul(i, e) {
  const t = a_();
  return (Ul = function(n, r) {
    return t[n -= 336];
  })(i, e);
}
function g6(i) {
  return i[Ul(336)]((e) => function(t) {
    const { material: n, geometry: r } = t, { geometryType: s, parameters: a } = r;
    return Qt(Ee({}, Ja(t)), { geometry: { geometryType: s, parameters: a }, material: mf(n) });
  }(e));
}
function v6(i, e) {
  const t = Ul;
  e == null || e[t(345)]((n) => function(r, s) {
    const a = Dl;
    if (!s)
      return;
    const { geometry: o, material: l } = s, { geometryType: c, parameters: h } = o, u = pf(c, h), d = Si(l[a(131)]), p = new W[a(123)](u, d);
    return p.isInnerMesh = !0, r[a(119)](p), gf(r, p[a(117)], l), $a(p, s), p;
  }(i, n));
}
function y6(i, e, t) {
  const n = Ul, r = t[n(359)]("已有列表");
  return r.open(), t.add(i, n(346), OC)[n(347)](n(343)), t[n(349)](i, n(350), No).name("材质"), t[n(358)](() => {
    const s = n, a = function(o, l) {
      const c = Dl, h = pf(o), u = Si(l), d = new W[c(123)](h, u);
      return d[c(124)] = !0, d;
    }(i[s(346)], i[s(350)]);
    e[s(351)](a), Ob(e, a, r.addFolder(a[s(357)][s(346)] + ":" + Jn(a)));
  })[n(347)]("添加"), e.children[n(345)]((s) => {
    const a = n;
    s[a(355)] && Ob(e, s, r[a(359)](s[a(357)][a(346)] + ":" + Jn(s)));
  }), t;
}
(function(i, e) {
  const t = vs, n = $y();
  for (; ; )
    try {
      if (parseInt(t(522)) / 1 + -parseInt(t(537)) / 2 * (-parseInt(t(529)) / 3) + parseInt(t(544)) / 4 + -parseInt(t(505)) / 5 + parseInt(t(514)) / 6 * (-parseInt(t(521)) / 7) + parseInt(t(513)) / 8 + -parseInt(t(507)) / 9 === 713966)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = Dh, n = e_();
  for (; ; )
    try {
      if (parseInt(t(226)) / 1 + -parseInt(t(241)) / 2 * (-parseInt(t(228)) / 3) + parseInt(t(230)) / 4 * (-parseInt(t(249)) / 5) + parseInt(t(250)) / 6 + parseInt(t(242)) / 7 + parseInt(t(227)) / 8 * (-parseInt(t(247)) / 9) + parseInt(t(237)) / 10 === 126695)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = fu, n = t_();
  for (; ; )
    try {
      if (-parseInt(t(339)) / 1 * (-parseInt(t(325)) / 2) + parseInt(t(344)) / 3 * (parseInt(t(313)) / 4) + -parseInt(t(342)) / 5 + parseInt(t(334)) / 6 + parseInt(t(321)) / 7 * (-parseInt(t(316)) / 8) + -parseInt(t(317)) / 9 + -parseInt(t(322)) / 10 * (parseInt(t(324)) / 11) === 204432)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Ol, n = i_();
  for (; ; )
    try {
      if (parseInt(t(446)) / 1 + -parseInt(t(430)) / 2 + -parseInt(t(443)) / 3 * (parseInt(t(429)) / 4) + -parseInt(t(431)) / 5 * (parseInt(t(444)) / 6) + parseInt(t(451)) / 7 * (-parseInt(t(454)) / 8) + -parseInt(t(457)) / 9 + parseInt(t(461)) / 10 * (parseInt(t(445)) / 11) === 675191)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Nf, n = r_();
  for (; ; )
    try {
      if (-parseInt(t(173)) / 1 * (-parseInt(t(184)) / 2) + parseInt(t(180)) / 3 + parseInt(t(175)) / 4 + -parseInt(t(178)) / 5 * (-parseInt(t(179)) / 6) + -parseInt(t(172)) / 7 + -parseInt(t(177)) / 8 * (parseInt(t(182)) / 9) + -parseInt(t(176)) / 10 === 192115)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Is, n = s_();
  for (; ; )
    try {
      if (-parseInt(t(472)) / 1 + -parseInt(t(487)) / 2 + -parseInt(t(473)) / 3 + -parseInt(t(496)) / 4 + parseInt(t(469)) / 5 + parseInt(t(478)) / 6 * (parseInt(t(480)) / 7) + parseInt(t(477)) / 8 === 390229)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Ul, n = a_();
  for (; ; )
    try {
      if (-parseInt(t(344)) / 1 + parseInt(t(341)) / 2 * (-parseInt(t(354)) / 3) + parseInt(t(339)) / 4 + parseInt(t(348)) / 5 * (-parseInt(t(340)) / 6) + parseInt(t(342)) / 7 * (parseInt(t(352)) / 8) + -parseInt(t(337)) / 9 + -parseInt(t(356)) / 10 * (-parseInt(t(338)) / 11) === 228331)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
class I4 extends Gh {
  constructor(e, t = {}) {
    const n = t.font;
    if (n === void 0)
      super();
    else {
      const r = n.generateShapes(e, t.size);
      t.depth === void 0 && t.height !== void 0 && console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead"), t.depth = t.depth !== void 0 ? t.depth : t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(r, t);
    }
    this.type = "TextGeometry";
  }
}
class _6 extends Lt {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, a = new xn(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      const l = s.parse(JSON.parse(o));
      t && t(l);
    }, n, r);
  }
  parse(e) {
    return new x6(e);
  }
}
class x6 {
  constructor(e) {
    this.isFont = !0, this.type = "Font", this.data = e;
  }
  generateShapes(e, t = 100) {
    const n = [], r = function(s, a, o) {
      const l = Array.from(s), c = a / o.resolution, h = (o.boundingBox.yMax - o.boundingBox.yMin + o.underlineThickness) * c, u = [];
      let d = 0, p = 0;
      for (let f = 0; f < l.length; f++) {
        const v = l[f];
        if (v === `
`)
          d = 0, p -= h;
        else {
          const m = b6(v, c, d, p, o);
          d += m.offsetX, u.push(m.path);
        }
      }
      return u;
    }(e, t, this.data);
    for (let s = 0, a = r.length; s < a; s++)
      n.push(...r[s].toShapes());
    return n;
  }
}
function b6(i, e, t, n, r) {
  const s = r.glyphs[i] || r.glyphs["?"];
  if (!s)
    return void console.error('THREE.Font: character "' + i + '" does not exists in font family ' + r.familyName + ".");
  const a = new xw();
  let o, l, c, h, u, d, p, f;
  if (s.o) {
    const v = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
    for (let m = 0, y = v.length; m < y; )
      switch (v[m++]) {
        case "m":
          o = v[m++] * e + t, l = v[m++] * e + n, a.moveTo(o, l);
          break;
        case "l":
          o = v[m++] * e + t, l = v[m++] * e + n, a.lineTo(o, l);
          break;
        case "q":
          c = v[m++] * e + t, h = v[m++] * e + n, u = v[m++] * e + t, d = v[m++] * e + n, a.quadraticCurveTo(u, d, c, h);
          break;
        case "b":
          c = v[m++] * e + t, h = v[m++] * e + n, u = v[m++] * e + t, d = v[m++] * e + n, p = v[m++] * e + t, f = v[m++] * e + n, a.bezierCurveTo(u, d, p, f, c, h);
      }
  }
  return { offsetX: s.ha * e, path: a };
}
function o_() {
  const i = ["5554467liHpHW", "5431650JBBLpH", "setAttribute", "setIndex", "load", "BufferGeometry", "4qTMZyi", "position", "Vector3", "filter", "2976410rZinaE", "length", "computeVertexNormals", "reduce", "7LMJJLv", "map", "attributes", "Float32BufferAttribute", "normal", "BufferAttribute", "3517752UBYYTc", "1119spyfXU", "min", "Vector2", "max", "115872PNlDSS", "2694mjLEQN", "28550gFYaZQ", "9713ZAhOdT"];
  return (o_ = function() {
    return i;
  })();
}
function kl(i, e) {
  const t = o_();
  return (kl = function(n, r) {
    return t[n -= 290];
  })(i, e);
}
function eM(i, e = "fence") {
  const t = kl, n = i[t(305)], r = e === "fence" ? i[t(309)]((d, p) => p - 1 > -1 && p + 1 < n && (p % 2 == 0 ? [p, p + 1, p - 1] : [p, p - 1, p + 1])).filter((d) => d)[t(307)]((d, p) => [...d, ...p], []) : i[t(309)]((d, p) => p >= 2 && [0, p - 1, p])[t(303)]((d) => d)[t(307)]((d, p) => [...d, ...p], []), s = i.reduce((d, p) => [...d, p.x, p.y, p.z], []), a = i[t(307)]((d, p) => ({ x: [...d.x, p.x], y: [...d.y, p.y], z: [...d.z, p.z] }), { x: [], y: [], z: [] }), o = new W[t(302)](Math[t(318)](...a.x), Math.max(...a.y), Math[t(318)](...a.z)), l = new W[t(302)](Math[t(316)](...a.x), Math[t(316)](...a.y), Math[t(316)](...a.z)), c = o.x - l.x, h = o.y - l.y, u = c > h ? c : h;
  return { indexGroup: r, faceGroup: s, uvGroup: i[t(309)]((d) => new W[t(317)]((d.x - l.x) / u, (d.y - l.y) / u))[t(307)]((d, p) => [...d, ...p], []) };
}
function tM(i, e, t) {
  const n = kl, r = new W[n(299)](), s = new Float32Array(i);
  if (r[n(296)](n(301), new it(s, 3)), e) {
    let a = new Uint16Array(e);
    r.index = new W[n(313)](a, 1);
  }
  return t && (r[n(310)].uv = new W[n(311)](t, 2)), r.computeVertexNormals(), r;
}
function nM(i, e, t, n) {
  const r = kl;
  i[r(297)](t), i[r(296)](r(301), new ye(e, 3)), i[r(296)]("uv", new ye(n, 2)), delete i[r(310)][r(312)], i[r(306)]();
}
function C4(i, e, t = null) {
  const n = new _6();
  return new Promise((r) => {
    n[kl(298)](i, (s) => r(new I4(e, Ee({ font: s, size: 1, depth: 0.2, height: 0.2, curveSegments: 12, bevelEnabled: !0, bevelThickness: 0, bevelSize: 0, bevelSegments: 5 }, t))));
  });
}
function l_(i, e) {
  const t = c_();
  return (l_ = function(n, r) {
    return t[n -= 258];
  })(i, e);
}
function c_() {
  const i = ["mesh", "drawPointList", "6WHMaFi", "34808RcUsKz", "10kzhqzY", "set", "7333AFmXWb", "fenceClose", "length", "18030386sshkgo", "10798361CruLWq", "54398832cTcBMO", "drawParams", "copy", "3866952JRHypv", "8craxbA", "Mesh", "3357595uWPVto", "166ixJbIK", "add", "Vector3", "callback", "materialType", "remove", "isDrawMesh", "push", "2286lArqur"];
  return (c_ = function() {
    return i;
  })();
}
function h_(i, e) {
  const t = u_();
  return (h_ = function(n, r) {
    return t[n -= 354];
  })(i, e);
}
function u_() {
  const i = ["callback", "set", "2886024YXqbqX", "materialType", "121786QQIoNk", "remove", "length", "258kLpCbl", "2015600nNHhFF", "323217yFdBUY", "mesh", "Mesh", "add", "2670624jmSmZk", "811736VdBIQX", "forEach", "747248TdAdGk", "isDrawMesh", "drawPointList", "1192GLmZoF"];
  return (u_ = function() {
    return i;
  })();
}
function d_() {
  const i = ["set", "5RvzKvQ", "isDrawMesh", "remove", "map", "geometry", "mesh", "872718yihnor", "CatmullRomCurve3", "Mesh", "dispose", "310187IeNuVO", "drawParams", "Vector3", "clone", "2972118XLqhiJ", "8EafhbP", "TubeGeometry", "divideScalar", "add", "length", "96052sGvtjA", "3318820fLEqIL", "5392359RkUVHZ", "isCurveMesh", "2137365mIQeGi"];
  return (d_ = function() {
    return i;
  })();
}
function p_(i, e) {
  const t = d_();
  return (p_ = function(n, r) {
    return t[n -= 305];
  })(i, e);
}
(function(i, e) {
  const t = kl, n = o_();
  for (; ; )
    try {
      if (parseInt(t(290)) / 1 + -parseInt(t(291)) / 2 * (parseInt(t(315)) / 3) + parseInt(t(300)) / 4 * (-parseInt(t(304)) / 5) + -parseInt(t(295)) / 6 * (parseInt(t(308)) / 7) + parseInt(t(314)) / 8 + -parseInt(t(294)) / 9 + parseInt(t(292)) / 10 * (parseInt(t(293)) / 11) === 456405)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = l_, n = c_();
  for (; ; )
    try {
      if (parseInt(t(269)) / 1 * (parseInt(t(281)) / 2) + -parseInt(t(277)) / 3 + -parseInt(t(278)) / 4 * (-parseInt(t(280)) / 5) + -parseInt(t(265)) / 6 * (parseInt(t(273)) / 7) + parseInt(t(266)) / 8 * (-parseInt(t(262)) / 9) + -parseInt(t(267)) / 10 * (parseInt(t(272)) / 11) + parseInt(t(274)) / 12 === 909026)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = h_, n = u_();
  for (; ; )
    try {
      if (-parseInt(t(365)) / 1 + -parseInt(t(373)) / 2 + -parseInt(t(364)) / 3 + -parseInt(t(367)) / 4 + -parseInt(t(359)) / 5 + parseInt(t(358)) / 6 * (-parseInt(t(355)) / 7) + -parseInt(t(370)) / 8 * (-parseInt(t(360)) / 9) === 868035)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = p_, n = d_();
  for (; ; )
    try {
      if (-parseInt(t(324)) / 1 + parseInt(t(308)) / 2 + parseInt(t(312)) / 3 + -parseInt(t(309)) / 4 + -parseInt(t(314)) / 5 * (-parseInt(t(328)) / 6) + -parseInt(t(320)) / 7 + parseInt(t(329)) / 8 * (parseInt(t(310)) / 9) === 590419)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const iM = new sn(), Dd = new S();
class R4 extends R1 {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new ye([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new ye([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new mp(t, 6, 1);
    return this.setAttribute("instanceStart", new Gn(n, 3, 0)), this.setAttribute("instanceEnd", new Gn(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new mp(t, 6, 1);
    return this.setAttribute("instanceColorStart", new Gn(n, 3, 0)), this.setAttribute("instanceColorEnd", new Gn(n, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new M1(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new sn());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), iM.setFromBufferAttribute(t), this.boundingBox.union(iM));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new an()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let r = 0;
      for (let s = 0, a = e.count; s < a; s++)
        Dd.fromBufferAttribute(e, s), r = Math.max(r, n.distanceToSquared(Dd)), Dd.fromBufferAttribute(t, s), r = Math.max(r, n.distanceToSquared(Dd));
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
_e.line = { worldUnits: { value: 1 }, linewidth: { value: 1 }, resolution: { value: new Y(1, 1) }, dashOffset: { value: 0 }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }, Dn.line = { uniforms: rn.merge([_e.common, _e.fog, _e.line]), vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`, fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		` };
class f_ extends st {
  constructor(e) {
    super({ type: "LineMaterial", uniforms: rn.clone(Dn.line.uniforms), vertexShader: Dn.line.vertexShader, fragmentShader: Dn.line.fragmentShader, clipping: !0 }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
}
const _g = new je(), rM = new S(), sM = new S(), gn = new je(), vn = new je(), Qi = new je(), xg = new S(), bg = new fe(), yn = new vw(), aM = new S(), Nd = new sn(), Od = new an(), Ji = new je();
let $i, pa;
function oM(i, e, t) {
  return Ji.set(0, 0, -e, 1).applyMatrix4(i.projectionMatrix), Ji.multiplyScalar(1 / Ji.w), Ji.x = pa / t.width, Ji.y = pa / t.height, Ji.applyMatrix4(i.projectionMatrixInverse), Ji.multiplyScalar(1 / Ji.w), Math.abs(Math.max(Ji.x, Ji.y));
}
class M6 extends ve {
  constructor(e = new R4(), t = new f_({ color: 16777215 * Math.random() })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, r = new Float32Array(2 * t.count);
    for (let a = 0, o = 0, l = t.count; a < l; a++, o += 2)
      rM.fromBufferAttribute(t, a), sM.fromBufferAttribute(n, a), r[o] = o === 0 ? 0 : r[o - 1], r[o + 1] = r[o] + rM.distanceTo(sM);
    const s = new mp(r, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Gn(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new Gn(s, 1, 1)), this;
  }
  raycast(e, t) {
    const n = this.material.worldUnits, r = e.camera;
    r !== null || n || console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    $i = e.ray;
    const a = this.matrixWorld, o = this.geometry, l = this.material;
    let c, h;
    pa = l.linewidth + s, o.boundingSphere === null && o.computeBoundingSphere(), Od.copy(o.boundingSphere).applyMatrix4(a), n ? c = 0.5 * pa : c = oM(r, Math.max(r.near, Od.distanceToPoint($i.origin)), l.resolution), Od.radius += c, $i.intersectsSphere(Od) !== !1 && (o.boundingBox === null && o.computeBoundingBox(), Nd.copy(o.boundingBox).applyMatrix4(a), n ? h = 0.5 * pa : h = oM(r, Math.max(r.near, Nd.distanceToPoint($i.origin)), l.resolution), Nd.expandByScalar(h), $i.intersectsBox(Nd) !== !1 && (n ? function(u, d) {
      const p = u.matrixWorld, f = u.geometry, v = f.attributes.instanceStart, m = f.attributes.instanceEnd;
      for (let y = 0, g = Math.min(f.instanceCount, v.count); y < g; y++) {
        yn.start.fromBufferAttribute(v, y), yn.end.fromBufferAttribute(m, y), yn.applyMatrix4(p);
        const _ = new S(), x = new S();
        $i.distanceSqToSegment(yn.start, yn.end, x, _), x.distanceTo(_) < 0.5 * pa && d.push({ point: x, pointOnLine: _, distance: $i.origin.distanceTo(x), object: u, face: null, faceIndex: y, uv: null, uv1: null });
      }
    }(this, t) : function(u, d, p) {
      const f = d.projectionMatrix, v = u.material.resolution, m = u.matrixWorld, y = u.geometry, g = y.attributes.instanceStart, _ = y.attributes.instanceEnd, x = Math.min(y.instanceCount, g.count), M = -d.near;
      $i.at(1, Qi), Qi.w = 1, Qi.applyMatrix4(d.matrixWorldInverse), Qi.applyMatrix4(f), Qi.multiplyScalar(1 / Qi.w), Qi.x *= v.x / 2, Qi.y *= v.y / 2, Qi.z = 0, xg.copy(Qi), bg.multiplyMatrices(d.matrixWorldInverse, m);
      for (let b = 0, w = x; b < w; b++) {
        if (gn.fromBufferAttribute(g, b), vn.fromBufferAttribute(_, b), gn.w = 1, vn.w = 1, gn.applyMatrix4(bg), vn.applyMatrix4(bg), gn.z > M && vn.z > M)
          continue;
        if (gn.z > M) {
          const P = gn.z - vn.z, N = (gn.z - M) / P;
          gn.lerp(vn, N);
        } else if (vn.z > M) {
          const P = vn.z - gn.z, N = (vn.z - M) / P;
          vn.lerp(gn, N);
        }
        gn.applyMatrix4(f), vn.applyMatrix4(f), gn.multiplyScalar(1 / gn.w), vn.multiplyScalar(1 / vn.w), gn.x *= v.x / 2, gn.y *= v.y / 2, vn.x *= v.x / 2, vn.y *= v.y / 2, yn.start.copy(gn), yn.start.z = 0, yn.end.copy(vn), yn.end.z = 0;
        const T = yn.closestPointToPointParameter(xg, !0);
        yn.at(T, aM);
        const A = en.lerp(gn.z, vn.z, T), L = A >= -1 && A <= 1, I = xg.distanceTo(aM) < 0.5 * pa;
        if (L && I) {
          yn.start.fromBufferAttribute(g, b), yn.end.fromBufferAttribute(_, b), yn.start.applyMatrix4(m), yn.end.applyMatrix4(m);
          const P = new S(), N = new S();
          $i.distanceSqToSegment(yn.start, yn.end, N, P), p.push({ point: N, pointOnLine: P, distance: $i.origin.distanceTo(N), object: u, face: null, faceIndex: b, uv: null, uv1: null });
        }
      }
    }(this, r, t)));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(_g), this.material.uniforms.resolution.value.set(_g.z, _g.w));
  }
}
class P4 extends R4 {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let r = 0; r < t; r += 3)
      n[2 * r] = e[r], n[2 * r + 1] = e[r + 1], n[2 * r + 2] = e[r + 2], n[2 * r + 3] = e[r + 3], n[2 * r + 4] = e[r + 4], n[2 * r + 5] = e[r + 5];
    return super.setPositions(n), this;
  }
  setColors(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let r = 0; r < t; r += 3)
      n[2 * r] = e[r], n[2 * r + 1] = e[r + 1], n[2 * r + 2] = e[r + 2], n[2 * r + 3] = e[r + 3], n[2 * r + 4] = e[r + 4], n[2 * r + 5] = e[r + 5];
    return super.setColors(n), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class w6 extends M6 {
  constructor(e = new P4(), t = new f_({ color: 16777215 * Math.random() })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
function m_() {
  const i = ["745QbmSGN", "3605108DsTQuW", "setPositions", "9pvuHOq", "center", "818184NgVhkF", "8538kgOHTt", "setFromObject", "Box3", "21OwUShd", "1244796fIcdGd", "15682430KzcNNs", "373980uzMwxQ", "776706Xlalmt", "computeLineDistances", "getCenter"];
  return (m_ = function() {
    return i;
  })();
}
function Of(i, e) {
  const t = m_();
  return (Of = function(n, r) {
    return t[n -= 358];
  })(i, e);
}
function L4(i) {
  const e = Of;
  new W[e(358)]()[e(373)](i)[e(365)](i.position), i.geometry[e(370)]();
}
function g_() {
  const i = ["isDrawMesh", "4724094ExXdmO", "add", "drawParams", "428YVqqOE", "length", "5534949VjuEiq", "geometry", "mesh", "80CMtzfG", "needsUpdate", "13670nNdvYY", "attributes", "1292685dgIFIh", "754443wtnTHE", "drawPointList", "1664410SbbAUp", "dispose", "callback", "54Jamlyn", "computeLineDistances", "position", "14855GnNcwj", "remove", "setPositions"];
  return (g_ = function() {
    return i;
  })();
}
function v_(i, e) {
  const t = g_();
  return (v_ = function(n, r) {
    return t[n -= 129];
  })(i, e);
}
function S6(i, e) {
  var s, a;
  const t = v_, { drawPointList: n } = e;
  if (n.length < 2)
    return void (e.mesh && (i[t(129)](e[t(139)]), e[t(139)] = null, (s = e[t(149)]) == null ? void 0 : s.call(e, t(129))));
  const r = e[t(146)].reduce((o, l) => [...o, l.x, l.y + 1e-3, l.z], []);
  if (!e[t(139)] && e[t(146)][t(136)] > 1) {
    const o = function(l) {
      const c = Of, h = new f_({ color: 0, linewidth: 1e-3, vertexColors: !1, dashed: !1, alphaToCoverage: !1 }), u = new P4()[c(368)](l), d = new w6(u, h);
      return d[c(364)](), d;
    }(r);
    o[t(131)] = !0, o[t(134)] = e, e[t(139)] = o, i[t(133)](e[t(139)]), (a = e[t(149)]) == null || a.call(e, "set");
  } else
    e.mesh && e.drawPointList.length > 0 && (e.mesh[t(138)][t(148)](), e[t(139)][t(138)][t(130)](r), e.mesh[t(151)](), e[t(139)][t(138)][t(143)][t(152)][t(141)] = !0);
}
function lM(i, e, t, n) {
  const r = Cs, s = t.addFolder(r(371)), a = t[r(381)](r(360));
  s[r(345)](), a[r(345)]();
  const o = n || { mode: i[r(353)], materialType: i[r(349)], drawPointList: [], mesh: null };
  function l(c) {
    o[r(338)].push(c), Ui(e, o), cM(e, o, c, a);
  }
  o[r(364)] = function(c) {
    const h = r;
    if (c === h(378))
      for (const u in s[h(367)])
        s.removeFolder(s[h(367)][u]);
    else {
      Gr(this[h(335)], s.addFolder(h(332)));
      const u = s.addFolder("材质配置");
      vf(e, this[h(335)][h(375)], u), this[h(353)] === h(382) && u[h(374)](this[h(335)][h(375)], "linewidth")[h(348)]("线宽");
    }
  }, function(c, h, u, d) {
    const p = Cs;
    if (h.mode === "围栏物体")
      !d && (h[p(344)] = 50, h[p(355)] = !0), u[p(374)](h, p(344))[p(348)](p(368)).onChange(() => Ui(c, h)), u[p(374)](h, "fenceClose")[p(348)]("围栏闭合")[p(357)](() => Ui(c, h));
    else if (h[p(353)] === p(351)) {
      !d && (h.height = 10, h[p(363)] = "y", h.tubularSegments = 64, h[p(361)] = 0.08, h[p(377)] = 8, h[p(352)] = !1);
      const f = u[p(381)](p(326));
      f.add(h, p(354))[p(348)]("高度").onChange(() => Ui(c, h)), f.add(h, p(363), ["x", "y", "z"])[p(348)]("轴向")[p(357)](() => Ui(c, h)), f[p(374)](h, p(329), 1)[p(348)](p(336))[p(357)](() => Ui(c, h))[p(339)](1), f.add(h, p(361), 0.01).name(p(365)).onChange(() => Ui(c, h)), f[p(374)](h, p(377), 1)[p(348)](p(362))[p(357)](() => Ui(c, h))[p(339)](1), f[p(374)](h, "closed")[p(348)](p(370)).onChange(() => Ui(c, h));
    }
  }(e, o, t, n), n && (o[r(338)][r(340)]((c) => cM(e, o, c, a)), o[r(364)](r(369))), t.addFn(() => o[r(335)] && e[r(328)][r(331)](o[r(335)])).name(r(373)), t[r(327)](() => {
    i[r(325)] = l;
  })[r(348)]("操作当前组"), t.addFn(() => {
    const c = r;
    t[c(376)][c(358)](t), o[c(335)] && e[c(378)](o[c(335)]), i.drawEventCall = null;
  })[r(348)]("移除此组"), i[r(325)] = l;
}
function y_() {
  const i = ["368110MBLeEV", "点列表", "radius", "管道半径分段", "axial", "callback", "管道半径", "folder", "__folders", "围栏高度", "set", "管道闭合", "相关控制", "includes", "选中物体", "add", "material", "parent", "radialSegments", "remove", "23298872nsVxqB", "3748227cYttCg", "addFolder", "直线路径", "drawParams", "keys", "drawEventCall", "曲线配置", "addFn", "transformControls", "tubularSegments", "围栏物体", "attach", "变换配置", "9oizgUP", "4181480cxMCTj", "mesh", "管道分段", "toFixed", "drawPointList", "step", "forEach", "平面绘制", "2723172BWoMlT", "5VdCWfg", "fenceHeight", "open", "2839140ZaDvRU", "移除点", "name", "materialType", "2497173lWTBDO", "曲线路径", "closed", "mode", "height", "fenceClose", "join", "onChange", "removeFolder"];
  return (y_ = function() {
    return i;
  })();
}
function cM(i, e, t, n) {
  const r = Cs, s = e[r(338)], a = n.addFn(() => {
    const o = s.indexOf(t);
    o > -1 && s.splice(o, 1), Ui(i, e), n.remove(a);
  })[r(348)](r(347) + [t.x, t.y, t.z].map((o) => o[r(337)](2))[r(356)](","));
}
function Cs(i, e) {
  const t = y_();
  return (Cs = function(n, r) {
    return t[n -= 323];
  })(i, e);
}
function Ui(i, e) {
  const t = Cs;
  switch (e[t(353)]) {
    case t(330):
      (function(n, r) {
        var u, d;
        const s = l_, a = [...r[s(264)]];
        if (a[s(271)] < 2)
          return void (r[s(263)] && (n[s(259)](r[s(263)]), ip(r[s(263)]), r[s(263)] = null, (u = r[s(284)]) == null ? void 0 : u.call(r, s(259))));
        r[s(270)] && r[s(264)][s(271)] > 2 && a[s(261)](r[s(264)][0]);
        const o = a.reduce((p, f) => {
          const v = s, m = new W[v(283)]()[v(276)](f);
          return m.y += r.fenceHeight, [...p, m, f];
        }, []), { indexGroup: l, faceGroup: c, uvGroup: h } = eM(o);
        if (o.length > 3 && !r[s(263)]) {
          const p = tM(c, l, h), f = Si(r[s(258)], { color: 16777215 }), v = new W[s(279)](p, f);
          v[s(260)] = !0, v[s(275)] = r, r[s(263)] = v, n[s(282)](r[s(263)]), (d = r[s(284)]) == null || d.call(r, s(268));
        } else
          r.mesh && nM(r.mesh.geometry, c, l, h);
      })(i, e);
      break;
    case t(341):
      (function(n, r) {
        var h, u;
        const s = h_, a = [...r[s(369)]];
        if (a[s(357)] < 3)
          return void (r.mesh && (n[s(356)](r[s(361)]), ip(r[s(361)]), r[s(361)] = null, (h = r[s(371)]) == null ? void 0 : h.call(r, "remove")));
        a[s(366)]((d) => d.y += 1e-3);
        const { indexGroup: o, faceGroup: l, uvGroup: c } = eM(a, "face");
        if (r[s(369)][s(357)] > 2 && !r[s(361)]) {
          const d = tM(l, o, c), p = Si(r[s(354)], { color: 16777215 }), f = new W[s(362)](d, p);
          f[s(368)] = !0, f.drawParams = r, r[s(361)] = f, n[s(363)](r[s(361)]), (u = r[s(371)]) == null || u.call(r, s(372));
        } else
          r[s(361)] && nM(r.mesh.geometry, l, o, c);
      })(i, e);
      break;
    case t(351):
      (function(n, r) {
        var v, m;
        const s = p_, { drawPointList: a, height: o, axial: l, tubularSegments: c, radius: h, radialSegments: u, closed: d } = r;
        if (a[s(307)] < 2)
          return void (r[s(319)] && (n[s(316)](r[s(319)]), ip(r[s(319)]), r[s(319)] = null, (v = r.callback) == null ? void 0 : v.call(r, s(316))));
        const p = a.map((y) => new W[s(326)](y.x, y.y, y.z))[s(317)]((y, g, _) => {
          const x = s;
          if (_[g + 1]) {
            const M = y[x(327)]()[x(306)](_[g + 1])[x(305)](2);
            return M[l] += o, [y, M];
          }
          return [y];
        }).flat(), f = new W[s(321)](p);
        if (r[s(319)])
          r[s(319)][s(318)][s(323)](), r.mesh[s(318)] = new W[s(330)](f, c, h, u, d);
        else {
          const y = new Ps(f, c, h, u, d), g = Si(r.materialType, { color: 16777215 }), _ = new W[s(322)](y, g);
          _[s(311)] = !0, _[s(315)] = !0, _[s(325)] = r, r[s(319)] = _, n[s(306)](r[s(319)]), (m = r.callback) == null || m.call(r, s(313));
        }
      })(i, e);
      break;
    case t(382):
      S6(i, e);
  }
}
function Fl(i, e) {
  var t = __();
  return (Fl = function(n, r) {
    return t[n -= 349];
  })(i, e);
}
function __() {
  var i = ["mode", "11FgSlRj", "add", "properties", "8046924sUTeih", "点模式", "addFn", "open", "2084224fQUHze", "drawParams", "171467kLnOXB", "绘制模式", "addFolder", "centerCoord3", "场景交点", "地图区域中心", "materialType", "modeList", "60CZOSPy", "geoInfo", "4531550oXsClH", "addDateFolder", "797088WvTcYk", "initTranslate", "标准材质", "曲线路径", "1029066oaOuSg", "isDrawMesh", "name", "4kszWnh", "children", "7qHgHSR", "close", "currentDrawFolder", "pointMode", "drawEventCall", "sub", "getTransformedVector", "map", "parent", "pointModeList", "围栏物体", "759762LclGJx", "position", "clone", "centroidCoord3", "4EPDOmY"];
  return (__ = function() {
    return i;
  })();
}
function T6(i) {
  return i[Fl(387)]((e) => function(t) {
    const n = Cs, r = {};
    return Object[n(324)](t[n(323)])[n(340)]((s) => {
      const a = n;
      !["mesh", a(366), a(364)][a(372)](s) && (r[s] = t[a(323)][s]);
    }), Qt(Ee({}, Ja(t)), { material: mf(t[n(375)]), drawParams: r });
  }(e));
}
function E6(i, e) {
  var t = Fl;
  e == null || e[t(387)]((n) => function(r, s) {
    const a = Cs;
    if (!s)
      return;
    const { drawParams: o } = s;
    Ui(r, o);
    const { mesh: l } = o;
    return $a(l, s), gf(r, l[a(375)], s[a(375)]), o;
  }(i, n));
}
function Bl(i, e) {
  const t = x_();
  return (Bl = function(n, r) {
    return t[n -= 401];
  })(i, e);
}
function x_() {
  const i = ["4231FJxIgz", "add", "22yXPzMa", "target", "12OQtZdb", "isMesh", "clientHeight", "EPSG:3857", "52lIVtRk", "EPSG:4326", "set", "multiply", "initTranslate", "9WVPZXJ", "1057791bldzTo", "Vector2", "Vector3", "applyEuler", "Box3", "offsetY", "sub", "1334768ERloMt", "478620jolfdJ", "position", "scale", "translationOriginDiff", "619950ezvsLm", "clone", "rotation", "clientWidth", "30066cSjWYC", "5EgKhxk", "1829940OhwKCb", "getTransformedVector"];
  return (x_ = function() {
    return i;
  })();
}
function Mg(i, e = 1e4) {
  const t = Bl, [n, r] = i, [s, a] = zn(t(414), t(412), [n, r]);
  return new W[t(420)](s / e, a / e);
}
function D4(i) {
  const e = Bl;
  return new Y(i.offsetX / i.target[e(434)] * 2 - 1, -i[e(424)] / i[e(408)][e(411)] * 2 + 1);
}
function N4(i) {
  const e = Bl;
  new W[e(423)]().setFromObject(i).getCenter(i[e(428)]), i[e(430)] = i[e(428)][e(432)](), i[e(404)] = (t) => {
    const n = e, r = t.clone();
    return r[n(425)](i[n(430)]), r[n(416)](i[n(429)]), r[n(422)](i[n(433)]), r[n(406)](i[n(428)]), r;
  }, i.traverse((t) => {
    const n = e;
    t[n(410)] && t[n(428)][n(425)](i.position), t[n(417)] = t.position[n(432)]();
  }), i[e(428)][e(415)](0, 0, 0);
}
function Nh(i, e) {
  const t = b_();
  return (Nh = function(n, r) {
    return t[n -= 473];
  })(i, e);
}
function hM(i, e, t = null) {
  const n = Nh, { globalConfig: r } = e, s = i[n(477)]((u) => Mg(u)), a = new W[n(510)](s), o = new W[n(475)]();
  o[n(498)] = a, r[n(513)].isEmpty ? o[n(481)].push(a) : o[n(507)][n(491)](a);
  const l = new W[n(501)](o, Ee({ depth: 20, bevelEnabled: !1 }, r.geometry.parameters)), c = e[n(511)] || Si(e[n(492)], { color: 16777215 * Math[n(508)](), transparent: !0 }), h = new W[n(487)](l, c);
  (function(u, d) {
    var f, v;
    const p = Nh;
    if (u.name = (f = d == null ? void 0 : d[p(509)]) == null ? void 0 : f[p(484)], d == null ? void 0 : d[p(509)][p(499)]) {
      const m = Mg(d[p(509)].center);
      d[p(509)][p(483)] = new W[p(478)](m.x, m.y, 0);
    }
    if ((v = d == null ? void 0 : d[p(509)]) != null && v[p(493)]) {
      const m = Mg(d.properties[p(493)]);
      d[p(509)][p(495)] = new W[p(478)](m.x, m.y, 0);
    }
    u[p(476)] = d;
  })(h, t), L4(h), e[n(494)](h);
}
function b_() {
  const i = ["145210ZZRvcF", "path", "center", "forEach", "ExtrudeGeometry", "5115695LmHGZZ", "465zktVst", "11RTPASo", "MultiPolygon", "24QTACXP", "curves", "random", "properties", "Path", "listMaterial", "6pPXYzl", "geometry", "3bqmbNU", "1942316cRTuuI", "Shape", "geoInfo", "map", "Vector3", "Polygon", "type", "holes", "6069735XLnhjP", "centerCoord3", "name", "5971NiqsHi", "coordinates", "Mesh", "isListMaterial", "35562vzGphw", "103801MLKtCI", "push", "materialType", "centroid", "attach", "centroidCoord3", "6208bJPZrp"];
  return (b_ = function() {
    return i;
  })();
}
function M_() {
  const i = ["标签字体粗细", "400", "position", "labelGroup", "410667oNOCFk", "forEach", "900", "style", "remove", "setScalar", "fontSize", "_position", "1049310jniZEk", "properties", "500", "标签旋转Z偏移", "sub", "keys", "addColor", "createElement", "标签位置Y偏移", "35LfxyxE", "onChange", "标签缩放X", "标签颜色", "centroidCoord3", "7420338KUVjgV", "标签旋转X偏移", "4KctemA", "1385944UTMpHB", "942977Ximznv", "800", "显示标签", "16tiJefh", "700", "标签缩放Z", "name", "color", "scale", "getTransformedVector", "add", "set", "values", "标签字体大小", "标签类型", "initTranslate", "标签位置X偏移", "pointerEvents", "600", "14027189ujfYif", "24AYfkHQ", "centerCoord3", "element", "fontWeight", "geoInfo", "type", "children", "innerText", "rotation", "13225190EVRclp", "globalConfig", "标签位置Z偏移", "show"];
  return (M_ = function() {
    return i;
  })();
}
function mu(i, e) {
  const t = M_();
  return (mu = function(n, r) {
    return t[n -= 167];
  })(i, e);
}
function K0(i, e, t) {
  const n = mu;
  e.labelGroup = {};
  const { type: r, color: s, fontSize: a, fontWeight: o, px: l, py: c, pz: h, rx: u, ry: d, rz: p, ss: f, sx: v, sy: m, sz: y } = t;
  e[n(200)][n(212)]((g) => {
    var x, M, b, w, T, A, L, I, P;
    const _ = n;
    if ((x = g[_(198)]) != null && x[_(220)][_(180)] && !e[_(210)][g[_(198)][_(220)].name]) {
      if (!((M = g.geoInfo) != null && M.properties[_(169)]) && !((b = g[_(198)]) != null && b.properties[_(195)]))
        return;
      const N = (((w = g[_(198)]) == null ? void 0 : w[_(220)][_(169)]) || ((T = g.geoInfo) == null ? void 0 : T[_(220)].centerCoord3))[_(184)](g[_(209)])[_(223)](g[_(189)]), F = e[_(183)](N), z = document[_(226)]("div");
      z[_(201)] = ((L = (A = g.geoInfo) == null ? void 0 : A[_(220)]) == null ? void 0 : L[_(180)]) || "", z.style[_(181)] = s, z[_(214)][_(217)] = a + "px", z[_(214)][_(197)] = o;
      const q = r === "2D" ? new GS(z) : new VS(z);
      q[_(218)] = F, q[_(209)][_(185)](q[_(218)].x + l, q[_(218)].y + c, q._position.z + h), q[_(202)].set(u, d, p), q.scale[_(185)](v, m, y), q[_(182)][_(216)](f), i[_(184)](q), z[_(214)][_(191)] = "none", e[_(210)][(P = (I = g[_(198)]) == null ? void 0 : I[_(220)]) == null ? void 0 : P[_(180)]] = q;
    }
  });
}
function w_() {
  const i = ["透射率", "3976aRyaDJ", "标准材质", "addFolder", "texture", "globalConfig", "水平重复", "清漆层", "mesh", "color", "RootMaterials", "bevelThickness", "1867779bdfnRS", "更新贴图", "斜角偏移", "清漆层粗糙度", "2886pPCbmI", "add", "isSaveMaterials", "isEmpty", "material", "TextureLoader", "金属感", "parent", "单材质更改存储", "sheenRoughness", "path", "bevelSize", "emissiveIntensity", "斜角大小", "shapes", "mapUrl", "基础材质", "clearcoat", "addColor", "name", "9SMDuAM", "useGlobalConfig", "emissive", "1380XnCzxU", "形状配置", "sheenColor", "sheen", "commonAnimateRender", "16198610mRaDsf", "接收阴影", "bevelOffset", "wireframe", "手动更新材质", "水平偏移", "parameters", "2730048lMTWHk", "自发光", "垂直偏移动画", "min", "wrapS", "反射率", "旋转动画", "repeat", "includes", "push", "set", "reflectivity", "RepeatWrapping", "envBackground", "envMap", "children", "rotation", "geometry", "ExtrudeGeometry", "materialType", "透明度", "光泽粗糙度", "load", "forEach", "textureAnimation", "形状路径挤压体", "envMapIntensity", "光泽颜色", "(全局 )阴影配置", "使用(全局)配置", "物理材质", "(全局)材质配置", "needsUpdate", "549408gqbgOH", "opacity", "isSaveChildren", "transmission", "卡通材质", "子物体更改存储", "center", "环境贴图", "贴图路径", "贴图动画", "curves", "map", "399570NAyepP", "wrapT", "metalness", "addFn", "环境贴图强度", "#fff", "7714OazzHK", "产生阴影", "垂直中心", "castShadow", "offset", "holes", "onChange", "depth", "roughness", "transparent", "commonFrames", "receiveShadow", "isTextureAnimation", "光泽度", "垂直重复", "clearcoatRoughness"];
  return (w_ = function() {
    return i;
  })();
}
function dr(i, e) {
  const t = w_();
  return (dr = function(n, r) {
    return t[n -= 349];
  })(i, e);
}
function O4(i, e) {
  const t = dr, { commonFrames: n } = i, { globalConfig: r } = e;
  if (!r[t(354)])
    return;
  const { mesh: s, material: a } = r;
  if (e[t(383)].forEach((o) => {
    const l = t;
    o[l(422)] = s[l(422)], o.receiveShadow = s[l(430)];
  }), a[t(466)]) {
    const o = new W[t(456)]().load(a.mapUrl);
    o[t(372)] = W[t(380)], o.wrapT = In, o.repeat[t(378)](a[t(412)].repeat.x, a[t(412)].repeat.y), o[t(423)][t(378)](a[t(412)][t(423)].x, a[t(412)][t(423)].y), o.center[t(378)](a[t(412)][t(407)].x, a.map[t(407)].y), o.rotation = a[t(412)].rotation, e[t(439)] = o, e[t(360)] = function() {
      const l = t;
      this[l(439)].offset.x += this[l(440)].material[l(392)][l(423)].x, this.texture[l(423)].y += this[l(440)][l(455)][l(392)][l(423)].y, this[l(439)][l(384)] += this[l(440)][l(455)][l(392)].rotation;
    }, n.push(e);
  }
  e[t(445)].forEach((o) => {
    const l = t;
    o.color.set(a.color), o[l(364)] = a.wireframe, o.transparent = a[l(428)], o.opacity = a[l(402)], ["标准材质", "物理材质"][l(376)](e.materialType) && (o[l(415)] = a[l(415)], o[l(427)] = a[l(427)]), e[l(387)] !== l(349) && (o[l(355)][l(378)](a[l(355)]), o[l(463)] = a[l(463)]), e[l(387)] === l(398) && (o[l(350)] = a.clearcoat, o[l(434)] = a.clearcoatRoughness, o[l(359)] = a.sheen, o[l(460)] = a[l(460)], o[l(358)].set(a.sheenColor), o[l(404)] = a.transmission), o.envMap = a[l(382)] ? i.envBackground : null, o[l(394)] = a[l(394)], o[l(379)] = a[l(379)], o.map = e[l(439)], o.needsUpdate = !0;
  }), e[t(458)].envMapChangeUseList[t(377)](() => e[t(445)][t(391)]((o) => o[t(382)] = e.parent[t(381)]));
}
function A6(i, e, t) {
  const n = dr, { globalConfig: r } = e;
  t[n(452)](r, n(403))[n(352)](n(406)), t[n(452)](r, n(453))[n(352)](n(459)), t[n(452)](r, "useGlobalConfig").name(n(397));
  const s = t[n(438)](n(396));
  s[n(452)](r[n(443)], "castShadow")[n(352)](n(420))[n(425)](() => e.children.forEach((a) => a[n(422)] = r[n(443)][n(422)])), s[n(452)](r[n(443)], n(430)).name(n(362))[n(425)](() => e[n(383)][n(391)]((a) => a.receiveShadow = r[n(443)][n(430)])), U4(i, e, t[n(438)](n(399))), function(a, o) {
    const l = dr, { globalConfig: c } = a;
    let h = null;
    function u() {
      h && clearTimeout(h), h = setTimeout(() => {
        const d = dr;
        a.children[d(391)]((p) => {
          const f = d;
          p[f(385)].dispose(), c[f(385)][f(454)] ? (p[f(385)][f(367)][f(465)][f(424)] = [p.geometry[f(367)][f(465)][f(461)]], p[f(385)].parameters[f(465)][f(411)] = []) : (p[f(385)][f(367)].shapes.curves = [p[f(385)].parameters.shapes.path], p.geometry.parameters[f(465)][f(424)] = []), p.geometry = new W[f(386)](p.geometry.parameters.shapes, c.geometry[f(367)]), p[f(385)][f(407)]();
        }), h = null;
      }, 200);
    }
    o[l(452)](c[l(385)], l(454))[l(352)]("镂空")[l(425)](u), o[l(452)](c[l(385)][l(367)], l(426))[l(352)]("深度")[l(425)](u)[l(371)](1e-3), o[l(452)](c[l(385)].parameters, "bevelEnabled")[l(352)]("斜角")[l(425)](u), o[l(452)](c[l(385)].parameters, l(446))[l(352)]("斜角厚度").onChange(u)[l(371)](0), o[l(452)](c[l(385)][l(367)], l(462))[l(352)](l(464))[l(425)](u)[l(371)](0), o[l(452)](c[l(385)].parameters, l(363))[l(352)](l(449))[l(425)](u).min(0);
  }(e, t[n(438)](n(357)));
}
function U4(i, e, t) {
  const n = dr, { globalConfig: r } = e, { material: s } = r;
  t[n(351)](s, n(444))[n(352)]("颜色")[n(425)]((a) => e[n(445)].forEach((o) => o.color[n(378)](a))), t.add(s, n(364))[n(352)]("线框")[n(425)]((a) => e[n(445)][n(391)]((o) => o[n(364)] = a)), t.add(s, "transparent")[n(352)]("透明")[n(425)]((a) => e[n(445)][n(391)]((o) => o.transparent = a)), t[n(452)](s, n(402), 0, 1)[n(352)](n(388)).onChange((a) => e[n(445)][n(391)]((o) => o[n(402)] = a)), [n(437), "物理材质"].includes(e[n(387)]) && (t[n(452)](s, "metalness", 0, 1)[n(352)](n(457))[n(425)]((a) => e[n(445)][n(391)]((o) => o[n(415)] = a)), t[n(452)](s, "roughness", 0, 1)[n(352)]("粗糙感")[n(425)]((a) => e.RootMaterials[n(391)]((o) => o[n(427)] = a))), e.materialType !== n(349) && (t[n(351)](s, n(355))[n(352)](n(369)).onChange((a) => e[n(445)].forEach((o) => o.emissive[n(378)](a))), t[n(452)](s, n(463), 0).name("自发光强度")[n(425)]((a) => e[n(445)][n(391)]((o) => o[n(463)] = a))), e[n(387)] !== n(405) && (t.add(s, "envMap").name(n(408))[n(425)]((a) => e[n(445)][n(391)]((o) => a ? o.envMap = i[n(381)] : o[n(382)] = null)), t[n(452)](s, n(394), 0).name(n(417))[n(425)]((a) => e[n(445)][n(391)]((o) => o[n(394)] = a)), t.add(s, n(379), 0, 1)[n(352)](n(373))[n(425)]((a) => e[n(445)].forEach((o) => o[n(379)] = a))), e.materialType === "物理材质" && (t[n(452)](s, n(350), 0, 1)[n(352)](n(442))[n(425)]((a) => e[n(445)][n(391)]((o) => o[n(350)] = a)), t[n(452)](s, "clearcoatRoughness", 0, 1)[n(352)](n(450))[n(425)]((a) => e[n(445)][n(391)]((o) => o[n(434)] = a)), t[n(452)](s, n(359), 0, 1)[n(352)](n(432))[n(425)]((a) => e[n(445)][n(391)]((o) => o[n(359)] = a)), t[n(452)](s, n(460), 0, 1)[n(352)](n(389))[n(425)]((a) => e[n(445)].forEach((o) => o[n(460)] = a)), t.addColor(s, "sheenColor")[n(352)](n(395))[n(425)]((a) => e[n(445)][n(391)]((o) => o[n(358)][n(378)](a))), t[n(452)](s, n(404), 0, 1).name(n(435))[n(425)]((a) => e[n(445)][n(391)]((o) => o.transmission = a))), t[n(416)](() => e[n(445)].forEach((a) => a[n(400)] = !0))[n(352)](n(365)), function(a, o, l) {
    const c = dr, { material: h } = o[c(440)];
    function u(f) {
      const v = c;
      o.RootMaterials[v(391)]((m) => {
        const y = v;
        m[y(412)] && (m[y(412)][f] = h.map[f]);
      });
    }
    function d() {
      const f = c, { mapUrl: v, map: m } = h;
      if (!v)
        return;
      const y = new W[f(456)]()[f(390)](v);
      y[f(372)] = In, y[f(414)] = W[f(380)], y.repeat[f(378)](m[f(375)].x, m.repeat.y), y[f(423)][f(378)](m.offset.x, m[f(423)].y), y[f(407)][f(378)](m[f(407)].x, m[f(407)].y), y[f(384)] = m[f(384)], o[f(439)] = y, o.RootMaterials[f(391)]((g) => {
        const _ = f;
        g[_(412)] = y, g[_(400)] = !0;
      });
    }
    function p(f) {
      const v = c;
      f ? (o.commonAnimateRender = function() {
        const m = dr;
        this[m(439)][m(423)].x += this[m(440)].material[m(392)][m(423)].x, this[m(439)][m(423)].y += this[m(440)][m(455)][m(392)][m(423)].y, this.texture.rotation += this[m(440)].material[m(392)][m(384)];
      }, a[v(377)](o)) : delete o[v(439)][v(360)];
    }
    l[c(452)](h, c(466))[c(352)](c(409)), l[c(452)](h[c(412)][c(375)], "x")[c(352)](c(441)).onChange((f) => u(c(375))), l[c(452)](h[c(412)].repeat, "y").name(c(433))[c(425)]((f) => u(c(375))), l[c(452)](h[c(412)][c(423)], "x").name(c(366))[c(425)]((f) => u(c(423))), l[c(452)](h.map[c(423)], "y").name("垂直偏移").onChange((f) => u(c(423))), l[c(452)](h[c(412)], "rotation", 0, 2 * Math.PI)[c(352)]("旋转").onChange((f) => u(c(384))), l[c(452)](h[c(412)][c(407)], "x")[c(352)]("水平中心")[c(425)]((f) => u("center")), l[c(452)](h[c(412)].center, "y").name(c(421)).onChange((f) => u(c(407))), l[c(452)](h[c(392)], c(431))[c(352)](c(410))[c(425)]((f) => p(f)), l.add(h[c(392)][c(423)], "x")[c(352)]("水平偏移动画"), l[c(452)](h[c(392)][c(423)], "y")[c(352)](c(370)), l[c(452)](h[c(392)], c(384), 0, 2 * Math.PI)[c(352)](c(374)), l[c(416)](() => d())[c(352)](c(448));
  }(i[n(429)], e, t.addFolder("贴图"));
}
function S_() {
  const i = ["features", "6156542dcwlDk", "remove", "子项和全局配置", "3797466niswTV", "forEach", "addFolder", "name", "string", "add", "34376PSWOKf", "isSaveMaterials", "4839768HKteMW", "RootMaterials", "json", "isListMaterial", "19125198bGUaeY", "6305188Voxgwh", "5lsOnJO", "rotation", "url", "基础配置", "listMaterial", "标签配置", "isSaveChildren", "1010508gxIGfx", "8SsfQVk", "then", "删除地图", "Group", "children", "edgeMaterialType", "globalConfig", "map", "materialType"];
  return (S_ = function() {
    return i;
  })();
}
function to(i, e) {
  const t = S_();
  return (to = function(n, r) {
    return t[n -= 341];
  })(i, e);
}
function I6(i, e) {
  return di(this, null, function* () {
    var r;
    const t = to;
    if (!e)
      return;
    const n = new W[t(354)]();
    return n[t(345)] = e[t(345)], n[t(359)] = e[t(359)], n[t(357)] = e.globalConfig, n[t(375)] = e.isListMaterial, n[t(356)] = e[t(356)], yield T_(i, n), $a(n, e), O4(i, n), n[t(357)][t(349)] && Df(n[t(355)], e[t(355)]), n[t(357)][t(371)] && n[t(373)][t(365)]((s, a) => ay(s, e[t(373)][a])), (r = n[t(347)]) == null || r[t(365)]((s, a) => gf(i, s, e.listMaterial[a])), function(s, a) {
      const o = mu, { label: l } = a[o(204)];
      l[o(206)] && K0(s, a, l);
    }(i, n), n;
  });
}
function C6(i, e, t, n) {
  const r = to, s = new W[r(354)]();
  return s.url = i, s.materialType = e, s.isListMaterial = t, s[r(356)] = n, function(a) {
    const o = dr;
    a.globalConfig || (a[o(440)] = { useGlobalConfig: !1, isSaveChildren: !0, isSaveMaterials: !0, mesh: { castShadow: !1, receiveShadow: !1 }, material: { color: 16777215, wireframe: !1, transparent: !0, opacity: 1, metalness: 0, roughness: 0, emissive: 0, emissiveIntensity: 1, clearcoat: 0, clearcoatRoughness: 0, sheen: 0, sheenRoughness: 0, sheenColor: 0, transmission: 0, envMap: !1, envMapIntensity: 1, reflectivity: 0.98, mapUrl: "", textureAnimation: { isTextureAnimation: !1, offset: { x: 0, y: 0.01 }, rotation: 0 }, map: { repeat: { x: 1, y: 1 }, offset: { x: 0, y: 0 }, center: { x: 0, y: 0 }, rotation: 0 } }, geometry: { geometryType: o(393), isEmpty: !1, parameters: { depth: 16, bevelEnabled: !1, bevelThickness: 0, bevelSize: 0, bevelOffset: 0 } }, label: { show: !1, type: "2D", color: o(418), fontSize: 12, fontWeight: 400, px: 0, py: 0, pz: 0, rx: 0, ry: 0, rz: 0, ss: 1, sx: 1, sy: 1, sz: 1 } });
  }(s), s;
}
function T_(i, e) {
  return di(this, null, function* () {
    const t = to;
    let n = null;
    return n = typeof e[t(345)] === t(368) ? yield fetch(e.url)[t(352)]((r) => r[t(374)]()) : e[t(345)], function(r, s) {
      const a = Nh;
      if (s[a(488)]) {
        const { materialType: o, edgeMaterialType: l } = s;
        s[a(511)] = [Si(o, { color: 16777215 * Math[a(508)](), transparent: !0 }), Si(l, { color: 16777215 * Math[a(508)](), transparent: !0 })];
      }
      r[a(500)]((o) => {
        const l = a;
        o.geometry[l(480)] === l(505) ? o.geometry[l(486)][l(500)]((c) => c.forEach((h) => hM(h, s, o))) : o[l(513)][l(480)] === l(479) && o.geometry[l(486)][l(500)]((c) => hM(c, s, o));
      });
    }(n[t(360)], e), N4(e), e[t(373)] = xf(e), e[t(344)].x = -Math.PI / 2, e.isGeoGroup = !0, i.add(e), e;
  });
}
function uM(i, e, t) {
  var r;
  const n = to;
  t[n(369)](e, n(345)).name("地址源修改"), Gr(e, t[n(366)](n(346))), A6(i, e, t.addFolder(n(363))), function(s, a, o) {
    const l = mu, { label: c } = a[l(204)];
    function h(d) {
      const p = l;
      if (!a.labelGroup)
        return;
      const f = Object[p(186)](a[p(210)]);
      switch (d) {
        case "type":
          u(), K0(s, a, c);
          break;
        case "color":
          f[p(212)]((v) => v.element[p(214)].color = c[d]);
          break;
        case p(217):
          f.forEach((v) => v[p(196)][p(214)].fontSize = c[d] + "px");
          break;
        case p(197):
          f.forEach((v) => v[p(196)][p(214)][p(197)] = c[d]);
          break;
        case "px":
          f[p(212)]((v) => v[p(209)].x = v._position.x + c[d]);
          break;
        case "py":
          f[p(212)]((v) => v[p(209)].y = v[p(218)].y + c[d]);
          break;
        case "pz":
          f[p(212)]((v) => v[p(209)].z = v[p(218)].z + c[d]);
          break;
        case "rx":
          f[p(212)]((v) => v[p(202)].x = c[d]);
          break;
        case "ry":
          f[p(212)]((v) => v.rotation.y = c[d]);
          break;
        case "rz":
          f[p(212)]((v) => v[p(202)].z = c[d]);
          break;
        case "ss":
          f[p(212)]((v) => v[p(182)][p(216)](c[d]));
          break;
        case "sx":
          f.forEach((v) => v[p(182)].x = c[d]);
          break;
        case "sy":
          f[p(212)]((v) => v[p(182)].y = c[d]);
          break;
        case "sz":
          f.forEach((v) => v[p(182)].z = c[d]);
      }
    }
    function u() {
      const d = l;
      a.labelGroup && Object[d(224)](a.labelGroup)[d(212)]((p) => {
        const f = d;
        s[f(215)](a[f(210)][p]), delete a[f(210)][p];
      });
    }
    o[l(184)](c, l(206))[l(180)](l(176)).onChange((d) => d ? K0(s, a, c) : u()), o.add(c, l(199), ["2D", "3D"])[l(180)](l(188))[l(229)]((d) => h(l(199))), o[l(225)](c, l(181))[l(180)](l(168))[l(229)]((d) => h("color")), o[l(184)](c, l(217), 0)[l(180)](l(187))[l(229)]((d) => h(l(217))), o.add(c, l(197), [l(208), l(221), l(192), l(178), l(175), l(213)])[l(180)](l(207))[l(229)]((d) => h(l(197))), o[l(184)](c, "px").name(l(190))[l(229)]((d) => h("px")), o[l(184)](c, "py")[l(180)](l(227))[l(229)]((d) => h("py")), o.add(c, "pz")[l(180)](l(205)).onChange((d) => h("pz")), o[l(184)](c, "rx", 0, 2 * Math.PI)[l(180)](l(171))[l(229)]((d) => h("rx")), o.add(c, "ry", 0, 2 * Math.PI)[l(180)]("标签旋转Y偏移")[l(229)]((d) => h("ry")), o[l(184)](c, "rz", 0, 2 * Math.PI)[l(180)](l(222))[l(229)]((d) => h("rz")), o[l(184)](c, "ss").name("标签缩放").onChange((d) => h("ss")), o[l(184)](c, "sx")[l(180)](l(167))[l(229)]((d) => h("sx")), o[l(184)](c, "sy")[l(180)]("标签缩放Y")[l(229)]((d) => h("sy")), o[l(184)](c, "sz")[l(180)](l(179)).onChange((d) => h("sz"));
  }(i, e, t[n(366)](n(348))), (r = e[n(347)]) == null || r.forEach((s, a) => vf(i, s, t.addFolder(a ? "边缘" : "面"))), t.addFn(() => {
    const s = n;
    t.parent.removeFolder(t), i[s(362)](e);
  })[n(367)](n(353));
}
function zl(i, e) {
  const t = E_();
  return (zl = function(n, r) {
    return t[n -= 218];
  })(i, e);
}
function R6() {
  const i = zl;
  return { url: i(247), materialType: "标准材质", isListMaterial: !0, edgeMaterialType: i(229), progressList: [], createGeoGroup: T_ };
}
function P6(i) {
  return i[zl(242)]((e) => function(t) {
    const n = to, { url: r, globalConfig: s, materialType: a, isListMaterial: o, edgeMaterialType: l, listMaterial: c, children: h, RootMaterials: u } = t;
    return Qt(Ee({}, Ja(t)), { url: r, globalConfig: s, materialType: a, isListMaterial: o, edgeMaterialType: l, listMaterial: c == null ? void 0 : c[n(358)]((d) => mf(d)), RootMaterials: s.isSaveMaterials ? u[n(358)]((d) => sy(d)) : void 0, children: s[n(349)] ? Lf(h) : void 0 });
  }(e));
}
function E_() {
  const i = ["1118387hyXTHZ", "10749072cPQPKc", "边缘材质类型", "地图数据地址", "358629EQpCmE", "open", "6FjskUq", "12296781DiDaBm", "isListMaterial", "materialType", "地图材质类型", "添加地图", "标准材质", "11pfCvcE", "edgeMaterialType", "10jdFKku", "10852376xjfmAa", "26SfjHDw", "addFn", "7eUFyHM", "4194745hkJjuV", "progressList", "url", "addFolder", "add", "map", "isGeoGroup", "children", "1196928AQNHvi", "forEach", "https://z2586300277.github.io/3d-file-server/files/json/china.json", "name"];
  return (E_ = function() {
    return i;
  })();
}
function Ur(i, e) {
  const t = A_();
  return (Ur = function(n, r) {
    return t[n -= 206];
  })(i, e);
}
function A_() {
  const i = ["coordinates", "castShadow", "geometry", "json", "step", "产生阴影", "onChange", "tubularSegmentsMultiple", "points", "11670Mzdhef", "length", "2154888GNVnuV", "16yAuaSl", "dlength", "Group", "8742489zqZXJg", "RootMaterials", "3035ifuqNi", "dispose", "globalConfig", "MultiPolygon", "4508577osDTJW", "6UuJvBM", "rotation", "分段倍乘", "isSaveChildren", "addFolder", "type", "isSaveMaterials", "attach", "children", "name", "mesh", "center", "CatmullRomCurve3", "random", "map", "删除边界", "单材质更改存储", "add", "radius", "5218128TthsiW", "materialType", "100748ZxRbUs", "radialSegments", "286860YBfLWQ", "removeFolder", "receiveShadow", "then", "curve", "Mesh", "forEach", "接收阴影", "url", "closed"];
  return (A_ = function() {
    return i;
  })();
}
function dM(i, e, t) {
  const n = Ur;
  E4(e, t.addFolder("基础配置"));
  const { globalConfig: r } = e;
  t[n(232)](r, n(218))[n(224)]("子物体更改存储"), t[n(232)](r, n(221))[n(224)](n(231)), t[n(232)](r, "useGlobalConfig")[n(224)]("全局材质配置");
  const s = t[n(219)]("阴影");
  s[n(232)](r.mesh, n(249)).name(n(253)).onChange(() => e.children[n(244)]((a) => a[n(249)] = r.mesh[n(249)])), s[n(232)](r.mesh, "receiveShadow")[n(224)](n(245))[n(254)](() => e[n(223)].forEach((a) => a[n(240)] = r[n(225)][n(240)])), function(a, o) {
    const l = Ur, { globalConfig: c } = a, { geometry: h } = c;
    let u = null;
    function d() {
      u && clearTimeout(u), u = setTimeout(() => {
        const p = Ur;
        a[p(223)].forEach((f) => {
          const v = p;
          f[v(250)][v(211)](), f[v(250)] = new Ps(f[v(242)], (f[v(242)][v(256)][v(258)] - 1) * h.tubularSegmentsMultiple, h[v(233)], h[v(237)], h[v(247)]), f.geometry[v(226)]();
        }), u = null;
      }, 200);
    }
    o[l(232)](h, l(255), 1)[l(224)](l(217))[l(254)](d)[l(252)](1), o.add(h, "radius", 0.01).name("管道半径")[l(254)](d), o[l(232)](h, l(237), 2).name("管道半径分段")[l(254)](d)[l(252)](1), o.add(h, l(247))[l(224)]("管道是否闭合")[l(254)](d);
  }(e, t[n(219)]("几何体")), U4(i, e, t[n(219)]("材质")), t.addFn(() => {
    const a = n;
    t.parent[a(239)](t), i.remove(e);
  }).name(n(230));
}
function k4(i, e, t = 0) {
  const n = Ur, r = new W[n(207)]();
  return r[n(235)] = e, r[n(246)] = i, r[n(206)] = t, r.globalConfig = { useGlobalConfig: !1, isSaveMaterials: !0, isSaveChildren: !0, mesh: { castShadow: !1, receiveShadow: !1 }, material: { color: 16777215, wireframe: !1, transparent: !0, opacity: 1, metalness: 0, roughness: 0, emissive: 0, emissiveIntensity: 1, clearcoat: 0, clearcoatRoughness: 0, sheen: 0, sheenRoughness: 0, sheenColor: 0, transmission: 0, envMap: !1, envMapIntensity: 1, reflectivity: 0.98, mapUrl: "", textureAnimation: { isTextureAnimation: !1, offset: { x: 0, y: 0.01 }, rotation: 0 }, map: { repeat: { x: 1, y: 1 }, offset: { x: 0, y: 0 }, center: { x: 0, y: 0 }, rotation: 0 } }, geometry: { radialSegments: 4, radius: 2, closed: !1, tubularSegmentsMultiple: 1 } }, fetch(i)[n(241)]((s) => s[n(251)]()).then((s) => {
    const a = n, { features: o } = s;
    return o[a(244)]((l) => {
      const c = a;
      l[c(250)].type === c(213) ? l[c(250)][c(248)][c(244)]((h) => h[c(244)]((u) => wg(r, u))) : l.geometry[c(220)] === "Polygon" ? l[c(250)].coordinates[c(244)]((h) => wg(r, h)) : l[c(250)][c(220)] === "LineString" && l[c(250)][c(248)][c(258)] > 1 && wg(r, l[c(250)][c(248)]);
    }), N4(r), r.RootMaterials = xf(r), r[a(216)].x = -Math.PI / 2, r.isBorderGroup = !0, r;
  });
}
function wg(i, e) {
  const t = Ur;
  if (e.length < i[t(206)])
    return;
  const n = e.map((l) => function(c, h = 1e4) {
    const u = Bl, [d, p] = c, [f, v] = zn(u(414), u(412), [d, p]);
    return new W[u(421)](f / h, v / h, 0);
  }(l)), r = new W[t(227)](n), s = new Ps(r, n[t(258)] - 1, 2, 4, !1), a = Si(i[t(235)], { color: 16777215 * Math[t(228)](), transparent: !0, alphaHash: !0 }), o = new W[t(243)](s, a);
  o.curve = r, L4(o), i[t(222)](o);
}
function I_() {
  const i = ["isBorderGroup", "边界物体数据源", "children", "2736461wbOtYy", "1006950uabppI", "基础材质", "低于点数舍弃", "attach_add", "96SAOavK", "then", "name", "97645bfLLfo", "forEach", "materialType", "734067hmOtNV", "8eDVGNQ", "open", "添加边界物体", "url", "1062042bHagIs", "add", "addFolder", "240316inIuXr", "1195300omUtxX", "dlength"];
  return (I_ = function() {
    return i;
  })();
}
function gu(i, e) {
  const t = I_();
  return (gu = function(n, r) {
    return t[n -= 372];
  })(i, e);
}
function L6(i) {
  return i.map((e) => function(t) {
    const n = Ur, { children: r, RootMaterials: s } = t;
    return Qt(Ee({}, Ky(t)), { globalConfig: t[n(212)], url: t[n(246)], dlength: t[n(206)], materialType: t[n(235)], RootMaterials: t.globalConfig.isSaveMaterials ? s[n(229)]((a) => sy(a)) : void 0, children: t[n(212)][n(218)] ? Lf(r) : void 0 });
  }(e));
}
function D6(i, e) {
  e && e[gu(386)]((t) => function(n, r) {
    return di(this, null, function* () {
      const s = Ur;
      if (!r)
        return;
      const a = yield k4(r[s(246)], r[s(235)], r[s(206)]);
      a[s(212)] = r[s(212)];
      const { geometry: o } = a[s(212)];
      return a[s(223)][s(244)]((l) => {
        const c = s;
        l[c(250)].dispose(), l[c(250)] = new Ps(l[c(242)], (l.curve[c(256)][c(258)] - 1) * o[c(255)], o.radius, o[c(237)], o.closed), l.geometry[c(226)]();
      }), n[s(232)](a), Qy(a, r), O4(n, a), a.globalConfig[s(218)] && Df(a[s(223)], r[s(223)]), a[s(212)][s(221)] && a[s(209)][s(244)]((l, c) => ay(l, r[s(209)][c])), a;
    });
  }(i, t));
}
function C_() {
  const i = ["intensity-number-float-1", "replace", "pointTexture-texture-sampler2D-", "5296264RQkqAv", "367389gPxVYZ", "iTime", "mixRatio-number-float-1", "bind", "render", "<UV_PLACEHOLDER>", "speed-number-float-0.01", "iTime-number-float-0", "2ERyssx", "if(hasUv) uv=vUv;", "discardVal-number-float-0.5", "assign", "size-number-float-100", "speed", "hasUv-bool-bool-true", "328743PGQftQ", "4804035pqZuxN", "310zYAvSm", "uniforms", "<SPLIT_PLACEHOLDER>", "search", "1185180grqfwK", "fragmentFunc", "value", "mixColor-color-vec3-0xffffff", "fragmentBody", "2798288sJxqOQ", "iTime+speed", "397906RGBfOU", "7wGuyrK", "isdecaySize-bool-bool-true"];
  return (C_ = function() {
    return i;
  })();
}
function R_(i, e) {
  const t = C_();
  return (R_ = function(n, r) {
    return t[n -= 165];
  })(i, e);
}
function Oh(i, e) {
  const t = P_();
  return (Oh = function(n, r) {
    return t[n -= 492];
  })(i, e);
}
function P_() {
  const i = ["670578vvsPsO", "sportType", "isParticleMesh", "mapUrl", "geometry", "23565949zQjYxJ", "2334105JxhvrE", "particlesSum", "3136064KousBc", "1292fkJGNj", "material", "ShaderMaterial", "keys", "BufferAttribute", "random", "12yYBcCq", "parameters", "3NCoQEn", "abs", "60VokDsm", "outer", `
            
            vec3 useColor = `, "Points", `void main() {

            vec2 vUv = gl_PointCoord.xy - .5;

            `, "materialRender", "inner", "set", `

            uniform float size;

            uniform bool isdecaySize;

            void main() {

                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

                gl_PointSize = isdecaySize ? size * ( 300.0 / -mvPosition.z ) : size;

                gl_Position = projectionMatrix * mvPosition;

            } 

        `, "map", "1152iffhPJ", "commonAnimateRender", "2630480tlMBVu", "setAttribute", "4159230UzqBPz", `;

            vec4 textureColor = texture2D( pointTexture, gl_PointCoord );

            if (textureColor.a < discardVal) discard;

            else useColor *= textureColor.rgb;

            gl_FragColor = vec4( mix( mixColor, useColor * vec3( intensity, intensity, intensity), mixRatio ) , opacity );
            
        }`, "maxVelocity", "56dSbvrJ", "commonFrames", "geometryRender", "BufferGeometry", "join"];
  return (P_ = function() {
    return i;
  })();
}
function F4(i, e, t) {
  const n = Oh, r = B4(t), s = function(o, l) {
    const c = Oh, { uniforms: h, fragmentFunc: u, fragmentBody: d, key: p, render: f } = function(m, y, g = "") {
      const _ = R_, { name: x, customUniforms: M, key: b, fragment: w, render: T } = ZS[y], A = { uniforms: Ee({}, Lp(m, [_(183) + g, _(197), _(195), "opacity-number-float-1", _(180), _(199), _(192), _(191), _(181), _(187), _(174), "iResolution-dom-vec2-0,0"])), fragmentFunc: "", fragmentBody: "", key: b, shaderProgramsCodeName: x };
      if (M && Object[_(196)](A.uniforms, Lp(m, M)), w[_(170)](_(169)) !== -1) {
        const [L, I] = w.split("<SPLIT_PLACEHOLDER>");
        A[_(172)] = L, A.fragmentBody = I[_(182)]("<UV_PLACEHOLDER>", _(194));
      } else
        A[_(175)] = w[_(182)](_(190), "if(hasUv) uv=vUv;");
      return T === _(177) ? A[_(189)] = () => A.uniforms[_(186)][_(173)] += A.uniforms[_(198)][_(173)] : A[_(189)] = new Function(T)[_(188)](A[_(168)]), A;
    }(o, l.shaderCodeName, l[c(501)]), v = new W[c(509)]({ uniforms: h, vertexShader: c(525), fragmentShader: Object[c(510)](h)[c(526)]((m) => "uniform " + h[m].unit + " " + m + `;
`)[c(497)]("") + (u + c(521) + d + c(519) + p + c(532)), transparent: !0, depthTest: !0, blending: al });
    return v.materialRender = f, v;
  }(e, t), a = new W[n(520)](r, s);
  return a[n(514)] = t, a[n(528)] = () => {
    var l, c, h, u;
    const o = n;
    (c = (l = a[o(502)]).geometryRender) == null || c.call(l), (u = (h = a[o(508)])[o(522)]) == null || u.call(h);
  }, a[n(500)] = !0, i.add(a), i[n(494)].push(a), a;
}
function B4(i) {
  const e = Oh;
  if (i.outer - i[e(523)] < 1)
    return new W[e(496)]();
  const t = new Float32Array(3 * i[e(505)]), n = new Float32Array(3 * i[e(505)]), r = { 全随机: (o) => {
    const l = e;
    n[3 * o] += (Math[l(512)]() - 0.5) * i[l(492)] / 1e3, n[3 * o + 1] += (Math[l(512)]() - 0.5) * i.maxVelocity / 1e3, n[3 * o + 2] += (Math[l(512)]() - 0.5) * i[l(492)] / 1e3;
  }, 随机向上: (o) => {
    const l = e;
    n[3 * o] += (Math[l(512)]() - 0.5) * i[l(492)] / 1e3, n[3 * o + 1] += Math[l(516)]((Math.random() - 0.5) * i[l(492)] / 1e5), n[3 * o + 2] += (Math[l(512)]() - 0.5) * i[l(492)] / 1e3;
  }, 随机向下: (o) => {
    const l = e;
    n[3 * o] += (Math.random() - 0.5) * i[l(492)] / 1e3, n[3 * o + 1] -= Math[l(516)]((Math[l(512)]() - 0.5) * i[l(492)] / 1e5), n[3 * o + 2] += (Math[l(512)]() - 0.5) * i[l(492)] / 1e3;
  }, 直线匀速向上: (o) => {
    const l = e;
    n[3 * o] = 0, n[3 * o + 1] += i[l(492)] / 2 / 1e5, n[3 * o + 2] = 0;
  }, 直线匀速向下: (o) => {
    const l = e;
    n[3 * o] = 0, n[3 * o + 1] -= i[l(492)] / 2 / 1e5, n[3 * o + 2] = 0;
  } }[i[e(499)]];
  function s() {
    const o = e;
    let l, c, h;
    do
      l = 2 * Math[o(512)]() * i.outer - i[o(518)], c = 2 * Math.random() * i[o(518)] - i[o(518)], h = 2 * Math[o(512)]() * i[o(518)] - i[o(518)];
    while (Math[o(516)](l) <= i.inner && Math[o(516)](c) <= i[o(523)] && Math[o(516)](h) <= i.inner);
    return [l, c, h];
  }
  for (let o = 0; o < i.particlesSum; o++)
    t[e(524)](s(), 3 * o);
  const a = new Re();
  return a[e(530)]("position", new W[e(511)](t, 3)), a[e(495)] = () => {
    const o = e;
    for (let l = 0; l < i[o(505)]; l++)
      if (r(l), t[3 * l] += n[3 * l], t[3 * l + 1] += n[3 * l + 1], t[3 * l + 2] += n[3 * l + 2], Math[o(516)](t[3 * l]) > i.outer || Math[o(516)](t[3 * l + 1]) > i[o(518)] || Math.abs(t[3 * l + 2]) > i.outer || Math.abs(t[3 * l]) < i.inner && Math[o(516)](t[3 * l + 1]) < i[o(523)] && Math[o(516)](t[3 * l + 2]) < i[o(523)]) {
        const [c, h, u] = s();
        t[3 * l] = c, t[3 * l + 1] = h, t[3 * l + 2] = u, n[3 * l] = 0, n[3 * l + 1] = 0, n[3 * l + 2] = 0;
      }
    a.attributes.position.needsUpdate = !0;
  }, a;
}
function ba(i, e) {
  const t = L_();
  return (ba = function(n, r) {
    return t[n -= 128];
  })(i, e);
}
function L_() {
  const i = ["3RszrMc", "parent", "直线匀速向上", "9yzlAWx", "particlesSum", "parameters", "5888840YBgJDf", "sportType", "needsUpdate", "add", "混合模式", "blending", "onChange", "全随机", "外半径", "depthTest", "6660KZJrGb", "直线匀速向下", "5537OyyOaQ", "attach", "name", "addFolder", "remove", "transformControls", "uniforms", "基础属性", "BufferGeometry", "removeFolder", "339uSMOhp", "深度测试", "236706FmOtPM", "geometry", "addFn", "dispose", "3209420Wuqpxe", "着色器参数", "8884140LgLniL", "最大速度", "运动方式", "34600fhwRXG", "630KxktRF", "32780sKLWea", "material"];
  return (L_ = function() {
    return i;
  })();
}
function pM(i, e, t) {
  const n = ba;
  Gr(e, t[n(140)](n(144))), function(r, s) {
    const a = ba;
    let o = null;
    function l() {
      const c = ba;
      o || (r.geometry[c(152)](), r[c(150)] = new W[c(145)](), o = setTimeout(() => {
        r.geometry = B4(r.parameters), o = null;
      }, 200));
    }
    s.add(r[a(167)], a(166), 1)[a(139)]("数量")[a(131)](l), s[a(128)](r.parameters, "inner", 0)[a(139)]("内半径")[a(131)](l), s.add(r[a(167)], "outer", 500)[a(139)](a(133)).onChange(l), s[a(128)](r[a(167)], "maxVelocity")[a(139)](a(156))[a(131)](l), s[a(128)](r[a(167)], a(169), [a(132), "随机向下", "随机向上", a(164), a(136)])[a(139)](a(157))[a(131)](l);
  }(e, t[n(140)]("几何")), function(r, s) {
    const a = ba;
    s.add(r, a(134)).name(a(148)).onChange(() => r.needsUpdate = !0), s[a(128)](r, a(130), fv)[a(139)](a(129))[a(131)]((o) => (r.blending = Number(o), r[a(170)] = !0)), np(r[a(143)], s[a(140)](a(154)));
  }(e[n(161)], t.addFolder("材质")), t[n(151)](() => i[n(142)][n(138)](e)).name("选中"), t[n(151)](() => {
    const r = n;
    i[r(141)](e), t[r(163)][r(146)](t);
  }).name("删除");
}
function Hl(i, e) {
  const t = D_();
  return (Hl = function(n, r) {
    return t[n -= 327];
  })(i, e);
}
function D_() {
  const i = ["keys", "mapUrl", "粒子列表", "100xYTzyZ", "add", "88WJuLDf", "贴图路径", "1485855soXxdJ", "内半径", "水波纹", "open", "外半径", "着色器", "addFolder", "map", "maxVelocity", "直线匀速向上", "outer", "2613138EzjPNo", "name", "85445iylkeW", "全随机", "993816VMQOhI", "https://z2586300277.github.io/three-editor/dist/files/channels/snow.png", "5906CcbNmn", "particlesSum", "直线匀速向下", "2218224XtmqDA", "随机向下", "shaderCodeName", "inner", "10325367OERqOy"];
  return (D_ = function() {
    return i;
  })();
}
function N6() {
  const i = Hl;
  return { particlesSum: 1e5, inner: 0, outer: 2e3, maxVelocity: 50, mapUrl: i(347), sportType: i(345), shaderCodeName: i(333) };
}
function O6(i) {
  return i[Hl(338)]((e) => function(t) {
    const { material: n } = t, { uniforms: r, blending: s, depthTest: a } = n;
    return Qt(Ee({}, Ja(t)), { parameters: t.parameters, material: { uniforms: KS(r), blending: s, depthTest: a } });
  }(e));
}
function U6(i, e, t) {
  const n = Hl;
  t == null || t[n(338)]((r) => function(s, a, o) {
    const l = ba;
    if (!o)
      return;
    const c = F4(s, a, o.parameters);
    $a(c, o);
    const { material: h } = o;
    return c[l(161)][l(130)] = h[l(130)], c[l(161)][l(134)] = h[l(134)], QS(c[l(161)][l(143)], h[l(143)]), h[l(170)] = !0, c;
  }(i, e, r));
}
function N_() {
  const i = ["dispose", "isTextMesh", "曲线分段", "bevelSize", "180TVLoqo", "651468dWcSbb", "addFn", "parent", "add", "geometry", "bevelThickness", "62880jZzbzO", "removeFolder", "4826738XYuXnL", "step", "onChange", "material", "curveSegments", "size", "remove", "fontLink", "depth", "materialType", "1071YlpMwo", "bevelEnabled", "text", "addFolder", "759205unvxIt", "斜角大小", "height", "2044056wUpqck", "bevelSegments", "斜角厚度", "斜角分段", "name", "min", "1369974GZtMnU", "110880YpeofI", "几何体"];
  return (N_ = function() {
    return i;
  })();
}
function Na(i, e) {
  const t = N_();
  return (Na = function(n, r) {
    return t[n -= 280];
  })(i, e);
}
function fM(i, e, t) {
  const n = Na;
  Gr(e, t[n(299)]("基础配置")), function(r, s) {
    const a = Na, { geometry: o } = r, { parameters: l } = o, { options: c } = l;
    let h = null;
    function u() {
      h && clearTimeout(h), h = setTimeout(() => {
        const d = Na;
        r[d(282)][d(312)](), r.geometry = new I4(r[d(298)], c), h = null;
      }, 200);
    }
    s.add(r, a(298))[a(288)](u)[a(307)]("文本"), s[a(281)](c, a(291))[a(288)](u)[a(307)]("大小"), s.add(c, "depth").onChange(u)[a(307)]("深度"), s[a(281)](c, a(302)).onChange(u)[a(307)]("高度"), s[a(281)](c, a(290))[a(288)](u)[a(307)](a(314))[a(287)](1).min(1), s.add(c, "bevelEnabled")[a(288)](u)[a(307)]("斜角"), s[a(281)](c, "bevelThickness")[a(288)](u)[a(307)](a(305)), s[a(281)](c, "bevelSize")[a(288)](u)[a(307)](a(301)), s[a(281)](c, a(304)).onChange(u)[a(307)](a(306))[a(287)](1)[a(308)](0);
  }(e, t.addFolder(n(311))), vf(i, e[n(289)], t[n(299)]("材质")), t[n(318)](() => {
    const r = n;
    i[r(292)](e), t[r(280)][r(285)](t);
  })[n(307)]("删除");
}
function O_(i, e) {
  const t = U_();
  return (O_ = function(n, r) {
    return t[n -= 469];
  })(i, e);
}
function U_() {
  const i = ["isTextMesh", "Mesh", "字体链接", "添加文本物体", "attach_add", "addFolder", "add", "forEach", "3549819ctwPjc", "children", "3093800udUPNC", "8zwoCnN", "fontLink", "name", "7847973ClRRdB", "文本内容", "open", "4437690CQWBnY", "text", "257092hkyBsh", "1eOrrUV", "materialType", "then", "336696Mhmbwp", "689008bMmEyV", "slice"];
  return (U_ = function() {
    return i;
  })();
}
function k6(i) {
  return i.map((e) => function(t) {
    const n = Na, { material: r, geometry: s } = t, { parameters: a } = s, { options: o } = a;
    return Qt(Ee({}, Ja(t)), { fontLink: t.fontLink, text: t[n(298)], geometry: { geometryType: "TextGeometry", parameters: { size: o.size, depth: o[n(294)], height: o[n(302)], curveSegments: o[n(290)], bevelEnabled: o[n(297)], bevelThickness: o[n(283)], bevelSize: o[n(315)], bevelSegments: o.bevelSegments } }, material: mf(r) });
  }(e));
}
function F6(i, e) {
  e == null || e.forEach((t) => function(n, r) {
    return di(this, null, function* () {
      const s = Na;
      if (!r)
        return;
      const { geometry: a, material: o } = r, { parameters: l } = a, c = yield C4(r[s(293)], r.text, l), h = Si(o[s(295)]), u = new ve(c, h);
      return u[s(293)] = r[s(293)], u[s(298)] = r.text, u[s(313)] = !0, n.add(u), gf(n, u[s(289)], o), $a(u, r), u;
    });
  }(i, t));
}
(function(i, e) {
  const t = Of, n = m_();
  for (; ; )
    try {
      if (-parseInt(t(362)) / 1 + parseInt(t(363)) / 2 + parseInt(t(360)) / 3 + -parseInt(t(367)) / 4 + -parseInt(t(366)) / 5 * (parseInt(t(372)) / 6) + parseInt(t(359)) / 7 * (-parseInt(t(371)) / 8) + -parseInt(t(369)) / 9 * (-parseInt(t(361)) / 10) === 577425)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = v_, n = g_();
  for (; ; )
    try {
      if (-parseInt(t(142)) / 1 * (parseInt(t(150)) / 2) + -parseInt(t(144)) / 3 + -parseInt(t(135)) / 4 * (-parseInt(t(153)) / 5) + parseInt(t(132)) / 6 + parseInt(t(137)) / 7 + parseInt(t(140)) / 8 * (-parseInt(t(145)) / 9) + parseInt(t(147)) / 10 === 424139)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Cs, n = y_();
  for (; ; )
    try {
      if (-parseInt(t(343)) / 1 * (-parseInt(t(359)) / 2) + -parseInt(t(350)) / 3 + -parseInt(t(342)) / 4 + -parseInt(t(334)) / 5 + -parseInt(t(346)) / 6 + -parseInt(t(380)) / 7 + -parseInt(t(379)) / 8 * (-parseInt(t(333)) / 9) === 474503)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  for (var t = Fl, n = __(); ; )
    try {
      if (-parseInt(t(359)) / 1 * (-parseInt(t(395)) / 2) + -parseInt(t(375)) / 3 * (parseInt(t(378)) / 4) + -parseInt(t(369)) / 5 + -parseInt(t(371)) / 6 * (-parseInt(t(380)) / 7) + parseInt(t(357)) / 8 + parseInt(t(391)) / 9 * (parseInt(t(367)) / 10) + -parseInt(t(350)) / 11 * (-parseInt(t(353)) / 12) === 664063)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Bl, n = x_();
  for (; ; )
    try {
      if (parseInt(t(405)) / 1 * (parseInt(t(409)) / 2) + parseInt(t(401)) / 3 * (-parseInt(t(413)) / 4) + parseInt(t(402)) / 5 * (-parseInt(t(431)) / 6) + parseInt(t(419)) / 7 + -parseInt(t(426)) / 8 * (-parseInt(t(418)) / 9) + -parseInt(t(427)) / 10 * (parseInt(t(407)) / 11) + parseInt(t(403)) / 12 === 166505)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Nh, n = b_();
  for (; ; )
    try {
      if (-parseInt(t(490)) / 1 * (parseInt(t(512)) / 2) + parseInt(t(473)) / 3 * (parseInt(t(474)) / 4) + -parseInt(t(503)) / 5 * (parseInt(t(489)) / 6) + -parseInt(t(485)) / 7 * (-parseInt(t(496)) / 8) + -parseInt(t(482)) / 9 + -parseInt(t(497)) / 10 * (-parseInt(t(504)) / 11) + parseInt(t(506)) / 12 * (parseInt(t(502)) / 13) === 412029)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = mu, n = M_();
  for (; ; )
    try {
      if (parseInt(t(174)) / 1 * (parseInt(t(172)) / 2) + parseInt(t(211)) / 3 * (-parseInt(t(194)) / 4) + parseInt(t(228)) / 5 * (-parseInt(t(219)) / 6) + parseInt(t(173)) / 7 + parseInt(t(177)) / 8 * (-parseInt(t(170)) / 9) + parseInt(t(203)) / 10 + parseInt(t(193)) / 11 === 987171)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = dr, n = w_();
  for (; ; )
    try {
      if (-parseInt(t(401)) / 1 + parseInt(t(413)) / 2 * (parseInt(t(353)) / 3) + -parseInt(t(436)) / 4 * (parseInt(t(356)) / 5) + parseInt(t(451)) / 6 * (-parseInt(t(419)) / 7) + -parseInt(t(368)) / 8 + -parseInt(t(447)) / 9 + parseInt(t(361)) / 10 === 316615)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = to, n = S_();
  for (; ; )
    try {
      if (-parseInt(t(370)) / 1 + parseInt(t(350)) / 2 + -parseInt(t(372)) / 3 + -parseInt(t(342)) / 4 + -parseInt(t(343)) / 5 * (-parseInt(t(364)) / 6) + parseInt(t(361)) / 7 * (parseInt(t(351)) / 8) + parseInt(t(341)) / 9 === 918764)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = zl, n = E_();
  for (; ; )
    try {
      if (parseInt(t(249)) / 1 + -parseInt(t(234)) / 2 * (parseInt(t(221)) / 3) + -parseInt(t(245)) / 4 + -parseInt(t(237)) / 5 * (-parseInt(t(223)) / 6) + -parseInt(t(236)) / 7 * (-parseInt(t(233)) / 8) + parseInt(t(224)) / 9 * (-parseInt(t(232)) / 10) + -parseInt(t(230)) / 11 * (-parseInt(t(218)) / 12) === 990039)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Ur, n = A_();
  for (; ; )
    try {
      if (-parseInt(t(236)) / 1 * (-parseInt(t(215)) / 2) + parseInt(t(259)) / 3 + -parseInt(t(234)) / 4 + -parseInt(t(210)) / 5 * (-parseInt(t(257)) / 6) + -parseInt(t(208)) / 7 + parseInt(t(260)) / 8 * (parseInt(t(214)) / 9) + parseInt(t(238)) / 10 === 678288)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = gu, n = I_();
  for (; ; )
    try {
      if (parseInt(t(396)) / 1 + -parseInt(t(378)) / 2 + parseInt(t(393)) / 3 + parseInt(t(372)) / 4 + parseInt(t(385)) / 5 * (-parseInt(t(382)) / 6) + parseInt(t(377)) / 7 + -parseInt(t(389)) / 8 * (parseInt(t(388)) / 9) === 386576)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = R_, n = C_();
  for (; ; )
    try {
      if (parseInt(t(193)) / 1 * (parseInt(t(178)) / 2) + parseInt(t(185)) / 3 + -parseInt(t(176)) / 4 + parseInt(t(166)) / 5 + -parseInt(t(171)) / 6 * (-parseInt(t(179)) / 7) + parseInt(t(184)) / 8 + parseInt(t(165)) / 9 * (-parseInt(t(167)) / 10) === 508830)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Oh, n = P_();
  for (; ; )
    try {
      if (-parseInt(t(527)) / 1 * (-parseInt(t(507)) / 2) + parseInt(t(515)) / 3 * (-parseInt(t(529)) / 4) + parseInt(t(531)) / 5 + -parseInt(t(498)) / 6 * (-parseInt(t(493)) / 7) + -parseInt(t(506)) / 8 + parseInt(t(504)) / 9 * (parseInt(t(517)) / 10) + -parseInt(t(503)) / 11 * (parseInt(t(513)) / 12) === 834225)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = ba, n = L_();
  for (; ; )
    try {
      if (parseInt(t(162)) / 1 * (-parseInt(t(149)) / 2) + -parseInt(t(147)) / 3 * (-parseInt(t(158)) / 4) + parseInt(t(153)) / 5 + parseInt(t(135)) / 6 * (-parseInt(t(137)) / 7) + parseInt(t(168)) / 8 * (parseInt(t(165)) / 9) + -parseInt(t(159)) / 10 * (-parseInt(t(160)) / 11) + -parseInt(t(155)) / 12 === 569765)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Hl, n = D_();
  for (; ; )
    try {
      if (-parseInt(t(348)) / 1 * (-parseInt(t(327)) / 2) + parseInt(t(346)) / 3 + -parseInt(t(329)) / 4 * (-parseInt(t(344)) / 5) + parseInt(t(342)) / 6 + parseInt(t(331)) / 7 + -parseInt(t(351)) / 8 + -parseInt(t(355)) / 9 === 225777)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Na, n = N_();
  for (; ; )
    try {
      if (parseInt(t(300)) / 1 + -parseInt(t(309)) / 2 + parseInt(t(317)) / 3 + parseInt(t(303)) / 4 + -parseInt(t(310)) / 5 * (parseInt(t(316)) / 6) + -parseInt(t(286)) / 7 + -parseInt(t(284)) / 8 * (-parseInt(t(296)) / 9) === 382914)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = O_, n = U_();
  for (; ; )
    try {
      if (parseInt(t(492)) / 1 * (-parseInt(t(491)) / 2) + parseInt(t(469)) / 3 * (parseInt(t(483)) / 4) + parseInt(t(482)) / 5 + -parseInt(t(489)) / 6 + -parseInt(t(480)) / 7 + parseInt(t(470)) / 8 + parseInt(t(486)) / 9 === 426069)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
class Uf extends ve {
  constructor(e, t = {}) {
    super(e), this.isReflector = !0, this.type = "Reflector", this.camera = new jt();
    const n = this, r = t.color !== void 0 ? new ce(t.color) : new ce(8355711), s = t.textureWidth || 512, a = t.textureHeight || 512, o = t.clipBias || 0, l = t.shader || Uf.ReflectorShader, c = t.multisample !== void 0 ? t.multisample : 4, h = new Fi(), u = new S(), d = new S(), p = new S(), f = new fe(), v = new S(0, 0, -1), m = new je(), y = new S(), g = new S(), _ = new je(), x = new fe(), M = this.camera, b = new dt(s, a, { samples: c, type: Vt }), w = new st({ name: l.name !== void 0 ? l.name : "unspecified", uniforms: rn.clone(l.uniforms), fragmentShader: l.fragmentShader, vertexShader: l.vertexShader });
    w.uniforms.tDiffuse.value = b.texture, w.uniforms.color.value = r, w.uniforms.textureMatrix.value = x, this.material = w, this.onBeforeRender = function(T, A, L) {
      if (d.setFromMatrixPosition(n.matrixWorld), p.setFromMatrixPosition(L.matrixWorld), f.extractRotation(n.matrixWorld), u.set(0, 0, 1), u.applyMatrix4(f), y.subVectors(d, p), y.dot(u) > 0)
        return;
      y.reflect(u).negate(), y.add(d), f.extractRotation(L.matrixWorld), v.set(0, 0, -1), v.applyMatrix4(f), v.add(p), g.subVectors(d, v), g.reflect(u).negate(), g.add(d), M.position.copy(y), M.up.set(0, 1, 0), M.up.applyMatrix4(f), M.up.reflect(u), M.lookAt(g), M.far = L.far, M.updateMatrixWorld(), M.projectionMatrix.copy(L.projectionMatrix), x.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), x.multiply(M.projectionMatrix), x.multiply(M.matrixWorldInverse), x.multiply(n.matrixWorld), h.setFromNormalAndCoplanarPoint(u, d), h.applyMatrix4(M.matrixWorldInverse), m.set(h.normal.x, h.normal.y, h.normal.z, h.constant);
      const I = M.projectionMatrix;
      _.x = (Math.sign(m.x) + I.elements[8]) / I.elements[0], _.y = (Math.sign(m.y) + I.elements[9]) / I.elements[5], _.z = -1, _.w = (1 + I.elements[10]) / I.elements[14], m.multiplyScalar(2 / m.dot(_)), I.elements[2] = m.x, I.elements[6] = m.y, I.elements[10] = m.z + 1 - o, I.elements[14] = m.w, n.visible = !1;
      const P = T.getRenderTarget(), N = T.xr.enabled, F = T.shadowMap.autoUpdate;
      T.xr.enabled = !1, T.shadowMap.autoUpdate = !1, T.setRenderTarget(b), T.state.buffers.depth.setMask(!0), T.autoClear === !1 && T.clear(), T.render(A, M), T.xr.enabled = N, T.shadowMap.autoUpdate = F, T.setRenderTarget(P);
      const z = L.viewport;
      z !== void 0 && T.state.viewport(z), n.visible = !0;
    }, this.getRenderTarget = function() {
      return b;
    }, this.dispose = function() {
      b.dispose(), n.material.dispose();
    };
  }
}
function fa(i, e) {
  const t = k_();
  return (fa = function(n, r) {
    return t[n -= 361];
  })(i, e);
}
function k_() {
  const i = ["15415670uavbCb", "initParameters", "6CeDsql", "clipBias", "clientHeight", "setHex", "528220WphlgR", "6ggxbER", "color", "visible", "145810YaIRZY", "4529628xlCblb", "getHex", "uniforms", "PlaneGeometry", "name", "7792008HrGAGM", "wireframe", "rotateX", "2694601QbqSUW", "value", "material", "getPixelRatio", "add", "308215TpYFff", "9rxPkLW"];
  return (k_ = function() {
    return i;
  })();
}
Uf.ReflectorShader = { name: "ReflectorShader", uniforms: { color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null } }, vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`, fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}` }, function(i, e) {
  const t = fa, n = k_();
  for (; ; )
    try {
      if (parseInt(t(383)) / 1 + parseInt(t(361)) / 2 * (parseInt(t(379)) / 3) + parseInt(t(362)) / 4 + -parseInt(t(375)) / 5 + -parseInt(t(384)) / 6 * (parseInt(t(370)) / 7) + -parseInt(t(367)) / 8 * (-parseInt(t(376)) / 9) + -parseInt(t(377)) / 10 === 792285)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const B6 = { name: "镜面", disBlendShader: !0, initParameters: { clipBias: 0.01, color: 12700619 }, initPanel: function(i) {
  const e = fa;
  i[e(374)](this.initParameters, e(380))[e(366)]("裁剪偏移"), i.addColor(this[e(378)], e(385))[e(366)]("颜色");
}, create: function(i, e) {
  const t = fa, n = Ee(Ee({}, this[t(378)]), e == null ? void 0 : e.initParameters), { DOM: r, renderer: s } = i, a = new Uf(new W[t(365)](100, 100), Ee({ clipBias: 0.01, textureWidth: r.clientWidth * s[t(373)](), textureHeight: r[t(381)] * s[t(373)](), color: 12700619 }, n));
  return a[t(378)] = n, a[t(369)](-Math.PI / 2), a;
}, changePanel: function(i, e) {
  const t = fa, { material: n } = i;
  e[t(374)](n, t(386))[t(366)]("可见"), e[t(374)](n, t(368))[t(366)]("线框"), e.addHexColor(n[t(364)][t(385)][t(371)])[t(366)]("颜色");
}, getStorage: function(i) {
  const e = fa, { material: t, initParameters: n } = i;
  return { initParameters: n, material: { wireframe: t[e(368)], color: t[e(364)][e(385)][e(371)][e(363)]() } };
}, setStorage: function(i, e) {
  const t = fa;
  if (!e)
    return;
  const { material: n } = i;
  n[t(368)] = e[t(372)][t(368)], n[t(364)][t(385)].value[t(382)](e[t(372)][t(385)]);
} }, Po = F_;
function F_(i, e) {
  const t = B_();
  return (F_ = function(n, r) {
    return t[n -= 435];
  })(i, e);
}
function B_() {
  const i = ["RootMaterials", "material", "initParameters", "91nOoixf", "5701932kaHaoK", "1535tYWvBi", "getHex", "name", "rotation", "370202knACcT", "876702xepfzL", "clone", "opacity", "AdditiveBlending", "2596wGsyJO", "DoubleSide", "RepeatWrapping", "更新贴图", "setHex", "size", "add", "map", "wrapT", "wrapS", "MeshBasicMaterial", "forEach", "6885IrXhRE", "立柱尺寸", "color", "https://z2586300277.github.io/3d-file-server/images/channels/lightMap.png", "addFn", "67007ELPKZh", "CylinderGeometry", "185960CjztzE", "面透明度", "url", "children", "PlaneGeometry", "addHexColor", "资源路径", "load", "Mesh"];
  return (B_ = function() {
    return i;
  })();
}
(function(i, e) {
  const t = F_, n = B_();
  for (; ; )
    try {
      if (parseInt(t(453)) / 1 + -parseInt(t(473)) / 2 + -parseInt(t(448)) / 3 + -parseInt(t(436)) / 4 * (parseInt(t(469)) / 5) + parseInt(t(474)) / 6 + parseInt(t(467)) / 7 * (-parseInt(t(455)) / 8) + parseInt(t(468)) / 9 === 157848)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const z6 = { name: "光柱", initParameters: { url: Po(451), size: 0.25 }, initPanel: function(i) {
  const e = Po;
  i[e(442)](this[e(466)], e(457)).name(e(461)), i.add(this[e(466)], "size")[e(471)](e(449));
}, create: function({}, i) {
  const e = Po, t = Ee(Ee({}, this[e(466)]), i == null ? void 0 : i.initParameters), n = new W[e(454)](t[e(441)] || 0.3, t[e(441)] || 0.3, 20, 6), r = new nn({ color: 16572044, transparent: !0, opacity: 0.5, side: W[e(437)] }), s = new W[e(463)](n, r);
  r.blending = W[e(435)];
  const a = new Va()[e(462)](t.url);
  a[e(445)] = In, a[e(444)] = In;
  const o = new W[e(459)](1.5, 20), l = new W[e(446)]({ transparent: !0, opacity: 0.3, side: W[e(437)], map: a });
  l.blending = W[e(435)], l.depthTest = !1;
  const c = new W[e(463)](o, l), h = c[e(475)]();
  h.rotation.y = Math.PI / 3;
  const u = c[e(475)]();
  u[e(472)].y = -Math.PI / 3, s[e(442)](u), s[e(442)](c), s[e(442)](h), s.position.y = 10;
  const d = new oi();
  return d.RootMaterials = [r, l], d[e(442)](s), d.initParameters = t, d;
}, changePanel(i, e, {}) {
  const t = Po, [n, r] = i.RootMaterials;
  e.add(i[t(466)], t(457)).name(t(461)), e[t(460)](n[t(450)])[t(471)]("立柱颜色"), e[t(442)](n, t(476), 0, 1)[t(471)]("立柱透明度"), e[t(460)](r[t(450)]).name("面颜色"), e[t(442)](r, t(476), 0, 1)[t(471)](t(456)), e[t(452)](() => {
    const s = t, { url: a } = i.initParameters;
    if (!a)
      return;
    const o = new Va()[s(462)](a);
    o.wrapS = W[s(438)], o[s(444)] = W[s(438)], i[s(458)][0][s(458)][s(447)]((l) => {
      const c = s;
      l[c(465)][c(443)] = o;
    });
  })[t(471)](t(439));
}, getStorage: function(i) {
  const e = Po, { initParameters: t } = i, [n, r] = i[e(464)];
  return { initParameters: t, RootMaterials: [{ color: n[e(450)][e(470)](), opacity: n[e(476)] }, { color: r[e(450)][e(470)](), opacity: r[e(476)] }] };
}, setStorage: function(i, e) {
  const t = Po;
  if (!e)
    return;
  const [n, r] = i[t(464)], [s, a] = e[t(464)];
  n[t(450)][t(440)](s.color), n[t(476)] = s[t(476)], r.color[t(440)](a[t(450)]), r[t(476)] = a[t(476)];
} }, vu = z_;
function z_(i, e) {
  const t = H_();
  return (z_ = function(n, r) {
    return t[n -= 236];
  })(i, e);
}
(function(i, e) {
  const t = z_, n = H_();
  for (; ; )
    try {
      if (parseInt(t(239)) / 1 + parseInt(t(250)) / 2 + parseInt(t(249)) / 3 + parseInt(t(260)) / 4 + -parseInt(t(256)) / 5 * (-parseInt(t(245)) / 6) + -parseInt(t(237)) / 7 * (parseInt(t(241)) / 8) + -parseInt(t(253)) / 9 * (parseInt(t(236)) / 10) === 181474)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const z4 = [B6, z6], yu = (i) => z4.find((e) => e[vu(243)] === i);
function H_() {
  const i = ["addFn", "504024WawXPT", "getStorage", "parent", "addFolder", "831822uCLKWv", "91430aLvNZI", "attach", "removeFolder", "9xxpYyj", "isDesignMesh", "相关配置", "10GNGeMW", "add", "disBlendShader", "changePanel", "1233696oXBUIY", "7220370IogxfF", "7cMwaNP", "designType", "111532nnhsZZ", "基础配置", "59536mqDNFC", "remove", "name"];
  return (H_ = function() {
    return i;
  })();
}
function mM(i, e, t) {
  var o;
  const n = vu, { scene: r, transformControls: s } = t, a = yu(i[n(238)]);
  Gr(i, e[n(248)](n(240))), (o = a[n(259)]) == null || o.call(a, i, e[n(248)](n(255)), t), e[n(244)](() => s[n(251)](i)).name("选中"), e.addFn(() => {
    const l = n;
    r[l(242)](i), e[l(247)][l(252)](e);
  })[n(243)]("删除");
}
function H4(i, e, t) {
  const n = vu, r = i.create(e, t);
  if (r)
    return r[n(254)] = !0, r[n(238)] = i[n(243)], i[n(258)] && (r.disBlendShader = !0), r;
}
function H6(i) {
  return i[Gl(312)]((e) => function(t) {
    var a;
    const n = vu, { designType: r } = t, s = yu(r);
    return Ee(Ee({ designType: r }, Ja(t)), (a = s[n(246)]) == null ? void 0 : a.call(s, t));
  }(e));
}
function Gl(i, e) {
  const t = G_();
  return (Gl = function(n, r) {
    return t[n -= 302];
  })(i, e);
}
function G6(i, e) {
  const t = Gl;
  e == null || e[t(316)]((n) => function(r, s) {
    var h;
    const a = vu;
    if (!s)
      return;
    const { scene: o } = r, l = yu(s[a(238)]), c = H4(l, r, s);
    o[a(257)](c), $a(c, s), (h = l.setStorage) == null || h.call(l, c, s, r);
  }(i, n));
}
function gM(i, e) {
  var r;
  const t = Gl, n = yu(i);
  n && ((r = n[t(320)]) == null || r.call(n, e));
}
function G_() {
  const i = ["map", "add", "children", "401913YRYrsX", "forEach", "22crEqUl", "950jOLMJG", "1524600Fsgsdj", "initPanel", "初始参数", "name", "240162dUjGfY", "2188pYrNZq", "68232SVDnZH", "2868912nTeMWA", "onChange", "isDesignMesh", "type", "478934RifXCU", "attach_add", "addFolder", "10sJfaga", "42ZsyqIo", "1fvqcIZ", "parent"];
  return (G_ = function() {
    return i;
  })();
}
function _u(i, e) {
  const t = V_();
  return (_u = function(n, r) {
    return t[n -= 111];
  })(i, e);
}
function V_() {
  const i = ["forEach", "rootInfo", "drawMeshList", "170527cAvCYn", "文本物体", "内置物体", "particleList", "modelList", "地图边界", "3214938bnrQIp", "灯光配置", "粒子物体", "6MjFWUM", "6105856rRoPtg", "设计物体", "textMeshList", "borderGroupList", "isParticleMesh", "24664LbyuFB", "isDesignMesh", "innerMeshList", "模型管理", "isGeoGroup", "3054272fmhOgw", "isTextMesh", "isBorderGroup", "lighting", "2406123NCejVu", "geoGroupList", "lightList", "push", "5cleGUG", "绘制物体", "isLight", "addCoreDragFolder", "designMeshList", "717889LhcsqK"];
  return (V_ = function() {
    return i;
  })();
}
function V6() {
  return { modelCore: { rootFolder: null, insertModel: null, progressList: [], url: "https://z2586300277.github.io/three-editor/dist/files/resource/LittlestTokyo.glb", modelAnimationPlay: n_ }, innerMeshCore: { geometryType: "立方体", materialType: Ul(353) }, drawCore: (i = Fl, { mode: "围栏物体", pointMode: "场景交点", pointModeList: [i(363), "地图区域中心", "地图行政中心"], modeList: [i(390), "平面绘制", i(374), "直线路径"], materialType: i(373), drawEventCall: null, currentDrawFolder: null, sceneEventCall: function(e, t) {
    var r, s, a, o, l;
    var n = i;
    switch (this[n(383)]) {
      case n(363):
        return (r = this[n(384)]) == null ? void 0 : r.call(this, e);
      case n(364):
        return (s = t[n(368)]) != null && s.properties.centroidCoord3 ? (a = this[n(384)]) == null ? void 0 : a.call(this, t[n(388)][n(386)](t[n(368)][n(352)][n(394)][n(393)]()[n(351)](t[n(392)])[n(385)](t.initTranslate))) : void 0;
      case "地图行政中心":
        return (o = t[n(368)]) != null && o[n(352)][n(362)] ? (l = this[n(384)]) == null ? void 0 : l.call(this, t.parent[n(386)](t.geoInfo.properties[n(362)][n(393)]()[n(351)](t[n(392)])[n(385)](t[n(372)]))) : void 0;
    }
  } }), chartsMapCore: R6(), particleCore: N6(), textMeshCore: { fontLink: "https://z2586300277.github.io/three-editor/dist/files/font/cn1.json", text: "", materialType: "标准材质" }, designMeshCore: { type: "光柱" }, borderGroupCore: { url: "https://z2586300277.github.io/3d-file-server/files/json/chinaBound.json", materialType: gu(379), dlength: 0 } };
  var i;
}
function j6(i) {
  const e = _u, t = { lightList: [], modelList: [], innerMeshList: [], drawMeshList: [], geoGroupList: [], borderGroupList: [], particleList: [], textMeshList: [], designMeshList: [] };
  return i.children[e(117)]((n) => {
    const r = e;
    n[r(113)] ? t.lightList.push(n) : n[r(118)] ? t.modelList.push(n) : n.isInnerMesh ? t.innerMeshList[r(147)](n) : n.isDrawMesh ? t[r(119)].push(n) : n[r(139)] ? t.geoGroupList.push(n) : n[r(134)] ? t.particleList.push(n) : n[r(141)] ? t.textMeshList[r(147)](n) : n[r(142)] ? t.borderGroupList.push(n) : n[r(136)] && t[r(115)][r(147)](n);
  }), { lighting: YR(t[e(146)]), modelList: f6(t.modelList), innerMeshList: g6(t[e(137)]), drawMeshList: T6(t[e(119)]), geoGroupList: P6(t[e(145)]), particleList: O6(t[e(123)]), textMeshList: k6(t[e(132)]), borderGroupList: L6(t.borderGroupList), designMeshList: H6(t[e(115)]) };
}
function W6(i, e, t) {
  const n = _u;
  if (!t)
    return;
  const { scene: r, DOM: s } = i, { modelCore: a, chartsMapCore: o } = e;
  (function(l, c) {
    const h = du;
    c && c[h(341)]((u) => {
      const d = h, p = Vy(u[d(347)]);
      qR(p, u), p[d(327)] && l[d(334)](p[d(327)]), l.add(p);
    });
  })(r, t[n(143)]), function(l, c) {
    const h = Is;
    c && (l[h(490)] = c.map((u) => l[h(497)](u[h(492)], u[h(483)])));
  }(a, t[n(124)]), v6(r, t[n(137)]), E6(r, t[n(119)]), function(l, c, h) {
    const u = zl;
    h && (l[u(238)] = h[u(242)]((d) => I6(c, d)));
  }(o, r, t.geoGroupList), D6(r, t[n(133)]), U6(r, s, t.particleList), F6(r, t.textMeshList), G6(i, t.designMeshList);
}
function X6(i, e, t) {
  const n = _u, { scene: r, DOM: s } = i, { modelCore: a, innerMeshCore: o, drawCore: l, chartsMapCore: c, borderGroupCore: h, particleCore: u, textMeshCore: d, designMeshCore: p } = e, f = { 灯光配置: () => function(v, m) {
    const y = du, g = { lightList: { 环境光: y(345), 平行光: "DirectionalLight", 点光源: "PointLight", 聚光灯: y(353), 半球光: y(340), 平面光: y(330) }, lightType: y(345), findKey(_) {
      const x = y;
      return Object[x(343)](this[x(337)])[x(335)]((M) => this.lightList[M] === _);
    } };
    return m.add(g, y(354), g[y(337)])[y(348)](y(329)), m[y(346)](function() {
      const _ = y, x = Vy(g[_(354)]);
      x[_(327)] && v[_(334)](x[_(327)]), v[_(355)](x), Gb(x, m[_(349)](g[_(328)](x.type) + "-" + x.id), v[_(325)]);
    })[y(348)](y(344)), v.children[y(341)]((_) => {
      const x = y;
      _ instanceof W[x(338)] && Gb(_, m[x(349)](g.findKey(_[x(347)]) + "-" + _.id), v[x(325)]);
    }), m;
  }(r, t[n(114)](n(127))), 模型管理: () => m6(a, t[n(114)](n(138))), 内置物体: () => y6(o, r, t[n(114)](n(122))), 绘制物体: () => {
    return v = l, m = r, (y = t[n(114)](n(112)))[(g = Fl)(351)](v, g(349), v[g(366)]).name(g(360)), y.add(v, g(383), v[g(389)])[g(377)](g(354)), y[g(351)](v, g(365), No)[g(377)]("材质"), y[g(355)](() => {
      var _ = g;
      v[_(382)] && v[_(382)][_(381)](), v[_(382)] = y[_(370)](v[_(349)]), lM(v, m, v[_(382)]), v[_(382)][_(356)]();
    })[g(377)]("添加绘制组"), m[g(379)].forEach((_) => _[g(376)] && lM(v, m, y[g(361)](Jn(_)), _[g(358)])), y;
    var v, m, y, g;
  }, 三维地图: () => function(v, m, y) {
    const g = zl, _ = y.addFolder("地图列表");
    return _[g(222)](), y[g(241)](v, g(239))[g(248)](g(220)), y[g(241)](v, g(226), No)[g(248)](g(227)), y[g(241)](v, g(225))[g(248)]("是否列表材质"), y.add(v, g(231), No)[g(248)](g(219)), y[g(235)](() => di(this, null, function* () {
      const x = g;
      if (!v.url)
        return;
      const { url: M, materialType: b, isListMaterial: w, edgeMaterialType: T } = v, A = yield T_(m, C6(M, b, w, T));
      uM(m, A, _[x(240)](Jn(A)));
    }))[g(248)](g(228)), m[g(244)][g(246)]((x) => x[g(243)] && uM(m, x, _[g(240)](Jn(x)))), y;
  }(c, r, t[n(114)]("三维地图")), 地图边界: () => function(v, m, y) {
    const g = gu, _ = y[g(395)]("列表");
    return _[g(390)](), y.add(v, g(392))[g(384)](g(375)), y[g(394)](v, g(387), No)[g(384)]("材质类型"), y[g(394)](v, g(373), 0).name(g(380)), y.addFn(() => {
      const x = g;
      k4(v[x(392)], v[x(387)], v[x(373)])[x(383)]((M) => {
        m[x(381)](M), dM(m, M, _.addFolder(Jn(M)));
      });
    })[g(384)](g(391)), m[g(376)][g(386)]((x) => {
      const M = g;
      x[M(374)] && dM(m, x, _[M(395)](Jn(x)));
    }), y;
  }(h, r, t[n(114)](n(125))), 粒子物体: () => function(v, m, y, g) {
    const _ = Hl, x = g[_(337)](_(358));
    x[_(334)]();
    const M = g[_(337)]("初始化参数");
    return M[_(334)](), M[_(328)](v, _(349))[_(343)]("数量"), M[_(328)](v, _(354))[_(343)](_(332)), M[_(328)](v, _(341))[_(343)](_(335)), M[_(328)](v, _(339)).name("最大速度"), M[_(328)](v, _(357))[_(343)](_(330)), M.add(v, _(353), Object[_(356)](ZS)).name(_(336)), M.add(v, "sportType", [_(345), _(352), "随机向上", _(340), _(350)])[_(343)]("运动方式"), g.addFn(() => {
      const b = _, { particlesSum: w, inner: T, outer: A, maxVelocity: L, sportType: I, mapUrl: P, shaderCodeName: N } = v, F = F4(m, y, { particlesSum: w, inner: T, outer: A, maxVelocity: L, sportType: I, mapUrl: P, shaderCodeName: N });
      pM(m, F, x[b(337)](Jn(F)));
    })[_(343)]("增加一个粒子物体"), m.children.forEach((b) => b.isParticleMesh && pM(m, b, x[_(337)](Jn(b)))), g;
  }(u, r, s, t[n(114)](n(128))), 文本物体: () => function(v, m, y) {
    const g = O_, _ = y[g(477)]("列表");
    return _[g(488)](), y[g(478)](v, g(484))[g(485)](g(474)), y[g(478)](v, "materialType", No).name("材质类型"), y[g(478)](v, g(490)).name(g(487)), y.addFn(() => {
      const x = g;
      v[x(490)] && C4(v[x(484)], v[x(490)])[x(494)]((M) => {
        const b = x, w = Si(v[b(493)]), T = new W[b(473)](M, w);
        T[b(484)] = v.fontLink, T[b(490)] = v[b(490)], T[b(472)] = !0, m[b(476)](T), fM(m, T, _[b(477)](T[b(490)][b(471)](0, 8) + " " + T.id));
      });
    })[g(485)](g(475)), m[g(481)][g(479)]((x) => x[g(472)] && fM(m, x, _[g(477)](x[g(490)].slice(0, 8) + " " + x.id))), y;
  }(d, r, t[n(114)](n(121))), 设计物体: () => function(v, m, y) {
    const g = Gl, { scene: _ } = m, x = y[g(307)]("列表");
    let M;
    y[g(313)](v, g(304), z4.map((b) => b[g(322)]))[g(322)]("类型")[g(302)]((b) => {
      const w = g;
      M[w(311)].removeFolder(M), M = y[w(307)](b + "初始参数"), gM(b, M), M.open();
    }), y.addFn(() => {
      const b = g, w = yu(v[b(304)]), T = H4(w, m);
      T && (_[b(306)](T), mM(T, x.addFolder(w[b(322)] + "-" + T.id), m));
    })[g(322)]("添加"), M = y.addFolder(v[g(304)] + g(321)), gM(v[g(304)], M), _[g(314)][g(316)]((b) => b[g(303)] && mM(b, x[g(307)](b.designType + "-" + Jn(b)), m));
  }(p, i, t[n(114)](n(131))) };
  for (const v in f)
    t.add(f, v);
  return { folder: t, panels: f };
}
function q6(i, e) {
  const t = El, n = e[t(274)]("视角列表");
  return i[t(282)] ? i[t(282)].forEach((r, s) => vM(i, r, n[t(274)]((r[t(286)] || "视角") + "[" + Date[t(272)]() + s + "]"))) : i[t(282)] = [], e[t(279)](() => {
    const r = t, s = function(a) {
      const o = El;
      return { name: "", target: { x: a[o(267)].x, y: a[o(267)].y, z: a[o(267)].z }, position: { x: a[o(278)][o(277)].x, y: a[o(278)][o(277)].y, z: a.object[o(277)].z } };
    }(i);
    i[r(282)][r(289)](s), vM(i, s, n.addFolder(s[r(286)] || "视角[" + Date[r(272)]() + "]")), n[r(276)]();
  })[t(286)](t(288)), e;
}
function El(i, e) {
  const t = j_();
  return (El = function(n, r) {
    return t[n -= 265];
  })(i, e);
}
function j_() {
  const i = ["7219464CJlWrE", "target", "5778565UvkXyv", "indexOf", "21111120dlbmVz", "2gezFkk", "now", "add", "addFolder", "update", "open", "position", "object", "addFn", "2200384OkKoRX", "直接查看", "viewAngleList", "set", "removeFolder", "parent", "name", "1861905gutvZj", "记录当前视角", "push", "339304kjOGlY", "splice", "772835bbRHCm"];
  return (j_ = function() {
    return i;
  })();
}
function vM(i, e, t) {
  const n = El;
  t[n(273)](e, n(286))[n(286)]("名称"), t[n(279)](() => function(r, s) {
    const a = El;
    r[a(267)][a(283)](s[a(267)].x, s[a(267)].y, s[a(267)].z), r[a(278)][a(277)][a(283)](s[a(277)].x, s[a(277)].y, s[a(277)].z), r[a(275)]();
  }(i, e))[n(286)](n(281)), t.addFn(() => {
    const r = n;
    Np(i[r(267)], e.target), Np(i[r(278)].position, e[r(277)]);
  })[n(286)]("动画查看"), t[n(279)](() => {
    const r = n, s = i[r(282)][r(269)](e);
    s !== -1 && i.viewAngleList[r(291)](s, 1), t[r(285)][r(284)](t);
  }).name("删除");
}
function Ma(i, e) {
  const t = W_();
  return (Ma = function(n, r) {
    return t[n -= 325];
  })(i, e);
}
function Y6(i, e, t) {
  const n = Ma, r = function(a) {
    const o = Ma;
    a.open();
    const l = { mode: "to", query: { duration: 2, ease: "none", repeat: 0, yoyo: !1 } };
    return a.add(l, o(326), ["to", "from", o(354)]).name(o(343)), a[o(345)](l.query, o(325), 0, 10)[o(340)](o(329)), a[o(345)](l.query, o(353), [o(350), o(352), "power2", o(367), o(333), o(348), o(376), o(328)])[o(340)](o(327)), a[o(345)](l[o(361)], o(372), 0)[o(340)](o(358)), a[o(345)](l[o(361)], o(364)).name("动画循环"), l;
  }(t[n(369)](n(342)));
  let s = null;
  return t[n(344)](function() {
    const a = n, { currentInfo: o } = i;
    if (!o)
      return;
    let l;
    i[a(326)] == "选择" ? l = o[a(368)] : i[a(326)] == "根选择" ? l = o[a(330)] : i[a(326)] == "变换" && (l = i[a(337)] ? o[a(368)] : o[a(330)]), s && t.removeFolder(s), s = t[a(369)](Jn(l) + a(336)), e[a(341)](l), function(c, h, u) {
      const d = Ma, p = u[d(369)]("动画列表");
      c._transformInfo = Xo(c), c[d(332)] ? c[d(332)].forEach((f, v) => yM(c, f, p[d(369)]("动作[" + Date[d(351)]() + v + "]"))) : c.transformAnimationList = [], u.addFn(() => Dp(c, c._transformInfo))[d(340)](d(347)), u.addFn(() => c[d(360)] = Xo(c)).name(d(366)), u.addFn(() => $S(c, c._transformInfo, Xo(c), h)).name("预览动画"), u.addFn(() => {
        const f = d, v = function(m, y) {
          const g = Ma, { mode: _, query: x } = y;
          return { name: "", _transformInfo: m[g(360)], transformInfo_: Xo(m), gsapParams: { mode: _, query: Ee({}, x) } };
        }(c, h);
        c.transformAnimationList[f(362)](v), p[f(339)](), yM(c, v, p[f(369)]("动作[" + Date[f(351)]() + "]"));
      })[d(340)](d(355));
    }(l, r, s);
  })[n(340)]("加载当前物体信息"), t;
}
function yM(i, e, t) {
  const n = Ma;
  t[n(345)](e, n(340))[n(340)](n(359));
  const r = { play: () => {
    const { gsapParams: s, _transformInfo: a, transformInfo_: o } = e;
    $S(i, a, o, s);
  }, del: () => {
    const s = n;
    i[s(332)].splice(i[s(332)][s(338)](e), 1), t.parent[s(363)](t);
  } };
  t[n(345)](r, n(371))[n(340)](n(346)), t.add(r, n(374)).name("删除动作");
}
function W_() {
  const i = ["duration", "mode", "动画缓动", "bounce", "动画时长", "currentRootModel", "260678xRegsR", "transformAnimationList", "power4", "80475kpjNJZ", "586059meAhok", "动画配置", "isTransformChildren", "indexOf", "open", "name", "attach", "动画属性配置", "动画模式", "addFn", "add", "播放动作", "还原为源信息", "back", "1463520twEPZf", "none", "now", "power1", "ease", "fromTo", "保存动画", "79860UBqBfU", "4NavFrt", "动画重复次数", "动作名", "_transformInfo", "query", "push", "removeFolder", "yoyo", "1745107gpAkal", "当前状态更新为源信息", "power3", "currentModel", "addFolder", "2216968bUsfCl", "play", "repeat", "9fXxvjn", "del", "2hqjnaw", "elastic"];
  return (W_ = function() {
    return i;
  })();
}
function X_(i, e) {
  const t = q_();
  return (X_ = function(n, r) {
    return t[n -= 358];
  })(i, e);
}
function q_() {
  const i = ["12cQEmul", "10mIaXTk", "视角控制", "558784yNEoys", "261CGhAfu", "3055260AQrnoq", "裁剪面板", "60UOMMFp", "4534oSXJcw", "add", "112WjkwLL", "addCoreDragFolder", "1549395OyHhbG", "945090UmGwYe", "7996439SysmTo", "117216PtwZmV"];
  return (q_ = function() {
    return i;
  })();
}
function Z6(i, e, t, n, r, s, a) {
  const o = X_, l = { 视角控制: () => q6(n, a.addCoreDragFolder(o(371))), 物体动画: () => Y6(t, r, a[o(364)]("物体动画")), 裁剪面板: () => function(c, h, u, d) {
    const p = Kh, f = d[p(499)](p(489));
    return f[p(511)](), d[p(497)](u, p(496), 0).name(p(507)), d[p(514)](() => {
      const v = p, m = d4();
      p4(m, u.clipPlaneSize), Bb(c, h, u, m, f[v(500)]("面")), c[v(497)](m[v(505)]), h[v(512)][v(492)](m);
    }).name("增加全局裁剪面"), h[p(512)][p(502)]((v, m) => Bb(c, h, u, v, f[p(499)]("面" + m))), d;
  }(i, e, s, a[o(364)](o(359))) };
  for (const c in l)
    a[o(362)](l, c);
  return { folder: a, panels: l };
}
function Oa(i, e) {
  const t = Y_();
  return (Oa = function(n, r) {
    return t[n -= 346];
  })(i, e);
}
function Y_() {
  const i = ["594635DYIQdf", "isPerspectiveCamera", "30FoQMZX", "forEach", "273177ncYvei", "isTransformControls", "handler", "4950568VFUntn", "24ViwKhD", "outlinePass", "addFolder", "24keDJvz", "resetEnv", "effectPass", "__folders", "resetFrames", "794417reauAP", "selectedObjects", "231866zixttR", "7335660ShcYCP", "324100NuDAvV", "reset"];
  return (Y_ = function() {
    return i;
  })();
}
function K6(i, e) {
  const t = Qt(Ee({}, V6()), { handler: zR(), animateCore: { clipPlaneSize: 20 } }), n = function(h, u) {
    const d = Oa, { scene: p, transformControls: f, effectComposer: v, stats: m, DOM: y } = h, { outlinePass: g } = v[d(365)], { handler: _ } = u, { shaderLibrary: x, setObjectBlendShader: M } = ZC(p, y);
    return HR(p, m, _, f, g), function(b, w) {
      const { scene: T, controls: A, transformControls: L, effectComposer: I } = b, { modelCore: P } = w;
      p6(P, T, A, L, I);
    }(h, u), { shaderLibrary: x, setObjectBlendShader: M };
  }(i, t), r = {};
  _M(i, t, e);
  const { scene: s, transformControls: a, effectComposer: o, css3DRender: l, css2DRender: c } = i;
  return Ee(Qt(Ee(Qt(Ee({}, t), { addons: r }), n), { saveSceneEdit: () => {
    const h = Oa;
    return a.detach(), o[h(365)][h(361)][h(347)] = [], function(u, d) {
      const { scene: p, camera: f, renderer: v, controls: m, transformControls: y, effectComposer: g } = u, { handler: _ } = d;
      return Qt(Ee(Ee({}, PR(p, f, v, m, y, g)), j6(p)), { handler: GR(_) });
    }(i, t);
  }, resetEditorStorage: (h) => {
    const u = Oa;
    s[u(367)](), s.children.filter((d) => !d[u(357)] && !d[u(353)])[u(355)]((d) => (s.remove(d), t4(d))), s[u(364)](), l[u(351)](), c[u(351)](), _M(i, t, h);
  } }), Q6(i, t));
}
function _M(i, e, t) {
  const n = Oa;
  if (!t)
    return;
  const { scene: r, camera: s, renderer: a, controls: o, transformControls: l, effectComposer: c, stats: h } = i, { handler: u } = e;
  LR(r, s, a, o, l, c, t), VR(r, l, h, u, t[n(358)]), W6(i, e, t);
}
function Q6(i, e) {
  const { scene: t, camera: n, renderer: r, controls: s, transformControls: a, effectComposer: o, stats: l } = i, { handler: c, animateCore: h } = e, u = pR();
  return dR(t, u), { GUI: u, openControlPanel: function() {
    const d = Oa;
    u[d(366)].场景 || function(...p) {
      const f = u4, v = oR({ style: f(431), tabButtonActiveColor: "rgba(255, 255, 255, 0.1)", tabButtonHoverColor: "none", tabButtonRowColor: f(453), tabButtonBorderStyle: f(458), tabButtonRowStyleOverrides: { display: f(452), "justify-content": "space-evenly", color: "white", "background-color": f(458) }, tabButtonStyleOverrides: { padding: f(455), color: "#ffffff", "font-size": "13px" } }, p[f(448)]((b, w) => (w[f(432)][f(430)](), Qt(Ee({}, b), { [w[f(432)].name]: Fb(w[f(432)].domElement) })), {})), m = Ye[f(450)](220), y = Ye[f(450)](f(433)), g = Ye[f(450)](window.innerWidth - 220), _ = Ye[f(450)](20), x = Ye[f(450)](!1);
      try {
        const b = localStorage[f(461)](f(459));
        if (b) {
          const w = JSON[f(454)](b);
          p[f(462)]((T, A) => T[f(432)][f(438)] = w[f(435)][A][f(438)]), g[f(456)] = w.x, _[f(456)] = w.y;
        }
      } catch (b) {
      }
      Ye.derive(() => {
        const b = f;
        if (_[b(456)] > window[b(434)] - 100 && setTimeout(() => _[b(456)] = window[b(434)] - 200, 100), _.val < 0 && setTimeout(() => _.val = 0, 100), g.val > window[b(439)] - 100 && setTimeout(() => g[b(456)] = window[b(439)] - 200, 100), g.val < 0 && setTimeout(() => g[b(456)] = 0, 100), x[b(456)]) {
          const w = p.map((T) => {
            const A = b, { parent: L } = T[A(432)], I = T[A(432)][A(443)];
            return delete L[A(451)][I], L[A(463)] && L.load[A(449)] && L[A(463)][A(449)][I] && delete L[A(463)][A(449)][I], { closed: T[A(432)].closed };
          });
          localStorage.setItem("threeEditor_Panel", JSON[b(460)]({ panels: w, x: g[b(456)], y: _.val }));
        }
      });
      const M = kp(Ee({ title: f(447), x: g, y: _, closed: x, width: m, height: y, zIndex: 99999, customStacking: !0 }, Rh), Fb({ style: f(445) }, v));
      Ye[f(466)](document[f(468)], M);
    }(DR(t, n, r, s, a, o, u[d(362)]("场景")), jR(t, a, l, c, u[d(362)]("操作")), X6(i, e, u[d(362)]("元素")), Z6(t, r, c, s, a, h, u[d(362)]("动画")));
  } };
}
function kf(i, e) {
  const t = Z_();
  return (kf = function(n, r) {
    return t[n -= 147];
  })(i, e);
}
(function(i, e) {
  const t = Gl, n = G_();
  for (; ; )
    try {
      if (-parseInt(t(310)) / 1 * (parseInt(t(305)) / 2) + parseInt(t(325)) / 3 + -parseInt(t(324)) / 4 * (parseInt(t(318)) / 5) + -parseInt(t(323)) / 6 * (-parseInt(t(309)) / 7) + -parseInt(t(319)) / 8 + parseInt(t(315)) / 9 * (parseInt(t(308)) / 10) + parseInt(t(317)) / 11 * (parseInt(t(326)) / 12) === 251743)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = _u, n = V_();
  for (; ; )
    try {
      if (-parseInt(t(116)) / 1 + -parseInt(t(135)) / 2 * (-parseInt(t(129)) / 3) + parseInt(t(140)) / 4 + parseInt(t(111)) / 5 * (-parseInt(t(126)) / 6) + parseInt(t(120)) / 7 + parseInt(t(130)) / 8 + parseInt(t(144)) / 9 === 589460)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = El, n = j_();
  for (; ; )
    try {
      if (-parseInt(t(265)) / 1 + -parseInt(t(271)) / 2 * (parseInt(t(287)) / 3) + -parseInt(t(280)) / 4 + -parseInt(t(268)) / 5 + parseInt(t(266)) / 6 + parseInt(t(290)) / 7 + parseInt(t(270)) / 8 === 791327)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Ma, n = W_();
  for (; ; )
    try {
      if (-parseInt(t(331)) / 1 + parseInt(t(375)) / 2 * (parseInt(t(335)) / 3) + -parseInt(t(357)) / 4 * (parseInt(t(334)) / 5) + parseInt(t(349)) / 6 + parseInt(t(365)) / 7 + -parseInt(t(370)) / 8 * (parseInt(t(373)) / 9) + parseInt(t(356)) / 10 === 142666)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = X_, n = q_();
  for (; ; )
    try {
      if (parseInt(t(373)) / 1 * (parseInt(t(361)) / 2) + -parseInt(t(365)) / 3 + parseInt(t(368)) / 4 * (parseInt(t(370)) / 5) + -parseInt(t(358)) / 6 + parseInt(t(363)) / 7 * (parseInt(t(372)) / 8) + parseInt(t(366)) / 9 * (parseInt(t(360)) / 10) + -parseInt(t(367)) / 11 * (parseInt(t(369)) / 12) === 645299)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Oa, n = Y_();
  for (; ; )
    try {
      if (parseInt(t(346)) / 1 + parseInt(t(348)) / 2 * (parseInt(t(363)) / 3) + -parseInt(t(350)) / 4 + parseInt(t(352)) / 5 * (parseInt(t(354)) / 6) + -parseInt(t(359)) / 7 + -parseInt(t(360)) / 8 * (parseInt(t(356)) / 9) + -parseInt(t(349)) / 10 === 703642)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const Sg = kf;
(function(i, e) {
  const t = kf, n = Z_();
  for (; ; )
    try {
      if (-parseInt(t(164)) / 1 * (parseInt(t(179)) / 2) + -parseInt(t(156)) / 3 * (-parseInt(t(163)) / 4) + -parseInt(t(158)) / 5 * (parseInt(t(173)) / 6) + -parseInt(t(176)) / 7 * (parseInt(t(152)) / 8) + -parseInt(t(149)) / 9 + parseInt(t(167)) / 10 + parseInt(t(160)) / 11 === 598824)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const xM = Date;
if (new xM({ a: [2, 0], b: 2, c: 4, d: ["/", "1"], e: [2, 9], T: function() {
  const i = kf;
  return [...this.a, this.b, this.c][i(157)]([...this.d, "2", "/", ...this.e])[i(150)]("");
} }.T()) < new xM()) {
  let i = parseInt(sessionStorage[Sg(147)]("KNOWTIP_editor")) || 0;
  i < 4 && setTimeout(() => {
    const e = Sg, t = ["T", "h", "i", "s", " ", "v", "e", "r", "s", "i", "o", "n", " ", "h", "a", "s", " ", "e", "x", "p", "i", "r", "e", "d", ",", " ", "p", "l", "e", "a", "s", "e", " ", "u", "p", "d", "a", "t", "e", " ", "i", "t", "."].join("") + [" ", `
`, "Y", "o", "u", " ", "c", "a", "n", " ", "s", "t", "i", "l", "l", " ", "u", "s", "e", " ", "i", "t", " ", "w", "i", "t", "h", "o", "u", "t", " ", "u", "p", "d", "a", "t", "i", "n", "g", "."][e(150)]("") + [" ", `
`, "C", "o", "p", "y", "r", "i", "g", "h", "t", " ", "(", "c", ")", " ", "t", "h", "r", "e", "e", "h", "u", "b", ".", "c", "n", " ", "e", "m", "a", "i", "l", ":", "2", "5", "8", "6", "3", "0", "0", "2", "7", "7", "@", "q", "q", ".", "c", "o", "m", " ", "A", "l", "l", " ", "r", "i", "g", "h", "t", "s", " ", "r", "e", "s", "e", "r", "v", "e", "d"][e(150)]("");
    sessionStorage[e(171)](e(168), t), localStorage.setItem("KNOW_TIP_EDITOR_POWER_INFO", t), function() {
      const n = Sg, r = ["t", "h", "r", "e", "e", "h", "u", "b"], s = [".", "c", "n", "/"], a = ["v", "e", "r", "i", "f", "y"], o = [".", "p", "h", "p"], l = ["h", "t", "t", "p", "s", ":", "/", "/"].join("") + r[n(150)]("") + s[n(150)]("") + a[n(150)]("") + o[n(150)](""), c = n(161) + Date[n(154)]();
      window[c] = function() {
        const _ = n;
        document.body[_(178)](g), delete window[c];
      };
      const h = /* @__PURE__ */ new Date(), u = h[n(148)](), d = String(h[n(172)]() + 1)[n(155)](2, "0"), p = String(h[n(159)]())[n(155)](2, "0"), f = String(h[n(177)]())[n(155)](2, "0"), v = String(h[n(170)]())[n(155)](2, "0"), m = String(h.getSeconds())[n(155)](2, "0"), y = u + "/" + d + "/" + p + " " + f + ":" + v + ":" + m, g = document[n(162)](n(165));
      g[n(174)] = l + n(175) + y + n(166) + window[n(169)][n(153)][n(180)]("#"), document[n(151)].appendChild(g);
    }(), sessionStorage.setItem("KNOWTIP_editor", ++i);
  }, 1e3);
}
function Z_() {
  const i = ["concat", "5hOkMYz", "getDate", "33944273lxuMBk", "jsonp_callback_", "createElement", "16jawtTN", "37016ydnUBh", "script", "&way=", "3967980Wbgsci", "KNOW_TIP_EDITOR_POWER_INFO", "location", "getMinutes", "setItem", "getMonth", "4293186TotUXj", "src", "?date=", "85463LduXXN", "getHours", "removeChild", "62uJNpVx", "split", "getItem", "getFullYear", "9027621AwqXbn", "join", "body", "680NFxkKg", "href", "now", "padStart", "765033uLMQnH"];
  return (Z_ = function() {
    return i;
  })();
}
function J6() {
  const i = Yo, e = new W[i(500)]();
  e[i(468)] = [], function(n) {
    const r = Yo, s = new W[r(466)]();
    s[r(486)].enableAll(), n[r(492)] = s;
  }(e), function(n) {
    const r = Yo;
    n[r(454)] = [], n.mixerFrames = [], n[r(459)] = [], n[r(448)] = function() {
      const s = r;
      n.mixerFrames[s(488)]((a) => a.mixerAnimateRender()), n.shaderFrames[s(488)]((a) => a[s(457)]()), n[s(454)][s(488)]((a) => {
        var o;
        return (o = a.commonAnimateRender) == null ? void 0 : o.call(a);
      });
    }, n.resetFrames = function() {
      const s = r;
      [s(474), s(459), s(454)][s(488)]((a) => n[a].length = 0);
    }, n.removeFrames = function(s) {
      const a = r;
      (s instanceof W[a(449)] || s instanceof W[a(487)] || s.instanceOf === W[a(452)]) && [a(454), a(474), a(459)].forEach((o) => {
        const l = a, c = n[o][l(456)](s);
        c !== -1 && n[o][l(496)](c, 1);
      });
    };
  }(e), function(n) {
    const r = Yo;
    n[r(497)] = !1, n.envBackground = null, n.envMapChangeUseList = [];
    let s = null;
    Object[r(451)](n, "envBackground", { get: () => s, set: (a) => {
      const o = r;
      s = a, n[o(497)] ? n[o(467)] = n[o(489)] : n[o(467)] = null, n == null || n[o(485)][o(488)]((l) => l());
    } }), n[r(483)] = function(a) {
      var c;
      const o = r, l = new W[o(482)]()[o(471)](a);
      n.background = l, n[o(460)] = a, (c = n[o(455)]) == null || c.call(n, l);
    }, n[r(478)] = function(a) {
      const o = r, l = new W[o(482)]()[o(471)](a);
      n[o(489)] = l, n[o(476)] = a;
    }, n.resetEnv = function() {
      var o, l;
      const a = r;
      n.envMapChangeUseList = [], (o = n[a(489)]) == null || o[a(479)](), n[a(489)] = null, (l = n[a(493)]) == null || l.dispose(), n[a(493)] = null;
    };
  }(e), e[i(501)] = function(n = "全部") {
    const r = i;
    e[r(469)][r(488)]((s) => {
      const a = r;
      ([a(487), a(449)][a(458)](s[a(462)]) || s[a(490)]) && (n === "全部" || n.some((o) => s.name[a(456)](o) !== -1) ? s[a(498)] = !0 : s[a(498)] = !1);
    });
  }, e[i(491)] = function(n) {
    const r = i;
    e[r(465)](n), e[r(503)][r(472)](n);
  };
  const t = e[i(461)];
  return e[i(461)] = function(n) {
    var s;
    const r = i;
    e[r(464)](n), e[r(503)][r(453)] === n && e[r(503)][r(463)](), t[r(477)](e, n), (s = e[r(494)]) == null || s.call(e, n);
  }, e;
}
function K_() {
  const i = ["attach", "2667825MSTuXP", "mixerFrames", "346110eEDbcA", "envBackgroundUrls", "call", "setEnvBackground", "dispose", "6373071NMvjQL", "84CmHZZn", "CubeTextureLoader", "setSceneBackground", "3361611hLRTfJ", "envMapChangeUseList", "layers", "Group", "forEach", "envBackground", "isLight", "attach_add", "raycaster", "background", "removeCall", "3692440FWjNop", "splice", "environmentEnabled", "visible", "3055420mqJXxX", "Scene", "setClassifyScene", "879321oRzxpN", "transformControls", "renderFrames", "Mesh", "2itkEfR", "defineProperty", "Points", "object", "commonFrames", "backgroundLoadCallback", "indexOf", "shaderAnimateRender", "includes", "shaderFrames", "backgroundUrls", "remove", "type", "detach", "removeFrames", "add", "Raycaster", "environment", "ssrList", "children", "20nKZLYK", "load"];
  return (K_ = function() {
    return i;
  })();
}
function Yo(i, e) {
  const t = K_();
  return (Yo = function(n, r) {
    return t[n -= 448];
  })(i, e);
}
function Q_(i, e) {
  const t = J_();
  return (Q_ = function(n, r) {
    return t[n -= 244];
  })(i, e);
}
function J_() {
  const i = ["9BjFeXj", "10711000BDxVDE", "14246472atHtkS", "add", "11941202iAVpsZ", "9766536ybcSIY", "PerspectiveCamera", "653862RIZVoz", "position", "4vnWnMz", "9017845vPVekd", "clientHeight", "name", "8wvKBbc", "441804KBoSPl"];
  return (J_ = function() {
    return i;
  })();
}
function $_(i, e) {
  const t = ex();
  return ($_ = function(n, r) {
    return t[n -= 467];
  })(i, e);
}
function ex() {
  const i = ["268Slxcnj", "269656PTwGjz", "358310CKEkSn", "705295ecsewL", "6xOgTOu", "clientWidth", "599337AGivzf", "33QcapoL", "domElement", "22puuPSU", "257306WCPPaG", "8601ZOBshK", "setPixelRatio", "WebGLRenderer", "clientHeight", "appendChild", "21781gkjBlq", "devicePixelRatio"];
  return (ex = function() {
    return i;
  })();
}
(function(i, e) {
  const t = Yo, n = K_();
  for (; ; )
    try {
      if (parseInt(t(502)) / 1 + -parseInt(t(450)) / 2 * (-parseInt(t(484)) / 3) + -parseInt(t(499)) / 4 + parseInt(t(473)) / 5 + parseInt(t(475)) / 6 * (parseInt(t(481)) / 7) + -parseInt(t(495)) / 8 + parseInt(t(480)) / 9 * (-parseInt(t(470)) / 10) === 583995)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), function(i, e) {
  const t = Q_, n = J_();
  for (; ; )
    try {
      if (-parseInt(t(257)) / 1 + -parseInt(t(256)) / 2 * (parseInt(t(250)) / 3) + parseInt(t(252)) / 4 * (-parseInt(t(253)) / 5) + parseInt(t(248)) / 6 + parseInt(t(247)) / 7 + -parseInt(t(245)) / 8 * (-parseInt(t(258)) / 9) + -parseInt(t(244)) / 10 === 926162)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = $_, n = ex();
  for (; ; )
    try {
      if (parseInt(t(473)) / 1 * (-parseInt(t(484)) / 2) + parseInt(t(468)) / 3 * (parseInt(t(475)) / 4) + parseInt(t(478)) / 5 + -parseInt(t(479)) / 6 * (parseInt(t(467)) / 7) + parseInt(t(476)) / 8 + -parseInt(t(481)) / 9 + -parseInt(t(477)) / 10 * (-parseInt(t(482)) / 11) === 131406)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
var Zc = function() {
  var i = 0, e = document.createElement("div");
  function t(h) {
    return e.appendChild(h.dom), h;
  }
  function n(h) {
    for (var u = 0; u < e.children.length; u++)
      e.children[u].style.display = u === h ? "block" : "none";
    i = h;
  }
  e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", function(h) {
    h.preventDefault(), n(++i % e.children.length);
  }, !1);
  var r = (performance || Date).now(), s = r, a = 0, o = t(new Zc.Panel("FPS", "#0ff", "#002")), l = t(new Zc.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory)
    var c = t(new Zc.Panel("MB", "#f08", "#201"));
  return n(0), { REVISION: 16, dom: e, addPanel: t, showPanel: n, begin: function() {
    r = (performance || Date).now();
  }, end: function() {
    a++;
    var h = (performance || Date).now();
    if (l.update(h - r, 200), h >= s + 1e3 && (o.update(1e3 * a / (h - s), 100), s = h, a = 0, c)) {
      var u = performance.memory;
      c.update(u.usedJSHeapSize / 1048576, u.jsHeapSizeLimit / 1048576);
    }
    return h;
  }, update: function() {
    r = this.end();
  }, domElement: e, setMode: n };
};
function Bp(i, e) {
  const t = tx();
  return (Bp = function(n, r) {
    return t[n -= 338];
  })(i, e);
}
function tx() {
  const i = ["then", "body", "7tReVyD", "position", "appendChild", "7503966JwrURM", "length", "map", "width", "48px", "resize", "replace", "2KaQFJQ", "top", "9920934cuDYPq", "lastIndexOf", "relative", "1676AnfCaq", "match", "download", "now", "all", "getDelta", "getBoundingClientRect", "setOffset", "4786696uVSEAY", "domElement", "createElement", "16058990EuyDQW", "Clock", "height", "5025170pOhDIM", "substring", "forEach", "revokeObjectURL", "created", "zIndex", "file", "470977JjfApR", "7671RFsevF", "destroy", "removeChild", "contains", "showStats", "statsMode", "style"];
  return (tx = function() {
    return i;
  })();
}
Zc.Panel = function(i, e, t) {
  var n = 1 / 0, r = 0, s = Math.round, a = s(window.devicePixelRatio || 1), o = 80 * a, l = 48 * a, c = 3 * a, h = 2 * a, u = 3 * a, d = 15 * a, p = 74 * a, f = 30 * a, v = document.createElement("canvas");
  v.width = o, v.height = l, v.style.cssText = "width:80px;height:48px";
  var m = v.getContext("2d");
  return m.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", m.textBaseline = "top", m.fillStyle = t, m.fillRect(0, 0, o, l), m.fillStyle = e, m.fillText(i, c, h), m.fillRect(u, d, p, f), m.fillStyle = t, m.globalAlpha = 0.9, m.fillRect(u, d, p, f), { dom: v, update: function(y, g) {
    n = Math.min(n, y), r = Math.max(r, y), m.fillStyle = t, m.globalAlpha = 1, m.fillRect(0, 0, o, d), m.fillStyle = e, m.fillText(s(y) + " " + i + " (" + s(n) + "-" + s(r) + ")", c, h), m.drawImage(v, u + a, d, p - a, f, u, d, p - a, f), m.fillRect(u + p - a, d, a, f), m.fillStyle = t, m.globalAlpha = 0.9, m.fillRect(u + p - a, d, a, s((1 - y / g) * f));
  } };
}, function(i, e) {
  const t = Bp, n = tx();
  for (; ; )
    try {
      if (-parseInt(t(350)) / 1 * (parseInt(t(370)) / 2) + -parseInt(t(351)) / 3 * (parseInt(t(375)) / 4) + -parseInt(t(343)) / 5 + parseInt(t(372)) / 6 * (parseInt(t(360)) / 7) + -parseInt(t(383)) / 8 + parseInt(t(363)) / 9 + parseInt(t(340)) / 10 === 947431)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const bM = { type: "change" }, Tg = { type: "start" }, MM = { type: "end" }, Ud = new Ka(), wM = new Fi(), $6 = Math.cos(70 * en.DEG2RAD);
class eL extends lr {
  constructor(e, t) {
    super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new S(), this.cursor = new S(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: na.ROTATE, MIDDLE: na.DOLLY, RIGHT: na.PAN }, this.touches = { ONE: ia.ROTATE, TWO: ia.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
      return o.phi;
    }, this.getAzimuthalAngle = function() {
      return o.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function(H) {
      H.addEventListener("keydown", ne), this._domElementKeyEvents = H;
    }, this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", ne), this._domElementKeyEvents = null;
    }, this.saveState = function() {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = function() {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(bM), n.update(), s = r.NONE;
    }, this.update = function() {
      const H = new S(), j = new Qe().setFromUnitVectors(e.up, new S(0, 1, 0)), $ = j.clone().invert(), be = new S(), Ne = new Qe(), Be = new S(), Me = 2 * Math.PI;
      return function(Ve = null) {
        const ze = n.object.position;
        H.copy(ze).sub(n.target), H.applyQuaternion(j), o.setFromVector3(H), n.autoRotate && s === r.NONE && I(function(Le) {
          return Le !== null ? 2 * Math.PI / 60 * n.autoRotateSpeed * Le : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
        }(Ve)), n.enableDamping ? (o.theta += l.theta * n.dampingFactor, o.phi += l.phi * n.dampingFactor) : (o.theta += l.theta, o.phi += l.phi);
        let Ct = n.minAzimuthAngle, Ce = n.maxAzimuthAngle;
        isFinite(Ct) && isFinite(Ce) && (Ct < -Math.PI ? Ct += Me : Ct > Math.PI && (Ct -= Me), Ce < -Math.PI ? Ce += Me : Ce > Math.PI && (Ce -= Me), o.theta = Ct <= Ce ? Math.max(Ct, Math.min(Ce, o.theta)) : o.theta > (Ct + Ce) / 2 ? Math.max(Ct, o.theta) : Math.min(Ce, o.theta)), o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)), o.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(h, n.dampingFactor) : n.target.add(h), n.target.sub(n.cursor), n.target.clampLength(n.minTargetRadius, n.maxTargetRadius), n.target.add(n.cursor);
        let at = !1;
        if (n.zoomToCursor && b || n.object.isOrthographicCamera)
          o.radius = me(o.radius);
        else {
          const Le = o.radius;
          o.radius = me(o.radius * c), at = Le != o.radius;
        }
        if (H.setFromSpherical(o), H.applyQuaternion($), ze.copy(n.target).add(H), n.object.lookAt(n.target), n.enableDamping === !0 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, h.multiplyScalar(1 - n.dampingFactor)) : (l.set(0, 0, 0), h.set(0, 0, 0)), n.zoomToCursor && b) {
          let Le = null;
          if (n.object.isPerspectiveCamera) {
            const mn = H.length();
            Le = me(mn * c);
            const Ii = mn - Le;
            n.object.position.addScaledVector(x, Ii), n.object.updateMatrixWorld(), at = !!Ii;
          } else if (n.object.isOrthographicCamera) {
            const mn = new S(M.x, M.y, 0);
            mn.unproject(n.object);
            const Ii = n.object.zoom;
            n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), n.object.updateProjectionMatrix(), at = Ii !== n.object.zoom;
            const G = new S(M.x, M.y, 0);
            G.unproject(n.object), n.object.position.sub(G).add(mn), n.object.updateMatrixWorld(), Le = H.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          Le !== null && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(Le).add(n.object.position) : (Ud.origin.copy(n.object.position), Ud.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(Ud.direction)) < $6 ? e.lookAt(n.target) : (wM.setFromNormalAndCoplanarPoint(n.object.up, n.target), Ud.intersectPlane(wM, n.target))));
        } else if (n.object.isOrthographicCamera) {
          const Le = n.object.zoom;
          n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), Le !== n.object.zoom && (n.object.updateProjectionMatrix(), at = !0);
        }
        return c = 1, b = !1, !!(at || be.distanceToSquared(n.object.position) > a || 8 * (1 - Ne.dot(n.object.quaternion)) > a || Be.distanceToSquared(n.target) > a) && (n.dispatchEvent(bM), be.copy(n.object.position), Ne.copy(n.object.quaternion), Be.copy(n.target), !0);
      };
    }(), this.dispose = function() {
      n.domElement.removeEventListener("contextmenu", de), n.domElement.removeEventListener("pointerdown", Q), n.domElement.removeEventListener("pointercancel", k), n.domElement.removeEventListener("wheel", E), n.domElement.removeEventListener("pointermove", O), n.domElement.removeEventListener("pointerup", k), n.domElement.getRootNode().removeEventListener("keydown", U, { capture: !0 }), n._domElementKeyEvents !== null && (n._domElementKeyEvents.removeEventListener("keydown", ne), n._domElementKeyEvents = null);
    };
    const n = this, r = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
    let s = r.NONE;
    const a = 1e-6, o = new M0(), l = new M0();
    let c = 1;
    const h = new S(), u = new Y(), d = new Y(), p = new Y(), f = new Y(), v = new Y(), m = new Y(), y = new Y(), g = new Y(), _ = new Y(), x = new S(), M = new Y();
    let b = !1;
    const w = [], T = {};
    let A = !1;
    function L(H) {
      const j = Math.abs(0.01 * H);
      return Math.pow(0.95, n.zoomSpeed * j);
    }
    function I(H) {
      l.theta -= H;
    }
    function P(H) {
      l.phi -= H;
    }
    const N = function() {
      const H = new S();
      return function(j, $) {
        H.setFromMatrixColumn($, 0), H.multiplyScalar(-j), h.add(H);
      };
    }(), F = function() {
      const H = new S();
      return function(j, $) {
        n.screenSpacePanning === !0 ? H.setFromMatrixColumn($, 1) : (H.setFromMatrixColumn($, 0), H.crossVectors(n.object.up, H)), H.multiplyScalar(j), h.add(H);
      };
    }(), z = function() {
      const H = new S();
      return function(j, $) {
        const be = n.domElement;
        if (n.object.isPerspectiveCamera) {
          const Ne = n.object.position;
          H.copy(Ne).sub(n.target);
          let Be = H.length();
          Be *= Math.tan(n.object.fov / 2 * Math.PI / 180), N(2 * j * Be / be.clientHeight, n.object.matrix), F(2 * $ * Be / be.clientHeight, n.object.matrix);
        } else
          n.object.isOrthographicCamera ? (N(j * (n.object.right - n.object.left) / n.object.zoom / be.clientWidth, n.object.matrix), F($ * (n.object.top - n.object.bottom) / n.object.zoom / be.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    }();
    function q(H) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c /= H : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function re(H) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c *= H : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function ie(H, j) {
      if (!n.zoomToCursor)
        return;
      b = !0;
      const $ = n.domElement.getBoundingClientRect(), be = H - $.left, Ne = j - $.top, Be = $.width, Me = $.height;
      M.x = be / Be * 2 - 1, M.y = -Ne / Me * 2 + 1, x.set(M.x, M.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function me(H) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, H));
    }
    function Se(H) {
      u.set(H.clientX, H.clientY);
    }
    function te(H) {
      f.set(H.clientX, H.clientY);
    }
    function se(H) {
      if (w.length === 1)
        u.set(H.pageX, H.pageY);
      else {
        const j = ue(H), $ = 0.5 * (H.pageX + j.x), be = 0.5 * (H.pageY + j.y);
        u.set($, be);
      }
    }
    function he(H) {
      if (w.length === 1)
        f.set(H.pageX, H.pageY);
      else {
        const j = ue(H), $ = 0.5 * (H.pageX + j.x), be = 0.5 * (H.pageY + j.y);
        f.set($, be);
      }
    }
    function ae(H) {
      const j = ue(H), $ = H.pageX - j.x, be = H.pageY - j.y, Ne = Math.sqrt($ * $ + be * be);
      y.set(0, Ne);
    }
    function D(H) {
      if (w.length == 1)
        d.set(H.pageX, H.pageY);
      else {
        const $ = ue(H), be = 0.5 * (H.pageX + $.x), Ne = 0.5 * (H.pageY + $.y);
        d.set(be, Ne);
      }
      p.subVectors(d, u).multiplyScalar(n.rotateSpeed);
      const j = n.domElement;
      I(2 * Math.PI * p.x / j.clientHeight), P(2 * Math.PI * p.y / j.clientHeight), u.copy(d);
    }
    function R(H) {
      if (w.length === 1)
        v.set(H.pageX, H.pageY);
      else {
        const j = ue(H), $ = 0.5 * (H.pageX + j.x), be = 0.5 * (H.pageY + j.y);
        v.set($, be);
      }
      m.subVectors(v, f).multiplyScalar(n.panSpeed), z(m.x, m.y), f.copy(v);
    }
    function X(H) {
      const j = ue(H), $ = H.pageX - j.x, be = H.pageY - j.y, Ne = Math.sqrt($ * $ + be * be);
      g.set(0, Ne), _.set(0, Math.pow(g.y / y.y, n.zoomSpeed)), q(_.y), y.copy(g), ie(0.5 * (H.pageX + j.x), 0.5 * (H.pageY + j.y));
    }
    function Q(H) {
      n.enabled !== !1 && (w.length === 0 && (n.domElement.setPointerCapture(H.pointerId), n.domElement.addEventListener("pointermove", O), n.domElement.addEventListener("pointerup", k)), function(j) {
        for (let $ = 0; $ < w.length; $++)
          if (w[$] == j.pointerId)
            return !0;
        return !1;
      }(H) || (function(j) {
        w.push(j.pointerId);
      }(H), H.pointerType === "touch" ? V(H) : function(j) {
        let $;
        switch (j.button) {
          case 0:
            $ = n.mouseButtons.LEFT;
            break;
          case 1:
            $ = n.mouseButtons.MIDDLE;
            break;
          case 2:
            $ = n.mouseButtons.RIGHT;
            break;
          default:
            $ = -1;
        }
        switch ($) {
          case na.DOLLY:
            if (n.enableZoom === !1)
              return;
            (function(be) {
              ie(be.clientX, be.clientX), y.set(be.clientX, be.clientY);
            })(j), s = r.DOLLY;
            break;
          case na.ROTATE:
            if (j.ctrlKey || j.metaKey || j.shiftKey) {
              if (n.enablePan === !1)
                return;
              te(j), s = r.PAN;
            } else {
              if (n.enableRotate === !1)
                return;
              Se(j), s = r.ROTATE;
            }
            break;
          case na.PAN:
            if (j.ctrlKey || j.metaKey || j.shiftKey) {
              if (n.enableRotate === !1)
                return;
              Se(j), s = r.ROTATE;
            } else {
              if (n.enablePan === !1)
                return;
              te(j), s = r.PAN;
            }
            break;
          default:
            s = r.NONE;
        }
        s !== r.NONE && n.dispatchEvent(Tg);
      }(H)));
    }
    function O(H) {
      n.enabled !== !1 && (H.pointerType === "touch" ? function(j) {
        switch (xe(j), s) {
          case r.TOUCH_ROTATE:
            if (n.enableRotate === !1)
              return;
            D(j), n.update();
            break;
          case r.TOUCH_PAN:
            if (n.enablePan === !1)
              return;
            R(j), n.update();
            break;
          case r.TOUCH_DOLLY_PAN:
            if (n.enableZoom === !1 && n.enablePan === !1)
              return;
            (function($) {
              n.enableZoom && X($), n.enablePan && R($);
            })(j), n.update();
            break;
          case r.TOUCH_DOLLY_ROTATE:
            if (n.enableZoom === !1 && n.enableRotate === !1)
              return;
            (function($) {
              n.enableZoom && X($), n.enableRotate && D($);
            })(j), n.update();
            break;
          default:
            s = r.NONE;
        }
      }(H) : function(j) {
        switch (s) {
          case r.ROTATE:
            if (n.enableRotate === !1)
              return;
            (function($) {
              d.set($.clientX, $.clientY), p.subVectors(d, u).multiplyScalar(n.rotateSpeed);
              const be = n.domElement;
              I(2 * Math.PI * p.x / be.clientHeight), P(2 * Math.PI * p.y / be.clientHeight), u.copy(d), n.update();
            })(j);
            break;
          case r.DOLLY:
            if (n.enableZoom === !1)
              return;
            (function($) {
              g.set($.clientX, $.clientY), _.subVectors(g, y), _.y > 0 ? q(L(_.y)) : _.y < 0 && re(L(_.y)), y.copy(g), n.update();
            })(j);
            break;
          case r.PAN:
            if (n.enablePan === !1)
              return;
            (function($) {
              v.set($.clientX, $.clientY), m.subVectors(v, f).multiplyScalar(n.panSpeed), z(m.x, m.y), f.copy(v), n.update();
            })(j);
        }
      }(H));
    }
    function k(H) {
      switch (function(j) {
        delete T[j.pointerId];
        for (let $ = 0; $ < w.length; $++)
          if (w[$] == j.pointerId)
            return void w.splice($, 1);
      }(H), w.length) {
        case 0:
          n.domElement.releasePointerCapture(H.pointerId), n.domElement.removeEventListener("pointermove", O), n.domElement.removeEventListener("pointerup", k), n.dispatchEvent(MM), s = r.NONE;
          break;
        case 1:
          const j = w[0], $ = T[j];
          V({ pointerId: j, pageX: $.x, pageY: $.y });
      }
    }
    function E(H) {
      n.enabled !== !1 && n.enableZoom !== !1 && s === r.NONE && (H.preventDefault(), n.dispatchEvent(Tg), function(j) {
        ie(j.clientX, j.clientY), j.deltaY < 0 ? re(L(j.deltaY)) : j.deltaY > 0 && q(L(j.deltaY)), n.update();
      }(function(j) {
        const $ = j.deltaMode, be = { clientX: j.clientX, clientY: j.clientY, deltaY: j.deltaY };
        switch ($) {
          case 1:
            be.deltaY *= 16;
            break;
          case 2:
            be.deltaY *= 100;
        }
        return j.ctrlKey && !A && (be.deltaY *= 10), be;
      }(H)), n.dispatchEvent(MM));
    }
    function U(H) {
      H.key === "Control" && (A = !0, n.domElement.getRootNode().addEventListener("keyup", B, { passive: !0, capture: !0 }));
    }
    function B(H) {
      H.key === "Control" && (A = !1, n.domElement.getRootNode().removeEventListener("keyup", B, { passive: !0, capture: !0 }));
    }
    function ne(H) {
      n.enabled !== !1 && n.enablePan !== !1 && function(j) {
        let $ = !1;
        switch (j.code) {
          case n.keys.UP:
            j.ctrlKey || j.metaKey || j.shiftKey ? P(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : z(0, n.keyPanSpeed), $ = !0;
            break;
          case n.keys.BOTTOM:
            j.ctrlKey || j.metaKey || j.shiftKey ? P(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : z(0, -n.keyPanSpeed), $ = !0;
            break;
          case n.keys.LEFT:
            j.ctrlKey || j.metaKey || j.shiftKey ? I(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : z(n.keyPanSpeed, 0), $ = !0;
            break;
          case n.keys.RIGHT:
            j.ctrlKey || j.metaKey || j.shiftKey ? I(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : z(-n.keyPanSpeed, 0), $ = !0;
        }
        $ && (j.preventDefault(), n.update());
      }(H);
    }
    function V(H) {
      switch (xe(H), w.length) {
        case 1:
          switch (n.touches.ONE) {
            case ia.ROTATE:
              if (n.enableRotate === !1)
                return;
              se(H), s = r.TOUCH_ROTATE;
              break;
            case ia.PAN:
              if (n.enablePan === !1)
                return;
              he(H), s = r.TOUCH_PAN;
              break;
            default:
              s = r.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case ia.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              (function(j) {
                n.enableZoom && ae(j), n.enablePan && he(j);
              })(H), s = r.TOUCH_DOLLY_PAN;
              break;
            case ia.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              (function(j) {
                n.enableZoom && ae(j), n.enableRotate && se(j);
              })(H), s = r.TOUCH_DOLLY_ROTATE;
              break;
            default:
              s = r.NONE;
          }
          break;
        default:
          s = r.NONE;
      }
      s !== r.NONE && n.dispatchEvent(Tg);
    }
    function de(H) {
      n.enabled !== !1 && H.preventDefault();
    }
    function xe(H) {
      let j = T[H.pointerId];
      j === void 0 && (j = new Y(), T[H.pointerId] = j), j.set(H.pageX, H.pageY);
    }
    function ue(H) {
      const j = H.pointerId === w[0] ? w[1] : w[0];
      return T[j];
    }
    n.domElement.addEventListener("contextmenu", de), n.domElement.addEventListener("pointerdown", Q), n.domElement.addEventListener("pointercancel", k), n.domElement.addEventListener("wheel", E, { passive: !1 }), n.domElement.getRootNode().addEventListener("keydown", U, { passive: !0, capture: !0 }), this.update();
  }
}
const ta = new D1(), Sn = new S(), es = new S(), xt = new Qe(), SM = { X: new S(1, 0, 0), Y: new S(0, 1, 0), Z: new S(0, 0, 1) }, Eg = { type: "change" }, TM = { type: "mouseDown", mode: null }, EM = { type: "mouseUp", mode: null }, AM = { type: "objectChange" };
class tL extends Fe {
  constructor(e, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
    const n = new oL();
    this._gizmo = n, this.add(n);
    const r = new lL();
    this._plane = r, this.add(r);
    const s = this;
    function a(y, g) {
      let _ = g;
      Object.defineProperty(s, y, { get: function() {
        return _ !== void 0 ? _ : g;
      }, set: function(x) {
        _ !== x && (_ = x, r[y] = x, n[y] = x, s.dispatchEvent({ type: y + "-changed", value: x }), s.dispatchEvent(Eg));
      } }), s[y] = g, r[y] = g, n[y] = g;
    }
    a("camera", e), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "world"), a("size", 1), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0);
    const o = new S(), l = new S(), c = new Qe(), h = new Qe(), u = new S(), d = new Qe(), p = new S(), f = new S(), v = new S(), m = new S();
    a("worldPosition", o), a("worldPositionStart", l), a("worldQuaternion", c), a("worldQuaternionStart", h), a("cameraPosition", u), a("cameraQuaternion", d), a("pointStart", p), a("pointEnd", f), a("rotationAxis", v), a("rotationAngle", 0), a("eye", m), this._offset = new S(), this._startNorm = new S(), this._endNorm = new S(), this._cameraScale = new S(), this._parentPosition = new S(), this._parentQuaternion = new Qe(), this._parentQuaternionInv = new Qe(), this._parentScale = new S(), this._worldScaleStart = new S(), this._worldQuaternionInv = new Qe(), this._worldScale = new S(), this._positionStart = new S(), this._quaternionStart = new Qe(), this._scaleStart = new S(), this._getPointer = nL.bind(this), this._onPointerDown = rL.bind(this), this._onPointerHover = iL.bind(this), this._onPointerMove = sL.bind(this), this._onPointerUp = aL.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld(e) {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    e !== null && ta.setFromCamera(e, this.camera);
    const t = Ag(this._gizmo.picker[this.mode], ta);
    this.axis = t ? t.object.name : null;
  }
  pointerDown(e) {
    if (this.object !== void 0 && this.dragging !== !0 && (e == null || e.button === 0) && this.axis !== null) {
      e !== null && ta.setFromCamera(e, this.camera);
      const t = Ag(this._plane, ta, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, TM.mode = this.mode, this.dispatchEvent(TM);
    }
  }
  pointerMove(e) {
    const t = this.axis, n = this.mode, r = this.object;
    let s = this.space;
    if (n === "scale" ? s = "local" : t !== "E" && t !== "XYZE" && t !== "XYZ" || (s = "world"), r === void 0 || t === null || this.dragging === !1 || e !== null && e.button !== -1)
      return;
    e !== null && ta.setFromCamera(e, this.camera);
    const a = Ag(this._plane, ta, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), n === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), s === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), s === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r.position.copy(this._offset).add(this._positionStart), this.translationSnap && (s === "local" && (r.position.applyQuaternion(xt.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)), s === "world" && (r.parent && r.position.add(Sn.setFromMatrixPosition(r.parent.matrixWorld)), t.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(Sn.setFromMatrixPosition(r.parent.matrixWorld))));
      else if (n === "scale") {
        if (t.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), es.set(o, o, o);
        } else
          Sn.copy(this.pointStart), es.copy(this.pointEnd), Sn.applyQuaternion(this._worldQuaternionInv), es.applyQuaternion(this._worldQuaternionInv), es.divide(Sn), t.search("X") === -1 && (es.x = 1), t.search("Y") === -1 && (es.y = 1), t.search("Z") === -1 && (es.z = 1);
        r.scale.copy(this._scaleStart).multiply(es), this.scaleSnap && (t.search("X") !== -1 && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(Sn.setFromMatrixPosition(this.camera.matrixWorld));
        let l = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Sn.copy(this.rotationAxis).cross(this.eye)) * o) : t !== "X" && t !== "Y" && t !== "Z" || (this.rotationAxis.copy(SM[t]), Sn.copy(SM[t]), s === "local" && Sn.applyQuaternion(this.worldQuaternion), Sn.cross(this.eye), Sn.length() === 0 ? l = !0 : this.rotationAngle = this._offset.dot(Sn.normalize()) * o), (t === "E" || l) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), s === "local" && t !== "E" && t !== "XYZE" ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(xt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(xt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Eg), this.dispatchEvent(AM);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (EM.mode = this.mode, this.dispatchEvent(EM)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Eg), this.dispatchEvent(AM), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return ta;
  }
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function nL(i) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return { x: 0, y: 0, button: i.button };
  {
    const e = this.domElement.getBoundingClientRect();
    return { x: (i.clientX - e.left) / e.width * 2 - 1, y: -(i.clientY - e.top) / e.height * 2 + 1, button: i.button };
  }
}
function iL(i) {
  if (this.enabled)
    switch (i.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(i));
    }
}
function rL(i) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(i.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(i)), this.pointerDown(this._getPointer(i)));
}
function sL(i) {
  this.enabled && this.pointerMove(this._getPointer(i));
}
function aL(i) {
  this.enabled && (this.domElement.releasePointerCapture(i.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(i)));
}
function Ag(i, e, t) {
  const n = e.intersectObject(i, !0);
  for (let r = 0; r < n.length; r++)
    if (n[r].object.visible || t)
      return n[r];
  return !1;
}
const kd = new bt(), mt = new S(0, 1, 0), IM = new S(0, 0, 0), CM = new fe(), Fd = new Qe(), rp = new Qe(), er = new S(), RM = new fe(), Nc = new S(1, 0, 0), oa = new S(0, 1, 0), Oc = new S(0, 0, 1), Bd = new S(), wc = new S(), Sc = new S();
class oL extends Fe {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new nn({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }), t = new zt({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }), n = e.clone();
    n.opacity = 0.15;
    const r = t.clone();
    r.opacity = 0.5;
    const s = e.clone();
    s.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const o = e.clone();
    o.color.setHex(255);
    const l = e.clone();
    l.color.setHex(16711680), l.opacity = 0.5;
    const c = e.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const h = e.clone();
    h.color.setHex(255), h.opacity = 0.5;
    const u = e.clone();
    u.opacity = 0.25;
    const d = e.clone();
    d.color.setHex(16776960), d.opacity = 0.25, e.clone().color.setHex(16776960);
    const p = e.clone();
    p.color.setHex(7895160);
    const f = new Ft(0, 0.04, 0.1, 12);
    f.translate(0, 0.05, 0);
    const v = new Pt(0.08, 0.08, 0.08);
    v.translate(0, 0.04, 0);
    const m = new Re();
    m.setAttribute("position", new ye([0, 0, 0, 1, 0, 0], 3));
    const y = new Ft(75e-4, 75e-4, 0.5, 3);
    function g(N, F) {
      const z = new Rr(N, 75e-4, 3, 64, F * Math.PI * 2);
      return z.rotateY(Math.PI / 2), z.rotateX(Math.PI / 2), z;
    }
    y.translate(0, 0.25, 0);
    const _ = { X: [[new ve(f, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new ve(f, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]], [new ve(y, s), [0, 0, 0], [0, 0, -Math.PI / 2]]], Y: [[new ve(f, a), [0, 0.5, 0]], [new ve(f, a), [0, -0.5, 0], [Math.PI, 0, 0]], [new ve(y, a)]], Z: [[new ve(f, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new ve(f, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]], [new ve(y, o), null, [Math.PI / 2, 0, 0]]], XYZ: [[new ve(new Lr(0.1, 0), u.clone()), [0, 0, 0]]], XY: [[new ve(new Pt(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]], YZ: [[new ve(new Pt(0.15, 0.15, 0.01), l.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new ve(new Pt(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, x = { X: [[new ve(new Ft(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new ve(new Ft(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new ve(new Ft(0.2, 0, 0.6, 4), n), [0, 0.3, 0]], [new ve(new Ft(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new ve(new Ft(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new ve(new Ft(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XYZ: [[new ve(new Lr(0.2, 0), n)]], XY: [[new ve(new Pt(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]], YZ: [[new ve(new Pt(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new ve(new Pt(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, M = { START: [[new ve(new Lr(0.01, 2), r), null, null, null, "helper"]], END: [[new ve(new Lr(0.01, 2), r), null, null, null, "helper"]], DELTA: [[new dn(function() {
      const N = new Re();
      return N.setAttribute("position", new ye([0, 0, 0, 1, 1, 1], 3)), N;
    }(), r), null, null, null, "helper"]], X: [[new dn(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new dn(m, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new dn(m, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }, b = { XYZE: [[new ve(g(0.5, 1), p), null, [0, Math.PI / 2, 0]]], X: [[new ve(g(0.5, 0.5), s)]], Y: [[new ve(g(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]], Z: [[new ve(g(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]], E: [[new ve(g(0.75, 1), d), null, [0, Math.PI / 2, 0]]] }, w = { AXIS: [[new dn(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]] }, T = { XYZE: [[new ve(new gl(0.25, 10, 8), n)]], X: [[new ve(new Rr(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]], Y: [[new ve(new Rr(0.5, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]], Z: [[new ve(new Rr(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]], E: [[new ve(new Rr(0.75, 0.1, 2, 24), n)]] }, A = { X: [[new ve(v, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new ve(y, s), [0, 0, 0], [0, 0, -Math.PI / 2]], [new ve(v, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new ve(v, a), [0, 0.5, 0]], [new ve(y, a)], [new ve(v, a), [0, -0.5, 0], [0, 0, Math.PI]]], Z: [[new ve(v, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new ve(y, o), [0, 0, 0], [Math.PI / 2, 0, 0]], [new ve(v, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]], XY: [[new ve(new Pt(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]], YZ: [[new ve(new Pt(0.15, 0.15, 0.01), l), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new ve(new Pt(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new ve(new Pt(0.1, 0.1, 0.1), u.clone())]] }, L = { X: [[new ve(new Ft(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new ve(new Ft(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new ve(new Ft(0.2, 0, 0.6, 4), n), [0, 0.3, 0]], [new ve(new Ft(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new ve(new Ft(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new ve(new Ft(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XY: [[new ve(new Pt(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]], YZ: [[new ve(new Pt(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new ve(new Pt(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new ve(new Pt(0.2, 0.2, 0.2), n), [0, 0, 0]]] }, I = { X: [[new dn(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new dn(m, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new dn(m, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] };
    function P(N) {
      const F = new Fe();
      for (const z in N)
        for (let q = N[z].length; q--; ) {
          const re = N[z][q][0].clone(), ie = N[z][q][1], me = N[z][q][2], Se = N[z][q][3], te = N[z][q][4];
          re.name = z, re.tag = te, ie && re.position.set(ie[0], ie[1], ie[2]), me && re.rotation.set(me[0], me[1], me[2]), Se && re.scale.set(Se[0], Se[1], Se[2]), re.updateMatrix();
          const se = re.geometry.clone();
          se.applyMatrix4(re.matrix), re.geometry = se, re.renderOrder = 1 / 0, re.position.set(0, 0, 0), re.rotation.set(0, 0, 0), re.scale.set(1, 1, 1), F.add(re);
        }
      return F;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = P(_)), this.add(this.gizmo.rotate = P(b)), this.add(this.gizmo.scale = P(A)), this.add(this.picker.translate = P(x)), this.add(this.picker.rotate = P(T)), this.add(this.picker.scale = P(L)), this.add(this.helper.translate = P(M)), this.add(this.helper.rotate = P(w)), this.add(this.helper.scale = P(I)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  updateMatrixWorld(e) {
    const t = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : rp;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let n = [];
    n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      let a;
      s.visible = !0, s.rotation.set(0, 0, 0), s.position.copy(this.worldPosition), a = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), s.scale.set(1, 1, 1).multiplyScalar(a * this.size / 4), s.tag !== "helper" ? (s.quaternion.copy(t), this.mode === "translate" || this.mode === "scale" ? (s.name === "X" && Math.abs(mt.copy(Nc).applyQuaternion(t).dot(this.eye)) > 0.99 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "Y" && Math.abs(mt.copy(oa).applyQuaternion(t).dot(this.eye)) > 0.99 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "Z" && Math.abs(mt.copy(Oc).applyQuaternion(t).dot(this.eye)) > 0.99 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "XY" && Math.abs(mt.copy(Oc).applyQuaternion(t).dot(this.eye)) < 0.2 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "YZ" && Math.abs(mt.copy(Nc).applyQuaternion(t).dot(this.eye)) < 0.2 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "XZ" && Math.abs(mt.copy(oa).applyQuaternion(t).dot(this.eye)) < 0.2 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1)) : this.mode === "rotate" && (Fd.copy(t), mt.copy(this.eye).applyQuaternion(xt.copy(t).invert()), s.name.search("E") !== -1 && s.quaternion.setFromRotationMatrix(CM.lookAt(this.eye, IM, oa)), s.name === "X" && (xt.setFromAxisAngle(Nc, Math.atan2(-mt.y, mt.z)), xt.multiplyQuaternions(Fd, xt), s.quaternion.copy(xt)), s.name === "Y" && (xt.setFromAxisAngle(oa, Math.atan2(mt.x, mt.z)), xt.multiplyQuaternions(Fd, xt), s.quaternion.copy(xt)), s.name === "Z" && (xt.setFromAxisAngle(Oc, Math.atan2(mt.y, mt.x)), xt.multiplyQuaternions(Fd, xt), s.quaternion.copy(xt))), s.visible = s.visible && (s.name.indexOf("X") === -1 || this.showX), s.visible = s.visible && (s.name.indexOf("Y") === -1 || this.showY), s.visible = s.visible && (s.name.indexOf("Z") === -1 || this.showZ), s.visible = s.visible && (s.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), s.material._color = s.material._color || s.material.color.clone(), s.material._opacity = s.material._opacity || s.material.opacity, s.material.color.copy(s.material._color), s.material.opacity = s.material._opacity, this.enabled && this.axis && (s.name === this.axis || this.axis.split("").some(function(o) {
        return s.name === o;
      })) && (s.material.color.setHex(16776960), s.material.opacity = 1)) : (s.visible = !1, s.name === "AXIS" ? (s.visible = !!this.axis, this.axis === "X" && (xt.setFromEuler(kd.set(0, 0, 0)), s.quaternion.copy(t).multiply(xt), Math.abs(mt.copy(Nc).applyQuaternion(t).dot(this.eye)) > 0.9 && (s.visible = !1)), this.axis === "Y" && (xt.setFromEuler(kd.set(0, 0, Math.PI / 2)), s.quaternion.copy(t).multiply(xt), Math.abs(mt.copy(oa).applyQuaternion(t).dot(this.eye)) > 0.9 && (s.visible = !1)), this.axis === "Z" && (xt.setFromEuler(kd.set(0, Math.PI / 2, 0)), s.quaternion.copy(t).multiply(xt), Math.abs(mt.copy(Oc).applyQuaternion(t).dot(this.eye)) > 0.9 && (s.visible = !1)), this.axis === "XYZE" && (xt.setFromEuler(kd.set(0, Math.PI / 2, 0)), mt.copy(this.rotationAxis), s.quaternion.setFromRotationMatrix(CM.lookAt(IM, mt, oa)), s.quaternion.multiply(xt), s.visible = this.dragging), this.axis === "E" && (s.visible = !1)) : s.name === "START" ? (s.position.copy(this.worldPositionStart), s.visible = this.dragging) : s.name === "END" ? (s.position.copy(this.worldPosition), s.visible = this.dragging) : s.name === "DELTA" ? (s.position.copy(this.worldPositionStart), s.quaternion.copy(this.worldQuaternionStart), Sn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Sn.applyQuaternion(this.worldQuaternionStart.clone().invert()), s.scale.copy(Sn), s.visible = this.dragging) : (s.quaternion.copy(t), this.dragging ? s.position.copy(this.worldPositionStart) : s.position.copy(this.worldPosition), this.axis && (s.visible = this.axis.search(s.name) !== -1)));
    }
    super.updateMatrixWorld(e);
  }
}
class lL extends ve {
  constructor() {
    super(new Qa(1e5, 1e5, 2, 2), new nn({ visible: !1, wireframe: !0, side: tn, transparent: !0, opacity: 0.1, toneMapped: !1 })), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), Bd.copy(Nc).applyQuaternion(t === "local" ? this.worldQuaternion : rp), wc.copy(oa).applyQuaternion(t === "local" ? this.worldQuaternion : rp), Sc.copy(Oc).applyQuaternion(t === "local" ? this.worldQuaternion : rp), mt.copy(wc), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            mt.copy(this.eye).cross(Bd), er.copy(Bd).cross(mt);
            break;
          case "Y":
            mt.copy(this.eye).cross(wc), er.copy(wc).cross(mt);
            break;
          case "Z":
            mt.copy(this.eye).cross(Sc), er.copy(Sc).cross(mt);
            break;
          case "XY":
            er.copy(Sc);
            break;
          case "YZ":
            er.copy(Bd);
            break;
          case "XZ":
            mt.copy(Sc), er.copy(wc);
            break;
          case "XYZ":
          case "E":
            er.set(0, 0, 0);
        }
        break;
      default:
        er.set(0, 0, 0);
    }
    er.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (RM.lookAt(Sn.set(0, 0, 0), er, mt), this.quaternion.setFromRotationMatrix(RM)), super.updateMatrixWorld(e);
  }
}
function nx() {
  const i = ["maxDistance", "8eScQbD", "name", "value", "11993114hskQjS", "TransformControls", "addEventListener", "includes", "dampingFactor", "visible", "isTransformControls", "object", "Box3", "traverse", "minDistance", "178190BhZpkO", "dragging-changed", "225820olhRbl", "4151910SmxNuz", "setFromObject", "688347oZayTi", "2650084GvmYRW", "transformControls", "dragChangeCallback", "61641nFVjPn", "box", "domElement", "box3Helper", "add"];
  return (nx = function() {
    return i;
  })();
}
function zp(i, e) {
  const t = nx();
  return (zp = function(n, r) {
    return t[n -= 431];
  })(i, e);
}
(function(i, e) {
  const t = zp, n = nx();
  for (; ; )
    try {
      if (-parseInt(t(437)) / 1 + -parseInt(t(457)) / 2 + parseInt(t(433)) / 3 + -parseInt(t(434)) / 4 + -parseInt(t(459)) / 5 + -parseInt(t(431)) / 6 + -parseInt(t(446)) / 7 * (-parseInt(t(443)) / 8) === 392345)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
const kr = { name: "CopyShader", uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}` };
class Vr {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const cL = new Ha(-1, 1, 1, -1, 0, 1), hL = new class extends Re {
  constructor() {
    super(), this.setAttribute("position", new ye([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ye([0, 2, 0, 0, 2, 0], 2));
  }
}();
class Vl {
  constructor(e) {
    this._mesh = new ve(hL, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, cL);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class ix extends Vr {
  constructor(e, t) {
    super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof st ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = rn.clone(e.uniforms), this.material = new st({ name: e.name !== void 0 ? e.name : "unspecified", defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this.fsQuad = new Vl(this.material);
  }
  render(e, t, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class PM extends Vr {
  constructor(e, t) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, t, n) {
    const r = e.getContext(), s = e.state;
    let a, o;
    s.buffers.color.setMask(!1), s.buffers.depth.setMask(!1), s.buffers.color.setLocked(!0), s.buffers.depth.setLocked(!0), this.inverse ? (a = 0, o = 1) : (a = 1, o = 0), s.buffers.stencil.setTest(!0), s.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), s.buffers.stencil.setFunc(r.ALWAYS, a, 4294967295), s.buffers.stencil.setClear(o), s.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), s.buffers.color.setLocked(!1), s.buffers.depth.setLocked(!1), s.buffers.color.setMask(!0), s.buffers.depth.setMask(!0), s.buffers.stencil.setLocked(!1), s.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), s.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), s.buffers.stencil.setLocked(!0);
  }
}
class uL extends Vr {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class dL {
  constructor(e, t) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), t === void 0) {
      const n = e.getSize(new Y());
      this._width = n.width, this._height = n.height, (t = new dt(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: Vt })).texture.name = "EffectComposer.rt1";
    } else
      this._width = t.width, this._height = t.height;
    this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new ix(kr), this.copyPass.material.blending = 0, this.clock = new x0();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    t !== -1 && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let n = !1;
    for (let r = 0, s = this.passes.length; r < s; r++) {
      const a = this.passes[r];
      if (a.enabled !== !1) {
        if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), a.needsSwap) {
          if (n) {
            const o = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        PM !== void 0 && (a instanceof PM ? n = !0 : a instanceof uL && (n = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (e === void 0) {
      const t = this.renderer.getSize(new Y());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, t) {
    this._width = e, this._height = t;
    const n = this._width * this._pixelRatio, r = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
    for (let s = 0; s < this.passes.length; s++)
      this.passes[s].setSize(n, r);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class pL extends Vr {
  constructor(e, t, n = null, r = null, s = null) {
    super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = s, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new ce();
  }
  render(e, t, n) {
    const r = e.autoClear;
    let s, a;
    e.autoClear = !1, this.overrideMaterial !== null && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (s = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == 1 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(s), this.overrideMaterial !== null && (this.scene.overrideMaterial = a), e.autoClear = r;
  }
}
class ps extends Vr {
  constructor(e, t, n, r) {
    super(), this.renderScene = t, this.renderCamera = n, this.selectedObjects = r !== void 0 ? r : [], this.visibleEdgeColor = new ce(1, 1, 1), this.hiddenEdgeColor = new ce(0.1, 0.04, 0.02), this.edgeGlow = 0, this.usePatternTexture = !1, this.edgeThickness = 1, this.edgeStrength = 3, this.downSampleRatio = 2, this.pulsePeriod = 0, this._visibilityCache = /* @__PURE__ */ new Map(), this.resolution = e !== void 0 ? new Y(e.x, e.y) : new Y(256, 256);
    const s = Math.round(this.resolution.x / this.downSampleRatio), a = Math.round(this.resolution.y / this.downSampleRatio);
    this.renderTargetMaskBuffer = new dt(this.resolution.x, this.resolution.y), this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = !1, this.depthMaterial = new Zp(), this.depthMaterial.side = tn, this.depthMaterial.depthPacking = u1, this.depthMaterial.blending = 0, this.prepareMaskMaterial = this.getPrepareMaskMaterial(), this.prepareMaskMaterial.side = tn, this.prepareMaskMaterial.fragmentShader = function(l, c) {
      const h = c.isPerspectiveCamera ? "perspective" : "orthographic";
      return l.replace(/DEPTH_TO_VIEW_Z/g, h + "DepthToViewZ");
    }(this.prepareMaskMaterial.fragmentShader, this.renderCamera), this.renderTargetDepthBuffer = new dt(this.resolution.x, this.resolution.y, { type: Vt }), this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = !1, this.renderTargetMaskDownSampleBuffer = new dt(s, a, { type: Vt }), this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1, this.renderTargetBlurBuffer1 = new dt(s, a, { type: Vt }), this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = !1, this.renderTargetBlurBuffer2 = new dt(Math.round(s / 2), Math.round(a / 2), { type: Vt }), this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = !1, this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new dt(s, a, { type: Vt }), this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1, this.renderTargetEdgeBuffer2 = new dt(Math.round(s / 2), Math.round(a / 2), { type: Vt }), this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1, this.separableBlurMaterial1 = this.getSeperableBlurMaterial(4), this.separableBlurMaterial1.uniforms.texSize.value.set(s, a), this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeperableBlurMaterial(4), this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(s / 2), Math.round(a / 2)), this.separableBlurMaterial2.uniforms.kernelRadius.value = 4, this.overlayMaterial = this.getOverlayMaterial();
    const o = kr;
    this.copyUniforms = rn.clone(o.uniforms), this.materialCopy = new st({ uniforms: this.copyUniforms, vertexShader: o.vertexShader, fragmentShader: o.fragmentShader, blending: 0, depthTest: !1, depthWrite: !1 }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new ce(), this.oldClearAlpha = 1, this.fsQuad = new Vl(null), this.tempPulseColor1 = new ce(), this.tempPulseColor2 = new ce(), this.textureMatrix = new fe();
  }
  dispose() {
    this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose(), this.depthMaterial.dispose(), this.prepareMaskMaterial.dispose(), this.edgeDetectionMaterial.dispose(), this.separableBlurMaterial1.dispose(), this.separableBlurMaterial2.dispose(), this.overlayMaterial.dispose(), this.materialCopy.dispose(), this.fsQuad.dispose();
  }
  setSize(e, t) {
    this.renderTargetMaskBuffer.setSize(e, t), this.renderTargetDepthBuffer.setSize(e, t);
    let n = Math.round(e / this.downSampleRatio), r = Math.round(t / this.downSampleRatio);
    this.renderTargetMaskDownSampleBuffer.setSize(n, r), this.renderTargetBlurBuffer1.setSize(n, r), this.renderTargetEdgeBuffer1.setSize(n, r), this.separableBlurMaterial1.uniforms.texSize.value.set(n, r), n = Math.round(n / 2), r = Math.round(r / 2), this.renderTargetBlurBuffer2.setSize(n, r), this.renderTargetEdgeBuffer2.setSize(n, r), this.separableBlurMaterial2.uniforms.texSize.value.set(n, r);
  }
  changeVisibilityOfSelectedObjects(e) {
    const t = this._visibilityCache;
    function n(r) {
      r.isMesh && (e === !0 ? r.visible = t.get(r) : (t.set(r, r.visible), r.visible = e));
    }
    for (let r = 0; r < this.selectedObjects.length; r++)
      this.selectedObjects[r].traverse(n);
  }
  changeVisibilityOfNonSelectedObjects(e) {
    const t = this._visibilityCache, n = [];
    function r(s) {
      s.isMesh && n.push(s);
    }
    for (let s = 0; s < this.selectedObjects.length; s++)
      this.selectedObjects[s].traverse(r);
    this.renderScene.traverse(function(s) {
      if (s.isMesh || s.isSprite) {
        let a = !1;
        for (let o = 0; o < n.length; o++)
          if (n[o].id === s.id) {
            a = !0;
            break;
          }
        if (a === !1) {
          const o = s.visible;
          e !== !1 && t.get(s) !== !0 || (s.visible = e), t.set(s, o);
        }
      } else
        (s.isPoints || s.isLine) && (e === !0 ? s.visible = t.get(s) : (t.set(s, s.visible), s.visible = e));
    });
  }
  updateTextureMatrix() {
    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
  }
  render(e, t, n, r, s) {
    if (this.selectedObjects.length > 0) {
      e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
      const a = e.autoClear;
      e.autoClear = !1, s && e.state.buffers.stencil.setTest(!1), e.setClearColor(16777215, 1), this.changeVisibilityOfSelectedObjects(!1);
      const o = this.renderScene.background;
      if (this.renderScene.background = null, this.renderScene.overrideMaterial = this.depthMaterial, e.setRenderTarget(this.renderTargetDepthBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.changeVisibilityOfSelectedObjects(!0), this._visibilityCache.clear(), this.updateTextureMatrix(), this.changeVisibilityOfNonSelectedObjects(!1), this.renderScene.overrideMaterial = this.prepareMaskMaterial, this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near, this.renderCamera.far), this.prepareMaskMaterial.uniforms.depthTexture.value = this.renderTargetDepthBuffer.texture, this.prepareMaskMaterial.uniforms.textureMatrix.value = this.textureMatrix, e.setRenderTarget(this.renderTargetMaskBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.renderScene.overrideMaterial = null, this.changeVisibilityOfNonSelectedObjects(!0), this._visibilityCache.clear(), this.renderScene.background = o, this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, e.setRenderTarget(this.renderTargetMaskDownSampleBuffer), e.clear(), this.fsQuad.render(e), this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), this.pulsePeriod > 0) {
        const l = 0.625 + 0.75 * Math.cos(0.01 * performance.now() / this.pulsePeriod) / 2;
        this.tempPulseColor1.multiplyScalar(l), this.tempPulseColor2.multiplyScalar(l);
      }
      this.fsQuad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial1, this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = ps.BlurDirectionX, this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, e.setRenderTarget(this.renderTargetBlurBuffer1), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = ps.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial2, this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial2.uniforms.direction.value = ps.BlurDirectionX, e.setRenderTarget(this.renderTargetBlurBuffer2), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, this.separableBlurMaterial2.uniforms.direction.value = ps.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer2), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.overlayMaterial, this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, s && e.state.buffers.stencil.setTest(!0), e.setRenderTarget(n), this.fsQuad.render(e), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = a;
    }
    this.renderToScreen && (this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = n.texture, e.setRenderTarget(null), this.fsQuad.render(e));
  }
  getPrepareMaskMaterial() {
    return new st({ uniforms: { depthTexture: { value: null }, cameraNearFar: { value: new Y(0.5, 0.5) }, textureMatrix: { value: null } }, vertexShader: `#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;

					vec4 worldPosition = vec4( transformed, 1.0 );

					#ifdef USE_INSTANCING

						worldPosition = instanceMatrix * worldPosition;

					#endif
					
					worldPosition = modelMatrix * worldPosition;

					projTexCoord = textureMatrix * worldPosition;

				}`, fragmentShader: `#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}` });
  }
  getEdgeDetectionMaterial() {
    return new st({ uniforms: { maskTexture: { value: null }, texSize: { value: new Y(0.5, 0.5) }, visibleEdgeColor: { value: new S(1, 1, 1) }, hiddenEdgeColor: { value: new S(1, 1, 1) } }, vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}` });
  }
  getSeperableBlurMaterial(e) {
    return new st({ defines: { MAX_RADIUS: e }, uniforms: { colorTexture: { value: null }, texSize: { value: new Y(0.5, 0.5) }, direction: { value: new Y(0.5, 0.5) }, kernelRadius: { value: 1 } }, vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float sigma = kernelRadius/2.0;
					float weightSum = gaussianPdf(0.0, sigma);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float x = kernelRadius * float(i) / float(MAX_RADIUS);
						float w = gaussianPdf(x, sigma);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}` });
  }
  getOverlayMaterial() {
    return new st({ uniforms: { maskTexture: { value: null }, edgeTexture1: { value: null }, edgeTexture2: { value: null }, patternTexture: { value: null }, edgeStrength: { value: 1 }, edgeGlow: { value: 1 }, usePatternTexture: { value: 0 } }, vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`, blending: al, depthTest: !1, depthWrite: !1, transparent: !0 });
  }
}
ps.BlurDirectionX = new Y(1, 0), ps.BlurDirectionY = new Y(0, 1);
const fL = { name: "OutputShader", uniforms: { tDiffuse: { value: null }, toneMappingExposure: { value: 1 } }, vertexShader: `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}` };
class mL extends Vr {
  constructor() {
    super();
    const e = fL;
    this.uniforms = rn.clone(e.uniforms), this.material = new w1({ name: e.name, uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader }), this.fsQuad = new Vl(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  render(e, t, n) {
    this.uniforms.tDiffuse.value = n.texture, this.uniforms.toneMappingExposure.value = e.toneMappingExposure, this._outputColorSpace === e.outputColorSpace && this._toneMapping === e.toneMapping || (this._outputColorSpace = e.outputColorSpace, this._toneMapping = e.toneMapping, this.material.defines = {}, rt.getTransfer(this._outputColorSpace) === ft && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === t1 ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === n1 ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === i1 ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === r1 ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this._toneMapping === s1 ? this.material.defines.AGX_TONE_MAPPING = "" : this._toneMapping === a1 && (this.material.defines.NEUTRAL_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const gL = { name: "LuminosityHighPassShader", shaderID: "luminosityHighPass", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new ce(0) }, defaultOpacity: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}` };
class Al extends Vr {
  constructor(e, t, n, r) {
    super(), this.strength = t !== void 0 ? t : 1, this.radius = n, this.threshold = r, this.resolution = e !== void 0 ? new Y(e.x, e.y) : new Y(256, 256), this.clearColor = new ce(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
    let s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new dt(s, a, { type: Vt }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
    for (let h = 0; h < this.nMips; h++) {
      const u = new dt(s, a, { type: Vt });
      u.texture.name = "UnrealBloomPass.h" + h, u.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(u);
      const d = new dt(s, a, { type: Vt });
      d.texture.name = "UnrealBloomPass.v" + h, d.texture.generateMipmaps = !1, this.renderTargetsVertical.push(d), s = Math.round(s / 2), a = Math.round(a / 2);
    }
    const o = gL;
    this.highPassUniforms = rn.clone(o.uniforms), this.highPassUniforms.luminosityThreshold.value = r, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new st({ uniforms: this.highPassUniforms, vertexShader: o.vertexShader, fragmentShader: o.fragmentShader }), this.separableBlurMaterials = [];
    const l = [3, 5, 7, 9, 11];
    s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
    for (let h = 0; h < this.nMips; h++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[h])), this.separableBlurMaterials[h].uniforms.invSize.value = new Y(1 / s, 1 / a), s = Math.round(s / 2), a = Math.round(a / 2);
    this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = 0.1, this.compositeMaterial.uniforms.bloomFactors.value = [1, 0.8, 0.6, 0.4, 0.2], this.bloomTintColors = [new S(1, 1, 1), new S(1, 1, 1), new S(1, 1, 1), new S(1, 1, 1), new S(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
    const c = kr;
    this.copyUniforms = rn.clone(c.uniforms), this.blendMaterial = new st({ uniforms: this.copyUniforms, vertexShader: c.vertexShader, fragmentShader: c.fragmentShader, blending: al, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new ce(), this.oldClearAlpha = 1, this.basic = new nn(), this.fsQuad = new Vl(null);
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
    for (let e = 0; e < this.separableBlurMaterials.length; e++)
      this.separableBlurMaterials[e].dispose();
    this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose();
  }
  setSize(e, t) {
    let n = Math.round(e / 2), r = Math.round(t / 2);
    this.renderTargetBright.setSize(n, r);
    for (let s = 0; s < this.nMips; s++)
      this.renderTargetsHorizontal[s].setSize(n, r), this.renderTargetsVertical[s].setSize(n, r), this.separableBlurMaterials[s].uniforms.invSize.value = new Y(1 / n, 1 / r), n = Math.round(n / 2), r = Math.round(r / 2);
  }
  render(e, t, n, r, s) {
    e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
    const a = e.autoClear;
    e.autoClear = !1, e.setClearColor(this.clearColor, 0), s && e.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
    let o = this.renderTargetBright;
    for (let l = 0; l < this.nMips; l++)
      this.fsQuad.material = this.separableBlurMaterials[l], this.separableBlurMaterials[l].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[l].uniforms.direction.value = Al.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[l]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture, this.separableBlurMaterials[l].uniforms.direction.value = Al.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[l]), e.clear(), this.fsQuad.render(e), o = this.renderTargetsVertical[l];
    this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, s && e.state.buffers.stencil.setTest(!0), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = a;
  }
  getSeperableBlurMaterial(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(0.39894 * Math.exp(-0.5 * n * n / (e * e)) / e);
    return new st({ defines: { KERNEL_RADIUS: e }, uniforms: { colorTexture: { value: null }, invSize: { value: new Y(0.5, 0.5) }, direction: { value: new Y(0.5, 0.5) }, gaussianCoefficients: { value: t } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}` });
  }
  getCompositeMaterial(e) {
    return new st({ defines: { NUM_MIPS: e }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}` });
  }
}
function rx(i, e) {
  var t = sx();
  return (rx = function(n, r) {
    return t[n -= 218];
  })(i, e);
}
function sx() {
  var i = [`
        uniform float opacity;
        uniform float intensity;
        uniform sampler2D tDiffuse;
        uniform vec3 maskColor;
        uniform float R;
        uniform float sr;
        varying vec2 vUv;
        void main() {
          // 阴影颜色
          vec4 texel = texture2D( tDiffuse, vUv );
          // 距离中心的距离
          float dist = sqrt((vUv.x-0.5)*(vUv.x-0.5)+(vUv.y-0.5)*(vUv.y-0.5));
          // 渐变, sr 是开始黑色参数
          float rr = (sr - smoothstep(R, R + 0.5, dist));
          // 叠加黑色
          texel *= vec4(maskColor * rr * vec3(intensity,intensity,intensity), 1.0);
          gl_FragColor = opacity * texel;
        }
      `, "4918976Wngbma", "3073002PesOMh", "837660JDxkCY", `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
      `, "1903330dHzwRZ", "324549AfatXV", "3488656eBkHhB", "2RSOJKK", "ScreenMaskShader", "370nKuFkj", "Color", "23832DDSMhE", "2331FPLEnv"];
  return (sx = function() {
    return i;
  })();
}
Al.BlurDirectionX = new Y(1, 0), Al.BlurDirectionY = new Y(0, 1), function(i, e) {
  for (var t = rx, n = sx(); ; )
    try {
      if (-parseInt(t(220)) / 1 + parseInt(t(225)) / 2 * (parseInt(t(219)) / 3) + parseInt(t(224)) / 4 + parseInt(t(222)) / 5 + parseInt(t(229)) / 6 * (parseInt(t(230)) / 7) + -parseInt(t(218)) / 8 + -parseInt(t(223)) / 9 * (parseInt(t(227)) / 10) === 813051)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
class vL extends ix {
  constructor() {
    var e = rx;
    super({ name: e(226), uniforms: { tDiffuse: { value: null }, opacity: { value: 1 }, intensity: { value: 1 }, maskColor: { value: new W[e(228)](1, 1, 1) }, R: { value: 0.2 }, sr: { value: 1.2 } }, vertexShader: e(221), fragmentShader: e(231) });
  }
}
const yL = { name: "FXAAShader", uniforms: { tDiffuse: { value: null }, resolution: { value: new Y(1 / 1024, 1 / 512) } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `
		precision highp float;

		uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

		//----------------------------------------------------------------------------------
		// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag
		// SDK Version: v3.00
		// Email:       gameworks@nvidia.com
		// Site:        http://developer.nvidia.com/
		//
		// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
		//
		// Redistribution and use in source and binary forms, with or without
		// modification, are permitted provided that the following conditions
		// are met:
		//  * Redistributions of source code must retain the above copyright
		//    notice, this list of conditions and the following disclaimer.
		//  * Redistributions in binary form must reproduce the above copyright
		//    notice, this list of conditions and the following disclaimer in the
		//    documentation and/or other materials provided with the distribution.
		//  * Neither the name of NVIDIA CORPORATION nor the names of its
		//    contributors may be used to endorse or promote products derived
		//    from this software without specific prior written permission.
		//
		// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
		// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
		// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
		// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
		// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		//
		//----------------------------------------------------------------------------------

		#ifndef FXAA_DISCARD
			//
			// Only valid for PC OpenGL currently.
			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
			//
			// 1 = Use discard on pixels which don't need AA.
			//     For APIs which enable concurrent TEX+ROP from same surface.
			// 0 = Return unchanged color on pixels which don't need AA.
			//
			#define FXAA_DISCARD 0
		#endif

		/*--------------------------------------------------------------------------*/
		#define FxaaTexTop(t, p) texture2D(t, p, -100.0)
		#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)
		/*--------------------------------------------------------------------------*/

		#define NUM_SAMPLES 5

		// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha
		float contrast( vec4 a, vec4 b ) {
			vec4 diff = abs( a - b );
			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );
		}

		/*============================================================================

									FXAA3 QUALITY - PC

		============================================================================*/

		/*--------------------------------------------------------------------------*/
		vec4 FxaaPixelShader(
			vec2 posM,
			sampler2D tex,
			vec2 fxaaQualityRcpFrame,
			float fxaaQualityEdgeThreshold,
			float fxaaQualityinvEdgeThreshold
		) {
			vec4 rgbaM = FxaaTexTop(tex, posM);
			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);
			// . S .
			// W M E
			// . N .

			bool earlyExit = max( max( max(
					contrast( rgbaM, rgbaN ),
					contrast( rgbaM, rgbaS ) ),
					contrast( rgbaM, rgbaE ) ),
					contrast( rgbaM, rgbaW ) )
					< fxaaQualityEdgeThreshold;
			// . 0 .
			// 0 0 0
			// . 0 .

			#if (FXAA_DISCARD == 1)
				if(earlyExit) FxaaDiscard;
			#else
				if(earlyExit) return rgbaM;
			#endif

			float contrastN = contrast( rgbaM, rgbaN );
			float contrastS = contrast( rgbaM, rgbaS );
			float contrastE = contrast( rgbaM, rgbaE );
			float contrastW = contrast( rgbaM, rgbaW );

			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );
			relativeVContrast *= fxaaQualityinvEdgeThreshold;

			bool horzSpan = relativeVContrast > 0.;
			// . 1 .
			// 0 0 0
			// . 1 .

			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar
			if( abs( relativeVContrast ) < .3 ) {
				// locate the edge
				vec2 dirToEdge;
				dirToEdge.x = contrastE > contrastW ? 1. : -1.;
				dirToEdge.y = contrastS > contrastN ? 1. : -1.;
				// . 2 .      . 1 .
				// 1 0 2  ~=  0 0 1
				// . 1 .      . 0 .

				// tap 2 pixels and see which ones are "outside" the edge, to
				// determine if the edge is vertical or horizontal

				vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);
				float matchAlongH = contrast( rgbaM, rgbaAlongH );
				// . 1 .
				// 0 0 1
				// . 0 H

				vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);
				float matchAlongV = contrast( rgbaM, rgbaAlongV );
				// V 1 .
				// 0 0 1
				// . 0 .

				relativeVContrast = matchAlongV - matchAlongH;
				relativeVContrast *= fxaaQualityinvEdgeThreshold;

				if( abs( relativeVContrast ) < .3 ) { // 45 deg edge
					// 1 1 .
					// 0 0 1
					// . 0 1

					// do a simple blur
					return mix(
						rgbaM,
						(rgbaN + rgbaS + rgbaE + rgbaW) * .25,
						.4
					);
				}

				horzSpan = relativeVContrast > 0.;
			}

			if(!horzSpan) rgbaN = rgbaW;
			if(!horzSpan) rgbaS = rgbaE;
			// . 0 .      1
			// 1 0 1  ->  0
			// . 0 .      1

			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );
			if(!pairN) rgbaN = rgbaS;

			vec2 offNP;
			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;

			bool doneN = false;
			bool doneP = false;

			float nDist = 0.;
			float pDist = 0.;

			vec2 posN = posM;
			vec2 posP = posM;

			int iterationsUsed = 0;
			int iterationsUsedN = 0;
			int iterationsUsedP = 0;
			for( int i = 0; i < NUM_SAMPLES; i++ ) {
				iterationsUsed = i;

				float increment = float(i + 1);

				if(!doneN) {
					nDist += increment;
					posN = posM + offNP * nDist;
					vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);
					doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );
					iterationsUsedN = i;
				}

				if(!doneP) {
					pDist += increment;
					posP = posM - offNP * pDist;
					vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);
					doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );
					iterationsUsedP = i;
				}

				if(doneN || doneP) break;
			}


			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge

			float dist = min(
				doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,
				doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.
			);

			// hacky way of reduces blurriness of mostly diagonal edges
			// but reduces AA quality
			dist = pow(dist, .5);

			dist = 1. - dist;

			return mix(
				rgbaM,
				rgbaN,
				dist * .5
			);
		}

		void main() {
			const float edgeDetectionQuality = .2;
			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;

			gl_FragColor = FxaaPixelShader(
				vUv,
				tDiffuse,
				resolution,
				edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard
				invEdgeDetectionQuality
			);

		}
	` }, zd = { name: "SAOShader", defines: { NUM_SAMPLES: 7, NUM_RINGS: 4, DIFFUSE_TEXTURE: 0, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, tDiffuse: { value: null }, tNormal: { value: null }, size: { value: new Y(512, 512) }, cameraNear: { value: 1 }, cameraFar: { value: 100 }, cameraProjectionMatrix: { value: new fe() }, cameraInverseProjectionMatrix: { value: new fe() }, scale: { value: 1 }, intensity: { value: 0.1 }, bias: { value: 0.5 }, minResolution: { value: 0 }, kernelRadius: { value: 100 }, randomSeed: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `
		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform highp sampler2D tDepth;
		uniform highp sampler2D tNormal;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			return texture2D( tDepth, screenPosition ).x;
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}` }, ts = { name: "DepthLimitedBlurShader", defines: { KERNEL_RADIUS: 4, DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDiffuse: { value: null }, size: { value: new Y(512, 512) }, sampleUvOffsets: { value: [new Y(0, 0)] }, sampleWeights: { value: [1] }, tDepth: { value: null }, cameraNear: { value: 10 }, cameraFar: { value: 1e3 }, depthCutoff: { value: 10 } }, vertexShader: `

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}` }, Hp = { createSampleWeights: function(i, e) {
  const t = [];
  for (let n = 0; n <= i; n++)
    t.push(_L(n, e));
  return t;
}, createSampleOffsets: function(i, e) {
  const t = [];
  for (let n = 0; n <= i; n++)
    t.push(e.clone().multiplyScalar(n));
  return t;
}, configure: function(i, e, t, n) {
  i.defines.KERNEL_RADIUS = e, i.uniforms.sampleUvOffsets.value = Hp.createSampleOffsets(e, n), i.uniforms.sampleWeights.value = Hp.createSampleWeights(e, t), i.needsUpdate = !0;
} };
function _L(i, e) {
  return Math.exp(-i * i / (e * e * 2)) / (Math.sqrt(2 * Math.PI) * e);
}
class Uh extends Vr {
  constructor(e, t, n = new Y(256, 256)) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.originalClearColor = new ce(), this._oldClearColor = new ce(), this.oldClearAlpha = 1, this.params = { output: 0, saoBias: 0.5, saoIntensity: 0.18, saoScale: 1, saoKernelRadius: 100, saoMinResolution: 0, saoBlur: !0, saoBlurRadius: 8, saoBlurStdDev: 4, saoBlurDepthCutoff: 0.01 }, this.resolution = new Y(n.x, n.y), this.saoRenderTarget = new dt(this.resolution.x, this.resolution.y, { type: Vt }), this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
    const r = new Bh();
    r.format = xs, r.type = _s, this.normalRenderTarget = new dt(this.resolution.x, this.resolution.y, { minFilter: lt, magFilter: lt, type: Vt, depthTexture: r }), this.normalMaterial = new cf(), this.normalMaterial.blending = 0, this.saoMaterial = new st({ defines: Object.assign({}, zd.defines), fragmentShader: zd.fragmentShader, vertexShader: zd.vertexShader, uniforms: rn.clone(zd.uniforms) }), this.saoMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.saoMaterial.uniforms.tDepth.value = r, this.saoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.saoMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.saoMaterial.uniforms.cameraProjectionMatrix.value = this.camera.projectionMatrix, this.saoMaterial.blending = 0, this.vBlurMaterial = new st({ uniforms: rn.clone(ts.uniforms), defines: Object.assign({}, ts.defines), vertexShader: ts.vertexShader, fragmentShader: ts.fragmentShader }), this.vBlurMaterial.defines.DEPTH_PACKING = 0, this.vBlurMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.vBlurMaterial.uniforms.tDiffuse.value = this.saoRenderTarget.texture, this.vBlurMaterial.uniforms.tDepth.value = r, this.vBlurMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.vBlurMaterial.blending = 0, this.hBlurMaterial = new st({ uniforms: rn.clone(ts.uniforms), defines: Object.assign({}, ts.defines), vertexShader: ts.vertexShader, fragmentShader: ts.fragmentShader }), this.hBlurMaterial.defines.DEPTH_PACKING = 0, this.hBlurMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.hBlurMaterial.uniforms.tDiffuse.value = this.blurIntermediateRenderTarget.texture, this.hBlurMaterial.uniforms.tDepth.value = r, this.hBlurMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.hBlurMaterial.blending = 0, this.materialCopy = new st({ uniforms: rn.clone(kr.uniforms), vertexShader: kr.vertexShader, fragmentShader: kr.fragmentShader, blending: 0 }), this.materialCopy.transparent = !0, this.materialCopy.depthTest = !1, this.materialCopy.depthWrite = !1, this.materialCopy.blending = 5, this.materialCopy.blendSrc = 208, this.materialCopy.blendDst = ap, this.materialCopy.blendEquation = Mi, this.materialCopy.blendSrcAlpha = 206, this.materialCopy.blendDstAlpha = ap, this.materialCopy.blendEquationAlpha = Mi, this.fsQuad = new Vl(null);
  }
  render(e, t, n) {
    this.renderToScreen && (this.materialCopy.blending = 0, this.materialCopy.uniforms.tDiffuse.value = n.texture, this.materialCopy.needsUpdate = !0, this.renderPass(e, this.materialCopy, null)), e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
    const r = e.autoClear;
    e.autoClear = !1, this.saoMaterial.uniforms.bias.value = this.params.saoBias, this.saoMaterial.uniforms.intensity.value = this.params.saoIntensity, this.saoMaterial.uniforms.scale.value = this.params.saoScale, this.saoMaterial.uniforms.kernelRadius.value = this.params.saoKernelRadius, this.saoMaterial.uniforms.minResolution.value = this.params.saoMinResolution, this.saoMaterial.uniforms.cameraNear.value = this.camera.near, this.saoMaterial.uniforms.cameraFar.value = this.camera.far;
    const s = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
    this.vBlurMaterial.uniforms.depthCutoff.value = s, this.hBlurMaterial.uniforms.depthCutoff.value = s, this.vBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.vBlurMaterial.uniforms.cameraFar.value = this.camera.far, this.hBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.hBlurMaterial.uniforms.cameraFar.value = this.camera.far, this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius), this.prevStdDev === this.params.saoBlurStdDev && this.prevNumSamples === this.params.saoBlurRadius || (Hp.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Y(0, 1)), Hp.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Y(1, 0)), this.prevStdDev = this.params.saoBlurStdDev, this.prevNumSamples = this.params.saoBlurRadius), this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 7829503, 1), this.renderPass(e, this.saoMaterial, this.saoRenderTarget, 16777215, 1), this.params.saoBlur && (this.renderPass(e, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1), this.renderPass(e, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1));
    const a = this.materialCopy;
    this.params.output === Uh.OUTPUT.Normal ? (this.materialCopy.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.materialCopy.needsUpdate = !0) : (this.materialCopy.uniforms.tDiffuse.value = this.saoRenderTarget.texture, this.materialCopy.needsUpdate = !0), this.params.output === Uh.OUTPUT.Default ? a.blending = 5 : a.blending = 0, this.renderPass(e, a, this.renderToScreen ? null : n), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = r;
  }
  renderPass(e, t, n, r, s) {
    e.getClearColor(this.originalClearColor);
    const a = e.getClearAlpha(), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.fsQuad.material = t, this.fsQuad.render(e), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  renderOverride(e, t, n, r, s) {
    e.getClearColor(this.originalClearColor);
    const a = e.getClearAlpha(), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, r = t.clearColor || r, s = t.clearAlpha || s, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.scene.overrideMaterial = t, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  setSize(e, t) {
    this.saoRenderTarget.setSize(e, t), this.blurIntermediateRenderTarget.setSize(e, t), this.normalRenderTarget.setSize(e, t), this.saoMaterial.uniforms.size.value.set(e, t), this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.saoMaterial.uniforms.cameraProjectionMatrix.value = this.camera.projectionMatrix, this.saoMaterial.needsUpdate = !0, this.vBlurMaterial.uniforms.size.value.set(e, t), this.vBlurMaterial.needsUpdate = !0, this.hBlurMaterial.uniforms.size.value.set(e, t), this.hBlurMaterial.needsUpdate = !0;
  }
  dispose() {
    this.saoRenderTarget.dispose(), this.blurIntermediateRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.normalMaterial.dispose(), this.saoMaterial.dispose(), this.vBlurMaterial.dispose(), this.hBlurMaterial.dispose(), this.materialCopy.dispose(), this.fsQuad.dispose();
  }
}
Uh.OUTPUT = { Default: 0, SAO: 1, Normal: 2 };
const tr = { name: "SSRShader", defines: { MAX_STEP: 0, PERSPECTIVE_CAMERA: !0, DISTANCE_ATTENUATION: !0, FRESNEL: !0, INFINITE_THICK: !1, SELECTIVE: !1 }, uniforms: { tDiffuse: { value: null }, tNormal: { value: null }, tMetalness: { value: null }, tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null }, resolution: { value: new Y() }, cameraProjectionMatrix: { value: new fe() }, cameraInverseProjectionMatrix: { value: new fe() }, opacity: { value: 0.5 }, maxDistance: { value: 180 }, cameraRange: { value: 0 }, thickness: { value: 0.018 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float thickness;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef PERSPECTIVE_CAMERA
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef SELECTIVE
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef PERSPECTIVE_CAMERA
				vec3 viewIncidentDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#else
				vec3 viewIncidentDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef PERSPECTIVE_CAMERA
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<float(MAX_STEP);i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef PERSPECTIVE_CAMERA
					// https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
				#endif

				// if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
				// https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
				if(viewReflectRayZ<=vZ){

					bool hit;
					#ifdef INFINITE_THICK
						hit=true;
					#else
						float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

						float minThickness;
						vec2 xyNeighbor=xy;
						xyNeighbor.x+=1.;
						vec2 uvNeighbor=xyNeighbor/resolution;
						vec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);
						minThickness=vPNeighbor.x-vP.x;
						minThickness*=3.;
						float tk=max(minThickness,thickness);

						hit=away<=tk;
					#endif

					if(hit){
						vec3 vN=getViewNormal( uv );
						if(dot(viewReflectDir,vN)>=0.) continue;
						float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
						if(distance>maxDistance) break;
						float op=opacity;
						#ifdef DISTANCE_ATTENUATION
							float ratio=1.-(distance/maxDistance);
							float attenuation=ratio*ratio;
							op=opacity*attenuation;
						#endif
						#ifdef FRESNEL
							float fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;
							op*=fresnelCoe;
						#endif
						vec4 reflectColor=texture2D(tDiffuse,uv);
						gl_FragColor.xyz=reflectColor.xyz;
						gl_FragColor.a=op;
						break;
					}
				}
			}
		}
	` }, Hd = { name: "SSRDepthShader", defines: { PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `

		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
			gl_FragColor = vec4( vec3( d ), 1.0 );

		}

	` }, ns = { name: "SSRBlurShader", uniforms: { tDiffuse: { value: null }, resolution: { value: new Y() }, opacity: { value: 0.5 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;
		void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

			vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	` };
class Ar extends Vr {
  constructor({ renderer: e, scene: t, camera: n, width: r, height: s, selects: a, bouncing: o = !1, groundReflector: l }) {
    super(), this.width = r !== void 0 ? r : 512, this.height = s !== void 0 ? s : 512, this.clear = !0, this.renderer = e, this.scene = t, this.camera = n, this.groundReflector = l, this.opacity = tr.uniforms.opacity.value, this.output = 0, this.maxDistance = tr.uniforms.maxDistance.value, this.thickness = tr.uniforms.thickness.value, this.tempColor = new ce(), this._selects = a, this.selective = Array.isArray(this._selects), Object.defineProperty(this, "selects", { get() {
      return this._selects;
    }, set(h) {
      this._selects !== h && (this._selects = h, Array.isArray(h) ? (this.selective = !0, this.ssrMaterial.defines.SELECTIVE = !0, this.ssrMaterial.needsUpdate = !0) : (this.selective = !1, this.ssrMaterial.defines.SELECTIVE = !1, this.ssrMaterial.needsUpdate = !0));
    } }), this._bouncing = o, Object.defineProperty(this, "bouncing", { get() {
      return this._bouncing;
    }, set(h) {
      this._bouncing !== h && (this._bouncing = h, this.ssrMaterial.uniforms.tDiffuse.value = h ? this.prevRenderTarget.texture : this.beautyRenderTarget.texture);
    } }), this.blur = !0, this._distanceAttenuation = tr.defines.DISTANCE_ATTENUATION, Object.defineProperty(this, "distanceAttenuation", { get() {
      return this._distanceAttenuation;
    }, set(h) {
      this._distanceAttenuation !== h && (this._distanceAttenuation = h, this.ssrMaterial.defines.DISTANCE_ATTENUATION = h, this.ssrMaterial.needsUpdate = !0);
    } }), this._fresnel = tr.defines.FRESNEL, Object.defineProperty(this, "fresnel", { get() {
      return this._fresnel;
    }, set(h) {
      this._fresnel !== h && (this._fresnel = h, this.ssrMaterial.defines.FRESNEL = h, this.ssrMaterial.needsUpdate = !0);
    } }), this._infiniteThick = tr.defines.INFINITE_THICK, Object.defineProperty(this, "infiniteThick", { get() {
      return this._infiniteThick;
    }, set(h) {
      this._infiniteThick !== h && (this._infiniteThick = h, this.ssrMaterial.defines.INFINITE_THICK = h, this.ssrMaterial.needsUpdate = !0);
    } });
    const c = new Bh();
    c.type = ll, c.minFilter = lt, c.magFilter = lt, this.beautyRenderTarget = new dt(this.width, this.height, { minFilter: lt, magFilter: lt, type: Vt, depthTexture: c, depthBuffer: !0 }), this.prevRenderTarget = new dt(this.width, this.height, { minFilter: lt, magFilter: lt }), this.normalRenderTarget = new dt(this.width, this.height, { minFilter: lt, magFilter: lt, type: Vt }), this.metalnessRenderTarget = new dt(this.width, this.height, { minFilter: lt, magFilter: lt, type: Vt }), this.ssrRenderTarget = new dt(this.width, this.height, { minFilter: lt, magFilter: lt }), this.blurRenderTarget = this.ssrRenderTarget.clone(), this.blurRenderTarget2 = this.ssrRenderTarget.clone(), this.ssrMaterial = new st({ defines: Object.assign({}, tr.defines, { MAX_STEP: Math.sqrt(this.width * this.width + this.height * this.height) }), uniforms: rn.clone(tr.uniforms), vertexShader: tr.vertexShader, fragmentShader: tr.fragmentShader, blending: 0 }), this.ssrMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.ssrMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.ssrMaterial.defines.SELECTIVE = this.selective, this.ssrMaterial.needsUpdate = !0, this.ssrMaterial.uniforms.tMetalness.value = this.metalnessRenderTarget.texture, this.ssrMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.ssrMaterial.uniforms.cameraNear.value = this.camera.near, this.ssrMaterial.uniforms.cameraFar.value = this.camera.far, this.ssrMaterial.uniforms.thickness.value = this.thickness, this.ssrMaterial.uniforms.resolution.value.set(this.width, this.height), this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.normalMaterial = new cf(), this.normalMaterial.blending = 0, this.metalnessOnMaterial = new nn({ color: "white" }), this.metalnessOffMaterial = new nn({ color: "black" }), this.blurMaterial = new st({ defines: Object.assign({}, ns.defines), uniforms: rn.clone(ns.uniforms), vertexShader: ns.vertexShader, fragmentShader: ns.fragmentShader }), this.blurMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.blurMaterial.uniforms.resolution.value.set(this.width, this.height), this.blurMaterial2 = new st({ defines: Object.assign({}, ns.defines), uniforms: rn.clone(ns.uniforms), vertexShader: ns.vertexShader, fragmentShader: ns.fragmentShader }), this.blurMaterial2.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.blurMaterial2.uniforms.resolution.value.set(this.width, this.height), this.depthRenderMaterial = new st({ defines: Object.assign({}, Hd.defines), uniforms: rn.clone(Hd.uniforms), vertexShader: Hd.vertexShader, fragmentShader: Hd.fragmentShader, blending: 0 }), this.depthRenderMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far, this.copyMaterial = new st({ uniforms: rn.clone(kr.uniforms), vertexShader: kr.vertexShader, fragmentShader: kr.fragmentShader, transparent: !0, depthTest: !1, depthWrite: !1, blendSrc: Ua, blendDst: ka, blendEquation: Mi, blendSrcAlpha: Ua, blendDstAlpha: ka, blendEquationAlpha: Mi }), this.fsQuad = new Vl(null), this.originalClearColor = new ce();
  }
  dispose() {
    this.beautyRenderTarget.dispose(), this.prevRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.metalnessRenderTarget.dispose(), this.ssrRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.blurRenderTarget2.dispose(), this.normalMaterial.dispose(), this.metalnessOnMaterial.dispose(), this.metalnessOffMaterial.dispose(), this.blurMaterial.dispose(), this.blurMaterial2.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose(), this.fsQuad.dispose();
  }
  render(e, t) {
    switch (e.setRenderTarget(this.beautyRenderTarget), e.clear(), this.groundReflector && (this.groundReflector.visible = !1, this.groundReflector.doRender(this.renderer, this.scene, this.camera), this.groundReflector.visible = !0), e.render(this.scene, this.camera), this.groundReflector && (this.groundReflector.visible = !1), this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 0, 0), this.selective && this.renderMetalness(e, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0), this.ssrMaterial.uniforms.opacity.value = this.opacity, this.ssrMaterial.uniforms.maxDistance.value = this.maxDistance, this.ssrMaterial.uniforms.thickness.value = this.thickness, this.renderPass(e, this.ssrMaterial, this.ssrRenderTarget), this.blur && (this.renderPass(e, this.blurMaterial, this.blurRenderTarget), this.renderPass(e, this.blurMaterial2, this.blurRenderTarget2)), this.output) {
      case Ar.OUTPUT.Default:
        this.bouncing ? (this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.prevRenderTarget), this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = 1, this.renderPass(e, this.copyMaterial, this.prevRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = this.prevRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t)) : (this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t), this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = 1, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t));
        break;
      case Ar.OUTPUT.SSR:
        this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t), this.bouncing && (this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.prevRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = 1, this.renderPass(e, this.copyMaterial, this.prevRenderTarget));
        break;
      case Ar.OUTPUT.Beauty:
        this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
        break;
      case Ar.OUTPUT.Depth:
        this.renderPass(e, this.depthRenderMaterial, this.renderToScreen ? null : t);
        break;
      case Ar.OUTPUT.Normal:
        this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
        break;
      case Ar.OUTPUT.Metalness:
        this.copyMaterial.uniforms.tDiffuse.value = this.metalnessRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
        break;
      default:
        console.warn("THREE.SSRPass: Unknown output type.");
    }
  }
  renderPass(e, t, n, r, s) {
    this.originalClearColor.copy(e.getClearColor(this.tempColor));
    const a = e.getClearAlpha(this.tempColor), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.fsQuad.material = t, this.fsQuad.render(e), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  renderOverride(e, t, n, r, s) {
    this.originalClearColor.copy(e.getClearColor(this.tempColor));
    const a = e.getClearAlpha(this.tempColor), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, r = t.clearColor || r, s = t.clearAlpha || s, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.scene.overrideMaterial = t, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  renderMetalness(e, t, n, r, s) {
    this.originalClearColor.copy(e.getClearColor(this.tempColor));
    const a = e.getClearAlpha(this.tempColor), o = e.autoClear;
    e.setRenderTarget(n), e.autoClear = !1, r = t.clearColor || r, s = t.clearAlpha || s, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.scene.traverseVisible((l) => {
      l._SSRPassBackupMaterial = l.material, this._selects.includes(l) ? l.material = this.metalnessOnMaterial : l.material = this.metalnessOffMaterial;
    }), e.render(this.scene, this.camera), this.scene.traverseVisible((l) => {
      l.material = l._SSRPassBackupMaterial;
    }), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  setSize(e, t) {
    this.width = e, this.height = t, this.ssrMaterial.defines.MAX_STEP = Math.sqrt(e * e + t * t), this.ssrMaterial.needsUpdate = !0, this.beautyRenderTarget.setSize(e, t), this.prevRenderTarget.setSize(e, t), this.ssrRenderTarget.setSize(e, t), this.normalRenderTarget.setSize(e, t), this.metalnessRenderTarget.setSize(e, t), this.blurRenderTarget.setSize(e, t), this.blurRenderTarget2.setSize(e, t), this.ssrMaterial.uniforms.resolution.value.set(e, t), this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.blurMaterial.uniforms.resolution.value.set(e, t), this.blurMaterial2.uniforms.resolution.value.set(e, t);
  }
}
function xL(i, e, t, n) {
  const r = ir, s = new dL(t), a = t[r(415)]();
  s[r(400)](n.clientWidth, n[r(373)]), s[r(404)](a), s.setRenderWay = function(l = r(409)) {
    const c = r;
    l === c(376) ? this[c(408)] = () => t[c(398)](i, e) : this[c(408)] = () => this[c(398)](), this[c(374)] = l;
  }, s[r(401)] = {}, s[r(394)]();
  const o = new pL(i, e);
  return s[r(383)](o), function(l, c, h) {
    const u = ir, d = new Uh(c, h);
    d[u(380)] = !1, d[u(402)].saoIntensity = 0.01, d[u(402)][u(416)] = 100, l[u(383)](d), l[u(401)][u(387)] = d;
  }(s, i, e), function(l, c) {
    const h = ir, u = new Al(new Y(c[h(417)], c[h(373)]), 1.5, 0.4, 0.85);
    u[h(380)] = !1, l[h(383)](u), l[h(401)].unrealBloomPass = u;
  }(s, n), function(l, c, h, u, d) {
    const p = ir, f = new Ar({ renderer: l, scene: c, camera: h, width: d[p(417)], height: d[p(373)], selects: c[p(386)] });
    f.thickness = 0.018, f[p(379)] = !1, f.maxDistance = 0.01, f[p(378)] = 0.5, f.enabled = !1, u[p(383)](f), u[p(401)][p(410)] = f;
  }(t, i, e, s, n), function(l, c, h, u) {
    const d = ir, p = new ps(new W[d(411)](u.clientWidth, u[d(373)]), c, h);
    p[d(391)] = !0, p[d(406)] = 3, p[d(389)] = 0, p.edgeThickness = 1, p[d(382)] = 0, p.usePatternTexture = !1, p[d(403)].set(16449071), p[d(372)][d(371)](16449071), p[d(405)][d(413)] = W[d(399)], p[d(405)][d(407)] = e1, l[d(383)](p), l[d(401)].outlinePass = p;
  }(s, i, e, n), function(l) {
    const c = new mL();
    l.addPass(c), l.effectPass.outputPass = c;
  }(s), function(l, c, h) {
    const u = ir, d = new ix(yL);
    d.multPixel = 1, d.resize = function() {
      const p = ir;
      d[p(375)][p(381)].resolution.value.x = d.multPixel / (c[p(417)] * h), d[p(375)][p(381)][p(396)].value.y = d[p(392)] / (c[p(373)] * h);
    }, d[u(390)](), l.addPass(d), l.effectPass[u(412)] = d;
  }(s, n, a), function(l) {
    const c = ir, h = new vL();
    h[c(380)] = !1, l[c(383)](h), l[c(401)].screenMaskPass = h;
  }(s), s[r(390)] = function() {
    const l = r, { unrealBloomPass: c, fxaaPass: h } = s[l(401)];
    s[l(400)](n[l(417)], n[l(373)]), c.setSize(n[l(417)], n[l(373)]), h[l(390)]();
  }, s;
}
function ir(i, e) {
  const t = ax();
  return (ir = function(n, r) {
    return t[n -= 369];
  })(i, e);
}
function ax() {
  const i = ["enabled", "uniforms", "pulsePeriod", "addPass", "153168DeKliS", "1299006IFQsbM", "ssrList", "saoPass", "304324GpfmdZ", "edgeGlow", "resize", "renderToScreen", "multPixel", "5ybtzhF", "setRenderWay", "270926TpbOZU", "resolution", "9JSXudl", "render", "CustomBlending", "setSize", "effectPass", "params", "visibleEdgeColor", "setPixelRatio", "overlayMaterial", "edgeStrength", "blendSrc", "effectComposerRender", "效果渲染", "ssrPass", "Vector2", "fxaaPass", "blending", "3698648YmyguE", "getPixelRatio", "saoScale", "clientWidth", "3rtvFWU", "11150660bMwOWt", "set", "hiddenEdgeColor", "clientHeight", "renderWay", "material", "源渲染", "2361016yKbdVH", "opacity", "infiniteThick"];
  return (ax = function() {
    return i;
  })();
}
function Gp(i, e) {
  const t = ox();
  return (Gp = function(n, r) {
    return t[n -= 154];
  })(i, e);
}
function ox() {
  const i = ["7595370IOEYFd", "shaderFrames", "clientHeight", "clientWidth", "8oVOMHe", "iResolution", "forEach", "157505GyNiDM", "143002TWVOUI", "fps", "render", "1454121iRwLuR", "value", "update", "dispose", "1330488vMjVQZ", "sceneParams", "4UsOvEH", "renderFrames", "4996523sqbUmO", "resize", "setSize", "removeChild", "uniforms", "Vector2", "4983448isRSuG", "length", "effectComposerRender"];
  return (ox = function() {
    return i;
  })();
}
function bL(i, e = {}) {
  const t = Gp, n = J6(), r = function(v, m) {
    const y = Q_, g = new jt(50, m.clientWidth / m[y(254)], 0.1, 1e5);
    return g[y(251)].set(10, 10, 10), g[y(255)] = y(249), v[y(246)](g), g;
  }(n, i), s = function({ webglRenderParams: v, pixelRatio: m }, y) {
    const g = $_, _ = new W[g(470)](Ee({ antialias: !0, alpha: !0, logarithmicDepthBuffer: !0 }, v));
    return _.setSize(y[g(480)], y[g(471)]), _[g(469)](m || window[g(474)]), y[g(472)](_[g(483)]), _;
  }(e, i), a = function(v, m) {
    const y = zp, g = new eL(v, m[y(439)]);
    return g.enableDamping = !0, g[y(450)] = 0.05, g[y(456)] = 0.01, g[y(442)] = 1e6, g.maxPolarAngle = Math.PI, g;
  }(r, s), o = function(v, m, y, g) {
    const _ = zp, x = new tL(m, y[_(439)]);
    v[_(435)] = x, x[_(444)] = _(447), x[_(455)]((b) => b[_(452)] = !0), v[_(441)](x);
    const M = new W[_(454)]();
    return x[_(448)](_(458), (b) => {
      var T;
      const w = _;
      g.enabled = !b[w(445)], x.drag_change_callback(b[w(445)]), (T = x[w(436)]) == null || T.call(x, b[w(445)]);
    }), x[_(448)]("change", () => {
      var w;
      const b = _;
      x[b(440)] && (["Group", "Mesh"][b(449)]((w = x == null ? void 0 : x[b(453)]) == null ? void 0 : w.type) ? (x[b(440)][b(438)] = M[b(432)](x[b(453)]), x.box3Helper[b(451)] = !0) : x.box3Helper[b(451)] = !1);
    }), x;
  }(n, r, s, a), l = xL(n, r, s, i), c = function(v) {
    const m = Rp, y = new LC();
    return y[m(162)] = () => {
      const g = m;
      y[g(170)](v[g(157)], v[g(177)]), y[g(180)][g(165)][g(159)] = 0, y[g(180)][g(165)][g(176)] = g(175), y[g(180)][g(165)].top = -v[g(177)] + "px", y[g(180)][g(165)][g(161)] = v.clientHeight + "px", y[g(180)][g(165)][g(179)] = v.clientWidth + "px", y.domElement.style[g(160)] = g(168);
    }, y.reset = () => y[m(180)][m(184)][m(183)]((g) => g[m(182)]()), y[m(162)](), v[m(178)](y[m(180)]), y;
  }(i), h = function(v) {
    const m = Rp, y = new CC();
    return y[m(162)] = () => {
      const g = m;
      y.setSize(v.clientWidth, v[g(177)]), y[g(180)][g(165)][g(159)] = 0, y[g(180)][g(165)][g(176)] = g(175), y[g(180)][g(165)][g(167)] = 2 * -v[g(177)] + "px", y[g(180)].style[g(161)] = v[g(177)] + "px", y[g(180)][g(165)][g(179)] = v[g(157)] + "px", y[g(180)][g(165)][g(160)] = g(168);
    }, y[m(173)] = () => y[m(180)].childNodes[m(183)]((g) => g[m(182)]()), y.resize(), v.appendChild(y[m(180)]), y;
  }(i), u = function(v) {
    const m = Bp, y = new Zc();
    return y.setMode(0), y.style = { offsetTop: 0, offsetLeft: 0 }, y[m(338)][m(357)][m(361)] = m(374), y[m(338)][m(357)][m(348)] = "auto", y[m(338)].style[m(366)] = "80px", y[m(338)][m(357)][m(342)] = m(367), y.resize = () => {
      const g = m, { offsetTop: _, offsetLeft: x } = y[g(357)];
      y[g(338)][g(357)][g(371)] = _ - 3 * v[g(381)]().height + "px", y[g(338)][g(357)].left = x + "px";
    }, y[m(368)](), y[m(382)] = (g, _) => {
      const x = m;
      y.style.offsetTop = g, y[x(357)].offsetLeft = _, y[x(368)]();
    }, y[m(355)] = !1, y[m(356)] = 0, y[m(347)] = () => !v[m(354)](y[m(338)]) && v[m(362)](y[m(338)]), y[m(352)] = () => v[m(354)](y[m(338)]) && v[m(353)](y[m(338)]), y;
  }(i), d = K6({ scene: n, camera: r, renderer: s, controls: a, transformControls: o, effectComposer: l, css3DRender: c, css2DRender: h, stats: u, DOM: i }, e[t(174)]), p = function(v) {
    const m = Bp, y = new W[m(341)]();
    if (!v)
      return (x) => x(y[m(380)]());
    const g = 1 / v;
    let _ = 0;
    return (x) => {
      const M = y[m(380)]();
      _ += M, _ > g && (x(M), _ = 0);
    };
  }(e[t(167)]);
  let f = null;
  return function v() {
    p(() => {
      const m = Gp;
      u[m(171)](), a.update(), n[m(176)](), l[m(157)](), c[m(168)](n, r), h.render(n, r);
    }), f = requestAnimationFrame(v);
  }(), Ee({ scene: n, camera: r, renderer: s, controls: a, transformControls: o, effectComposer: l, css3DRender: c, css2DRender: h, stats: u, DOM: i, renderSceneResize: function() {
    const v = t;
    r.aspect = i.clientWidth / i.clientHeight, r.updateProjectionMatrix(), s[v(179)](i[v(161)], i[v(160)]), l[v(178)](), n[v(159)][v(164)]((m) => m[v(181)][v(163)] && (m.uniforms[v(163)][v(170)] = new W[v(154)](i[v(161)], i.clientHeight))), c.resize(), h[v(178)](), u[v(178)]();
  }, destroySceneRender: function() {
    const v = t;
    cancelAnimationFrame(f), e4(n), s[v(172)]();
    for (let m in this)
      delete this[m];
    for (; i.children[v(156)]; )
      i[v(180)](i.firstChild);
    (function() {
      const m = Nf, y = document.body[m(186)](m(181));
      for (let g = y.length - 1; g >= 0; g--)
        y[g][m(183)][m(187)](y[g]);
    })();
  } }, d);
}
function kh(i, e) {
  const t = lx();
  return (kh = function(n, r) {
    return t[n -= 197];
  })(i, e);
}
function ML(i, e, t) {
  var y, g;
  const n = kh, { scene: r, camera: s, handler: a, drawCore: o, transformControls: l, effectComposer: c, GUI: h } = i, { outlinePass: u } = c[n(216)];
  l[n(207)]();
  const d = function(_, x, M) {
    const b = kh, { raycaster: w } = M;
    return w[b(224)](_, x), w.intersectObjects(M[b(197)]).filter((T) => !T[b(220)][b(209)] && T[b(220)][b(228)] && T.object[b(212)]);
  }(D4(e), s, r)[n(214)]((_) => _[n(220)][n(212)] && Ab(_[n(220)])[n(212)]);
  if (!d)
    return;
  const { object: p, point: f } = d, v = Ab(p);
  switch (a[n(210)]) {
    case "变换":
      u[n(206)] = [], a[n(213)] ? l[n(226)](p) : l[n(226)](v);
      break;
    case "选择":
      u[n(206)] = [p], a[n(200)] && ((y = h == null ? void 0 : h[n(203)]) == null || y.call(h, p));
      break;
    case "根选择":
      u[n(206)] = [v], a[n(200)] && ((g = h == null ? void 0 : h[n(203)]) == null || g.call(h, v));
      break;
    case n(222):
      o[n(201)](f, p);
    case n(205):
  }
  const m = { currentModel: p, currentRootModel: v, point: f, mode: a[n(210)] };
  i.currentInfo = m, a[n(217)] = m, t(m);
}
function lx() {
  const i = ["setFromCamera", "1178256cbsoRW", "attach", "9380ttOdif", "isMesh", "children", "1643118igBZbn", "intersectObjects", "selectPanelEnable", "sceneEventCall", "27126NsmlMY", "createSelectPanel", "477070KfReey", "点击信息", "selectedObjects", "detach", "1996LGMQNs", "isTransformControls", "mode", "2PTyQmE", "visible", "isTransformChildren", "find", "80MAvHvv", "effectPass", "currentInfo", "7281HjUmvk", "1099JdsAti", "object", "18EVPxUQ", "场景绘制", "7836288DmIjkb"];
  return (lx = function() {
    return i;
  })();
}
function Ff(i, e) {
  const t = cx();
  return (Ff = function(n, r) {
    return t[n -= 448];
  })(i, e);
}
Ar.OUTPUT = { Default: 0, SSR: 1, Beauty: 3, Depth: 4, Normal: 5, Metalness: 7 }, function(i, e) {
  const t = ir, n = ax();
  for (; ; )
    try {
      if (-parseInt(t(384)) / 1 + parseInt(t(395)) / 2 * (-parseInt(t(369)) / 3) + parseInt(t(388)) / 4 + -parseInt(t(393)) / 5 * (-parseInt(t(385)) / 6) + -parseInt(t(377)) / 7 + -parseInt(t(414)) / 8 * (parseInt(t(397)) / 9) + parseInt(t(370)) / 10 === 319398)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = Gp, n = ox();
  for (; ; )
    try {
      if (-parseInt(t(175)) / 1 * (parseInt(t(166)) / 2) + parseInt(t(173)) / 3 + -parseInt(t(155)) / 4 + -parseInt(t(165)) / 5 + parseInt(t(158)) / 6 + parseInt(t(177)) / 7 * (parseInt(t(162)) / 8) + -parseInt(t(169)) / 9 === 698244)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}(), function(i, e) {
  const t = kh, n = lx();
  for (; ; )
    try {
      if (-parseInt(t(218)) / 1 * (parseInt(t(211)) / 2) + -parseInt(t(198)) / 3 + parseInt(t(208)) / 4 * (-parseInt(t(227)) / 5) + parseInt(t(202)) / 6 * (parseInt(t(219)) / 7) + parseInt(t(225)) / 8 * (parseInt(t(221)) / 9) + -parseInt(t(215)) / 10 * (-parseInt(t(204)) / 11) + parseInt(t(223)) / 12 === 513234)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
}();
const Yt = Ff;
function cx() {
  const i = ["domElement", "outlinePass", "effectComposer", "813717TKfGuN", "getSceneEvent", "scene", "8tiDHnN", "styleOverrides", "render", "1249998ZeZNUv", "setOutlinePass", "5ZWWjTk", "setLight", "commonFrames", "isCurveMesh", "destroy", "modelCore", "add", "482972ckPDSH", "remove", "257272qWjPXb", "dracoPath", "452208wezGIW", "pointerEvents", "curvePath", "toDataURL", "setModelAnimationPlay", "renderer", "modelAnimationPlay", "457580QErHdU", "position", "auto", "3408209PgiyIF", "parameters", "/draco/", "animationPlayParams", "setCss2dDOM", "map", "getSceneEditorImage", "assign", "target", "getSceneCurveList", "setCss3dDOM", "style", "camera", "6rCfyqJ", "filter", "selectedObjects"];
  return (cx = function() {
    return i;
  })();
}
(function(i, e) {
  const t = Ff, n = cx();
  for (; ; )
    try {
      if (-parseInt(t(493)) / 1 + parseInt(t(449)) / 2 + parseInt(t(472)) / 3 * (-parseInt(t(495)) / 4) + parseInt(t(486)) / 5 * (parseInt(t(484)) / 6) + parseInt(t(459)) / 7 * (parseInt(t(481)) / 8) + -parseInt(t(478)) / 9 + parseInt(t(456)) / 10 === 265061)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})();
var wL, SL;
class Q0 {
  constructor(...e) {
    Object[Ff(466)](this, bL(...e));
  }
  [(wL = Yt(448), SL = Yt(482), Yt(463))](e, t) {
    const n = Yt;
    e[n(470)][n(450)] = n(458);
    const { scene: r } = this, s = new GS(e);
    return s[n(457)].copy(t), r[n(492)](s), s[n(490)] = () => r[n(494)](s), s;
  }
  [Yt(469)](e, t) {
    const n = Yt, { scene: r } = this, s = new VS(e);
    return s.position.copy(t), r[n(492)](s), s[n(490)] = () => r[n(494)](s), s;
  }
  [Yt(487)](...e) {
    const t = Yt, n = Vy(...e);
    return n.target && this[t(480)][t(492)](n[t(467)]), this[t(480)].add(n), n;
  }
  [Yt(479)](e, t) {
    ML(this, e, (n) => t == null ? void 0 : t(n));
  }
  getRawSceneEvent() {
    return function(e) {
      const t = new D1();
      return { raycaster: t, getIntersects: (n, r) => {
        const s = kh;
        return t[s(224)](D4(n), e), t[s(199)](r);
      } };
    }(this[Yt(471)]);
  }
  [Yt(485)](e = []) {
    const t = Yt;
    return this.effectComposer.effectPass[t(476)][t(474)] = e;
  }
  [Yt(465)](e) {
    const t = Yt;
    return this.renderer.render(this[t(480)], this[t(471)]), this[t(477)][t(483)](), this[t(454)][t(475)][t(452)](...e);
  }
  [Yt(453)](e) {
    const t = Yt;
    if (e != null && e[t(462)])
      return this[t(491)][t(455)](e, e[t(462)]);
  }
  [Yt(468)]() {
    const e = Yt;
    return this[e(480)].children[e(473)]((t) => t[e(489)])[e(464)]((t) => {
      var n, r;
      return { path: t[e(451)] || ((r = (n = t.geometry) == null ? void 0 : n[e(460)]) == null ? void 0 : r.path), mesh: t };
    });
  }
  setCurveAnimation(e, t = 1) {
    const n = Yt;
    if (e)
      return function(r, s = 1, a) {
        const o = Dh;
        return { id: Date[o(245)](), curve: r, time: 0, pause: !1, speed: s, start: function() {
          const l = o;
          a[l(244)](this) > -1 || (a[l(233)](this), this.pause = !1);
        }, destroy: function() {
          const l = o, c = a[l(244)](this);
          c > -1 && a.splice(c, 1), delete this[l(238)], delete this[l(229)];
        }, frameCallback: null, frameEndCallback: null, commonAnimateRender: function() {
          var c, h;
          const l = o;
          if (!this[l(246)]) {
            if (this.time += this[l(231)] / 1e3, this[l(239)] > 1 || this[l(239)] < 0)
              return this[l(239)] = this.time > 1 ? 1 : 0, this.pause = !0, (c = this.frameEndCallback) == null ? void 0 : c.call(this, l(223));
            (h = this[l(236)]) == null || h.call(this, this[l(235)].getPointAt(this.time));
          }
        } };
      }(e, t, this[n(480)][n(488)]);
  }
}
Wf(Q0, wL, Yt(461)), Wf(Q0, SL, Rh);
var LM = hx;
function hx(i, e) {
  var t = ux();
  return (hx = function(n, r) {
    return t[n -= 258];
  })(i, e);
}
function ux() {
  var i = ["68296txUgHY", "117980ILUYuo", "12753670EmEgkc", "50VqvQpp", "264pfKOAl", "18BMxBTs", "log", `欢迎使用THREE-EDITOR, 本产品永久免费使用。 
Copyright (c) threehub.cn email:2586300277@qq.com All rights reserved. 
不想显示这个提示请手动删除！`, "1000755iieLOm", "11qYGNRU", "5028DfYDsY", "239164dtXAhi", "672132tfPMgl"];
  return (ux = function() {
    return i;
  })();
}
(function(i, e) {
  for (var t = hx, n = ux(); ; )
    try {
      if (parseInt(t(267)) / 1 + parseInt(t(270)) / 2 * (-parseInt(t(263)) / 3) + parseInt(t(264)) / 4 * (-parseInt(t(269)) / 5) + -parseInt(t(265)) / 6 + -parseInt(t(261)) / 7 + -parseInt(t(266)) / 8 * (parseInt(t(258)) / 9) + -parseInt(t(268)) / 10 * (-parseInt(t(262)) / 11) === 302144)
        break;
      n.push(n.shift());
    } catch (r) {
      n.push(n.shift());
    }
})(), console[LM(259)](LM(260));
export {
  GS as CSS2DObject,
  VS as CSS3DObject,
  W as THREE,
  Q0 as ThreeEditor,
  RL as cloneObjectMaterial,
  QC as createCanvasText,
  Np as createGsapAnimation,
  PL as createMesh,
  DL as createSpriteText,
  To as dat,
  IL as getDirectionQuaternion,
  EL as getDistanceScalePoint,
  pf as getGeometry,
  Si as getMaterial,
  DC as getObjectBox3,
  NC as getObjectViews,
  Z1 as gsap,
  CL as objectChangeMaterial,
  LL as objectChangeTransform,
  zn as proj4,
  $S as setGsapMeshAction,
  AL as syncVectorTransform
};
