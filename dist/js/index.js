var fw = Object.defineProperty, mw = Object.defineProperties;
var gw = Object.getOwnPropertyDescriptors;
var q0 = Object.getOwnPropertySymbols;
var vw = Object.prototype.hasOwnProperty, yw = Object.prototype.propertyIsEnumerable;
var Y0 = Math.pow, cp = (n, e, t) => e in n ? fw(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Te = (n, e) => {
  for (var t in e || (e = {}))
    vw.call(e, t) && cp(n, t, e[t]);
  if (q0)
    for (var t of q0(e))
      yw.call(e, t) && cp(n, t, e[t]);
  return n;
}, $t = (n, e) => mw(n, gw(e));
var up = (n, e, t) => (cp(n, typeof e != "symbol" ? e + "" : e, t), t);
var li = (n, e, t) => new Promise((i, r) => {
  var s = (l) => {
    try {
      o(t.next(l));
    } catch (h) {
      r(h);
    }
  }, a = (l) => {
    try {
      o(t.throw(l));
    } catch (h) {
      r(h);
    }
  }, o = (l) => l.done ? i(l.value) : Promise.resolve(l.value).then(s, a);
  o((t = t.apply(n, e)).next());
});
const Hu = "165", Ys = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Zs = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, yd = 1, pg = 2, Ri = 3, Mi = 0, Tn = 1, bt = 2, Ar = 2, Ro = 5, $n = 100, xw = 101, Mw = 102, Io = 200, kh = 201, xd = 202, Md = 203, us = 204, ds = 205, zh = 206, bd = 207, Vh = 208, Sd = 209, bw = 210, Sw = 211, ww = 212, _w = 213, Tw = 214, Hh = 0, z1 = 1, V1 = 2, $i = 0, wd = 1, _d = 2, Td = 3, Ed = 4, fg = 5, Ad = 6, mg = 7, Xf = "attached", H1 = "detached", Cd = 300, Cr = 301, ps = 302, Lo = 303, sh = 304, $o = 306, jt = 1e3, vn = 1001, fs = 1002, at = 1003, Pd = 1004, sa = 1005, Vt = 1006, xo = 1007, er = 1008, ba = 1009, No = 1012, gg = 1013, Sa = 1014, ni = 1015, Ht = 1016, vg = 1017, yg = 1018, ms = 1020, yi = 1023, Do = 1026, gs = 1027, xg = 1028, Mg = 1029, bg = 1031, Sg = 1033, Tu = 33776, Eu = 33777, Au = 33778, Cu = 33779, qf = 35840, Yf = 35841, Zf = 35842, Kf = 35843, Jf = 36196, Qf = 37492, $f = 37496, em = 37808, tm = 37809, nm = 37810, im = 37811, rm = 37812, sm = 37813, am = 37814, om = 37815, lm = 37816, hm = 37817, cm = 37818, um = 37819, dm = 37820, pm = 37821, Pu = 36492, fm = 36494, mm = 36495, gm = 36284, vm = 36285, ym = 36286, wg = 2200, _g = 2201, Oo = 2300, Uo = 2301, Ru = 2302, aa = 2400, oa = 2401, ah = 2402, G1 = 2500, Tg = 2501, Eg = 3201, ea = "", mt = "srgb", Jt = "srgb-linear", Rd = "display-p3", Gh = "display-p3-linear", oh = "linear", ft = "srgb", lh = "rec709", hh = "p3", Ks = 7680, Ew = 512, Aw = 513, Cw = 514, Pw = 515, Rw = 516, Iw = 517, Lw = 518, Nw = 519, ch = 35044, xm = "300 es", wa = 2e3, uh = 2001;
class rr {
  addEventListener(e, t) {
    this.M === void 0 && (this.M = {});
    const i = this.M;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this.M === void 0)
      return !1;
    const i = this.M;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this.M === void 0)
      return;
    const i = this.M[e];
    if (i !== void 0) {
      const r = i.indexOf(t);
      r !== -1 && i.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this.M === void 0)
      return;
    const t = this.M[e.type];
    if (t !== void 0) {
      e.target = this;
      const i = t.slice(0);
      for (let r = 0, s = i.length; r < s; r++)
        i[r].call(this, e);
      e.target = null;
    }
  }
}
const xn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Z0 = 1234567;
const ua = Math.PI / 180, Fo = 180 / Math.PI;
function ri() {
  const n = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0;
  return (xn[255 & n] + xn[n >> 8 & 255] + xn[n >> 16 & 255] + xn[n >> 24 & 255] + "-" + xn[255 & e] + xn[e >> 8 & 255] + "-" + xn[e >> 16 & 15 | 64] + xn[e >> 24 & 255] + "-" + xn[63 & t | 128] + xn[t >> 8 & 255] + "-" + xn[t >> 16 & 255] + xn[t >> 24 & 255] + xn[255 & i] + xn[i >> 8 & 255] + xn[i >> 16 & 255] + xn[i >> 24 & 255]).toLowerCase();
}
function Rt(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function Mm(n, e) {
  return (n % e + e) % e;
}
function Wl(n, e, t) {
  return (1 - t) * n + t * e;
}
function Nn(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Oe(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(4294967295 * n);
    case Uint16Array:
      return Math.round(65535 * n);
    case Uint8Array:
      return Math.round(255 * n);
    case Int32Array:
      return Math.round(2147483647 * n);
    case Int16Array:
      return Math.round(32767 * n);
    case Int8Array:
      return Math.round(127 * n);
    default:
      throw new Error("Invalid component type.");
  }
}
const nn = { DEG2RAD: ua, RAD2DEG: Fo, generateUUID: ri, clamp: Rt, euclideanModulo: Mm, mapLinear: function(n, e, t, i, r) {
  return i + (n - e) * (r - i) / (t - e);
}, inverseLerp: function(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}, lerp: Wl, damp: function(n, e, t, i) {
  return Wl(n, e, 1 - Math.exp(-t * i));
}, pingpong: function(n, e = 1) {
  return e - Math.abs(Mm(n, 2 * e) - e);
}, smoothstep: function(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e)) * n * (3 - 2 * n);
}, smootherstep: function(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e)) * n * n * (n * (6 * n - 15) + 10);
}, randInt: function(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}, randFloat: function(n, e) {
  return n + Math.random() * (e - n);
}, randFloatSpread: function(n) {
  return n * (0.5 - Math.random());
}, seededRandom: function(n) {
  n !== void 0 && (Z0 = n);
  let e = Z0 += 1831565813;
  return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296;
}, degToRad: function(n) {
  return n * ua;
}, radToDeg: function(n) {
  return n * Fo;
}, isPowerOfTwo: function(n) {
  return !(n & n - 1) && n !== 0;
}, ceilPowerOfTwo: function(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}, floorPowerOfTwo: function(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}, setQuaternionFromProperEuler: function(n, e, t, i, r) {
  const s = Math.cos, a = Math.sin, o = s(t / 2), l = a(t / 2), h = s((e + i) / 2), c = a((e + i) / 2), u = s((e - i) / 2), d = a((e - i) / 2), p = s((i - e) / 2), m = a((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(o * c, l * u, l * d, o * h);
      break;
    case "YZY":
      n.set(l * d, o * c, l * u, o * h);
      break;
    case "ZXZ":
      n.set(l * u, l * d, o * c, o * h);
      break;
    case "XZX":
      n.set(o * c, l * m, l * p, o * h);
      break;
    case "YXY":
      n.set(l * p, o * c, l * m, o * h);
      break;
    case "ZYZ":
      n.set(l * m, l * p, o * c, o * h);
  }
}, normalize: Oe, denormalize: Nn };
class X {
  constructor(e = 0, t = 0) {
    X.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Rt(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = this.x - e.x, a = this.y - e.y;
    return this.x = s * i - a * r + e.x, this.y = s * r + a * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class De {
  constructor(e, t, i, r, s, a, o, l, h) {
    De.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, a, o, l, h);
  }
  set(e, t, i, r, s, a, o, l, h) {
    const c = this.elements;
    return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = s, c[5] = l, c[6] = i, c[7] = a, c[8] = h, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, a = i[0], o = i[3], l = i[6], h = i[1], c = i[4], u = i[7], d = i[2], p = i[5], m = i[8], g = r[0], f = r[3], v = r[6], y = r[1], x = r[4], M = r[7], b = r[2], S = r[5], w = r[8];
    return s[0] = a * g + o * y + l * b, s[3] = a * f + o * x + l * S, s[6] = a * v + o * M + l * w, s[1] = h * g + c * y + u * b, s[4] = h * f + c * x + u * S, s[7] = h * v + c * M + u * w, s[2] = d * g + p * y + m * b, s[5] = d * f + p * x + m * S, s[8] = d * v + p * M + m * w, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], a = e[4], o = e[5], l = e[6], h = e[7], c = e[8];
    return t * a * c - t * o * h - i * s * c + i * o * l + r * s * h - r * a * l;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], a = e[4], o = e[5], l = e[6], h = e[7], c = e[8], u = c * a - o * h, d = o * l - c * s, p = h * s - a * l, m = t * u + i * d + r * p;
    if (m === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / m;
    return e[0] = u * g, e[1] = (r * h - c * i) * g, e[2] = (o * i - r * a) * g, e[3] = d * g, e[4] = (c * t - r * l) * g, e[5] = (r * s - o * t) * g, e[6] = p * g, e[7] = (i * l - h * t) * g, e[8] = (a * t - i * s) * g, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, r, s, a, o) {
    const l = Math.cos(s), h = Math.sin(s);
    return this.set(i * l, i * h, -i * (l * a + h * o) + a + e, -r * h, r * l, -r * (-h * a + l * o) + o + t, 0, 0, 1), this;
  }
  scale(e, t) {
    return this.premultiply(dp.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(dp.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(dp.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 9; r++)
      if (t[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const dp = new De();
function j1(n) {
  for (let e = n.length - 1; e >= 0; --e)
    if (n[e] >= 65535)
      return !0;
  return !1;
}
const Dw = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
function lo(n, e) {
  return new Dw[n](e);
}
function dh(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function W1() {
  const n = dh("canvas");
  return n.style.display = "block", n;
}
const K0 = {};
function Ag(n) {
  n in K0 || (K0[n] = !0);
}
const J0 = new De().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199), Q0 = new De().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735), sc = { [Jt]: { transfer: oh, primaries: lh, toReference: (n) => n, fromReference: (n) => n }, [mt]: { transfer: ft, primaries: lh, toReference: (n) => n.convertSRGBToLinear(), fromReference: (n) => n.convertLinearToSRGB() }, [Gh]: { transfer: oh, primaries: hh, toReference: (n) => n.applyMatrix3(Q0), fromReference: (n) => n.applyMatrix3(J0) }, [Rd]: { transfer: ft, primaries: hh, toReference: (n) => n.convertSRGBToLinear().applyMatrix3(Q0), fromReference: (n) => n.applyMatrix3(J0).convertLinearToSRGB() } }, Ow = /* @__PURE__ */ new Set([Jt, Gh]), it = { enabled: !0, _: Jt, get workingColorSpace() {
  return this._;
}, set workingColorSpace(n) {
  if (!Ow.has(n))
    throw new Error(`Unsupported working color space, "${n}".`);
  this._ = n;
}, convert: function(n, e, t) {
  if (this.enabled === !1 || e === t || !e || !t)
    return n;
  const i = sc[e].toReference;
  return (0, sc[t].fromReference)(i(n));
}, fromWorkingColorSpace: function(n, e) {
  return this.convert(n, this._, e);
}, toWorkingColorSpace: function(n, e) {
  return this.convert(n, e, this._);
}, getPrimaries: function(n) {
  return sc[n].primaries;
}, getTransfer: function(n) {
  return n === ea ? oh : sc[n].transfer;
} };
function Mo(n) {
  return n < 0.04045 ? 0.0773993808 * n : Math.pow(0.9478672986 * n + 0.0521327014, 2.4);
}
function pp(n) {
  return n < 31308e-7 ? 12.92 * n : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let Da;
class X1 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Da === void 0 && (Da = dh("canvas")), Da.width = e.width, Da.height = e.height;
      const i = Da.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Da;
    }
    return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", 0.6) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && e instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && e instanceof ImageBitmap) {
      const t = dh("canvas");
      t.width = e.width, t.height = e.height;
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height), s = r.data;
      for (let a = 0; a < s.length; a++)
        s[a] = 255 * Mo(s[a] / 255);
      return i.putImageData(r, 0, 0), t;
    }
    if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(255 * Mo(t[i] / 255)) : t[i] = Mo(t[i]);
      return { data: t, width: e.width, height: e.height };
    }
    return e;
  }
}
let Uw = 0;
class ta {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: Uw++ }), this.uuid = ri(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let a = 0, o = r.length; a < o; a++)
          r[a].isDataTexture ? s.push(fp(r[a].image)) : s.push(fp(r[a]));
      } else
        s = fp(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function fp(n) {
  return typeof HTMLImageElement != "undefined" && n instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && n instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && n instanceof ImageBitmap ? X1.getDataURL(n) : n.data ? { data: Array.from(n.data), width: n.width, height: n.height, type: n.data.constructor.name } : {};
}
let Fw = 0;
class pt extends rr {
  constructor(e = pt.DEFAULT_IMAGE, t = pt.DEFAULT_MAPPING, i = vn, r = vn, s = 1006, a = 1008, o = 1023, l = 1009, h = pt.DEFAULT_ANISOTROPY, c = "") {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Fw++ }), this.uuid = ri(), this.name = "", this.source = new ta(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = a, this.anisotropy = h, this.format = o, this.internalFormat = null, this.type = l, this.offset = new X(0, 0), this.repeat = new X(1, 1), this.center = new X(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new De(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Cd)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case jt:
          e.x = e.x - Math.floor(e.x);
          break;
        case vn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case fs:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case jt:
          e.y = e.y - Math.floor(e.y);
          break;
        case vn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case fs:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
pt.DEFAULT_IMAGE = null, pt.DEFAULT_MAPPING = Cd, pt.DEFAULT_ANISOTROPY = 1;
class Ve {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    Ve.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return this.x = e, this.y = t, this.z = i, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = this.w, a = e.elements;
    return this.x = a[0] * t + a[4] * i + a[8] * r + a[12] * s, this.y = a[1] * t + a[5] * i + a[9] * r + a[13] * s, this.z = a[2] * t + a[6] * i + a[10] * r + a[14] * s, this.w = a[3] * t + a[7] * i + a[11] * r + a[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements, h = l[0], c = l[4], u = l[8], d = l[1], p = l[5], m = l[9], g = l[2], f = l[6], v = l[10];
    if (Math.abs(c - d) < 0.01 && Math.abs(u - g) < 0.01 && Math.abs(m - f) < 0.01) {
      if (Math.abs(c + d) < 0.1 && Math.abs(u + g) < 0.1 && Math.abs(m + f) < 0.1 && Math.abs(h + p + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const x = (h + 1) / 2, M = (p + 1) / 2, b = (v + 1) / 2, S = (c + d) / 4, w = (u + g) / 4, T = (m + f) / 4;
      return x > M && x > b ? x < 0.01 ? (i = 0, r = 0.707106781, s = 0.707106781) : (i = Math.sqrt(x), r = S / i, s = w / i) : M > b ? M < 0.01 ? (i = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(M), i = S / r, s = T / r) : b < 0.01 ? (i = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(b), i = w / s, r = T / s), this.set(i, r, s, t), this;
    }
    let y = Math.sqrt((f - m) * (f - m) + (u - g) * (u - g) + (d - c) * (d - c));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (f - m) / y, this.y = (u - g) / y, this.z = (d - c) / y, this.w = Math.acos((h + p + v - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class q1 extends rr {
  constructor(e = 1, t = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Ve(0, 0, e, t), this.scissorTest = !1, this.viewport = new Ve(0, 0, e, t);
    const r = { width: e, height: t, depth: 1 };
    i = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: Vt, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1 }, i);
    const s = new pt(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    s.flipY = !1, s.generateMipmaps = i.generateMipmaps, s.internalFormat = i.internalFormat, this.textures = [];
    const a = i.count;
    for (let o = 0; o < a; o++)
      this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      this.width = e, this.height = t, this.depth = i;
      for (let r = 0, s = this.textures.length; r < s; r++)
        this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let i = 0, r = e.textures.length; i < r; i++)
      this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new ta(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ht extends q1 {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), this.isWebGLRenderTarget = !0;
  }
}
class Gu extends pt {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = at, this.minFilter = at, this.wrapR = vn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class bm extends pt {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = at, this.minFilter = at, this.wrapR = vn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Ye {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    this.isQuaternion = !0, this.N = e, this.I = t, this.U = i, this.O = r;
  }
  static slerpFlat(e, t, i, r, s, a, o) {
    let l = i[r + 0], h = i[r + 1], c = i[r + 2], u = i[r + 3];
    const d = s[a + 0], p = s[a + 1], m = s[a + 2], g = s[a + 3];
    if (o === 0)
      return e[t + 0] = l, e[t + 1] = h, e[t + 2] = c, void (e[t + 3] = u);
    if (o === 1)
      return e[t + 0] = d, e[t + 1] = p, e[t + 2] = m, void (e[t + 3] = g);
    if (u !== g || l !== d || h !== p || c !== m) {
      let f = 1 - o;
      const v = l * d + h * p + c * m + u * g, y = v >= 0 ? 1 : -1, x = 1 - v * v;
      if (x > Number.EPSILON) {
        const b = Math.sqrt(x), S = Math.atan2(b, v * y);
        f = Math.sin(f * S) / b, o = Math.sin(o * S) / b;
      }
      const M = o * y;
      if (l = l * f + d * M, h = h * f + p * M, c = c * f + m * M, u = u * f + g * M, f === 1 - o) {
        const b = 1 / Math.sqrt(l * l + h * h + c * c + u * u);
        l *= b, h *= b, c *= b, u *= b;
      }
    }
    e[t] = l, e[t + 1] = h, e[t + 2] = c, e[t + 3] = u;
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, a) {
    const o = i[r], l = i[r + 1], h = i[r + 2], c = i[r + 3], u = s[a], d = s[a + 1], p = s[a + 2], m = s[a + 3];
    return e[t] = o * m + c * u + l * p - h * d, e[t + 1] = l * m + c * d + h * u - o * p, e[t + 2] = h * m + c * p + o * d - l * u, e[t + 3] = c * m - o * u - l * d - h * p, e;
  }
  get x() {
    return this.N;
  }
  set x(e) {
    this.N = e, this.G();
  }
  get y() {
    return this.I;
  }
  set y(e) {
    this.I = e, this.G();
  }
  get z() {
    return this.U;
  }
  set z(e) {
    this.U = e, this.G();
  }
  get w() {
    return this.O;
  }
  set w(e) {
    this.O = e, this.G();
  }
  set(e, t, i, r) {
    return this.N = e, this.I = t, this.U = i, this.O = r, this.G(), this;
  }
  clone() {
    return new this.constructor(this.N, this.I, this.U, this.O);
  }
  copy(e) {
    return this.N = e.x, this.I = e.y, this.U = e.z, this.O = e.w, this.G(), this;
  }
  setFromEuler(e, t = !0) {
    const i = e.N, r = e.I, s = e.U, a = e.H, o = Math.cos, l = Math.sin, h = o(i / 2), c = o(r / 2), u = o(s / 2), d = l(i / 2), p = l(r / 2), m = l(s / 2);
    switch (a) {
      case "XYZ":
        this.N = d * c * u + h * p * m, this.I = h * p * u - d * c * m, this.U = h * c * m + d * p * u, this.O = h * c * u - d * p * m;
        break;
      case "YXZ":
        this.N = d * c * u + h * p * m, this.I = h * p * u - d * c * m, this.U = h * c * m - d * p * u, this.O = h * c * u + d * p * m;
        break;
      case "ZXY":
        this.N = d * c * u - h * p * m, this.I = h * p * u + d * c * m, this.U = h * c * m + d * p * u, this.O = h * c * u - d * p * m;
        break;
      case "ZYX":
        this.N = d * c * u - h * p * m, this.I = h * p * u + d * c * m, this.U = h * c * m - d * p * u, this.O = h * c * u + d * p * m;
        break;
      case "YZX":
        this.N = d * c * u + h * p * m, this.I = h * p * u + d * c * m, this.U = h * c * m - d * p * u, this.O = h * c * u - d * p * m;
        break;
      case "XZY":
        this.N = d * c * u - h * p * m, this.I = h * p * u - d * c * m, this.U = h * c * m + d * p * u, this.O = h * c * u + d * p * m;
    }
    return t === !0 && this.G(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, r = Math.sin(i);
    return this.N = e.x * r, this.I = e.y * r, this.U = e.z * r, this.O = Math.cos(i), this.G(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], r = t[4], s = t[8], a = t[1], o = t[5], l = t[9], h = t[2], c = t[6], u = t[10], d = i + o + u;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      this.O = 0.25 / p, this.N = (c - l) * p, this.I = (s - h) * p, this.U = (a - r) * p;
    } else if (i > o && i > u) {
      const p = 2 * Math.sqrt(1 + i - o - u);
      this.O = (c - l) / p, this.N = 0.25 * p, this.I = (r + a) / p, this.U = (s + h) / p;
    } else if (o > u) {
      const p = 2 * Math.sqrt(1 + o - i - u);
      this.O = (s - h) / p, this.N = (r + a) / p, this.I = 0.25 * p, this.U = (l + c) / p;
    } else {
      const p = 2 * Math.sqrt(1 + u - i - o);
      this.O = (a - r) / p, this.N = (s + h) / p, this.I = (l + c) / p, this.U = 0.25 * p;
    }
    return this.G(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this.N = -e.y, this.I = e.x, this.U = 0, this.O = i) : (this.N = 0, this.I = -e.z, this.U = e.y, this.O = i)) : (this.N = e.y * t.z - e.z * t.y, this.I = e.z * t.x - e.x * t.z, this.U = e.x * t.y - e.y * t.x, this.O = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Rt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0)
      return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this.N *= -1, this.I *= -1, this.U *= -1, this.G(), this;
  }
  dot(e) {
    return this.N * e.N + this.I * e.I + this.U * e.U + this.O * e.O;
  }
  lengthSq() {
    return this.N * this.N + this.I * this.I + this.U * this.U + this.O * this.O;
  }
  length() {
    return Math.sqrt(this.N * this.N + this.I * this.I + this.U * this.U + this.O * this.O);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this.N = 0, this.I = 0, this.U = 0, this.O = 1) : (e = 1 / e, this.N = this.N * e, this.I = this.I * e, this.U = this.U * e, this.O = this.O * e), this.G(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e.N, r = e.I, s = e.U, a = e.O, o = t.N, l = t.I, h = t.U, c = t.O;
    return this.N = i * c + a * o + r * h - s * l, this.I = r * c + a * l + s * o - i * h, this.U = s * c + a * h + i * l - r * o, this.O = a * c - i * o - r * l - s * h, this.G(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const i = this.N, r = this.I, s = this.U, a = this.O;
    let o = a * e.O + i * e.N + r * e.I + s * e.U;
    if (o < 0 ? (this.O = -e.O, this.N = -e.N, this.I = -e.I, this.U = -e.U, o = -o) : this.copy(e), o >= 1)
      return this.O = a, this.N = i, this.I = r, this.U = s, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const p = 1 - t;
      return this.O = p * a + t * this.O, this.N = p * i + t * this.N, this.I = p * r + t * this.I, this.U = p * s + t * this.U, this.normalize(), this;
    }
    const h = Math.sqrt(l), c = Math.atan2(h, o), u = Math.sin((1 - t) * c) / h, d = Math.sin(t * c) / h;
    return this.O = a * u + this.O * d, this.N = i * u + this.N * d, this.I = r * u + this.I * d, this.U = s * u + this.U * d, this.G(), this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), i = Math.random(), r = Math.sqrt(1 - i), s = Math.sqrt(i);
    return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t));
  }
  equals(e) {
    return e.N === this.N && e.I === this.I && e.U === this.U && e.O === this.O;
  }
  fromArray(e, t = 0) {
    return this.N = e[t], this.I = e[t + 1], this.U = e[t + 2], this.O = e[t + 3], this.G(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.N, e[t + 1] = this.I, e[t + 2] = this.U, e[t + 3] = this.O, e;
  }
  fromBufferAttribute(e, t) {
    return this.N = e.getX(t), this.I = e.getY(t), this.U = e.getZ(t), this.O = e.getW(t), this.G(), this;
  }
  toJSON() {
    return this.toArray();
  }
  W(e) {
    return this.G = e, this;
  }
  G() {
  }
  *[Symbol.iterator]() {
    yield this.N, yield this.I, yield this.U, yield this.O;
  }
}
class _ {
  constructor(e = 0, t = 0, i = 0) {
    _.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion($0.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion($0.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements, a = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * a, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * a, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * a, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, r = this.z, s = e.x, a = e.y, o = e.z, l = e.w, h = 2 * (a * r - o * i), c = 2 * (o * t - s * r), u = 2 * (s * i - a * t);
    return this.x = t + l * h + a * u - o * c, this.y = i + l * c + o * h - s * u, this.z = r + l * u + s * c - a * h, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, r = e.y, s = e.z, a = t.x, o = t.y, l = t.z;
    return this.x = r * l - s * o, this.y = s * a - i * l, this.z = i * o - r * a, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return mp.copy(this).projectOnVector(e), this.sub(mp);
  }
  reflect(e) {
    return this.sub(mp.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Rt(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, 4 * t);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, 3 * t);
  }
  setFromEuler(e) {
    return this.x = e.N, this.y = e.I, this.z = e.U, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = 2 * Math.random() - 1, i = Math.sqrt(1 - t * t);
    return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const mp = new _(), $0 = new Ye();
class yt {
  constructor(e = new _(1 / 0, 1 / 0, 1 / 0), t = new _(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Ti.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Ti.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Ti.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, Ti) : Ti.fromBufferAttribute(s, a), Ti.applyMatrix4(e.matrixWorld), this.expandByPoint(Ti);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), ac.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), ac.copy(i.boundingBox)), ac.applyMatrix4(e.matrixWorld), this.union(ac);
    }
    const r = e.children;
    for (let s = 0, a = r.length; s < a; s++)
      this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Ti), Ti.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(al), oc.subVectors(this.max, al), Oa.subVectors(e.a, al), Ua.subVectors(e.b, al), Fa.subVectors(e.c, al), Fr.subVectors(Ua, Oa), Br.subVectors(Fa, Ua), Rs.subVectors(Oa, Fa);
    let t = [0, -Fr.z, Fr.y, 0, -Br.z, Br.y, 0, -Rs.z, Rs.y, Fr.z, 0, -Fr.x, Br.z, 0, -Br.x, Rs.z, 0, -Rs.x, -Fr.y, Fr.x, 0, -Br.y, Br.x, 0, -Rs.y, Rs.x, 0];
    return !!gp(t, Oa, Ua, Fa, oc) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!gp(t, Oa, Ua, Fa, oc) && (lc.crossVectors(Fr, Br), t = [lc.x, lc.y, lc.z], gp(t, Oa, Ua, Fa, oc)));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ti).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = 0.5 * this.getSize(Ti).length()), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() || (hr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), hr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), hr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), hr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), hr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), hr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), hr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), hr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(hr)), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const hr = [new _(), new _(), new _(), new _(), new _(), new _(), new _(), new _()], Ti = new _(), ac = new yt(), Oa = new _(), Ua = new _(), Fa = new _(), Fr = new _(), Br = new _(), Rs = new _(), al = new _(), oc = new _(), lc = new _(), Is = new _();
function gp(n, e, t, i, r) {
  for (let s = 0, a = n.length - 3; s <= a; s += 3) {
    Is.fromArray(n, s);
    const o = r.x * Math.abs(Is.x) + r.y * Math.abs(Is.y) + r.z * Math.abs(Is.z), l = e.dot(Is), h = t.dot(Is), c = i.dot(Is);
    if (Math.max(-Math.max(l, h, c), Math.min(l, h, c)) > o)
      return !1;
  }
  return !0;
}
const Bw = new yt(), ol = new _(), vp = new _();
class rn {
  constructor(e = new _(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : Bw.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, a = e.length; s < a; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    ol.subVectors(e, this.center);
    const t = ol.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), r = 0.5 * (i - this.radius);
      this.center.addScaledVector(ol, r / i), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (vp.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(ol.copy(e.center).add(vp)), this.expandByPoint(ol.copy(e.center).sub(vp))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const cr = new _(), yp = new _(), hc = new _(), kr = new _(), xp = new _(), cc = new _(), Mp = new _();
class Ra {
  constructor(e = new _(), t = new _(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, cr)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = cr.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (cr.copy(this.origin).addScaledVector(this.direction, t), cr.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    yp.copy(e).add(t).multiplyScalar(0.5), hc.copy(t).sub(e).normalize(), kr.copy(this.origin).sub(yp);
    const s = 0.5 * e.distanceTo(t), a = -this.direction.dot(hc), o = kr.dot(this.direction), l = -kr.dot(hc), h = kr.lengthSq(), c = Math.abs(1 - a * a);
    let u, d, p, m;
    if (c > 0)
      if (u = a * l - o, d = a * o - l, m = s * c, u >= 0)
        if (d >= -m)
          if (d <= m) {
            const g = 1 / c;
            u *= g, d *= g, p = u * (u + a * d + 2 * o) + d * (a * u + d + 2 * l) + h;
          } else
            d = s, u = Math.max(0, -(a * d + o)), p = -u * u + d * (d + 2 * l) + h;
        else
          d = -s, u = Math.max(0, -(a * d + o)), p = -u * u + d * (d + 2 * l) + h;
      else
        d <= -m ? (u = Math.max(0, -(-a * s + o)), d = u > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -u * u + d * (d + 2 * l) + h) : d <= m ? (u = 0, d = Math.min(Math.max(-s, -l), s), p = d * (d + 2 * l) + h) : (u = Math.max(0, -(a * s + o)), d = u > 0 ? s : Math.min(Math.max(-s, -l), s), p = -u * u + d * (d + 2 * l) + h);
    else
      d = a > 0 ? -s : s, u = Math.max(0, -(a * d + o)), p = -u * u + d * (d + 2 * l) + h;
    return i && i.copy(this.origin).addScaledVector(this.direction, u), r && r.copy(yp).addScaledVector(hc, d), p;
  }
  intersectSphere(e, t) {
    cr.subVectors(e.center, this.origin);
    const i = cr.dot(this.direction), r = cr.dot(cr) - i * i, s = e.radius * e.radius;
    if (r > s)
      return null;
    const a = Math.sqrt(s - r), o = i - a, l = i + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 ? !0 : e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, a, o, l;
    const h = 1 / this.direction.x, c = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
    return h >= 0 ? (i = (e.min.x - d.x) * h, r = (e.max.x - d.x) * h) : (i = (e.max.x - d.x) * h, r = (e.min.x - d.x) * h), c >= 0 ? (s = (e.min.y - d.y) * c, a = (e.max.y - d.y) * c) : (s = (e.max.y - d.y) * c, a = (e.min.y - d.y) * c), i > a || s > r ? null : ((s > i || isNaN(i)) && (i = s), (a < r || isNaN(r)) && (r = a), u >= 0 ? (o = (e.min.z - d.z) * u, l = (e.max.z - d.z) * u) : (o = (e.max.z - d.z) * u, l = (e.min.z - d.z) * u), i > l || o > r ? null : ((o > i || i != i) && (i = o), (l < r || r != r) && (r = l), r < 0 ? null : this.at(i >= 0 ? i : r, t)));
  }
  intersectsBox(e) {
    return this.intersectBox(e, cr) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    xp.subVectors(t, e), cc.subVectors(i, e), Mp.crossVectors(xp, cc);
    let a, o = this.direction.dot(Mp);
    if (o > 0) {
      if (r)
        return null;
      a = 1;
    } else {
      if (!(o < 0))
        return null;
      a = -1, o = -o;
    }
    kr.subVectors(this.origin, e);
    const l = a * this.direction.dot(cc.crossVectors(kr, cc));
    if (l < 0)
      return null;
    const h = a * this.direction.dot(xp.cross(kr));
    if (h < 0 || l + h > o)
      return null;
    const c = -a * kr.dot(Mp);
    return c < 0 ? null : this.at(c / o, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class fe {
  constructor(e, t, i, r, s, a, o, l, h, c, u, d, p, m, g, f) {
    fe.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, a, o, l, h, c, u, d, p, m, g, f);
  }
  set(e, t, i, r, s, a, o, l, h, c, u, d, p, m, g, f) {
    const v = this.elements;
    return v[0] = e, v[4] = t, v[8] = i, v[12] = r, v[1] = s, v[5] = a, v[9] = o, v[13] = l, v[2] = h, v[6] = c, v[10] = u, v[14] = d, v[3] = p, v[7] = m, v[11] = g, v[15] = f, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new fe().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, r = 1 / Ba.setFromMatrixColumn(e, 0).length(), s = 1 / Ba.setFromMatrixColumn(e, 1).length(), a = 1 / Ba.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z, a = Math.cos(i), o = Math.sin(i), l = Math.cos(r), h = Math.sin(r), c = Math.cos(s), u = Math.sin(s);
    if (e.order === "XYZ") {
      const d = a * c, p = a * u, m = o * c, g = o * u;
      t[0] = l * c, t[4] = -l * u, t[8] = h, t[1] = p + m * h, t[5] = d - g * h, t[9] = -o * l, t[2] = g - d * h, t[6] = m + p * h, t[10] = a * l;
    } else if (e.order === "YXZ") {
      const d = l * c, p = l * u, m = h * c, g = h * u;
      t[0] = d + g * o, t[4] = m * o - p, t[8] = a * h, t[1] = a * u, t[5] = a * c, t[9] = -o, t[2] = p * o - m, t[6] = g + d * o, t[10] = a * l;
    } else if (e.order === "ZXY") {
      const d = l * c, p = l * u, m = h * c, g = h * u;
      t[0] = d - g * o, t[4] = -a * u, t[8] = m + p * o, t[1] = p + m * o, t[5] = a * c, t[9] = g - d * o, t[2] = -a * h, t[6] = o, t[10] = a * l;
    } else if (e.order === "ZYX") {
      const d = a * c, p = a * u, m = o * c, g = o * u;
      t[0] = l * c, t[4] = m * h - p, t[8] = d * h + g, t[1] = l * u, t[5] = g * h + d, t[9] = p * h - m, t[2] = -h, t[6] = o * l, t[10] = a * l;
    } else if (e.order === "YZX") {
      const d = a * l, p = a * h, m = o * l, g = o * h;
      t[0] = l * c, t[4] = g - d * u, t[8] = m * u + p, t[1] = u, t[5] = a * c, t[9] = -o * c, t[2] = -h * c, t[6] = p * u + m, t[10] = d - g * u;
    } else if (e.order === "XZY") {
      const d = a * l, p = a * h, m = o * l, g = o * h;
      t[0] = l * c, t[4] = -u, t[8] = h * c, t[1] = d * u + g, t[5] = a * c, t[9] = p * u - m, t[2] = m * u - p, t[6] = o * c, t[10] = g * u + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(kw, e, zw);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return qn.subVectors(e, t), qn.lengthSq() === 0 && (qn.z = 1), qn.normalize(), zr.crossVectors(i, qn), zr.lengthSq() === 0 && (Math.abs(i.z) === 1 ? qn.x += 1e-4 : qn.z += 1e-4, qn.normalize(), zr.crossVectors(i, qn)), zr.normalize(), uc.crossVectors(qn, zr), r[0] = zr.x, r[4] = uc.x, r[8] = qn.x, r[1] = zr.y, r[5] = uc.y, r[9] = qn.y, r[2] = zr.z, r[6] = uc.z, r[10] = qn.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, a = i[0], o = i[4], l = i[8], h = i[12], c = i[1], u = i[5], d = i[9], p = i[13], m = i[2], g = i[6], f = i[10], v = i[14], y = i[3], x = i[7], M = i[11], b = i[15], S = r[0], w = r[4], T = r[8], C = r[12], I = r[1], A = r[5], L = r[9], D = r[13], U = r[2], H = r[6], Z = r[10], te = r[14], ne = r[3], ve = r[7], Se = r[11], Q = r[15];
    return s[0] = a * S + o * I + l * U + h * ne, s[4] = a * w + o * A + l * H + h * ve, s[8] = a * T + o * L + l * Z + h * Se, s[12] = a * C + o * D + l * te + h * Q, s[1] = c * S + u * I + d * U + p * ne, s[5] = c * w + u * A + d * H + p * ve, s[9] = c * T + u * L + d * Z + p * Se, s[13] = c * C + u * D + d * te + p * Q, s[2] = m * S + g * I + f * U + v * ne, s[6] = m * w + g * A + f * H + v * ve, s[10] = m * T + g * L + f * Z + v * Se, s[14] = m * C + g * D + f * te + v * Q, s[3] = y * S + x * I + M * U + b * ne, s[7] = y * w + x * A + M * H + b * ve, s[11] = y * T + x * L + M * Z + b * Se, s[15] = y * C + x * D + M * te + b * Q, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], r = e[8], s = e[12], a = e[1], o = e[5], l = e[9], h = e[13], c = e[2], u = e[6], d = e[10], p = e[14];
    return e[3] * (+s * l * u - r * h * u - s * o * d + i * h * d + r * o * p - i * l * p) + e[7] * (+t * l * p - t * h * d + s * a * d - r * a * p + r * h * c - s * l * c) + e[11] * (+t * h * u - t * o * p - s * a * u + i * a * p + s * o * c - i * h * c) + e[15] * (-r * o * c - t * l * u + t * o * d + r * a * u - i * a * d + i * l * c);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], a = e[4], o = e[5], l = e[6], h = e[7], c = e[8], u = e[9], d = e[10], p = e[11], m = e[12], g = e[13], f = e[14], v = e[15], y = u * f * h - g * d * h + g * l * p - o * f * p - u * l * v + o * d * v, x = m * d * h - c * f * h - m * l * p + a * f * p + c * l * v - a * d * v, M = c * g * h - m * u * h + m * o * p - a * g * p - c * o * v + a * u * v, b = m * u * l - c * g * l - m * o * d + a * g * d + c * o * f - a * u * f, S = t * y + i * x + r * M + s * b;
    if (S === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return e[0] = y * w, e[1] = (g * d * s - u * f * s - g * r * p + i * f * p + u * r * v - i * d * v) * w, e[2] = (o * f * s - g * l * s + g * r * h - i * f * h - o * r * v + i * l * v) * w, e[3] = (u * l * s - o * d * s - u * r * h + i * d * h + o * r * p - i * l * p) * w, e[4] = x * w, e[5] = (c * f * s - m * d * s + m * r * p - t * f * p - c * r * v + t * d * v) * w, e[6] = (m * l * s - a * f * s - m * r * h + t * f * h + a * r * v - t * l * v) * w, e[7] = (a * d * s - c * l * s + c * r * h - t * d * h - a * r * p + t * l * p) * w, e[8] = M * w, e[9] = (m * u * s - c * g * s - m * i * p + t * g * p + c * i * v - t * u * v) * w, e[10] = (a * g * s - m * o * s + m * i * h - t * g * h - a * i * v + t * o * v) * w, e[11] = (c * o * s - a * u * s - c * i * h + t * u * h + a * i * p - t * o * p) * w, e[12] = b * w, e[13] = (c * g * r - m * u * r + m * i * d - t * g * d - c * i * f + t * u * f) * w, e[14] = (m * o * r - a * g * r - m * i * l + t * g * l + a * i * f - t * o * f) * w, e[15] = (a * u * r - c * o * r + c * i * l - t * u * l - a * i * d + t * o * d) * w, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z;
    return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = 1 - i, a = e.x, o = e.y, l = e.z, h = s * a, c = s * o;
    return this.set(h * a + i, h * o - r * l, h * l + r * o, 0, h * o + r * l, c * o + i, c * l - r * a, 0, h * l - r * o, c * l + r * a, s * l * l + i, 0, 0, 0, 0, 1), this;
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, s, a) {
    return this.set(1, i, s, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements, s = t.N, a = t.I, o = t.U, l = t.O, h = s + s, c = a + a, u = o + o, d = s * h, p = s * c, m = s * u, g = a * c, f = a * u, v = o * u, y = l * h, x = l * c, M = l * u, b = i.x, S = i.y, w = i.z;
    return r[0] = (1 - (g + v)) * b, r[1] = (p + M) * b, r[2] = (m - x) * b, r[3] = 0, r[4] = (p - M) * S, r[5] = (1 - (d + v)) * S, r[6] = (f + y) * S, r[7] = 0, r[8] = (m + x) * w, r[9] = (f - y) * w, r[10] = (1 - (d + g)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Ba.set(r[0], r[1], r[2]).length();
    const a = Ba.set(r[4], r[5], r[6]).length(), o = Ba.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], Ei.copy(this);
    const l = 1 / s, h = 1 / a, c = 1 / o;
    return Ei.elements[0] *= l, Ei.elements[1] *= l, Ei.elements[2] *= l, Ei.elements[4] *= h, Ei.elements[5] *= h, Ei.elements[6] *= h, Ei.elements[8] *= c, Ei.elements[9] *= c, Ei.elements[10] *= c, t.setFromRotationMatrix(Ei), i.x = s, i.y = a, i.z = o, this;
  }
  makePerspective(e, t, i, r, s, a, o = 2e3) {
    const l = this.elements, h = 2 * s / (t - e), c = 2 * s / (i - r), u = (t + e) / (t - e), d = (i + r) / (i - r);
    let p, m;
    if (o === wa)
      p = -(a + s) / (a - s), m = -2 * a * s / (a - s);
    else {
      if (o !== uh)
        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
      p = -a / (a - s), m = -a * s / (a - s);
    }
    return l[0] = h, l[4] = 0, l[8] = u, l[12] = 0, l[1] = 0, l[5] = c, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, t, i, r, s, a, o = 2e3) {
    const l = this.elements, h = 1 / (t - e), c = 1 / (i - r), u = 1 / (a - s), d = (t + e) * h, p = (i + r) * c;
    let m, g;
    if (o === wa)
      m = (a + s) * u, g = -2 * u;
    else {
      if (o !== uh)
        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
      m = s * u, g = -1 * u;
    }
    return l[0] = 2 * h, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * c, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = g, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 16; r++)
      if (t[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const Ba = new _(), Ei = new fe(), kw = new _(0, 0, 0), zw = new _(1, 1, 1), zr = new _(), uc = new _(), qn = new _(), ev = new fe(), tv = new Ye();
class gt {
  constructor(e = 0, t = 0, i = 0, r = gt.DEFAULT_ORDER) {
    this.isEuler = !0, this.N = e, this.I = t, this.U = i, this.H = r;
  }
  get x() {
    return this.N;
  }
  set x(e) {
    this.N = e, this.G();
  }
  get y() {
    return this.I;
  }
  set y(e) {
    this.I = e, this.G();
  }
  get z() {
    return this.U;
  }
  set z(e) {
    this.U = e, this.G();
  }
  get order() {
    return this.H;
  }
  set order(e) {
    this.H = e, this.G();
  }
  set(e, t, i, r = this.H) {
    return this.N = e, this.I = t, this.U = i, this.H = r, this.G(), this;
  }
  clone() {
    return new this.constructor(this.N, this.I, this.U, this.H);
  }
  copy(e) {
    return this.N = e.N, this.I = e.I, this.U = e.U, this.H = e.H, this.G(), this;
  }
  setFromRotationMatrix(e, t = this.H, i = !0) {
    const r = e.elements, s = r[0], a = r[4], o = r[8], l = r[1], h = r[5], c = r[9], u = r[2], d = r[6], p = r[10];
    switch (t) {
      case "XYZ":
        this.I = Math.asin(Rt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this.N = Math.atan2(-c, p), this.U = Math.atan2(-a, s)) : (this.N = Math.atan2(d, h), this.U = 0);
        break;
      case "YXZ":
        this.N = Math.asin(-Rt(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this.I = Math.atan2(o, p), this.U = Math.atan2(l, h)) : (this.I = Math.atan2(-u, s), this.U = 0);
        break;
      case "ZXY":
        this.N = Math.asin(Rt(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this.I = Math.atan2(-u, p), this.U = Math.atan2(-a, h)) : (this.I = 0, this.U = Math.atan2(l, s));
        break;
      case "ZYX":
        this.I = Math.asin(-Rt(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this.N = Math.atan2(d, p), this.U = Math.atan2(l, s)) : (this.N = 0, this.U = Math.atan2(-a, h));
        break;
      case "YZX":
        this.U = Math.asin(Rt(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this.N = Math.atan2(-c, h), this.I = Math.atan2(-u, s)) : (this.N = 0, this.I = Math.atan2(o, p));
        break;
      case "XZY":
        this.U = Math.asin(-Rt(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this.N = Math.atan2(d, h), this.I = Math.atan2(o, s)) : (this.N = Math.atan2(-c, p), this.I = 0);
    }
    return this.H = t, i === !0 && this.G(), this;
  }
  setFromQuaternion(e, t, i) {
    return ev.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ev, t, i);
  }
  setFromVector3(e, t = this.H) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return tv.setFromEuler(this), this.setFromQuaternion(tv, e);
  }
  equals(e) {
    return e.N === this.N && e.I === this.I && e.U === this.U && e.H === this.H;
  }
  fromArray(e) {
    return this.N = e[0], this.I = e[1], this.U = e[2], e[3] !== void 0 && (this.H = e[3]), this.G(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.N, e[t + 1] = this.I, e[t + 2] = this.U, e[t + 3] = this.H, e;
  }
  W(e) {
    return this.G = e, this;
  }
  G() {
  }
  *[Symbol.iterator]() {
    yield this.N, yield this.I, yield this.U, yield this.H;
  }
}
gt.DEFAULT_ORDER = "XYZ";
class Id {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = 1 << e >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e;
  }
  disable(e) {
    this.mask &= ~(1 << e);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return !!(this.mask & e.mask);
  }
  isEnabled(e) {
    return !!(this.mask & 1 << e);
  }
}
let Vw = 0;
const nv = new _(), ka = new Ye(), ur = new fe(), dc = new _(), ll = new _(), Hw = new _(), Gw = new Ye(), iv = new _(1, 0, 0), rv = new _(0, 1, 0), sv = new _(0, 0, 1), av = { type: "added" }, jw = { type: "removed" }, za = { type: "childadded", child: null }, bp = { type: "childremoved", child: null };
class Ue extends rr {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Vw++ }), this.uuid = ri(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ue.DEFAULT_UP.clone();
    const e = new _(), t = new gt(), i = new Ye(), r = new _(1, 1, 1);
    t.W(function() {
      i.setFromEuler(t, !1);
    }), i.W(function() {
      t.setFromQuaternion(i, void 0, !1);
    }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new fe() }, normalMatrix: { value: new De() } }), this.matrix = new fe(), this.matrixWorld = new fe(), this.matrixAutoUpdate = Ue.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Ue.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Id(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return ka.setFromAxisAngle(e, t), this.quaternion.multiply(ka), this;
  }
  rotateOnWorldAxis(e, t) {
    return ka.setFromAxisAngle(e, t), this.quaternion.premultiply(ka), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(iv, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(rv, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(sv, e);
  }
  translateOnAxis(e, t) {
    return nv.copy(e).applyQuaternion(this.quaternion), this.position.add(nv.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(iv, e);
  }
  translateY(e) {
    return this.translateOnAxis(rv, e);
  }
  translateZ(e) {
    return this.translateOnAxis(sv, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(ur.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? dc.copy(e) : dc.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), ll.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ur.lookAt(ll, dc, this.up) : ur.lookAt(dc, ll, this.up), this.quaternion.setFromRotationMatrix(ur), r && (ur.extractRotation(r.matrixWorld), ka.setFromRotationMatrix(ur), this.quaternion.premultiply(ka.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this || e && e.isObject3D && (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(av), za.child = e, this.dispatchEvent(za), za.child = null), this;
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(jw), bp.child = e, this.dispatchEvent(bp), bp.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), ur.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), ur.multiply(e.parent.matrixWorld)), e.applyMatrix4(ur), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(av), za.child = e, this.dispatchEvent(za), za.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const s = this.children[i].getObjectByProperty(e, t);
      if (s !== void 0)
        return s;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const r = this.children;
    for (let s = 0, a = r.length; s < a; s++)
      r[s].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ll, e, Hw), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ll, Gw, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      s.matrixWorldAutoUpdate !== !0 && e !== !0 || s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const r = this.children;
      for (let s = 0, a = r.length; s < a; s++) {
        const o = r[s];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" });
    const r = {};
    function s(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this.j, r.reservedRanges = this.J, r.visibility = this.$, r.active = this.tt, r.bounds = this.et.map((o) => ({ boxInitialized: o.boxInitialized, boxMin: o.box.min.toArray(), boxMax: o.box.max.toArray(), sphereInitialized: o.sphereInitialized, sphereRadius: o.sphere.radius, sphereCenter: o.sphere.center.toArray() })), r.maxGeometryCount = this.nt, r.maxVertexCount = this.it, r.maxIndexCount = this.st, r.geometryInitialized = this.rt, r.geometryCount = this.ot, r.matricesTexture = this.ht.toJSON(e), this.ct !== null && (r.colorsTexture = this.ct.toJSON(e)), this.boundingSphere !== null && (r.boundingSphere = { center: r.boundingSphere.center.toArray(), radius: r.boundingSphere.radius }), this.boundingBox !== null && (r.boundingBox = { min: r.boundingBox.min.toArray(), max: r.boundingBox.max.toArray() })), this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let h = 0, c = l.length; h < c; h++) {
            const u = l[h];
            s(e.shapes, u);
          }
        else
          s(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, h = this.material.length; l < h; l++)
          o.push(s(e.materials, this.material[l]));
        r.material = o;
      } else
        r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let o = 0; o < this.children.length; o++)
        r.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries), l = a(e.materials), h = a(e.textures), c = a(e.images), u = a(e.shapes), d = a(e.skeletons), p = a(e.animations), m = a(e.nodes);
      o.length > 0 && (i.geometries = o), l.length > 0 && (i.materials = l), h.length > 0 && (i.textures = h), c.length > 0 && (i.images = c), u.length > 0 && (i.shapes = u), d.length > 0 && (i.skeletons = d), p.length > 0 && (i.animations = p), m.length > 0 && (i.nodes = m);
    }
    return i.object = r, i;
    function a(o) {
      const l = [];
      for (const h in o) {
        const c = o[h];
        delete c.metadata, l.push(c);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Ue.DEFAULT_UP = new _(0, 1, 0), Ue.DEFAULT_MATRIX_AUTO_UPDATE = !0, Ue.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Ai = new _(), dr = new _(), Sp = new _(), pr = new _(), Va = new _(), Ha = new _(), ov = new _(), wp = new _(), _p = new _(), Tp = new _();
class ei {
  constructor(e = new _(), t = new _(), i = new _()) {
    this.a = e, this.b = t, this.c = i;
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), Ai.subVectors(e, t), r.cross(Ai);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    Ai.subVectors(r, t), dr.subVectors(i, t), Sp.subVectors(e, t);
    const a = Ai.dot(Ai), o = Ai.dot(dr), l = Ai.dot(Sp), h = dr.dot(dr), c = dr.dot(Sp), u = a * h - o * o;
    if (u === 0)
      return s.set(0, 0, 0), null;
    const d = 1 / u, p = (h * l - o * c) * d, m = (a * c - o * l) * d;
    return s.set(1 - p - m, m, p);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, pr) !== null && pr.x >= 0 && pr.y >= 0 && pr.x + pr.y <= 1;
  }
  static getInterpolation(e, t, i, r, s, a, o, l) {
    return this.getBarycoord(e, t, i, r, pr) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, pr.x), l.addScaledVector(a, pr.y), l.addScaledVector(o, pr.z), l);
  }
  static isFrontFacing(e, t, i, r) {
    return Ai.subVectors(i, t), dr.subVectors(e, t), Ai.cross(dr).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Ai.subVectors(this.c, this.b), dr.subVectors(this.a, this.b), 0.5 * Ai.cross(dr).length();
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ei.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ei.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, i, r, s) {
    return ei.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return ei.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ei.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a, r = this.b, s = this.c;
    let a, o;
    Va.subVectors(r, i), Ha.subVectors(s, i), wp.subVectors(e, i);
    const l = Va.dot(wp), h = Ha.dot(wp);
    if (l <= 0 && h <= 0)
      return t.copy(i);
    _p.subVectors(e, r);
    const c = Va.dot(_p), u = Ha.dot(_p);
    if (c >= 0 && u <= c)
      return t.copy(r);
    const d = l * u - c * h;
    if (d <= 0 && l >= 0 && c <= 0)
      return a = l / (l - c), t.copy(i).addScaledVector(Va, a);
    Tp.subVectors(e, s);
    const p = Va.dot(Tp), m = Ha.dot(Tp);
    if (m >= 0 && p <= m)
      return t.copy(s);
    const g = p * h - l * m;
    if (g <= 0 && h >= 0 && m <= 0)
      return o = h / (h - m), t.copy(i).addScaledVector(Ha, o);
    const f = c * m - p * u;
    if (f <= 0 && u - c >= 0 && p - m >= 0)
      return ov.subVectors(s, r), o = (u - c) / (u - c + (p - m)), t.copy(r).addScaledVector(ov, o);
    const v = 1 / (f + g + d);
    return a = g * v, o = d * v, t.copy(i).addScaledVector(Va, a).addScaledVector(Ha, o);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Y1 = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Vr = { h: 0, s: 0, l: 0 }, pc = { h: 0, s: 0, l: 0 };
function Ep(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + 6 * (e - n) * t : t < 0.5 ? e : t < 2 / 3 ? n + 6 * (e - n) * (2 / 3 - t) : n;
}
let oe = class {
  constructor(n, e, t) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(n, e, t);
  }
  set(n, e, t) {
    if (e === void 0 && t === void 0) {
      const i = n;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(n, e, t);
    return this;
  }
  setScalar(n) {
    return this.r = n, this.g = n, this.b = n, this;
  }
  setHex(n, e = mt) {
    return n = Math.floor(n), this.r = (n >> 16 & 255) / 255, this.g = (n >> 8 & 255) / 255, this.b = (255 & n) / 255, it.toWorkingColorSpace(this, e), this;
  }
  setRGB(n, e, t, i = it.workingColorSpace) {
    return this.r = n, this.g = e, this.b = t, it.toWorkingColorSpace(this, i), this;
  }
  setHSL(n, e, t, i = it.workingColorSpace) {
    if (n = Mm(n, 1), e = Rt(e, 0, 1), t = Rt(t, 0, 1), e === 0)
      this.r = this.g = this.b = t;
    else {
      const r = t <= 0.5 ? t * (1 + e) : t + e - t * e, s = 2 * t - r;
      this.r = Ep(s, r, n + 1 / 3), this.g = Ep(s, r, n), this.b = Ep(s, r, n - 1 / 3);
    }
    return it.toWorkingColorSpace(this, i), this;
  }
  setStyle(n, e = mt) {
    function t(r) {
      r !== void 0 && parseFloat(r);
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(n)) {
      let r;
      const s = i[1], a = i[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return t(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return t(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return t(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(n)) {
      const r = i[1], s = r.length;
      if (s === 3)
        return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, e);
      if (s === 6)
        return this.setHex(parseInt(r, 16), e);
    } else if (n && n.length > 0)
      return this.setColorName(n, e);
    return this;
  }
  setColorName(n, e = mt) {
    const t = Y1[n.toLowerCase()];
    return t !== void 0 && this.setHex(t, e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(n) {
    return this.r = n.r, this.g = n.g, this.b = n.b, this;
  }
  copySRGBToLinear(n) {
    return this.r = Mo(n.r), this.g = Mo(n.g), this.b = Mo(n.b), this;
  }
  copyLinearToSRGB(n) {
    return this.r = pp(n.r), this.g = pp(n.g), this.b = pp(n.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(n = mt) {
    return it.fromWorkingColorSpace(Mn.copy(this), n), 65536 * Math.round(Rt(255 * Mn.r, 0, 255)) + 256 * Math.round(Rt(255 * Mn.g, 0, 255)) + Math.round(Rt(255 * Mn.b, 0, 255));
  }
  getHexString(n = mt) {
    return ("000000" + this.getHex(n).toString(16)).slice(-6);
  }
  getHSL(n, e = it.workingColorSpace) {
    it.fromWorkingColorSpace(Mn.copy(this), e);
    const t = Mn.r, i = Mn.g, r = Mn.b, s = Math.max(t, i, r), a = Math.min(t, i, r);
    let o, l;
    const h = (a + s) / 2;
    if (a === s)
      o = 0, l = 0;
    else {
      const c = s - a;
      switch (l = h <= 0.5 ? c / (s + a) : c / (2 - s - a), s) {
        case t:
          o = (i - r) / c + (i < r ? 6 : 0);
          break;
        case i:
          o = (r - t) / c + 2;
          break;
        case r:
          o = (t - i) / c + 4;
      }
      o /= 6;
    }
    return n.h = o, n.s = l, n.l = h, n;
  }
  getRGB(n, e = it.workingColorSpace) {
    return it.fromWorkingColorSpace(Mn.copy(this), e), n.r = Mn.r, n.g = Mn.g, n.b = Mn.b, n;
  }
  getStyle(n = mt) {
    it.fromWorkingColorSpace(Mn.copy(this), n);
    const e = Mn.r, t = Mn.g, i = Mn.b;
    return n !== mt ? `color(${n} ${e.toFixed(3)} ${t.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * e)},${Math.round(255 * t)},${Math.round(255 * i)})`;
  }
  offsetHSL(n, e, t) {
    return this.getHSL(Vr), this.setHSL(Vr.h + n, Vr.s + e, Vr.l + t);
  }
  add(n) {
    return this.r += n.r, this.g += n.g, this.b += n.b, this;
  }
  addColors(n, e) {
    return this.r = n.r + e.r, this.g = n.g + e.g, this.b = n.b + e.b, this;
  }
  addScalar(n) {
    return this.r += n, this.g += n, this.b += n, this;
  }
  sub(n) {
    return this.r = Math.max(0, this.r - n.r), this.g = Math.max(0, this.g - n.g), this.b = Math.max(0, this.b - n.b), this;
  }
  multiply(n) {
    return this.r *= n.r, this.g *= n.g, this.b *= n.b, this;
  }
  multiplyScalar(n) {
    return this.r *= n, this.g *= n, this.b *= n, this;
  }
  lerp(n, e) {
    return this.r += (n.r - this.r) * e, this.g += (n.g - this.g) * e, this.b += (n.b - this.b) * e, this;
  }
  lerpColors(n, e, t) {
    return this.r = n.r + (e.r - n.r) * t, this.g = n.g + (e.g - n.g) * t, this.b = n.b + (e.b - n.b) * t, this;
  }
  lerpHSL(n, e) {
    this.getHSL(Vr), n.getHSL(pc);
    const t = Wl(Vr.h, pc.h, e), i = Wl(Vr.s, pc.s, e), r = Wl(Vr.l, pc.l, e);
    return this.setHSL(t, i, r), this;
  }
  setFromVector3(n) {
    return this.r = n.x, this.g = n.y, this.b = n.z, this;
  }
  applyMatrix3(n) {
    const e = this.r, t = this.g, i = this.b, r = n.elements;
    return this.r = r[0] * e + r[3] * t + r[6] * i, this.g = r[1] * e + r[4] * t + r[7] * i, this.b = r[2] * e + r[5] * t + r[8] * i, this;
  }
  equals(n) {
    return n.r === this.r && n.g === this.g && n.b === this.b;
  }
  fromArray(n, e = 0) {
    return this.r = n[e], this.g = n[e + 1], this.b = n[e + 2], this;
  }
  toArray(n = [], e = 0) {
    return n[e] = this.r, n[e + 1] = this.g, n[e + 2] = this.b, n;
  }
  fromBufferAttribute(n, e) {
    return this.r = n.getX(e), this.g = n.getY(e), this.b = n.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const Mn = new oe();
oe.NAMES = Y1;
let Ww = 0;
class Xt extends rr {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Ww++ }), this.uuid = ri(), this.name = "", this.type = "Material", this.blending = 1, this.side = Mi, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = us, this.blendDst = ds, this.blendEquation = $n, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new oe(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ks, this.stencilZFail = Ks, this.stencilZPass = Ks, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this.lt = 0;
  }
  get alphaTest() {
    return this.lt;
  }
  set alphaTest(e) {
    this.lt > 0 != e > 0 && this.version++, this.lt = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0)
          continue;
        const r = this[t];
        r !== void 0 && (r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
    function r(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (i.blending = this.blending), this.side !== Mi && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== us && (i.blendSrc = this.blendSrc), this.blendDst !== ds && (i.blendDst = this.blendDst), this.blendEquation !== $n && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== 3 && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== 519 && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Ks && (i.stencilFail = this.stencilFail), this.stencilZFail !== Ks && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Ks && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData), t) {
      const s = r(e.textures), a = r(e.images);
      s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s)
        i[s] = t[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Wt extends Xt {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new oe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new gt(), this.combine = Hh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const br = Xw();
function Xw() {
  const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), i = new Uint32Array(512), r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const h = l - 127;
    h < -27 ? (i[l] = 0, i[256 | l] = 32768, r[l] = 24, r[256 | l] = 24) : h < -14 ? (i[l] = 1024 >> -h - 14, i[256 | l] = 1024 >> -h - 14 | 32768, r[l] = -h - 1, r[256 | l] = -h - 1) : h <= 15 ? (i[l] = h + 15 << 10, i[256 | l] = h + 15 << 10 | 32768, r[l] = 13, r[256 | l] = 13) : h < 128 ? (i[l] = 31744, i[256 | l] = 64512, r[l] = 24, r[256 | l] = 24) : (i[l] = 31744, i[256 | l] = 64512, r[l] = 13, r[256 | l] = 13);
  }
  const s = new Uint32Array(2048), a = new Uint32Array(64), o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let h = l << 13, c = 0;
    for (; !(8388608 & h); )
      h <<= 1, c -= 8388608;
    h &= -8388609, c += 947912704, s[l] = h | c;
  }
  for (let l = 1024; l < 2048; ++l)
    s[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    a[l] = l << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    a[l] = 2147483648 + (l - 32 << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (o[l] = 1024);
  return { floatView: e, uint32View: t, baseTable: i, shiftTable: r, mantissaTable: s, exponentTable: a, offsetTable: o };
}
function Fn(n) {
  Math.abs(n), n = Rt(n, -65504, 65504), br.floatView[0] = n;
  const e = br.uint32View[0], t = e >> 23 & 511;
  return br.baseTable[t] + ((8388607 & e) >> br.shiftTable[t]);
}
function Ol(n) {
  const e = n >> 10;
  return br.uint32View[0] = br.mantissaTable[br.offsetTable[e] + (1023 & n)] + br.exponentTable[e], br.floatView[0];
}
const qw = { toHalfFloat: Fn, fromHalfFloat: Ol }, Yt = new _(), fc = new X();
class Ke {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = ch, this.ut = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = ni, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return Ag("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this.ut;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        fc.fromBufferAttribute(this, t), fc.applyMatrix3(e), this.setXY(t, fc.x, fc.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        Yt.fromBufferAttribute(this, t), Yt.applyMatrix3(e), this.setXYZ(t, Yt.x, Yt.y, Yt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Yt.fromBufferAttribute(this, t), Yt.applyMatrix4(e), this.setXYZ(t, Yt.x, Yt.y, Yt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Yt.fromBufferAttribute(this, t), Yt.applyNormalMatrix(e), this.setXYZ(t, Yt.x, Yt.y, Yt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Yt.fromBufferAttribute(this, t), Yt.transformDirection(e), this.setXYZ(t, Yt.x, Yt.y, Yt.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = Nn(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = Oe(i, this.array)), this.array[e * this.itemSize + t] = i, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Nn(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Oe(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Nn(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Oe(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Nn(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Oe(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Nn(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Oe(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = Oe(t, this.array), i = Oe(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e *= this.itemSize, this.normalized && (t = Oe(t, this.array), i = Oe(i, this.array), r = Oe(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e *= this.itemSize, this.normalized && (t = Oe(t, this.array), i = Oe(i, this.array), r = Oe(r, this.array), s = Oe(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return this.name !== "" && (e.name = this.name), this.usage !== ch && (e.usage = this.usage), e;
  }
}
class Ld extends Ke {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class Cg extends Ke {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class ye extends Ke {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let Yw = 0;
const hi = new fe(), Ap = new Ue(), Ga = new _(), Yn = new yt(), hl = new yt(), ln = new _();
class Pe extends rr {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Yw++ }), this.uuid = ri(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (j1(e) ? Cg : Ld)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new De().getNormalMatrix(e);
      i.applyNormalMatrix(s), i.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return hi.makeRotationFromQuaternion(e), this.applyMatrix4(hi), this;
  }
  rotateX(e) {
    return hi.makeRotationX(e), this.applyMatrix4(hi), this;
  }
  rotateY(e) {
    return hi.makeRotationY(e), this.applyMatrix4(hi), this;
  }
  rotateZ(e) {
    return hi.makeRotationZ(e), this.applyMatrix4(hi), this;
  }
  translate(e, t, i) {
    return hi.makeTranslation(e, t, i), this.applyMatrix4(hi), this;
  }
  scale(e, t, i) {
    return hi.makeScale(e, t, i), this.applyMatrix4(hi), this;
  }
  lookAt(e) {
    return Ap.lookAt(e), Ap.updateMatrix(), this.applyMatrix4(Ap.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Ga).negate(), this.translate(Ga.x, Ga.y, Ga.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new ye(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new yt());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute)
      this.boundingBox.set(new _(-1 / 0, -1 / 0, -1 / 0), new _(1 / 0, 1 / 0, 1 / 0));
    else {
      if (e !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(e), t)
          for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            Yn.setFromBufferAttribute(s), this.morphTargetsRelative ? (ln.addVectors(this.boundingBox.min, Yn.min), this.boundingBox.expandByPoint(ln), ln.addVectors(this.boundingBox.max, Yn.max), this.boundingBox.expandByPoint(ln)) : (this.boundingBox.expandByPoint(Yn.min), this.boundingBox.expandByPoint(Yn.max));
          }
      } else
        this.boundingBox.makeEmpty();
      isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new rn());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute)
      this.boundingSphere.set(new _(), 1 / 0);
    else if (e) {
      const i = this.boundingSphere.center;
      if (Yn.setFromBufferAttribute(e), t)
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s];
          hl.setFromBufferAttribute(o), this.morphTargetsRelative ? (ln.addVectors(Yn.min, hl.min), Yn.expandByPoint(ln), ln.addVectors(Yn.max, hl.max), Yn.expandByPoint(ln)) : (Yn.expandByPoint(hl.min), Yn.expandByPoint(hl.max));
        }
      Yn.getCenter(i);
      let r = 0;
      for (let s = 0, a = e.count; s < a; s++)
        ln.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(ln));
      if (t)
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s], l = this.morphTargetsRelative;
          for (let h = 0, c = o.count; h < c; h++)
            ln.fromBufferAttribute(o, h), l && (Ga.fromBufferAttribute(e, h), ln.add(Ga)), r = Math.max(r, i.distanceToSquared(ln));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0)
      return;
    const i = t.position, r = t.normal, s = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ke(new Float32Array(4 * i.count), 4));
    const a = this.getAttribute("tangent"), o = [], l = [];
    for (let T = 0; T < i.count; T++)
      o[T] = new _(), l[T] = new _();
    const h = new _(), c = new _(), u = new _(), d = new X(), p = new X(), m = new X(), g = new _(), f = new _();
    function v(T, C, I) {
      h.fromBufferAttribute(i, T), c.fromBufferAttribute(i, C), u.fromBufferAttribute(i, I), d.fromBufferAttribute(s, T), p.fromBufferAttribute(s, C), m.fromBufferAttribute(s, I), c.sub(h), u.sub(h), p.sub(d), m.sub(d);
      const A = 1 / (p.x * m.y - m.x * p.y);
      isFinite(A) && (g.copy(c).multiplyScalar(m.y).addScaledVector(u, -p.y).multiplyScalar(A), f.copy(u).multiplyScalar(p.x).addScaledVector(c, -m.x).multiplyScalar(A), o[T].add(g), o[C].add(g), o[I].add(g), l[T].add(f), l[C].add(f), l[I].add(f));
    }
    let y = this.groups;
    y.length === 0 && (y = [{ start: 0, count: e.count }]);
    for (let T = 0, C = y.length; T < C; ++T) {
      const I = y[T], A = I.start;
      for (let L = A, D = A + I.count; L < D; L += 3)
        v(e.getX(L + 0), e.getX(L + 1), e.getX(L + 2));
    }
    const x = new _(), M = new _(), b = new _(), S = new _();
    function w(T) {
      b.fromBufferAttribute(r, T), S.copy(b);
      const C = o[T];
      x.copy(C), x.sub(b.multiplyScalar(b.dot(C))).normalize(), M.crossVectors(S, C);
      const I = M.dot(l[T]) < 0 ? -1 : 1;
      a.setXYZW(T, x.x, x.y, x.z, I);
    }
    for (let T = 0, C = y.length; T < C; ++T) {
      const I = y[T], A = I.start;
      for (let L = A, D = A + I.count; L < D; L += 3)
        w(e.getX(L + 0)), w(e.getX(L + 1)), w(e.getX(L + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new Ke(new Float32Array(3 * t.count), 3), this.setAttribute("normal", i);
      else
        for (let d = 0, p = i.count; d < p; d++)
          i.setXYZ(d, 0, 0, 0);
      const r = new _(), s = new _(), a = new _(), o = new _(), l = new _(), h = new _(), c = new _(), u = new _();
      if (e)
        for (let d = 0, p = e.count; d < p; d += 3) {
          const m = e.getX(d + 0), g = e.getX(d + 1), f = e.getX(d + 2);
          r.fromBufferAttribute(t, m), s.fromBufferAttribute(t, g), a.fromBufferAttribute(t, f), c.subVectors(a, s), u.subVectors(r, s), c.cross(u), o.fromBufferAttribute(i, m), l.fromBufferAttribute(i, g), h.fromBufferAttribute(i, f), o.add(c), l.add(c), h.add(c), i.setXYZ(m, o.x, o.y, o.z), i.setXYZ(g, l.x, l.y, l.z), i.setXYZ(f, h.x, h.y, h.z);
        }
      else
        for (let d = 0, p = t.count; d < p; d += 3)
          r.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), c.subVectors(a, s), u.subVectors(r, s), c.cross(u), i.setXYZ(d + 0, c.x, c.y, c.z), i.setXYZ(d + 1, c.x, c.y, c.z), i.setXYZ(d + 2, c.x, c.y, c.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      ln.fromBufferAttribute(e, t), ln.normalize(), e.setXYZ(t, ln.x, ln.y, ln.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const h = o.array, c = o.itemSize, u = o.normalized, d = new h.constructor(l.length * c);
      let p = 0, m = 0;
      for (let g = 0, f = l.length; g < f; g++) {
        p = o.isInterleavedBufferAttribute ? l[g] * o.data.stride + o.offset : l[g] * c;
        for (let v = 0; v < c; v++)
          d[m++] = h[p++];
      }
      return new Ke(d, c, u);
    }
    if (this.index === null)
      return this;
    const t = new Pe(), i = this.index.array, r = this.attributes;
    for (const o in r) {
      const l = e(r[o], i);
      t.setAttribute(o, l);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const l = [], h = s[o];
      for (let c = 0, u = h.length; c < u; c++) {
        const d = e(h[c], i);
        l.push(d);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const h = a[o];
      t.addGroup(h.start, h.count, h.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const h in l)
        l[h] !== void 0 && (e[h] = l[h]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
    const i = this.attributes;
    for (const l in i) {
      const h = i[l];
      e.data.attributes[l] = h.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const h = this.morphAttributes[l], c = [];
      for (let u = 0, d = h.length; u < d; u++) {
        const p = h[u];
        c.push(p.toJSON(e.data));
      }
      c.length > 0 && (r[l] = c, s = !0);
    }
    s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return o !== null && (e.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const h in r) {
      const c = r[h];
      this.setAttribute(h, c.clone(t));
    }
    const s = e.morphAttributes;
    for (const h in s) {
      const c = [], u = s[h];
      for (let d = 0, p = u.length; d < p; d++)
        c.push(u[d].clone(t));
      this.morphAttributes[h] = c;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let h = 0, c = a.length; h < c; h++) {
      const u = a[h];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const lv = new fe(), Ls = new Ra(), mc = new rn(), hv = new _(), ja = new _(), Wa = new _(), Xa = new _(), Cp = new _(), gc = new _(), vc = new X(), yc = new X(), xc = new X(), cv = new _(), uv = new _(), dv = new _(), Mc = new _(), bc = new _();
class ce extends Ue {
  constructor(e = new Pe(), t = new Wt()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const i = e[t[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, s = i.length; r < s; r++) {
          const a = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry, r = i.attributes.position, s = i.morphAttributes.position, a = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const o = this.morphTargetInfluences;
    if (s && o) {
      gc.set(0, 0, 0);
      for (let l = 0, h = s.length; l < h; l++) {
        const c = o[l], u = s[l];
        c !== 0 && (Cp.fromBufferAttribute(u, e), a ? gc.addScaledVector(Cp, c) : gc.addScaledVector(Cp.sub(t), c));
      }
      t.add(gc);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.material, s = this.matrixWorld;
    if (r !== void 0) {
      if (i.boundingSphere === null && i.computeBoundingSphere(), mc.copy(i.boundingSphere), mc.applyMatrix4(s), Ls.copy(e.ray).recast(e.near), mc.containsPoint(Ls.origin) === !1 && (Ls.intersectSphere(mc, hv) === null || Ls.origin.distanceToSquared(hv) > Y0(e.far - e.near, 2)))
        return;
      lv.copy(s).invert(), Ls.copy(e.ray).applyMatrix4(lv), i.boundingBox !== null && Ls.intersectsBox(i.boundingBox) === !1 || this.dt(e, t, Ls);
    }
  }
  dt(e, t, i) {
    let r;
    const s = this.geometry, a = this.material, o = s.index, l = s.attributes.position, h = s.attributes.uv, c = s.attributes.uv1, u = s.attributes.normal, d = s.groups, p = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let m = 0, g = d.length; m < g; m++) {
          const f = d[m], v = a[f.materialIndex];
          for (let y = Math.max(f.start, p.start), x = Math.min(o.count, Math.min(f.start + f.count, p.start + p.count)); y < x; y += 3)
            r = Sc(this, v, e, i, h, c, u, o.getX(y), o.getX(y + 1), o.getX(y + 2)), r && (r.faceIndex = Math.floor(y / 3), r.face.materialIndex = f.materialIndex, t.push(r));
        }
      else
        for (let m = Math.max(0, p.start), g = Math.min(o.count, p.start + p.count); m < g; m += 3)
          r = Sc(this, a, e, i, h, c, u, o.getX(m), o.getX(m + 1), o.getX(m + 2)), r && (r.faceIndex = Math.floor(m / 3), t.push(r));
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let m = 0, g = d.length; m < g; m++) {
          const f = d[m], v = a[f.materialIndex];
          for (let y = Math.max(f.start, p.start), x = Math.min(l.count, Math.min(f.start + f.count, p.start + p.count)); y < x; y += 3)
            r = Sc(this, v, e, i, h, c, u, y, y + 1, y + 2), r && (r.faceIndex = Math.floor(y / 3), r.face.materialIndex = f.materialIndex, t.push(r));
        }
      else
        for (let m = Math.max(0, p.start), g = Math.min(l.count, p.start + p.count); m < g; m += 3)
          r = Sc(this, a, e, i, h, c, u, m, m + 1, m + 2), r && (r.faceIndex = Math.floor(m / 3), t.push(r));
  }
}
function Sc(n, e, t, i, r, s, a, o, l, h) {
  n.getVertexPosition(o, ja), n.getVertexPosition(l, Wa), n.getVertexPosition(h, Xa);
  const c = function(u, d, p, m, g, f, v, y) {
    let x;
    if (x = d.side === Tn ? m.intersectTriangle(v, f, g, !0, y) : m.intersectTriangle(g, f, v, d.side === Mi, y), x === null)
      return null;
    bc.copy(y), bc.applyMatrix4(u.matrixWorld);
    const M = p.ray.origin.distanceTo(bc);
    return M < p.near || M > p.far ? null : { distance: M, point: bc.clone(), object: u };
  }(n, e, t, i, ja, Wa, Xa, Mc);
  if (c) {
    r && (vc.fromBufferAttribute(r, o), yc.fromBufferAttribute(r, l), xc.fromBufferAttribute(r, h), c.uv = ei.getInterpolation(Mc, ja, Wa, Xa, vc, yc, xc, new X())), s && (vc.fromBufferAttribute(s, o), yc.fromBufferAttribute(s, l), xc.fromBufferAttribute(s, h), c.uv1 = ei.getInterpolation(Mc, ja, Wa, Xa, vc, yc, xc, new X())), a && (cv.fromBufferAttribute(a, o), uv.fromBufferAttribute(a, l), dv.fromBufferAttribute(a, h), c.normal = ei.getInterpolation(Mc, ja, Wa, Xa, cv, uv, dv, new _()), c.normal.dot(i.direction) > 0 && c.normal.multiplyScalar(-1));
    const u = { a: o, b: l, c: h, normal: new _(), materialIndex: 0 };
    ei.getNormal(ja, Wa, Xa, u.normal), c.face = u;
  }
  return c;
}
class _t extends Pe {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: r, heightSegments: s, depthSegments: a };
    const o = this;
    r = Math.floor(r), s = Math.floor(s), a = Math.floor(a);
    const l = [], h = [], c = [], u = [];
    let d = 0, p = 0;
    function m(g, f, v, y, x, M, b, S, w, T, C) {
      const I = M / w, A = b / T, L = M / 2, D = b / 2, U = S / 2, H = w + 1, Z = T + 1;
      let te = 0, ne = 0;
      const ve = new _();
      for (let Se = 0; Se < Z; Se++) {
        const Q = Se * A - D;
        for (let ae = 0; ae < H; ae++) {
          const de = ae * I - L;
          ve[g] = de * y, ve[f] = Q * x, ve[v] = U, h.push(ve.x, ve.y, ve.z), ve[g] = 0, ve[f] = 0, ve[v] = S > 0 ? 1 : -1, c.push(ve.x, ve.y, ve.z), u.push(ae / w), u.push(1 - Se / T), te += 1;
        }
      }
      for (let Se = 0; Se < T; Se++)
        for (let Q = 0; Q < w; Q++) {
          const ae = d + Q + H * Se, de = d + Q + H * (Se + 1), ie = d + (Q + 1) + H * (Se + 1), N = d + (Q + 1) + H * Se;
          l.push(ae, de, N), l.push(de, ie, N), ne += 6;
        }
      o.addGroup(p, ne, C), p += ne, d += te;
    }
    m("z", "y", "x", -1, -1, i, t, e, a, s, 0), m("z", "y", "x", 1, -1, i, t, -e, a, s, 1), m("x", "z", "y", 1, 1, e, i, t, r, a, 2), m("x", "z", "y", 1, -1, e, i, -t, r, a, 3), m("x", "y", "z", 1, -1, e, t, i, r, s, 4), m("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new ye(h, 3)), this.setAttribute("normal", new ye(c, 3)), this.setAttribute("uv", new ye(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new _t(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Bo(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? e[t][i] = null : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r;
    }
  }
  return e;
}
function Cn(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = Bo(n[t]);
    for (const r in i)
      e[r] = i[r];
  }
  return e;
}
function Z1(n) {
  const e = n.getRenderTarget();
  return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : it.workingColorSpace;
}
const Kt = { clone: Bo, merge: Cn };
class tt extends Xt {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { clipCullDistance: !1, multiDraw: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Bo(e.uniforms), this.uniformsGroups = function(t) {
      const i = [];
      for (let r = 0; r < t.length; r++)
        i.push(t[r].clone());
      return i;
    }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const s = this.uniforms[r].value;
      s && s.isTexture ? t.uniforms[r] = { type: "t", value: s.toJSON(e).uuid } : s && s.isColor ? t.uniforms[r] = { type: "c", value: s.getHex() } : s && s.isVector2 ? t.uniforms[r] = { type: "v2", value: s.toArray() } : s && s.isVector3 ? t.uniforms[r] = { type: "v3", value: s.toArray() } : s && s.isVector4 ? t.uniforms[r] = { type: "v4", value: s.toArray() } : s && s.isMatrix3 ? t.uniforms[r] = { type: "m3", value: s.toArray() } : s && s.isMatrix4 ? t.uniforms[r] = { type: "m4", value: s.toArray() } : t.uniforms[r] = { value: s };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const i = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class Nd extends Ue {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new fe(), this.projectionMatrix = new fe(), this.projectionMatrixInverse = new fe(), this.coordinateSystem = wa;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Hr = new _(), pv = new X(), fv = new X();
class Gt extends Nd {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = 2 * Fo * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(0.5 * ua * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return 2 * Fo * Math.atan(Math.tan(0.5 * ua * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, i) {
    Hr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Hr.x, Hr.y).multiplyScalar(-e / Hr.z), Hr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Hr.x, Hr.y).multiplyScalar(-e / Hr.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, pv, fv), t.subVectors(fv, pv);
  }
  setViewOffset(e, t, i, r, s, a) {
    this.aspect = e / t, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(0.5 * ua * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, s = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, h = a.fullHeight;
      s += a.offsetX * r / l, t -= a.offsetY * i / h, r *= a.width / l, i *= a.height / h;
    }
    const o = this.filmOffset;
    o !== 0 && (s += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const qa = -90;
class K1 extends Ue {
  constructor(e, t, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new Gt(qa, 1, e, t);
    r.layers = this.layers, this.add(r);
    const s = new Gt(qa, 1, e, t);
    s.layers = this.layers, this.add(s);
    const a = new Gt(qa, 1, e, t);
    a.layers = this.layers, this.add(a);
    const o = new Gt(qa, 1, e, t);
    o.layers = this.layers, this.add(o);
    const l = new Gt(qa, 1, e, t);
    l.layers = this.layers, this.add(l);
    const h = new Gt(qa, 1, e, t);
    h.layers = this.layers, this.add(h);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [i, r, s, a, o, l] = t;
    for (const h of t)
      this.remove(h);
    if (e === wa)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else {
      if (e !== uh)
        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    }
    for (const h of t)
      this.add(h), h.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [s, a, o, l, h, c] = this.children, u = e.getRenderTarget(), d = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const g = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, r), e.render(t, s), e.setRenderTarget(i, 1, r), e.render(t, a), e.setRenderTarget(i, 2, r), e.render(t, o), e.setRenderTarget(i, 3, r), e.render(t, l), e.setRenderTarget(i, 4, r), e.render(t, h), i.texture.generateMipmaps = g, e.setRenderTarget(i, 5, r), e.render(t, c), e.setRenderTarget(u, d, p), e.xr.enabled = m, i.texture.needsPMREMUpdate = !0;
  }
}
class ph extends pt {
  constructor(e, t, i, r, s, a, o, l, h, c) {
    super(e = e !== void 0 ? e : [], t = t !== void 0 ? t : Cr, i, r, s, a, o, l, h, c), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class J1 extends ht {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i];
    this.texture = new ph(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 && t.generateMipmaps, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Vt;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, r = new _t(5, 5, 5), s = new tt({ name: "CubemapFromEquirect", uniforms: Bo(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: Tn, blending: 0 });
    s.uniforms.tEquirect.value = t;
    const a = new ce(r, s), o = t.minFilter;
    return t.minFilter === er && (t.minFilter = Vt), new K1(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const Pp = new _(), Zw = new _(), Kw = new De();
class Li {
  constructor(e = new _(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = Pp.subVectors(i, t).cross(Zw.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(Pp), r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || Kw.getNormalMatrix(e), r = this.coplanarPoint(Pp).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -r.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ns = new rn(), wc = new _();
class jh {
  constructor(e = new Li(), t = new Li(), i = new Li(), r = new Li(), s = new Li(), a = new Li()) {
    this.planes = [e, t, i, r, s, a];
  }
  set(e, t, i, r, s, a) {
    const o = this.planes;
    return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(r), o[4].copy(s), o[5].copy(a), this;
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = 2e3) {
    const i = this.planes, r = e.elements, s = r[0], a = r[1], o = r[2], l = r[3], h = r[4], c = r[5], u = r[6], d = r[7], p = r[8], m = r[9], g = r[10], f = r[11], v = r[12], y = r[13], x = r[14], M = r[15];
    if (i[0].setComponents(l - s, d - h, f - p, M - v).normalize(), i[1].setComponents(l + s, d + h, f + p, M + v).normalize(), i[2].setComponents(l + a, d + c, f + m, M + y).normalize(), i[3].setComponents(l - a, d - c, f - m, M - y).normalize(), i[4].setComponents(l - o, d - u, f - g, M - x).normalize(), t === wa)
      i[5].setComponents(l + o, d + u, f + g, M + x).normalize();
    else {
      if (t !== uh)
        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
      i[5].setComponents(o, u, g, x).normalize();
    }
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Ns.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), Ns.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Ns);
  }
  intersectsSprite(e) {
    return Ns.center.set(0, 0, 0), Ns.radius = 0.7071067811865476, Ns.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ns);
  }
  intersectsSphere(e) {
    const t = this.planes, i = e.center, r = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(i) < r)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (wc.x = r.normal.x > 0 ? e.max.x : e.min.x, wc.y = r.normal.y > 0 ? e.max.y : e.min.y, wc.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(wc) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      if (t[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Q1() {
  let n = null, e = !1, t = null, i = null;
  function r(s, a) {
    t(s, a), i = n.requestAnimationFrame(r);
  }
  return { start: function() {
    e !== !0 && t !== null && (i = n.requestAnimationFrame(r), e = !0);
  }, stop: function() {
    n.cancelAnimationFrame(i), e = !1;
  }, setAnimationLoop: function(s) {
    t = s;
  }, setContext: function(s) {
    n = s;
  } };
}
function Jw(n) {
  const e = /* @__PURE__ */ new WeakMap();
  return { get: function(t) {
    return t.isInterleavedBufferAttribute && (t = t.data), e.get(t);
  }, remove: function(t) {
    t.isInterleavedBufferAttribute && (t = t.data);
    const i = e.get(t);
    i && (n.deleteBuffer(i.buffer), e.delete(t));
  }, update: function(t, i) {
    if (t.isGLBufferAttribute) {
      const s = e.get(t);
      return void ((!s || s.version < t.version) && e.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version }));
    }
    t.isInterleavedBufferAttribute && (t = t.data);
    const r = e.get(t);
    if (r === void 0)
      e.set(t, function(s, a) {
        const o = s.array, l = s.usage, h = o.byteLength, c = n.createBuffer();
        let u;
        if (n.bindBuffer(a, c), n.bufferData(a, o, l), s.onUploadCallback(), o instanceof Float32Array)
          u = n.FLOAT;
        else if (o instanceof Uint16Array)
          u = s.isFloat16BufferAttribute ? n.HALF_FLOAT : n.UNSIGNED_SHORT;
        else if (o instanceof Int16Array)
          u = n.SHORT;
        else if (o instanceof Uint32Array)
          u = n.UNSIGNED_INT;
        else if (o instanceof Int32Array)
          u = n.INT;
        else if (o instanceof Int8Array)
          u = n.BYTE;
        else if (o instanceof Uint8Array)
          u = n.UNSIGNED_BYTE;
        else {
          if (!(o instanceof Uint8ClampedArray))
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + o);
          u = n.UNSIGNED_BYTE;
        }
        return { buffer: c, type: u, bytesPerElement: o.BYTES_PER_ELEMENT, version: s.version, size: h };
      }(t, i));
    else if (r.version < t.version) {
      if (r.size !== t.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      (function(s, a, o) {
        const l = a.array, h = a.ut, c = a.updateRanges;
        if (n.bindBuffer(o, s), h.count === -1 && c.length === 0 && n.bufferSubData(o, 0, l), c.length !== 0) {
          for (let u = 0, d = c.length; u < d; u++) {
            const p = c[u];
            n.bufferSubData(o, p.start * l.BYTES_PER_ELEMENT, l, p.start, p.count);
          }
          a.clearUpdateRanges();
        }
        h.count !== -1 && (n.bufferSubData(o, h.offset * l.BYTES_PER_ELEMENT, l, h.offset, h.count), h.count = -1), a.onUploadCallback();
      })(r.buffer, t, i), r.version = t.version;
    }
  } };
}
class or extends Pe {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r };
    const s = e / 2, a = t / 2, o = Math.floor(i), l = Math.floor(r), h = o + 1, c = l + 1, u = e / o, d = t / l, p = [], m = [], g = [], f = [];
    for (let v = 0; v < c; v++) {
      const y = v * d - a;
      for (let x = 0; x < h; x++) {
        const M = x * u - s;
        m.push(M, -y, 0), g.push(0, 0, 1), f.push(x / o), f.push(1 - v / l);
      }
    }
    for (let v = 0; v < l; v++)
      for (let y = 0; y < o; y++) {
        const x = y + h * v, M = y + h * (v + 1), b = y + 1 + h * (v + 1), S = y + 1 + h * v;
        p.push(x, M, S), p.push(M, b, S);
      }
    this.setIndex(p), this.setAttribute("position", new ye(m, 3)), this.setAttribute("normal", new ye(g, 3)), this.setAttribute("uv", new ye(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new or(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
const ke = { alphahash_fragment: `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, alphahash_pars_fragment: `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, alphatest_fragment: `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, batching_pars_vertex: `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, batching_vertex: `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, begin_vertex: `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, bsdfs: `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( batchId );
	vColor.xyz *= batchingColor.xyz;
#endif`, common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", colorspace_pars_fragment: `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, envmap_physical_pars_fragment: `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, map_particle_pars_fragment: `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, morphinstance_vertex: `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, morphcolor_vertex: `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, normal_fragment_maps: `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, opaque_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, uv_pars_fragment: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_pars_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}` }, xe = { common: { diffuse: { value: new oe(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new De() }, alphaMap: { value: null }, alphaMapTransform: { value: new De() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new De() } }, envmap: { envMap: { value: null }, envMapRotation: { value: new De() }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new De() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new De() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new De() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new De() }, normalScale: { value: new X(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new De() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new De() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new De() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new De() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new oe(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new oe(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new De() }, alphaTest: { value: 0 }, uvTransform: { value: new De() } }, sprite: { diffuse: { value: new oe(16777215) }, opacity: { value: 1 }, center: { value: new X(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new De() }, alphaMap: { value: null }, alphaMapTransform: { value: new De() }, alphaTest: { value: 0 } } }, In = { basic: { uniforms: Cn([xe.common, xe.specularmap, xe.envmap, xe.aomap, xe.lightmap, xe.fog]), vertexShader: ke.meshbasic_vert, fragmentShader: ke.meshbasic_frag }, lambert: { uniforms: Cn([xe.common, xe.specularmap, xe.envmap, xe.aomap, xe.lightmap, xe.emissivemap, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.fog, xe.lights, { emissive: { value: new oe(0) } }]), vertexShader: ke.meshlambert_vert, fragmentShader: ke.meshlambert_frag }, phong: { uniforms: Cn([xe.common, xe.specularmap, xe.envmap, xe.aomap, xe.lightmap, xe.emissivemap, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.fog, xe.lights, { emissive: { value: new oe(0) }, specular: { value: new oe(1118481) }, shininess: { value: 30 } }]), vertexShader: ke.meshphong_vert, fragmentShader: ke.meshphong_frag }, standard: { uniforms: Cn([xe.common, xe.envmap, xe.aomap, xe.lightmap, xe.emissivemap, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.roughnessmap, xe.metalnessmap, xe.fog, xe.lights, { emissive: { value: new oe(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: ke.meshphysical_vert, fragmentShader: ke.meshphysical_frag }, toon: { uniforms: Cn([xe.common, xe.aomap, xe.lightmap, xe.emissivemap, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.gradientmap, xe.fog, xe.lights, { emissive: { value: new oe(0) } }]), vertexShader: ke.meshtoon_vert, fragmentShader: ke.meshtoon_frag }, matcap: { uniforms: Cn([xe.common, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.fog, { matcap: { value: null } }]), vertexShader: ke.meshmatcap_vert, fragmentShader: ke.meshmatcap_frag }, points: { uniforms: Cn([xe.points, xe.fog]), vertexShader: ke.points_vert, fragmentShader: ke.points_frag }, dashed: { uniforms: Cn([xe.common, xe.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: ke.linedashed_vert, fragmentShader: ke.linedashed_frag }, depth: { uniforms: Cn([xe.common, xe.displacementmap]), vertexShader: ke.depth_vert, fragmentShader: ke.depth_frag }, normal: { uniforms: Cn([xe.common, xe.bumpmap, xe.normalmap, xe.displacementmap, { opacity: { value: 1 } }]), vertexShader: ke.meshnormal_vert, fragmentShader: ke.meshnormal_frag }, sprite: { uniforms: Cn([xe.sprite, xe.fog]), vertexShader: ke.sprite_vert, fragmentShader: ke.sprite_frag }, background: { uniforms: { uvTransform: { value: new De() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: ke.background_vert, fragmentShader: ke.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new De() } }, vertexShader: ke.backgroundCube_vert, fragmentShader: ke.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: ke.cube_vert, fragmentShader: ke.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: ke.equirect_vert, fragmentShader: ke.equirect_frag }, distanceRGBA: { uniforms: Cn([xe.common, xe.displacementmap, { referencePosition: { value: new _() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: ke.distanceRGBA_vert, fragmentShader: ke.distanceRGBA_frag }, shadow: { uniforms: Cn([xe.lights, xe.fog, { color: { value: new oe(0) }, opacity: { value: 1 } }]), vertexShader: ke.shadow_vert, fragmentShader: ke.shadow_frag } };
In.physical = { uniforms: Cn([In.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new De() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new De() }, clearcoatNormalScale: { value: new X(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new De() }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new De() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new De() }, sheen: { value: 0 }, sheenColor: { value: new oe(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new De() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new De() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new De() }, transmissionSamplerSize: { value: new X() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new De() }, attenuationDistance: { value: 0 }, attenuationColor: { value: new oe(0) }, specularColor: { value: new oe(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new De() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new De() }, anisotropyVector: { value: new X() }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new De() } }]), vertexShader: ke.meshphysical_vert, fragmentShader: ke.meshphysical_frag };
const _c = { r: 0, b: 0, g: 0 }, Ds = new gt(), Qw = new fe();
function $w(n, e, t, i, r, s, a) {
  const o = new oe(0);
  let l, h, c = s === !0 ? 0 : 1, u = null, d = 0, p = null;
  function m(f) {
    let v = f.isScene === !0 ? f.background : null;
    return v && v.isTexture && (v = (f.backgroundBlurriness > 0 ? t : e).get(v)), v;
  }
  function g(f, v) {
    f.getRGB(_c, Z1(n)), i.buffers.color.setClear(_c.r, _c.g, _c.b, v, a);
  }
  return { getClearColor: function() {
    return o;
  }, setClearColor: function(f, v = 1) {
    o.set(f), c = v, g(o, c);
  }, getClearAlpha: function() {
    return c;
  }, setClearAlpha: function(f) {
    c = f, g(o, c);
  }, render: function(f) {
    let v = !1;
    const y = m(f);
    y === null ? g(o, c) : y && y.isColor && (g(y, 1), v = !0);
    const x = n.xr.getEnvironmentBlendMode();
    x === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : x === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (n.autoClear || v) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
  }, addToRenderList: function(f, v) {
    const y = m(v);
    y && (y.isCubeTexture || y.mapping === $o) ? (h === void 0 && (h = new ce(new _t(1, 1, 1), new tt({ name: "BackgroundCubeMaterial", uniforms: Bo(In.backgroundCube.uniforms), vertexShader: In.backgroundCube.vertexShader, fragmentShader: In.backgroundCube.fragmentShader, side: Tn, depthTest: !1, depthWrite: !1, fog: !1 })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(x, M, b) {
      this.matrixWorld.copyPosition(b.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), r.update(h)), Ds.copy(v.backgroundRotation), Ds.x *= -1, Ds.y *= -1, Ds.z *= -1, y.isCubeTexture && y.isRenderTargetTexture === !1 && (Ds.y *= -1, Ds.z *= -1), h.material.uniforms.envMap.value = y, h.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(Qw.makeRotationFromEuler(Ds)), h.material.toneMapped = it.getTransfer(y.colorSpace) !== ft, u === y && d === y.version && p === n.toneMapping || (h.material.needsUpdate = !0, u = y, d = y.version, p = n.toneMapping), h.layers.enableAll(), f.unshift(h, h.geometry, h.material, 0, 0, null)) : y && y.isTexture && (l === void 0 && (l = new ce(new or(2, 2), new tt({ name: "BackgroundMaterial", uniforms: Bo(In.background.uniforms), vertexShader: In.background.vertexShader, fragmentShader: In.background.fragmentShader, side: Mi, depthTest: !1, depthWrite: !1, fog: !1 })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), r.update(l)), l.material.uniforms.t2D.value = y, l.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, l.material.toneMapped = it.getTransfer(y.colorSpace) !== ft, y.matrixAutoUpdate === !0 && y.updateMatrix(), l.material.uniforms.uvTransform.value.copy(y.matrix), u === y && d === y.version && p === n.toneMapping || (l.material.needsUpdate = !0, u = y, d = y.version, p = n.toneMapping), l.layers.enableAll(), f.unshift(l, l.geometry, l.material, 0, 0, null));
  } };
}
function e_(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS), i = {}, r = h(null);
  let s = r, a = !1;
  function o(v) {
    return n.bindVertexArray(v);
  }
  function l(v) {
    return n.deleteVertexArray(v);
  }
  function h(v) {
    const y = [], x = [], M = [];
    for (let b = 0; b < t; b++)
      y[b] = 0, x[b] = 0, M[b] = 0;
    return { geometry: null, program: null, wireframe: !1, newAttributes: y, enabledAttributes: x, attributeDivisors: M, object: v, attributes: {}, index: null };
  }
  function c() {
    const v = s.newAttributes;
    for (let y = 0, x = v.length; y < x; y++)
      v[y] = 0;
  }
  function u(v) {
    d(v, 0);
  }
  function d(v, y) {
    const x = s.newAttributes, M = s.enabledAttributes, b = s.attributeDivisors;
    x[v] = 1, M[v] === 0 && (n.enableVertexAttribArray(v), M[v] = 1), b[v] !== y && (n.vertexAttribDivisor(v, y), b[v] = y);
  }
  function p() {
    const v = s.newAttributes, y = s.enabledAttributes;
    for (let x = 0, M = y.length; x < M; x++)
      y[x] !== v[x] && (n.disableVertexAttribArray(x), y[x] = 0);
  }
  function m(v, y, x, M, b, S, w) {
    w === !0 ? n.vertexAttribIPointer(v, y, x, b, S) : n.vertexAttribPointer(v, y, x, M, b, S);
  }
  function g() {
    f(), a = !0, s !== r && (s = r, o(s.object));
  }
  function f() {
    r.geometry = null, r.program = null, r.wireframe = !1;
  }
  return { setup: function(v, y, x, M, b) {
    let S = !1;
    const w = function(T, C, I) {
      const A = I.wireframe === !0;
      let L = i[T.id];
      L === void 0 && (L = {}, i[T.id] = L);
      let D = L[C.id];
      D === void 0 && (D = {}, L[C.id] = D);
      let U = D[A];
      return U === void 0 && (U = h(n.createVertexArray()), D[A] = U), U;
    }(M, x, y);
    s !== w && (s = w, o(s.object)), S = function(T, C, I, A) {
      const L = s.attributes, D = C.attributes;
      let U = 0;
      const H = I.getAttributes();
      for (const Z in H)
        if (H[Z].location >= 0) {
          const te = L[Z];
          let ne = D[Z];
          if (ne === void 0 && (Z === "instanceMatrix" && T.instanceMatrix && (ne = T.instanceMatrix), Z === "instanceColor" && T.instanceColor && (ne = T.instanceColor)), te === void 0 || te.attribute !== ne || ne && te.data !== ne.data)
            return !0;
          U++;
        }
      return s.attributesNum !== U || s.index !== A;
    }(v, M, x, b), S && function(T, C, I, A) {
      const L = {}, D = C.attributes;
      let U = 0;
      const H = I.getAttributes();
      for (const Z in H)
        if (H[Z].location >= 0) {
          let te = D[Z];
          te === void 0 && (Z === "instanceMatrix" && T.instanceMatrix && (te = T.instanceMatrix), Z === "instanceColor" && T.instanceColor && (te = T.instanceColor));
          const ne = {};
          ne.attribute = te, te && te.data && (ne.data = te.data), L[Z] = ne, U++;
        }
      s.attributes = L, s.attributesNum = U, s.index = A;
    }(v, M, x, b), b !== null && e.update(b, n.ELEMENT_ARRAY_BUFFER), (S || a) && (a = !1, function(T, C, I, A) {
      c();
      const L = A.attributes, D = I.getAttributes(), U = C.defaultAttributeValues;
      for (const H in D) {
        const Z = D[H];
        if (Z.location >= 0) {
          let te = L[H];
          if (te === void 0 && (H === "instanceMatrix" && T.instanceMatrix && (te = T.instanceMatrix), H === "instanceColor" && T.instanceColor && (te = T.instanceColor)), te !== void 0) {
            const ne = te.normalized, ve = te.itemSize, Se = e.get(te);
            if (Se === void 0)
              continue;
            const Q = Se.buffer, ae = Se.type, de = Se.bytesPerElement, ie = ae === n.INT || ae === n.UNSIGNED_INT || te.gpuType === gg;
            if (te.isInterleavedBufferAttribute) {
              const N = te.data, R = N.stride, j = te.offset;
              if (N.isInstancedInterleavedBuffer) {
                for (let K = 0; K < Z.locationSize; K++)
                  d(Z.location + K, N.meshPerAttribute);
                T.isInstancedMesh !== !0 && A.vt === void 0 && (A.vt = N.meshPerAttribute * N.count);
              } else
                for (let K = 0; K < Z.locationSize; K++)
                  u(Z.location + K);
              n.bindBuffer(n.ARRAY_BUFFER, Q);
              for (let K = 0; K < Z.locationSize; K++)
                m(Z.location + K, ve / Z.locationSize, ae, ne, R * de, (j + ve / Z.locationSize * K) * de, ie);
            } else {
              if (te.isInstancedBufferAttribute) {
                for (let N = 0; N < Z.locationSize; N++)
                  d(Z.location + N, te.meshPerAttribute);
                T.isInstancedMesh !== !0 && A.vt === void 0 && (A.vt = te.meshPerAttribute * te.count);
              } else
                for (let N = 0; N < Z.locationSize; N++)
                  u(Z.location + N);
              n.bindBuffer(n.ARRAY_BUFFER, Q);
              for (let N = 0; N < Z.locationSize; N++)
                m(Z.location + N, ve / Z.locationSize, ae, ne, ve * de, ve / Z.locationSize * N * de, ie);
            }
          } else if (U !== void 0) {
            const ne = U[H];
            if (ne !== void 0)
              switch (ne.length) {
                case 2:
                  n.vertexAttrib2fv(Z.location, ne);
                  break;
                case 3:
                  n.vertexAttrib3fv(Z.location, ne);
                  break;
                case 4:
                  n.vertexAttrib4fv(Z.location, ne);
                  break;
                default:
                  n.vertexAttrib1fv(Z.location, ne);
              }
          }
        }
      }
      p();
    }(v, y, x, M), b !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(b).buffer));
  }, reset: g, resetDefaultState: f, dispose: function() {
    g();
    for (const v in i) {
      const y = i[v];
      for (const x in y) {
        const M = y[x];
        for (const b in M)
          l(M[b].object), delete M[b];
        delete y[x];
      }
      delete i[v];
    }
  }, releaseStatesOfGeometry: function(v) {
    if (i[v.id] === void 0)
      return;
    const y = i[v.id];
    for (const x in y) {
      const M = y[x];
      for (const b in M)
        l(M[b].object), delete M[b];
      delete y[x];
    }
    delete i[v.id];
  }, releaseStatesOfProgram: function(v) {
    for (const y in i) {
      const x = i[y];
      if (x[v.id] === void 0)
        continue;
      const M = x[v.id];
      for (const b in M)
        l(M[b].object), delete M[b];
      delete x[v.id];
    }
  }, initAttributes: c, enableAttribute: u, disableUnusedAttributes: p };
}
function t_(n, e, t) {
  let i;
  function r(s, a, o) {
    o !== 0 && (n.drawArraysInstanced(i, s, a, o), t.update(a, i, o));
  }
  this.setMode = function(s) {
    i = s;
  }, this.render = function(s, a) {
    n.drawArrays(i, s, a), t.update(a, i, 1);
  }, this.renderInstances = r, this.renderMultiDraw = function(s, a, o) {
    if (o === 0)
      return;
    const l = e.get("WEBGL_multi_draw");
    if (l === null)
      for (let h = 0; h < o; h++)
        this.render(s[h], a[h]);
    else {
      l.multiDrawArraysWEBGL(i, s, 0, a, 0, o);
      let h = 0;
      for (let c = 0; c < o; c++)
        h += a[c];
      t.update(h, i, 1);
    }
  }, this.renderMultiDrawInstances = function(s, a, o, l) {
    if (o === 0)
      return;
    const h = e.get("WEBGL_multi_draw");
    if (h === null)
      for (let c = 0; c < s.length; c++)
        r(s[c], a[c], l[c]);
    else {
      h.multiDrawArraysInstancedWEBGL(i, s, 0, a, 0, l, 0, o);
      let c = 0;
      for (let u = 0; u < o; u++)
        c += a[u];
      for (let u = 0; u < l.length; u++)
        t.update(c, i, l[u]);
    }
  };
}
function n_(n, e, t, i) {
  let r;
  function s(u) {
    if (u === "highp") {
      if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
        return "highp";
      u = "mediump";
    }
    return u === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let a = t.precision !== void 0 ? t.precision : "highp";
  const o = s(a);
  o !== a && (a = o);
  const l = t.logarithmicDepthBuffer === !0, h = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), c = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  return { isWebGL2: !0, getMaxAnisotropy: function() {
    if (r !== void 0)
      return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const u = e.get("EXT_texture_filter_anisotropic");
      r = n.getParameter(u.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }, getMaxPrecision: s, textureFormatReadable: function(u) {
    return u === yi || i.convert(u) === n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT);
  }, textureTypeReadable: function(u) {
    const d = u === Ht && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(u !== ba && i.convert(u) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && u !== ni && !d);
  }, precision: a, logarithmicDepthBuffer: l, maxTextures: h, maxVertexTextures: c, maxTextureSize: n.getParameter(n.MAX_TEXTURE_SIZE), maxCubemapSize: n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), maxAttributes: n.getParameter(n.MAX_VERTEX_ATTRIBS), maxVertexUniforms: n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), maxVaryings: n.getParameter(n.MAX_VARYING_VECTORS), maxFragmentUniforms: n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures: c > 0, maxSamples: n.getParameter(n.MAX_SAMPLES) };
}
function i_(n) {
  const e = this;
  let t = null, i = 0, r = !1, s = !1;
  const a = new Li(), o = new De(), l = { value: null, needsUpdate: !1 };
  function h(c, u, d, p) {
    const m = c !== null ? c.length : 0;
    let g = null;
    if (m !== 0) {
      if (g = l.value, p !== !0 || g === null) {
        const f = d + 4 * m, v = u.matrixWorldInverse;
        o.getNormalMatrix(v), (g === null || g.length < f) && (g = new Float32Array(f));
        for (let y = 0, x = d; y !== m; ++y, x += 4)
          a.copy(c[y]).applyMatrix4(v, o), a.normal.toArray(g, x), g[x + 3] = a.constant;
      }
      l.value = g, l.needsUpdate = !0;
    }
    return e.numPlanes = m, e.numIntersection = 0, g;
  }
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(c, u) {
    const d = c.length !== 0 || u || i !== 0 || r;
    return r = u, i = c.length, d;
  }, this.beginShadows = function() {
    s = !0, h(null);
  }, this.endShadows = function() {
    s = !1;
  }, this.setGlobalState = function(c, u) {
    t = h(c, u, 0);
  }, this.setState = function(c, u, d) {
    const p = c.clippingPlanes, m = c.clipIntersection, g = c.clipShadows, f = n.get(c);
    if (!r || p === null || p.length === 0 || s && !g)
      s ? h(null) : function() {
        l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
      }();
    else {
      const v = s ? 0 : i, y = 4 * v;
      let x = f.clippingState || null;
      l.value = x, x = h(p, u, y, d);
      for (let M = 0; M !== y; ++M)
        x[M] = t[M];
      f.clippingState = x, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += v;
    }
  };
}
function r_(n) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(r, s) {
    return s === Lo ? r.mapping = Cr : s === sh && (r.mapping = ps), r;
  }
  function i(r) {
    const s = r.target;
    s.removeEventListener("dispose", i);
    const a = e.get(s);
    a !== void 0 && (e.delete(s), a.dispose());
  }
  return { get: function(r) {
    if (r && r.isTexture) {
      const s = r.mapping;
      if (s === Lo || s === sh) {
        if (e.has(r))
          return t(e.get(r).texture, r.mapping);
        {
          const a = r.image;
          if (a && a.height > 0) {
            const o = new J1(a.height);
            return o.fromEquirectangularTexture(n, r), e.set(r, o), r.addEventListener("dispose", i), t(o.texture, r.mapping);
          }
          return null;
        }
      }
    }
    return r;
  }, dispose: function() {
    e = /* @__PURE__ */ new WeakMap();
  } };
}
class _a extends Nd {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, i, r, s, a) {
    this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = i - e, a = i + e, o = r + t, l = r - t;
    if (this.view !== null && this.view.enabled) {
      const h = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += h * this.view.offsetX, a = s + h * this.view.width, o -= c * this.view.offsetY, l = o - c * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const mv = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Tc = 20, Rp = new _a(), gv = new oe();
let Ip = null, Lp = 0, Np = 0, Dp = !1;
const Js = (1 + Math.sqrt(5)) / 2, Ya = 1 / Js, vv = [new _(-Js, Ya, 0), new _(Js, Ya, 0), new _(-Ya, 0, Js), new _(Ya, 0, Js), new _(0, Js, -Ya), new _(0, Js, Ya), new _(-1, 1, -1), new _(1, 1, -1), new _(-1, 1, 1), new _(1, 1, 1)];
class Sm {
  constructor(e) {
    this.gt = e, this.wt = null, this.Mt = 0, this._t = 0, this.xt = [], this.yt = [], this.St = [], this.bt = null, this.At = null, this.Et = null, this.Tt(this.bt);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    Ip = this.gt.getRenderTarget(), Lp = this.gt.getActiveCubeFace(), Np = this.gt.getActiveMipmapLevel(), Dp = this.gt.xr.enabled, this.gt.xr.enabled = !1, this.Ct(256);
    const s = this.Pt();
    return s.depthBuffer = !0, this.Lt(e, i, r, s), t > 0 && this.Nt(s, 0, 0, t), this.Rt(s), this.Dt(s), s;
  }
  fromEquirectangular(e, t = null) {
    return this.It(e, t);
  }
  fromCubemap(e, t = null) {
    return this.It(e, t);
  }
  compileCubemapShader() {
    this.At === null && (this.At = Mv(), this.Tt(this.At));
  }
  compileEquirectangularShader() {
    this.Et === null && (this.Et = xv(), this.Tt(this.Et));
  }
  dispose() {
    this.Ut(), this.At !== null && this.At.dispose(), this.Et !== null && this.Et.dispose();
  }
  Ct(e) {
    this.Mt = Math.floor(Math.log2(e)), this._t = Math.pow(2, this.Mt);
  }
  Ut() {
    this.bt !== null && this.bt.dispose(), this.wt !== null && this.wt.dispose();
    for (let e = 0; e < this.xt.length; e++)
      this.xt[e].dispose();
  }
  Dt(e) {
    this.gt.setRenderTarget(Ip, Lp, Np), this.gt.xr.enabled = Dp, e.scissorTest = !1, Ec(e, 0, 0, e.width, e.height);
  }
  It(e, t) {
    e.mapping === Cr || e.mapping === ps ? this.Ct(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this.Ct(e.image.width / 4), Ip = this.gt.getRenderTarget(), Lp = this.gt.getActiveCubeFace(), Np = this.gt.getActiveMipmapLevel(), Dp = this.gt.xr.enabled, this.gt.xr.enabled = !1;
    const i = t || this.Pt();
    return this.Ot(e, i), this.Rt(i), this.Dt(i), i;
  }
  Pt() {
    const e = 3 * Math.max(this._t, 112), t = 4 * this._t, i = { magFilter: Vt, minFilter: Vt, generateMipmaps: !1, type: Ht, format: yi, colorSpace: Jt, depthBuffer: !1 }, r = yv(e, t, i);
    if (this.wt === null || this.wt.width !== e || this.wt.height !== t) {
      this.wt !== null && this.Ut(), this.wt = yv(e, t, i);
      const { Mt: s } = this;
      ({ sizeLods: this.yt, lodPlanes: this.xt, sigmas: this.St } = function(a) {
        const o = [], l = [], h = [];
        let c = a;
        const u = a - 4 + 1 + mv.length;
        for (let d = 0; d < u; d++) {
          const p = Math.pow(2, c);
          l.push(p);
          let m = 1 / p;
          d > a - 4 ? m = mv[d - a + 4 - 1] : d === 0 && (m = 0), h.push(m);
          const g = 1 / (p - 2), f = -g, v = 1 + g, y = [f, f, v, f, v, v, f, f, v, v, f, v], x = 6, M = 6, b = 3, S = 2, w = 1, T = new Float32Array(b * M * x), C = new Float32Array(S * M * x), I = new Float32Array(w * M * x);
          for (let L = 0; L < x; L++) {
            const D = L % 3 * 2 / 3 - 1, U = L > 2 ? 0 : -1, H = [D, U, 0, D + 2 / 3, U, 0, D + 2 / 3, U + 1, 0, D, U, 0, D + 2 / 3, U + 1, 0, D, U + 1, 0];
            T.set(H, b * M * L), C.set(y, S * M * L);
            const Z = [L, L, L, L, L, L];
            I.set(Z, w * M * L);
          }
          const A = new Pe();
          A.setAttribute("position", new Ke(T, b)), A.setAttribute("uv", new Ke(C, S)), A.setAttribute("faceIndex", new Ke(I, w)), o.push(A), c > 4 && c--;
        }
        return { lodPlanes: o, sizeLods: l, sigmas: h };
      }(s)), this.bt = function(a, o, l) {
        const h = new Float32Array(Tc), c = new _(0, 1, 0);
        return new tt({ name: "SphericalGaussianBlur", defines: { n: Tc, CUBEUV_TEXEL_WIDTH: 1 / o, CUBEUV_TEXEL_HEIGHT: 1 / l, CUBEUV_MAX_MIP: `${a}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: h }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: c } }, vertexShader: Pg(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: 0, depthTest: !1, depthWrite: !1 });
      }(s, e, t);
    }
    return r;
  }
  Tt(e) {
    const t = new ce(this.xt[0], e);
    this.gt.compile(t, Rp);
  }
  Lt(e, t, i, r) {
    const s = new Gt(90, 1, t, i), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], l = this.gt, h = l.autoClear, c = l.toneMapping;
    l.getClearColor(gv), l.toneMapping = $i, l.autoClear = !1;
    const u = new Wt({ name: "PMREM.Background", side: Tn, depthWrite: !1, depthTest: !1 }), d = new ce(new _t(), u);
    let p = !1;
    const m = e.background;
    m ? m.isColor && (u.color.copy(m), e.background = null, p = !0) : (u.color.copy(gv), p = !0);
    for (let g = 0; g < 6; g++) {
      const f = g % 3;
      f === 0 ? (s.up.set(0, a[g], 0), s.lookAt(o[g], 0, 0)) : f === 1 ? (s.up.set(0, 0, a[g]), s.lookAt(0, o[g], 0)) : (s.up.set(0, a[g], 0), s.lookAt(0, 0, o[g]));
      const v = this._t;
      Ec(r, f * v, g > 2 ? v : 0, v, v), l.setRenderTarget(r), p && l.render(d, s), l.render(e, s);
    }
    d.geometry.dispose(), d.material.dispose(), l.toneMapping = c, l.autoClear = h, e.background = m;
  }
  Ot(e, t) {
    const i = this.gt, r = e.mapping === Cr || e.mapping === ps;
    r ? (this.At === null && (this.At = Mv()), this.At.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this.Et === null && (this.Et = xv());
    const s = r ? this.At : this.Et, a = new ce(this.xt[0], s);
    s.uniforms.envMap.value = e;
    const o = this._t;
    Ec(t, 0, 0, 3 * o, 2 * o), i.setRenderTarget(t), i.render(a, Rp);
  }
  Rt(e) {
    const t = this.gt, i = t.autoClear;
    t.autoClear = !1;
    const r = this.xt.length;
    for (let s = 1; s < r; s++) {
      const a = Math.sqrt(this.St[s] * this.St[s] - this.St[s - 1] * this.St[s - 1]), o = vv[(r - s - 1) % vv.length];
      this.Nt(e, s - 1, s, a, o);
    }
    t.autoClear = i;
  }
  Nt(e, t, i, r, s) {
    const a = this.wt;
    this.kt(e, a, t, i, r, "latitudinal", s), this.kt(a, e, i, i, r, "longitudinal", s);
  }
  kt(e, t, i, r, s, a, o) {
    const l = this.gt, h = this.bt, c = new ce(this.xt[r], h), u = h.uniforms, d = this.yt[i] - 1, p = isFinite(s) ? Math.PI / (2 * d) : 2 * Math.PI / 39, m = s / p, g = isFinite(s) ? 1 + Math.floor(3 * m) : Tc, f = [];
    let v = 0;
    for (let M = 0; M < Tc; ++M) {
      const b = M / m, S = Math.exp(-b * b / 2);
      f.push(S), M === 0 ? v += S : M < g && (v += 2 * S);
    }
    for (let M = 0; M < f.length; M++)
      f[M] = f[M] / v;
    u.envMap.value = e.texture, u.samples.value = g, u.weights.value = f, u.latitudinal.value = a === "latitudinal", o && (u.poleAxis.value = o);
    const { Mt: y } = this;
    u.dTheta.value = p, u.mipInt.value = y - i;
    const x = this.yt[r];
    Ec(t, 3 * x * (r > y - 4 ? r - y + 4 : 0), 4 * (this._t - x), 3 * x, 2 * x), l.setRenderTarget(t), l.render(c, Rp);
  }
}
function yv(n, e, t) {
  const i = new ht(n, e, t);
  return i.texture.mapping = $o, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function Ec(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function xv() {
  return new tt({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: Pg(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1 });
}
function Mv() {
  return new tt({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: Pg(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1 });
}
function Pg() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function s_(n) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function i(r) {
    const s = r.target;
    s.removeEventListener("dispose", i);
    const a = e.get(s);
    a !== void 0 && (e.delete(s), a.dispose());
  }
  return { get: function(r) {
    if (r && r.isTexture) {
      const s = r.mapping, a = s === Lo || s === sh, o = s === Cr || s === ps;
      if (a || o) {
        let l = e.get(r);
        const h = l !== void 0 ? l.texture.pmremVersion : 0;
        if (r.isRenderTargetTexture && r.pmremVersion !== h)
          return t === null && (t = new Sm(n)), l = a ? t.fromEquirectangular(r, l) : t.fromCubemap(r, l), l.texture.pmremVersion = r.pmremVersion, e.set(r, l), l.texture;
        if (l !== void 0)
          return l.texture;
        {
          const c = r.image;
          return a && c && c.height > 0 || o && c && function(u) {
            let d = 0;
            const p = 6;
            for (let m = 0; m < p; m++)
              u[m] !== void 0 && d++;
            return d === p;
          }(c) ? (t === null && (t = new Sm(n)), l = a ? t.fromEquirectangular(r) : t.fromCubemap(r), l.texture.pmremVersion = r.pmremVersion, e.set(r, l), r.addEventListener("dispose", i), l.texture) : null;
        }
      }
    }
    return r;
  }, dispose: function() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  } };
}
function a_(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0)
      return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return e[i] = r, r;
  }
  return { has: function(i) {
    return t(i) !== null;
  }, init: function() {
    t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
  }, get: function(i) {
    const r = t(i);
    return r === null && Ag("THREE.WebGLRenderer: " + i + " extension not supported."), r;
  } };
}
function o_(n, e, t, i) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function a(l) {
    const h = l.target;
    h.index !== null && e.remove(h.index);
    for (const u in h.attributes)
      e.remove(h.attributes[u]);
    for (const u in h.morphAttributes) {
      const d = h.morphAttributes[u];
      for (let p = 0, m = d.length; p < m; p++)
        e.remove(d[p]);
    }
    h.removeEventListener("dispose", a), delete r[h.id];
    const c = s.get(h);
    c && (e.remove(c), s.delete(h)), i.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === !0 && delete h.vt, t.memory.geometries--;
  }
  function o(l) {
    const h = [], c = l.index, u = l.attributes.position;
    let d = 0;
    if (c !== null) {
      const g = c.array;
      d = c.version;
      for (let f = 0, v = g.length; f < v; f += 3) {
        const y = g[f + 0], x = g[f + 1], M = g[f + 2];
        h.push(y, x, x, M, M, y);
      }
    } else {
      if (u === void 0)
        return;
      {
        const g = u.array;
        d = u.version;
        for (let f = 0, v = g.length / 3 - 1; f < v; f += 3) {
          const y = f + 0, x = f + 1, M = f + 2;
          h.push(y, x, x, M, M, y);
        }
      }
    }
    const p = new (j1(h) ? Cg : Ld)(h, 1);
    p.version = d;
    const m = s.get(l);
    m && e.remove(m), s.set(l, p);
  }
  return { get: function(l, h) {
    return r[h.id] === !0 || (h.addEventListener("dispose", a), r[h.id] = !0, t.memory.geometries++), h;
  }, update: function(l) {
    const h = l.attributes;
    for (const u in h)
      e.update(h[u], n.ARRAY_BUFFER);
    const c = l.morphAttributes;
    for (const u in c) {
      const d = c[u];
      for (let p = 0, m = d.length; p < m; p++)
        e.update(d[p], n.ARRAY_BUFFER);
    }
  }, getWireframeAttribute: function(l) {
    const h = s.get(l);
    if (h) {
      const c = l.index;
      c !== null && h.version < c.version && o(l);
    } else
      o(l);
    return s.get(l);
  } };
}
function l_(n, e, t) {
  let i, r, s;
  function a(o, l, h) {
    h !== 0 && (n.drawElementsInstanced(i, l, r, o * s, h), t.update(l, i, h));
  }
  this.setMode = function(o) {
    i = o;
  }, this.setIndex = function(o) {
    r = o.type, s = o.bytesPerElement;
  }, this.render = function(o, l) {
    n.drawElements(i, l, r, o * s), t.update(l, i, 1);
  }, this.renderInstances = a, this.renderMultiDraw = function(o, l, h) {
    if (h === 0)
      return;
    const c = e.get("WEBGL_multi_draw");
    if (c === null)
      for (let u = 0; u < h; u++)
        this.render(o[u] / s, l[u]);
    else {
      c.multiDrawElementsWEBGL(i, l, 0, r, o, 0, h);
      let u = 0;
      for (let d = 0; d < h; d++)
        u += l[d];
      t.update(u, i, 1);
    }
  }, this.renderMultiDrawInstances = function(o, l, h, c) {
    if (h === 0)
      return;
    const u = e.get("WEBGL_multi_draw");
    if (u === null)
      for (let d = 0; d < o.length; d++)
        a(o[d] / s, l[d], c[d]);
    else {
      u.multiDrawElementsInstancedWEBGL(i, l, 0, r, o, 0, c, 0, h);
      let d = 0;
      for (let p = 0; p < h; p++)
        d += l[p];
      for (let p = 0; p < c.length; p++)
        t.update(d, i, c[p]);
    }
  };
}
function h_(n) {
  const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function() {
    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
  }, update: function(t, i, r) {
    switch (e.calls++, i) {
      case n.TRIANGLES:
        e.triangles += r * (t / 3);
        break;
      case n.LINES:
        e.lines += r * (t / 2);
        break;
      case n.LINE_STRIP:
        e.lines += r * (t - 1);
        break;
      case n.LINE_LOOP:
        e.lines += r * t;
        break;
      case n.POINTS:
        e.points += r * t;
    }
  } };
}
function c_(n, e, t) {
  const i = /* @__PURE__ */ new WeakMap(), r = new Ve();
  return { update: function(s, a, o) {
    const l = s.morphTargetInfluences, h = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, c = h !== void 0 ? h.length : 0;
    let u = i.get(a);
    if (u === void 0 || u.count !== c) {
      u !== void 0 && u.texture.dispose();
      const d = a.morphAttributes.position !== void 0, p = a.morphAttributes.normal !== void 0, m = a.morphAttributes.color !== void 0, g = a.morphAttributes.position || [], f = a.morphAttributes.normal || [], v = a.morphAttributes.color || [];
      let y = 0;
      d === !0 && (y = 1), p === !0 && (y = 2), m === !0 && (y = 3);
      let x = a.attributes.position.count * y, M = 1;
      x > e.maxTextureSize && (M = Math.ceil(x / e.maxTextureSize), x = e.maxTextureSize);
      const b = new Float32Array(x * M * 4 * c), S = new Gu(b, x, M, c);
      S.type = ni, S.needsUpdate = !0;
      const w = 4 * y;
      for (let T = 0; T < c; T++) {
        const C = g[T], I = f[T], A = v[T], L = x * M * 4 * T;
        for (let D = 0; D < C.count; D++) {
          const U = D * w;
          d === !0 && (r.fromBufferAttribute(C, D), b[L + U + 0] = r.x, b[L + U + 1] = r.y, b[L + U + 2] = r.z, b[L + U + 3] = 0), p === !0 && (r.fromBufferAttribute(I, D), b[L + U + 4] = r.x, b[L + U + 5] = r.y, b[L + U + 6] = r.z, b[L + U + 7] = 0), m === !0 && (r.fromBufferAttribute(A, D), b[L + U + 8] = r.x, b[L + U + 9] = r.y, b[L + U + 10] = r.z, b[L + U + 11] = A.itemSize === 4 ? r.w : 1);
        }
      }
      u = { count: c, texture: S, size: new X(x, M) }, i.set(a, u), a.addEventListener("dispose", function T() {
        S.dispose(), i.delete(a), a.removeEventListener("dispose", T);
      });
    }
    if (s.isInstancedMesh === !0 && s.morphTexture !== null)
      o.getUniforms().setValue(n, "morphTexture", s.morphTexture, t);
    else {
      let d = 0;
      for (let m = 0; m < l.length; m++)
        d += l[m];
      const p = a.morphTargetsRelative ? 1 : 1 - d;
      o.getUniforms().setValue(n, "morphTargetBaseInfluence", p), o.getUniforms().setValue(n, "morphTargetInfluences", l);
    }
    o.getUniforms().setValue(n, "morphTargetsTexture", u.texture, t), o.getUniforms().setValue(n, "morphTargetsTextureSize", u.size);
  } };
}
function u_(n, e, t, i) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(a) {
    const o = a.target;
    o.removeEventListener("dispose", s), t.remove(o.instanceMatrix), o.instanceColor !== null && t.remove(o.instanceColor);
  }
  return { update: function(a) {
    const o = i.render.frame, l = a.geometry, h = e.get(a, l);
    if (r.get(h) !== o && (e.update(h), r.set(h, o)), a.isInstancedMesh && (a.hasEventListener("dispose", s) === !1 && a.addEventListener("dispose", s), r.get(a) !== o && (t.update(a.instanceMatrix, n.ARRAY_BUFFER), a.instanceColor !== null && t.update(a.instanceColor, n.ARRAY_BUFFER), r.set(a, o))), a.isSkinnedMesh) {
      const c = a.skeleton;
      r.get(c) !== o && (c.update(), r.set(c, o));
    }
    return h;
  }, dispose: function() {
    r = /* @__PURE__ */ new WeakMap();
  } };
}
class Wh extends pt {
  constructor(e, t, i, r, s, a, o, l, h, c = 1026) {
    if (c !== Do && c !== gs)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && c === Do && (i = Sa), i === void 0 && c === gs && (i = ms), super(null, r, s, a, o, l, c, i, h), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = o !== void 0 ? o : at, this.minFilter = l !== void 0 ? l : at, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const $1 = new pt(), eM = new Wh(1, 1);
eM.compareFunction = 515;
const tM = new Gu(), nM = new bm(), iM = new ph(), bv = [], Sv = [], wv = new Float32Array(16), _v = new Float32Array(9), Tv = new Float32Array(4);
function el(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0)
    return n;
  const r = e * t;
  let s = bv[r];
  if (s === void 0 && (s = new Float32Array(r), bv[r] = s), e !== 0) {
    i.toArray(s, 0);
    for (let a = 1, o = 0; a !== e; ++a)
      o += t, n[a].toArray(s, o);
  }
  return s;
}
function sn(n, e) {
  if (n.length !== e.length)
    return !1;
  for (let t = 0, i = n.length; t < i; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}
function an(n, e) {
  for (let t = 0, i = e.length; t < i; t++)
    n[t] = e[t];
}
function Dd(n, e) {
  let t = Sv[e];
  t === void 0 && (t = new Int32Array(e), Sv[e] = t);
  for (let i = 0; i !== e; ++i)
    t[i] = n.allocateTextureUnit();
  return t;
}
function d_(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e);
}
function p_(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y || (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (sn(t, e))
      return;
    n.uniform2fv(this.addr, e), an(t, e);
  }
}
function f_(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z || (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    t[0] === e.r && t[1] === e.g && t[2] === e.b || (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (sn(t, e))
      return;
    n.uniform3fv(this.addr, e), an(t, e);
  }
}
function m_(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z && t[3] === e.w || (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (sn(t, e))
      return;
    n.uniform4fv(this.addr, e), an(t, e);
  }
}
function g_(n, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (sn(t, e))
      return;
    n.uniformMatrix2fv(this.addr, !1, e), an(t, e);
  } else {
    if (sn(t, i))
      return;
    Tv.set(i), n.uniformMatrix2fv(this.addr, !1, Tv), an(t, i);
  }
}
function v_(n, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (sn(t, e))
      return;
    n.uniformMatrix3fv(this.addr, !1, e), an(t, e);
  } else {
    if (sn(t, i))
      return;
    _v.set(i), n.uniformMatrix3fv(this.addr, !1, _v), an(t, i);
  }
}
function y_(n, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (sn(t, e))
      return;
    n.uniformMatrix4fv(this.addr, !1, e), an(t, e);
  } else {
    if (sn(t, i))
      return;
    wv.set(i), n.uniformMatrix4fv(this.addr, !1, wv), an(t, i);
  }
}
function x_(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e);
}
function M_(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y || (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (sn(t, e))
      return;
    n.uniform2iv(this.addr, e), an(t, e);
  }
}
function b_(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z || (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (sn(t, e))
      return;
    n.uniform3iv(this.addr, e), an(t, e);
  }
}
function S_(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z && t[3] === e.w || (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (sn(t, e))
      return;
    n.uniform4iv(this.addr, e), an(t, e);
  }
}
function w_(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e);
}
function __(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y || (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (sn(t, e))
      return;
    n.uniform2uiv(this.addr, e), an(t, e);
  }
}
function T_(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z || (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (sn(t, e))
      return;
    n.uniform3uiv(this.addr, e), an(t, e);
  }
}
function E_(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    t[0] === e.x && t[1] === e.y && t[2] === e.z && t[3] === e.w || (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (sn(t, e))
      return;
    n.uniform4uiv(this.addr, e), an(t, e);
  }
}
function A_(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r);
  const s = this.type === n.SAMPLER_2D_SHADOW ? eM : $1;
  t.setTexture2D(e || s, r);
}
function C_(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || nM, r);
}
function P_(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || iM, r);
}
function R_(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || tM, r);
}
function I_(n, e) {
  n.uniform1fv(this.addr, e);
}
function L_(n, e) {
  const t = el(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function N_(n, e) {
  const t = el(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function D_(n, e) {
  const t = el(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function O_(n, e) {
  const t = el(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function U_(n, e) {
  const t = el(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function F_(n, e) {
  const t = el(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function B_(n, e) {
  n.uniform1iv(this.addr, e);
}
function k_(n, e) {
  n.uniform2iv(this.addr, e);
}
function z_(n, e) {
  n.uniform3iv(this.addr, e);
}
function V_(n, e) {
  n.uniform4iv(this.addr, e);
}
function H_(n, e) {
  n.uniform1uiv(this.addr, e);
}
function G_(n, e) {
  n.uniform2uiv(this.addr, e);
}
function j_(n, e) {
  n.uniform3uiv(this.addr, e);
}
function W_(n, e) {
  n.uniform4uiv(this.addr, e);
}
function X_(n, e, t) {
  const i = this.cache, r = e.length, s = Dd(t, r);
  sn(i, s) || (n.uniform1iv(this.addr, s), an(i, s));
  for (let a = 0; a !== r; ++a)
    t.setTexture2D(e[a] || $1, s[a]);
}
function q_(n, e, t) {
  const i = this.cache, r = e.length, s = Dd(t, r);
  sn(i, s) || (n.uniform1iv(this.addr, s), an(i, s));
  for (let a = 0; a !== r; ++a)
    t.setTexture3D(e[a] || nM, s[a]);
}
function Y_(n, e, t) {
  const i = this.cache, r = e.length, s = Dd(t, r);
  sn(i, s) || (n.uniform1iv(this.addr, s), an(i, s));
  for (let a = 0; a !== r; ++a)
    t.setTextureCube(e[a] || iM, s[a]);
}
function Z_(n, e, t) {
  const i = this.cache, r = e.length, s = Dd(t, r);
  sn(i, s) || (n.uniform1iv(this.addr, s), an(i, s));
  for (let a = 0; a !== r; ++a)
    t.setTexture2DArray(e[a] || tM, s[a]);
}
class K_ {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = function(r) {
      switch (r) {
        case 5126:
          return d_;
        case 35664:
          return p_;
        case 35665:
          return f_;
        case 35666:
          return m_;
        case 35674:
          return g_;
        case 35675:
          return v_;
        case 35676:
          return y_;
        case 5124:
        case 35670:
          return x_;
        case 35667:
        case 35671:
          return M_;
        case 35668:
        case 35672:
          return b_;
        case 35669:
        case 35673:
          return S_;
        case 5125:
          return w_;
        case 36294:
          return __;
        case 36295:
          return T_;
        case 36296:
          return E_;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return A_;
        case 35679:
        case 36299:
        case 36307:
          return C_;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return P_;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return R_;
      }
    }(t.type);
  }
}
class J_ {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function(r) {
      switch (r) {
        case 5126:
          return I_;
        case 35664:
          return L_;
        case 35665:
          return N_;
        case 35666:
          return D_;
        case 35674:
          return O_;
        case 35675:
          return U_;
        case 35676:
          return F_;
        case 5124:
        case 35670:
          return B_;
        case 35667:
        case 35671:
          return k_;
        case 35668:
        case 35672:
          return z_;
        case 35669:
        case 35673:
          return V_;
        case 5125:
          return H_;
        case 36294:
          return G_;
        case 36295:
          return j_;
        case 36296:
          return W_;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return X_;
        case 35679:
        case 36299:
        case 36307:
          return q_;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return Y_;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return Z_;
      }
    }(t.type);
  }
}
class Q_ {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, a = r.length; s !== a; ++s) {
      const o = r[s];
      o.setValue(e, t[o.id], i);
    }
  }
}
const Op = /(\w+)(\])?(\[|\.)?/g;
function Ev(n, e) {
  n.seq.push(e), n.map[e.id] = e;
}
function $_(n, e, t) {
  const i = n.name, r = i.length;
  for (Op.lastIndex = 0; ; ) {
    const s = Op.exec(i), a = Op.lastIndex;
    let o = s[1];
    const l = s[2] === "]", h = s[3];
    if (l && (o |= 0), h === void 0 || h === "[" && a + 2 === r) {
      Ev(t, h === void 0 ? new K_(o, n, e) : new J_(o, n, e));
      break;
    }
    {
      let c = t.map[o];
      c === void 0 && (c = new Q_(o), Ev(t, c)), t = c;
    }
  }
}
class Iu {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r);
      $_(s, e.getUniformLocation(t, s.name), this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, a = t.length; s !== a; ++s) {
      const o = t[s], l = i[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const a = e[r];
      a.id in t && i.push(a);
    }
    return i;
  }
}
function Av(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
const eT = 37297;
let tT = 0;
function Cv(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS), r = n.getShaderInfoLog(e).trim();
  if (i && r === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const a = parseInt(s[1]);
    return t.toUpperCase() + `

` + r + `

` + function(o, l) {
      const h = o.split(`
`), c = [], u = Math.max(l - 6, 0), d = Math.min(l + 6, h.length);
      for (let p = u; p < d; p++) {
        const m = p + 1;
        c.push(`${m === l ? ">" : " "} ${m}: ${h[p]}`);
      }
      return c.join(`
`);
    }(n.getShaderSource(e), a);
  }
  return r;
}
function nT(n, e) {
  const t = function(i) {
    const r = it.getPrimaries(it.workingColorSpace), s = it.getPrimaries(i);
    let a;
    switch (r === s ? a = "" : r === hh && s === lh ? a = "LinearDisplayP3ToLinearSRGB" : r === lh && s === hh && (a = "LinearSRGBToLinearDisplayP3"), i) {
      case Jt:
      case Gh:
        return [a, "LinearTransferOETF"];
      case mt:
      case Rd:
        return [a, "sRGBTransferOETF"];
      default:
        return [a, "LinearTransferOETF"];
    }
  }(e);
  return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function iT(n, e) {
  let t;
  switch (e) {
    case wd:
      t = "Linear";
      break;
    case _d:
      t = "Reinhard";
      break;
    case Td:
      t = "OptimizedCineon";
      break;
    case Ed:
      t = "ACESFilmic";
      break;
    case Ad:
      t = "AgX";
      break;
    case mg:
      t = "Neutral";
      break;
    case fg:
      t = "Custom";
      break;
    default:
      t = "Linear";
  }
  return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function cl(n) {
  return n !== "";
}
function Pv(n, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Rv(n, e) {
  return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const rT = /^[ \t]*#include +<([\w\d./]+)>/gm;
function wm(n) {
  return n.replace(rT, aT);
}
const sT = /* @__PURE__ */ new Map();
function aT(n, e) {
  let t = ke[e];
  if (t === void 0) {
    const i = sT.get(e);
    if (i === void 0)
      throw new Error("Can not resolve #include <" + e + ">");
    t = ke[i];
  }
  return wm(t);
}
const oT = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Iv(n) {
  return n.replace(oT, lT);
}
function lT(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function Lv(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function hT(n, e, t, i) {
  const r = n.getContext(), s = t.defines;
  let a = t.vertexShader, o = t.fragmentShader;
  const l = function(A) {
    let L = "SHADOWMAP_TYPE_BASIC";
    return A.shadowMapType === yd ? L = "SHADOWMAP_TYPE_PCF" : A.shadowMapType === pg ? L = "SHADOWMAP_TYPE_PCF_SOFT" : A.shadowMapType === Ri && (L = "SHADOWMAP_TYPE_VSM"), L;
  }(t), h = function(A) {
    let L = "ENVMAP_TYPE_CUBE";
    if (A.envMap)
      switch (A.envMapMode) {
        case Cr:
        case ps:
          L = "ENVMAP_TYPE_CUBE";
          break;
        case $o:
          L = "ENVMAP_TYPE_CUBE_UV";
      }
    return L;
  }(t), c = function(A) {
    let L = "ENVMAP_MODE_REFLECTION";
    return A.envMap && A.envMapMode === ps && (L = "ENVMAP_MODE_REFRACTION"), L;
  }(t), u = function(A) {
    let L = "ENVMAP_BLENDING_NONE";
    if (A.envMap)
      switch (A.combine) {
        case Hh:
          L = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case z1:
          L = "ENVMAP_BLENDING_MIX";
          break;
        case V1:
          L = "ENVMAP_BLENDING_ADD";
      }
    return L;
  }(t), d = function(A) {
    const L = A.envMapCubeUVHeight;
    if (L === null)
      return null;
    const D = Math.log2(L) - 2, U = 1 / L;
    return { texelWidth: 1 / (3 * Math.max(Math.pow(2, D), 112)), texelHeight: U, maxMip: D };
  }(t), p = function(A) {
    return [A.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", A.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(cl).join(`
`);
  }(t), m = function(A) {
    const L = [];
    for (const D in A) {
      const U = A[D];
      U !== !1 && L.push("#define " + D + " " + U);
    }
    return L.join(`
`);
  }(s), g = r.createProgram();
  let f, v, y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (f = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(cl).join(`
`), f.length > 0 && (f += `
`), v = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(cl).join(`
`), v.length > 0 && (v += `
`)) : (f = [Lv(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(cl).join(`
`), v = [Lv(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== $i ? "#define TONE_MAPPING" : "", t.toneMapping !== $i ? ke.tonemapping_pars_fragment : "", t.toneMapping !== $i ? iT("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", ke.colorspace_pars_fragment, nT("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(cl).join(`
`)), a = wm(a), a = Pv(a, t), a = Rv(a, t), o = wm(o), o = Pv(o, t), o = Rv(o, t), a = Iv(a), o = Iv(o), t.isRawShaderMaterial !== !0 && (y = `#version 300 es
`, f = [p, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + f, v = ["#define varying in", t.glslVersion === xm ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === xm ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + v);
  const x = y + f + a, M = y + v + o, b = Av(r, r.VERTEX_SHADER, x), S = Av(r, r.FRAGMENT_SHADER, M);
  function w(A) {
    if (n.debug.checkShaderErrors) {
      const L = r.getProgramInfoLog(g).trim(), D = r.getShaderInfoLog(b).trim(), U = r.getShaderInfoLog(S).trim();
      let H = !0, Z = !0;
      r.getProgramParameter(g, r.LINK_STATUS) === !1 ? (H = !1, typeof n.debug.onShaderError == "function" ? n.debug.onShaderError(r, g, b, S) : (Cv(r, b, "vertex"), Cv(r, S, "fragment"))) : L !== "" || D !== "" && U !== "" || (Z = !1), Z && (A.diagnostics = { runnable: H, programLog: L, vertexShader: { log: D, prefix: f }, fragmentShader: { log: U, prefix: v } });
    }
    r.deleteShader(b), r.deleteShader(S), T = new Iu(r, g), C = function(L, D) {
      const U = {}, H = L.getProgramParameter(D, L.ACTIVE_ATTRIBUTES);
      for (let Z = 0; Z < H; Z++) {
        const te = L.getActiveAttrib(D, Z), ne = te.name;
        let ve = 1;
        te.type === L.FLOAT_MAT2 && (ve = 2), te.type === L.FLOAT_MAT3 && (ve = 3), te.type === L.FLOAT_MAT4 && (ve = 4), U[ne] = { type: te.type, location: L.getAttribLocation(D, ne), locationSize: ve };
      }
      return U;
    }(r, g);
  }
  let T, C;
  r.attachShader(g, b), r.attachShader(g, S), t.index0AttributeName !== void 0 ? r.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(g, 0, "position"), r.linkProgram(g), this.getUniforms = function() {
    return T === void 0 && w(this), T;
  }, this.getAttributes = function() {
    return C === void 0 && w(this), C;
  };
  let I = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return I === !1 && (I = r.getProgramParameter(g, eT)), I;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), r.deleteProgram(g), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = tT++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = b, this.fragmentShader = S, this;
}
let cT = 0;
class uT {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, i = e.fragmentShader, r = this.Ft(t), s = this.Ft(i), a = this.Gt(e);
    return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this.Ft(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this.Ft(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  Gt(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  Ft(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && (i = new dT(e), t.set(e, i)), i;
  }
}
class dT {
  constructor(e) {
    this.id = cT++, this.code = e, this.usedTimes = 0;
  }
}
function pT(n, e, t, i, r, s, a) {
  const o = new Id(), l = new uT(), h = /* @__PURE__ */ new Set(), c = [], u = r.logarithmicDepthBuffer, d = r.vertexTextures;
  let p = r.precision;
  const m = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  function g(f) {
    return h.add(f), f === 0 ? "uv" : `uv${f}`;
  }
  return { getParameters: function(f, v, y, x, M) {
    const b = x.fog, S = M.geometry, w = f.isMeshStandardMaterial ? x.environment : null, T = (f.isMeshStandardMaterial ? t : e).get(f.envMap || w), C = T && T.mapping === $o ? T.image.height : null, I = m[f.type];
    f.precision !== null && (p = r.getMaxPrecision(f.precision), f.precision);
    const A = S.morphAttributes.position || S.morphAttributes.normal || S.morphAttributes.color, L = A !== void 0 ? A.length : 0;
    let D, U, H, Z, te = 0;
    if (S.morphAttributes.position !== void 0 && (te = 1), S.morphAttributes.normal !== void 0 && (te = 2), S.morphAttributes.color !== void 0 && (te = 3), I) {
      const Dt = In[I];
      D = Dt.vertexShader, U = Dt.fragmentShader;
    } else
      D = f.vertexShader, U = f.fragmentShader, l.update(f), H = l.getVertexShaderID(f), Z = l.getFragmentShaderID(f);
    const ne = n.getRenderTarget(), ve = M.isInstancedMesh === !0, Se = M.isBatchedMesh === !0, Q = !!f.map, ae = !!f.matcap, de = !!T, ie = !!f.aoMap, N = !!f.lightMap, R = !!f.bumpMap, j = !!f.normalMap, K = !!f.displacementMap, O = !!f.emissiveMap, k = !!f.metalnessMap, E = !!f.roughnessMap, B = f.anisotropy > 0, F = f.clearcoat > 0, re = f.dispersion > 0, V = f.iridescence > 0, se = f.sheen > 0, Me = f.transmission > 0, ue = B && !!f.anisotropyMap, z = F && !!f.clearcoatMap, W = F && !!f.clearcoatNormalMap, ee = F && !!f.clearcoatRoughnessMap, ge = V && !!f.iridescenceMap, Le = V && !!f.iridescenceThicknessMap, Fe = se && !!f.sheenColorMap, _e = se && !!f.sheenRoughnessMap, Be = !!f.specularMap, He = !!f.specularColorMap, nt = !!f.specularIntensityMap, Ce = Me && !!f.transmissionMap, rt = Me && !!f.thicknessMap, ze = !!f.gradientMap, Nt = !!f.alphaMap, Un = f.alphaTest > 0, lr = !!f.alphaHash, G = !!f.extensions;
    let il = $i;
    f.toneMapped && (ne !== null && ne.isXRRenderTarget !== !0 || (il = n.toneMapping));
    const As = { shaderID: I, shaderType: f.type, shaderName: f.name, vertexShader: D, fragmentShader: U, defines: f.defines, customVertexShaderID: H, customFragmentShaderID: Z, isRawShaderMaterial: f.isRawShaderMaterial === !0, glslVersion: f.glslVersion, precision: p, batching: Se, batchingColor: Se && M.ct !== null, instancing: ve, instancingColor: ve && M.instanceColor !== null, instancingMorph: ve && M.morphTexture !== null, supportsVertexTextures: d, outputColorSpace: ne === null ? n.outputColorSpace : ne.isXRRenderTarget === !0 ? ne.texture.colorSpace : Jt, alphaToCoverage: !!f.alphaToCoverage, map: Q, matcap: ae, envMap: de, envMapMode: de && T.mapping, envMapCubeUVHeight: C, aoMap: ie, lightMap: N, bumpMap: R, normalMap: j, displacementMap: d && K, emissiveMap: O, normalMapObjectSpace: j && f.normalMapType === 1, normalMapTangentSpace: j && f.normalMapType === 0, metalnessMap: k, roughnessMap: E, anisotropy: B, anisotropyMap: ue, clearcoat: F, clearcoatMap: z, clearcoatNormalMap: W, clearcoatRoughnessMap: ee, dispersion: re, iridescence: V, iridescenceMap: ge, iridescenceThicknessMap: Le, sheen: se, sheenColorMap: Fe, sheenRoughnessMap: _e, specularMap: Be, specularColorMap: He, specularIntensityMap: nt, transmission: Me, transmissionMap: Ce, thicknessMap: rt, gradientMap: ze, opaque: f.transparent === !1 && f.blending === 1 && f.alphaToCoverage === !1, alphaMap: Nt, alphaTest: Un, alphaHash: lr, combine: f.combine, mapUv: Q && g(f.map.channel), aoMapUv: ie && g(f.aoMap.channel), lightMapUv: N && g(f.lightMap.channel), bumpMapUv: R && g(f.bumpMap.channel), normalMapUv: j && g(f.normalMap.channel), displacementMapUv: K && g(f.displacementMap.channel), emissiveMapUv: O && g(f.emissiveMap.channel), metalnessMapUv: k && g(f.metalnessMap.channel), roughnessMapUv: E && g(f.roughnessMap.channel), anisotropyMapUv: ue && g(f.anisotropyMap.channel), clearcoatMapUv: z && g(f.clearcoatMap.channel), clearcoatNormalMapUv: W && g(f.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: ee && g(f.clearcoatRoughnessMap.channel), iridescenceMapUv: ge && g(f.iridescenceMap.channel), iridescenceThicknessMapUv: Le && g(f.iridescenceThicknessMap.channel), sheenColorMapUv: Fe && g(f.sheenColorMap.channel), sheenRoughnessMapUv: _e && g(f.sheenRoughnessMap.channel), specularMapUv: Be && g(f.specularMap.channel), specularColorMapUv: He && g(f.specularColorMap.channel), specularIntensityMapUv: nt && g(f.specularIntensityMap.channel), transmissionMapUv: Ce && g(f.transmissionMap.channel), thicknessMapUv: rt && g(f.thicknessMap.channel), alphaMapUv: Nt && g(f.alphaMap.channel), vertexTangents: !!S.attributes.tangent && (j || B), vertexColors: f.vertexColors, vertexAlphas: f.vertexColors === !0 && !!S.attributes.color && S.attributes.color.itemSize === 4, pointsUvs: M.isPoints === !0 && !!S.attributes.uv && (Q || Nt), fog: !!b, useFog: f.fog === !0, fogExp2: !!b && b.isFogExp2, flatShading: f.flatShading === !0, sizeAttenuation: f.sizeAttenuation === !0, logarithmicDepthBuffer: u, skinning: M.isSkinnedMesh === !0, morphTargets: S.morphAttributes.position !== void 0, morphNormals: S.morphAttributes.normal !== void 0, morphColors: S.morphAttributes.color !== void 0, morphTargetsCount: L, morphTextureStride: te, numDirLights: v.directional.length, numPointLights: v.point.length, numSpotLights: v.spot.length, numSpotLightMaps: v.spotLightMap.length, numRectAreaLights: v.rectArea.length, numHemiLights: v.hemi.length, numDirLightShadows: v.directionalShadowMap.length, numPointLightShadows: v.pointShadowMap.length, numSpotLightShadows: v.spotShadowMap.length, numSpotLightShadowsWithMaps: v.numSpotLightShadowsWithMaps, numLightProbes: v.numLightProbes, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: f.dithering, shadowMapEnabled: n.shadowMap.enabled && y.length > 0, shadowMapType: n.shadowMap.type, toneMapping: il, decodeVideoTexture: Q && f.map.isVideoTexture === !0 && it.getTransfer(f.map.colorSpace) === ft, premultipliedAlpha: f.premultipliedAlpha, doubleSided: f.side === bt, flipSided: f.side === Tn, useDepthPacking: f.depthPacking >= 0, depthPacking: f.depthPacking || 0, index0AttributeName: f.index0AttributeName, extensionClipCullDistance: G && f.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"), extensionMultiDraw: G && f.extensions.multiDraw === !0 && i.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"), customProgramCacheKey: f.customProgramCacheKey() };
    return As.vertexUv1s = h.has(1), As.vertexUv2s = h.has(2), As.vertexUv3s = h.has(3), h.clear(), As;
  }, getProgramCacheKey: function(f) {
    const v = [];
    if (f.shaderID ? v.push(f.shaderID) : (v.push(f.customVertexShaderID), v.push(f.customFragmentShaderID)), f.defines !== void 0)
      for (const y in f.defines)
        v.push(y), v.push(f.defines[y]);
    return f.isRawShaderMaterial === !1 && (function(y, x) {
      y.push(x.precision), y.push(x.outputColorSpace), y.push(x.envMapMode), y.push(x.envMapCubeUVHeight), y.push(x.mapUv), y.push(x.alphaMapUv), y.push(x.lightMapUv), y.push(x.aoMapUv), y.push(x.bumpMapUv), y.push(x.normalMapUv), y.push(x.displacementMapUv), y.push(x.emissiveMapUv), y.push(x.metalnessMapUv), y.push(x.roughnessMapUv), y.push(x.anisotropyMapUv), y.push(x.clearcoatMapUv), y.push(x.clearcoatNormalMapUv), y.push(x.clearcoatRoughnessMapUv), y.push(x.iridescenceMapUv), y.push(x.iridescenceThicknessMapUv), y.push(x.sheenColorMapUv), y.push(x.sheenRoughnessMapUv), y.push(x.specularMapUv), y.push(x.specularColorMapUv), y.push(x.specularIntensityMapUv), y.push(x.transmissionMapUv), y.push(x.thicknessMapUv), y.push(x.combine), y.push(x.fogExp2), y.push(x.sizeAttenuation), y.push(x.morphTargetsCount), y.push(x.morphAttributeCount), y.push(x.numDirLights), y.push(x.numPointLights), y.push(x.numSpotLights), y.push(x.numSpotLightMaps), y.push(x.numHemiLights), y.push(x.numRectAreaLights), y.push(x.numDirLightShadows), y.push(x.numPointLightShadows), y.push(x.numSpotLightShadows), y.push(x.numSpotLightShadowsWithMaps), y.push(x.numLightProbes), y.push(x.shadowMapType), y.push(x.toneMapping), y.push(x.numClippingPlanes), y.push(x.numClipIntersection), y.push(x.depthPacking);
    }(v, f), function(y, x) {
      o.disableAll(), x.supportsVertexTextures && o.enable(0), x.instancing && o.enable(1), x.instancingColor && o.enable(2), x.instancingMorph && o.enable(3), x.matcap && o.enable(4), x.envMap && o.enable(5), x.normalMapObjectSpace && o.enable(6), x.normalMapTangentSpace && o.enable(7), x.clearcoat && o.enable(8), x.iridescence && o.enable(9), x.alphaTest && o.enable(10), x.vertexColors && o.enable(11), x.vertexAlphas && o.enable(12), x.vertexUv1s && o.enable(13), x.vertexUv2s && o.enable(14), x.vertexUv3s && o.enable(15), x.vertexTangents && o.enable(16), x.anisotropy && o.enable(17), x.alphaHash && o.enable(18), x.batching && o.enable(19), x.dispersion && o.enable(20), x.batchingColor && o.enable(21), y.push(o.mask), o.disableAll(), x.fog && o.enable(0), x.useFog && o.enable(1), x.flatShading && o.enable(2), x.logarithmicDepthBuffer && o.enable(3), x.skinning && o.enable(4), x.morphTargets && o.enable(5), x.morphNormals && o.enable(6), x.morphColors && o.enable(7), x.premultipliedAlpha && o.enable(8), x.shadowMapEnabled && o.enable(9), x.doubleSided && o.enable(10), x.flipSided && o.enable(11), x.useDepthPacking && o.enable(12), x.dithering && o.enable(13), x.transmission && o.enable(14), x.sheen && o.enable(15), x.opaque && o.enable(16), x.pointsUvs && o.enable(17), x.decodeVideoTexture && o.enable(18), x.alphaToCoverage && o.enable(19), y.push(o.mask);
    }(v, f), v.push(n.outputColorSpace)), v.push(f.customProgramCacheKey), v.join();
  }, getUniforms: function(f) {
    const v = m[f.type];
    let y;
    if (v) {
      const x = In[v];
      y = Kt.clone(x.uniforms);
    } else
      y = f.uniforms;
    return y;
  }, acquireProgram: function(f, v) {
    let y;
    for (let x = 0, M = c.length; x < M; x++) {
      const b = c[x];
      if (b.cacheKey === v) {
        y = b, ++y.usedTimes;
        break;
      }
    }
    return y === void 0 && (y = new hT(n, v, f, s), c.push(y)), y;
  }, releaseProgram: function(f) {
    if (--f.usedTimes == 0) {
      const v = c.indexOf(f);
      c[v] = c[c.length - 1], c.pop(), f.destroy();
    }
  }, releaseShaderCache: function(f) {
    l.remove(f);
  }, programs: c, dispose: function() {
    l.dispose();
  } };
}
function fT() {
  let n = /* @__PURE__ */ new WeakMap();
  return { get: function(e) {
    let t = n.get(e);
    return t === void 0 && (t = {}, n.set(e, t)), t;
  }, remove: function(e) {
    n.delete(e);
  }, update: function(e, t, i) {
    n.get(e)[t] = i;
  }, dispose: function() {
    n = /* @__PURE__ */ new WeakMap();
  } };
}
function mT(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id;
}
function Nv(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id;
}
function Dv() {
  const n = [];
  let e = 0;
  const t = [], i = [], r = [];
  function s(a, o, l, h, c, u) {
    let d = n[e];
    return d === void 0 ? (d = { id: a.id, object: a, geometry: o, material: l, groupOrder: h, renderOrder: a.renderOrder, z: c, group: u }, n[e] = d) : (d.id = a.id, d.object = a, d.geometry = o, d.material = l, d.groupOrder = h, d.renderOrder = a.renderOrder, d.z = c, d.group = u), e++, d;
  }
  return { opaque: t, transmissive: i, transparent: r, init: function() {
    e = 0, t.length = 0, i.length = 0, r.length = 0;
  }, push: function(a, o, l, h, c, u) {
    const d = s(a, o, l, h, c, u);
    l.transmission > 0 ? i.push(d) : l.transparent === !0 ? r.push(d) : t.push(d);
  }, unshift: function(a, o, l, h, c, u) {
    const d = s(a, o, l, h, c, u);
    l.transmission > 0 ? i.unshift(d) : l.transparent === !0 ? r.unshift(d) : t.unshift(d);
  }, finish: function() {
    for (let a = e, o = n.length; a < o; a++) {
      const l = n[a];
      if (l.id === null)
        break;
      l.id = null, l.object = null, l.geometry = null, l.material = null, l.group = null;
    }
  }, sort: function(a, o) {
    t.length > 1 && t.sort(a || mT), i.length > 1 && i.sort(o || Nv), r.length > 1 && r.sort(o || Nv);
  } };
}
function gT() {
  let n = /* @__PURE__ */ new WeakMap();
  return { get: function(e, t) {
    const i = n.get(e);
    let r;
    return i === void 0 ? (r = new Dv(), n.set(e, [r])) : t >= i.length ? (r = new Dv(), i.push(r)) : r = i[t], r;
  }, dispose: function() {
    n = /* @__PURE__ */ new WeakMap();
  } };
}
function vT() {
  const n = {};
  return { get: function(e) {
    if (n[e.id] !== void 0)
      return n[e.id];
    let t;
    switch (e.type) {
      case "DirectionalLight":
        t = { direction: new _(), color: new oe() };
        break;
      case "SpotLight":
        t = { position: new _(), direction: new _(), color: new oe(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        t = { position: new _(), color: new oe(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        t = { direction: new _(), skyColor: new oe(), groundColor: new oe() };
        break;
      case "RectAreaLight":
        t = { color: new oe(), position: new _(), halfWidth: new _(), halfHeight: new _() };
    }
    return n[e.id] = t, t;
  } };
}
let yT = 0;
function xT(n, e) {
  return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
}
function MT(n) {
  const e = new vT(), t = /* @__PURE__ */ function() {
    const o = {};
    return { get: function(l) {
      if (o[l.id] !== void 0)
        return o[l.id];
      let h;
      switch (l.type) {
        case "DirectionalLight":
        case "SpotLight":
          h = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new X() };
          break;
        case "PointLight":
          h = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new X(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
      }
      return o[l.id] = h, h;
    } };
  }(), i = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 };
  for (let o = 0; o < 9; o++)
    i.probe.push(new _());
  const r = new _(), s = new fe(), a = new fe();
  return { setup: function(o) {
    let l = 0, h = 0, c = 0;
    for (let w = 0; w < 9; w++)
      i.probe[w].set(0, 0, 0);
    let u = 0, d = 0, p = 0, m = 0, g = 0, f = 0, v = 0, y = 0, x = 0, M = 0, b = 0;
    o.sort(xT);
    for (let w = 0, T = o.length; w < T; w++) {
      const C = o[w], I = C.color, A = C.intensity, L = C.distance, D = C.shadow && C.shadow.map ? C.shadow.map.texture : null;
      if (C.isAmbientLight)
        l += I.r * A, h += I.g * A, c += I.b * A;
      else if (C.isLightProbe) {
        for (let U = 0; U < 9; U++)
          i.probe[U].addScaledVector(C.sh.coefficients[U], A);
        b++;
      } else if (C.isDirectionalLight) {
        const U = e.get(C);
        if (U.color.copy(C.color).multiplyScalar(C.intensity), C.castShadow) {
          const H = C.shadow, Z = t.get(C);
          Z.shadowBias = H.bias, Z.shadowNormalBias = H.normalBias, Z.shadowRadius = H.radius, Z.shadowMapSize = H.mapSize, i.directionalShadow[u] = Z, i.directionalShadowMap[u] = D, i.directionalShadowMatrix[u] = C.shadow.matrix, f++;
        }
        i.directional[u] = U, u++;
      } else if (C.isSpotLight) {
        const U = e.get(C);
        U.position.setFromMatrixPosition(C.matrixWorld), U.color.copy(I).multiplyScalar(A), U.distance = L, U.coneCos = Math.cos(C.angle), U.penumbraCos = Math.cos(C.angle * (1 - C.penumbra)), U.decay = C.decay, i.spot[p] = U;
        const H = C.shadow;
        if (C.map && (i.spotLightMap[x] = C.map, x++, H.updateMatrices(C), C.castShadow && M++), i.spotLightMatrix[p] = H.matrix, C.castShadow) {
          const Z = t.get(C);
          Z.shadowBias = H.bias, Z.shadowNormalBias = H.normalBias, Z.shadowRadius = H.radius, Z.shadowMapSize = H.mapSize, i.spotShadow[p] = Z, i.spotShadowMap[p] = D, y++;
        }
        p++;
      } else if (C.isRectAreaLight) {
        const U = e.get(C);
        U.color.copy(I).multiplyScalar(A), U.halfWidth.set(0.5 * C.width, 0, 0), U.halfHeight.set(0, 0.5 * C.height, 0), i.rectArea[m] = U, m++;
      } else if (C.isPointLight) {
        const U = e.get(C);
        if (U.color.copy(C.color).multiplyScalar(C.intensity), U.distance = C.distance, U.decay = C.decay, C.castShadow) {
          const H = C.shadow, Z = t.get(C);
          Z.shadowBias = H.bias, Z.shadowNormalBias = H.normalBias, Z.shadowRadius = H.radius, Z.shadowMapSize = H.mapSize, Z.shadowCameraNear = H.camera.near, Z.shadowCameraFar = H.camera.far, i.pointShadow[d] = Z, i.pointShadowMap[d] = D, i.pointShadowMatrix[d] = C.shadow.matrix, v++;
        }
        i.point[d] = U, d++;
      } else if (C.isHemisphereLight) {
        const U = e.get(C);
        U.skyColor.copy(C.color).multiplyScalar(A), U.groundColor.copy(C.groundColor).multiplyScalar(A), i.hemi[g] = U, g++;
      }
    }
    m > 0 && (n.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = xe.LTC_FLOAT_1, i.rectAreaLTC2 = xe.LTC_FLOAT_2) : (i.rectAreaLTC1 = xe.LTC_HALF_1, i.rectAreaLTC2 = xe.LTC_HALF_2)), i.ambient[0] = l, i.ambient[1] = h, i.ambient[2] = c;
    const S = i.hash;
    S.directionalLength === u && S.pointLength === d && S.spotLength === p && S.rectAreaLength === m && S.hemiLength === g && S.numDirectionalShadows === f && S.numPointShadows === v && S.numSpotShadows === y && S.numSpotMaps === x && S.numLightProbes === b || (i.directional.length = u, i.spot.length = p, i.rectArea.length = m, i.point.length = d, i.hemi.length = g, i.directionalShadow.length = f, i.directionalShadowMap.length = f, i.pointShadow.length = v, i.pointShadowMap.length = v, i.spotShadow.length = y, i.spotShadowMap.length = y, i.directionalShadowMatrix.length = f, i.pointShadowMatrix.length = v, i.spotLightMatrix.length = y + x - M, i.spotLightMap.length = x, i.numSpotLightShadowsWithMaps = M, i.numLightProbes = b, S.directionalLength = u, S.pointLength = d, S.spotLength = p, S.rectAreaLength = m, S.hemiLength = g, S.numDirectionalShadows = f, S.numPointShadows = v, S.numSpotShadows = y, S.numSpotMaps = x, S.numLightProbes = b, i.version = yT++);
  }, setupView: function(o, l) {
    let h = 0, c = 0, u = 0, d = 0, p = 0;
    const m = l.matrixWorldInverse;
    for (let g = 0, f = o.length; g < f; g++) {
      const v = o[g];
      if (v.isDirectionalLight) {
        const y = i.directional[h];
        y.direction.setFromMatrixPosition(v.matrixWorld), r.setFromMatrixPosition(v.target.matrixWorld), y.direction.sub(r), y.direction.transformDirection(m), h++;
      } else if (v.isSpotLight) {
        const y = i.spot[u];
        y.position.setFromMatrixPosition(v.matrixWorld), y.position.applyMatrix4(m), y.direction.setFromMatrixPosition(v.matrixWorld), r.setFromMatrixPosition(v.target.matrixWorld), y.direction.sub(r), y.direction.transformDirection(m), u++;
      } else if (v.isRectAreaLight) {
        const y = i.rectArea[d];
        y.position.setFromMatrixPosition(v.matrixWorld), y.position.applyMatrix4(m), a.identity(), s.copy(v.matrixWorld), s.premultiply(m), a.extractRotation(s), y.halfWidth.set(0.5 * v.width, 0, 0), y.halfHeight.set(0, 0.5 * v.height, 0), y.halfWidth.applyMatrix4(a), y.halfHeight.applyMatrix4(a), d++;
      } else if (v.isPointLight) {
        const y = i.point[c];
        y.position.setFromMatrixPosition(v.matrixWorld), y.position.applyMatrix4(m), c++;
      } else if (v.isHemisphereLight) {
        const y = i.hemi[p];
        y.direction.setFromMatrixPosition(v.matrixWorld), y.direction.transformDirection(m), p++;
      }
    }
  }, state: i };
}
function Ov(n) {
  const e = new MT(n), t = [], i = [], r = { lightsArray: t, shadowsArray: i, camera: null, lights: e, transmissionRenderTarget: {} };
  return { init: function(s) {
    r.camera = s, t.length = 0, i.length = 0;
  }, state: r, setupLights: function() {
    e.setup(t);
  }, setupLightsView: function(s) {
    e.setupView(t, s);
  }, pushLight: function(s) {
    t.push(s);
  }, pushShadow: function(s) {
    i.push(s);
  } };
}
function bT(n) {
  let e = /* @__PURE__ */ new WeakMap();
  return { get: function(t, i = 0) {
    const r = e.get(t);
    let s;
    return r === void 0 ? (s = new Ov(n), e.set(t, [s])) : i >= r.length ? (s = new Ov(n), r.push(s)) : s = r[i], s;
  }, dispose: function() {
    e = /* @__PURE__ */ new WeakMap();
  } };
}
class Od extends Xt {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Rg extends Xt {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
function ST(n, e, t) {
  let i = new jh();
  const r = new X(), s = new X(), a = new Ve(), o = new Od({ depthPacking: Eg }), l = new Rg(), h = {}, c = t.maxTextureSize, u = { [Mi]: Tn, [Tn]: Mi, [bt]: bt }, d = new tt({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new X() }, radius: { value: 4 } }, vertexShader: `void main() {
	gl_Position = vec4( position, 1.0 );
}`, fragmentShader: `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}` }), p = d.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const m = new Pe();
  m.setAttribute("position", new Ke(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const g = new ce(m, d), f = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = yd;
  let v = this.type;
  function y(S, w) {
    const T = e.update(g);
    d.defines.VSM_SAMPLES !== S.blurSamples && (d.defines.VSM_SAMPLES = S.blurSamples, p.defines.VSM_SAMPLES = S.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), S.mapPass === null && (S.mapPass = new ht(r.x, r.y)), d.uniforms.shadow_pass.value = S.map.texture, d.uniforms.resolution.value = S.mapSize, d.uniforms.radius.value = S.radius, n.setRenderTarget(S.mapPass), n.clear(), n.renderBufferDirect(w, null, T, d, g, null), p.uniforms.shadow_pass.value = S.mapPass.texture, p.uniforms.resolution.value = S.mapSize, p.uniforms.radius.value = S.radius, n.setRenderTarget(S.map), n.clear(), n.renderBufferDirect(w, null, T, p, g, null);
  }
  function x(S, w, T, C) {
    let I = null;
    const A = T.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
    if (A !== void 0)
      I = A;
    else if (I = T.isPointLight === !0 ? l : o, n.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
      const L = I.uuid, D = w.uuid;
      let U = h[L];
      U === void 0 && (U = {}, h[L] = U);
      let H = U[D];
      H === void 0 && (H = I.clone(), U[D] = H, w.addEventListener("dispose", b)), I = H;
    }
    return I.visible = w.visible, I.wireframe = w.wireframe, I.side = C === Ri ? w.shadowSide !== null ? w.shadowSide : w.side : w.shadowSide !== null ? w.shadowSide : u[w.side], I.alphaMap = w.alphaMap, I.alphaTest = w.alphaTest, I.map = w.map, I.clipShadows = w.clipShadows, I.clippingPlanes = w.clippingPlanes, I.clipIntersection = w.clipIntersection, I.displacementMap = w.displacementMap, I.displacementScale = w.displacementScale, I.displacementBias = w.displacementBias, I.wireframeLinewidth = w.wireframeLinewidth, I.linewidth = w.linewidth, T.isPointLight === !0 && I.isMeshDistanceMaterial === !0 && (n.properties.get(I).light = T), I;
  }
  function M(S, w, T, C, I) {
    if (S.visible === !1)
      return;
    if (S.layers.test(w.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && I === Ri) && (!S.frustumCulled || i.intersectsObject(S))) {
      S.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, S.matrixWorld);
      const L = e.update(S), D = S.material;
      if (Array.isArray(D)) {
        const U = L.groups;
        for (let H = 0, Z = U.length; H < Z; H++) {
          const te = U[H], ne = D[te.materialIndex];
          if (ne && ne.visible) {
            const ve = x(S, ne, C, I);
            S.onBeforeShadow(n, S, w, T, L, ve, te), n.renderBufferDirect(T, null, L, ve, S, te), S.onAfterShadow(n, S, w, T, L, ve, te);
          }
        }
      } else if (D.visible) {
        const U = x(S, D, C, I);
        S.onBeforeShadow(n, S, w, T, L, U, null), n.renderBufferDirect(T, null, L, U, S, null), S.onAfterShadow(n, S, w, T, L, U, null);
      }
    }
    const A = S.children;
    for (let L = 0, D = A.length; L < D; L++)
      M(A[L], w, T, C, I);
  }
  function b(S) {
    S.target.removeEventListener("dispose", b);
    for (const w in h) {
      const T = h[w], C = S.target.uuid;
      C in T && (T[C].dispose(), delete T[C]);
    }
  }
  this.render = function(S, w, T) {
    if (f.enabled === !1 || f.autoUpdate === !1 && f.needsUpdate === !1 || S.length === 0)
      return;
    const C = n.getRenderTarget(), I = n.getActiveCubeFace(), A = n.getActiveMipmapLevel(), L = n.state;
    L.setBlending(0), L.buffers.color.setClear(1, 1, 1, 1), L.buffers.depth.setTest(!0), L.setScissorTest(!1);
    const D = v !== Ri && this.type === Ri, U = v === Ri && this.type !== Ri;
    for (let H = 0, Z = S.length; H < Z; H++) {
      const te = S[H], ne = te.shadow;
      if (ne === void 0 || ne.autoUpdate === !1 && ne.needsUpdate === !1)
        continue;
      r.copy(ne.mapSize);
      const ve = ne.getFrameExtents();
      if (r.multiply(ve), s.copy(ne.mapSize), (r.x > c || r.y > c) && (r.x > c && (s.x = Math.floor(c / ve.x), r.x = s.x * ve.x, ne.mapSize.x = s.x), r.y > c && (s.y = Math.floor(c / ve.y), r.y = s.y * ve.y, ne.mapSize.y = s.y)), ne.map === null || D === !0 || U === !0) {
        const Q = this.type !== Ri ? { minFilter: at, magFilter: at } : {};
        ne.map !== null && ne.map.dispose(), ne.map = new ht(r.x, r.y, Q), ne.map.texture.name = te.name + ".shadowMap", ne.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(ne.map), n.clear();
      const Se = ne.getViewportCount();
      for (let Q = 0; Q < Se; Q++) {
        const ae = ne.getViewport(Q);
        a.set(s.x * ae.x, s.y * ae.y, s.x * ae.z, s.y * ae.w), L.viewport(a), ne.updateMatrices(te, Q), i = ne.getFrustum(), M(w, T, ne.camera, te, this.type);
      }
      ne.isPointLightShadow !== !0 && this.type === Ri && y(ne, T), ne.needsUpdate = !1;
    }
    v = this.type, f.needsUpdate = !1, n.setRenderTarget(C, I, A);
  };
}
function wT(n) {
  const e = new function() {
    let E = !1;
    const B = new Ve();
    let F = null;
    const re = new Ve(0, 0, 0, 0);
    return { setMask: function(V) {
      F === V || E || (n.colorMask(V, V, V, V), F = V);
    }, setLocked: function(V) {
      E = V;
    }, setClear: function(V, se, Me, ue, z) {
      z === !0 && (V *= ue, se *= ue, Me *= ue), B.set(V, se, Me, ue), re.equals(B) === !1 && (n.clearColor(V, se, Me, ue), re.copy(B));
    }, reset: function() {
      E = !1, F = null, re.set(-1, 0, 0, 0);
    } };
  }(), t = new function() {
    let E = !1, B = null, F = null, re = null;
    return { setTest: function(V) {
      V ? de(n.DEPTH_TEST) : ie(n.DEPTH_TEST);
    }, setMask: function(V) {
      B === V || E || (n.depthMask(V), B = V);
    }, setFunc: function(V) {
      if (F !== V) {
        switch (V) {
          case 0:
            n.depthFunc(n.NEVER);
            break;
          case 1:
            n.depthFunc(n.ALWAYS);
            break;
          case 2:
            n.depthFunc(n.LESS);
            break;
          case 3:
          default:
            n.depthFunc(n.LEQUAL);
            break;
          case 4:
            n.depthFunc(n.EQUAL);
            break;
          case 5:
            n.depthFunc(n.GEQUAL);
            break;
          case 6:
            n.depthFunc(n.GREATER);
            break;
          case 7:
            n.depthFunc(n.NOTEQUAL);
        }
        F = V;
      }
    }, setLocked: function(V) {
      E = V;
    }, setClear: function(V) {
      re !== V && (n.clearDepth(V), re = V);
    }, reset: function() {
      E = !1, B = null, F = null, re = null;
    } };
  }(), i = new function() {
    let E = !1, B = null, F = null, re = null, V = null, se = null, Me = null, ue = null, z = null;
    return { setTest: function(W) {
      E || (W ? de(n.STENCIL_TEST) : ie(n.STENCIL_TEST));
    }, setMask: function(W) {
      B === W || E || (n.stencilMask(W), B = W);
    }, setFunc: function(W, ee, ge) {
      F === W && re === ee && V === ge || (n.stencilFunc(W, ee, ge), F = W, re = ee, V = ge);
    }, setOp: function(W, ee, ge) {
      se === W && Me === ee && ue === ge || (n.stencilOp(W, ee, ge), se = W, Me = ee, ue = ge);
    }, setLocked: function(W) {
      E = W;
    }, setClear: function(W) {
      z !== W && (n.clearStencil(W), z = W);
    }, reset: function() {
      E = !1, B = null, F = null, re = null, V = null, se = null, Me = null, ue = null, z = null;
    } };
  }(), r = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap();
  let a = {}, o = {}, l = /* @__PURE__ */ new WeakMap(), h = [], c = null, u = !1, d = null, p = null, m = null, g = null, f = null, v = null, y = null, x = new oe(0, 0, 0), M = 0, b = !1, S = null, w = null, T = null, C = null, I = null;
  const A = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let L = !1, D = 0;
  const U = n.getParameter(n.VERSION);
  U.indexOf("WebGL") !== -1 ? (D = parseFloat(/^WebGL (\d)/.exec(U)[1]), L = D >= 1) : U.indexOf("OpenGL ES") !== -1 && (D = parseFloat(/^OpenGL ES (\d)/.exec(U)[1]), L = D >= 2);
  let H = null, Z = {};
  const te = n.getParameter(n.SCISSOR_BOX), ne = n.getParameter(n.VIEWPORT), ve = new Ve().fromArray(te), Se = new Ve().fromArray(ne);
  function Q(E, B, F, re) {
    const V = new Uint8Array(4), se = n.createTexture();
    n.bindTexture(E, se), n.texParameteri(E, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(E, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let Me = 0; Me < F; Me++)
      E === n.TEXTURE_3D || E === n.TEXTURE_2D_ARRAY ? n.texImage3D(B, 0, n.RGBA, 1, 1, re, 0, n.RGBA, n.UNSIGNED_BYTE, V) : n.texImage2D(B + Me, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, V);
    return se;
  }
  const ae = {};
  function de(E) {
    a[E] !== !0 && (n.enable(E), a[E] = !0);
  }
  function ie(E) {
    a[E] !== !1 && (n.disable(E), a[E] = !1);
  }
  ae[n.TEXTURE_2D] = Q(n.TEXTURE_2D, n.TEXTURE_2D, 1), ae[n.TEXTURE_CUBE_MAP] = Q(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ae[n.TEXTURE_2D_ARRAY] = Q(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), ae[n.TEXTURE_3D] = Q(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1), e.setClear(0, 0, 0, 1), t.setClear(1), i.setClear(0), de(n.DEPTH_TEST), t.setFunc(3), K(!1), O(1), de(n.CULL_FACE), j(0);
  const N = { [$n]: n.FUNC_ADD, [xw]: n.FUNC_SUBTRACT, [Mw]: n.FUNC_REVERSE_SUBTRACT };
  N[103] = n.MIN, N[104] = n.MAX;
  const R = { [Io]: n.ZERO, [kh]: n.ONE, [xd]: n.SRC_COLOR, [us]: n.SRC_ALPHA, [bw]: n.SRC_ALPHA_SATURATE, [Vh]: n.DST_COLOR, [zh]: n.DST_ALPHA, [Md]: n.ONE_MINUS_SRC_COLOR, [ds]: n.ONE_MINUS_SRC_ALPHA, [Sd]: n.ONE_MINUS_DST_COLOR, [bd]: n.ONE_MINUS_DST_ALPHA, [Sw]: n.CONSTANT_COLOR, [ww]: n.ONE_MINUS_CONSTANT_COLOR, [_w]: n.CONSTANT_ALPHA, [Tw]: n.ONE_MINUS_CONSTANT_ALPHA };
  function j(E, B, F, re, V, se, Me, ue, z, W) {
    if (E !== 0) {
      if (u === !1 && (de(n.BLEND), u = !0), E === Ro)
        V = V || B, se = se || F, Me = Me || re, B === p && V === f || (n.blendEquationSeparate(N[B], N[V]), p = B, f = V), F === m && re === g && se === v && Me === y || (n.blendFuncSeparate(R[F], R[re], R[se], R[Me]), m = F, g = re, v = se, y = Me), ue.equals(x) !== !1 && z === M || (n.blendColor(ue.r, ue.g, ue.b, z), x.copy(ue), M = z), d = E, b = !1;
      else if (E !== d || W !== b) {
        if (p === $n && f === $n || (n.blendEquation(n.FUNC_ADD), p = $n, f = $n), W)
          switch (E) {
            case 1:
              n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case Ar:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case 3:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case 4:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
          }
        else
          switch (E) {
            case 1:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case Ar:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case 3:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case 4:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
          }
        m = null, g = null, v = null, y = null, x.set(0, 0, 0), M = 0, d = E, b = W;
      }
    } else
      u === !0 && (ie(n.BLEND), u = !1);
  }
  function K(E) {
    S !== E && (E ? n.frontFace(n.CW) : n.frontFace(n.CCW), S = E);
  }
  function O(E) {
    E !== 0 ? (de(n.CULL_FACE), E !== w && (E === 1 ? n.cullFace(n.BACK) : E === 2 ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : ie(n.CULL_FACE), w = E;
  }
  function k(E, B, F) {
    E ? (de(n.POLYGON_OFFSET_FILL), C === B && I === F || (n.polygonOffset(B, F), C = B, I = F)) : ie(n.POLYGON_OFFSET_FILL);
  }
  return { buffers: { color: e, depth: t, stencil: i }, enable: de, disable: ie, bindFramebuffer: function(E, B) {
    return o[E] !== B && (n.bindFramebuffer(E, B), o[E] = B, E === n.DRAW_FRAMEBUFFER && (o[n.FRAMEBUFFER] = B), E === n.FRAMEBUFFER && (o[n.DRAW_FRAMEBUFFER] = B), !0);
  }, drawBuffers: function(E, B) {
    let F = h, re = !1;
    if (E) {
      F = l.get(B), F === void 0 && (F = [], l.set(B, F));
      const V = E.textures;
      if (F.length !== V.length || F[0] !== n.COLOR_ATTACHMENT0) {
        for (let se = 0, Me = V.length; se < Me; se++)
          F[se] = n.COLOR_ATTACHMENT0 + se;
        F.length = V.length, re = !0;
      }
    } else
      F[0] !== n.BACK && (F[0] = n.BACK, re = !0);
    re && n.drawBuffers(F);
  }, useProgram: function(E) {
    return c !== E && (n.useProgram(E), c = E, !0);
  }, setBlending: j, setMaterial: function(E, B) {
    E.side === bt ? ie(n.CULL_FACE) : de(n.CULL_FACE);
    let F = E.side === Tn;
    B && (F = !F), K(F), E.blending === 1 && E.transparent === !1 ? j(0) : j(E.blending, E.blendEquation, E.blendSrc, E.blendDst, E.blendEquationAlpha, E.blendSrcAlpha, E.blendDstAlpha, E.blendColor, E.blendAlpha, E.premultipliedAlpha), t.setFunc(E.depthFunc), t.setTest(E.depthTest), t.setMask(E.depthWrite), e.setMask(E.colorWrite);
    const re = E.stencilWrite;
    i.setTest(re), re && (i.setMask(E.stencilWriteMask), i.setFunc(E.stencilFunc, E.stencilRef, E.stencilFuncMask), i.setOp(E.stencilFail, E.stencilZFail, E.stencilZPass)), k(E.polygonOffset, E.polygonOffsetFactor, E.polygonOffsetUnits), E.alphaToCoverage === !0 ? de(n.SAMPLE_ALPHA_TO_COVERAGE) : ie(n.SAMPLE_ALPHA_TO_COVERAGE);
  }, setFlipSided: K, setCullFace: O, setLineWidth: function(E) {
    E !== T && (L && n.lineWidth(E), T = E);
  }, setPolygonOffset: k, setScissorTest: function(E) {
    E ? de(n.SCISSOR_TEST) : ie(n.SCISSOR_TEST);
  }, activeTexture: function(E) {
    E === void 0 && (E = n.TEXTURE0 + A - 1), H !== E && (n.activeTexture(E), H = E);
  }, bindTexture: function(E, B, F) {
    F === void 0 && (F = H === null ? n.TEXTURE0 + A - 1 : H);
    let re = Z[F];
    re === void 0 && (re = { type: void 0, texture: void 0 }, Z[F] = re), re.type === E && re.texture === B || (H !== F && (n.activeTexture(F), H = F), n.bindTexture(E, B || ae[E]), re.type = E, re.texture = B);
  }, unbindTexture: function() {
    const E = Z[H];
    E !== void 0 && E.type !== void 0 && (n.bindTexture(E.type, null), E.type = void 0, E.texture = void 0);
  }, compressedTexImage2D: function() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (E) {
    }
  }, compressedTexImage3D: function() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (E) {
    }
  }, texImage2D: function() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (E) {
    }
  }, texImage3D: function() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (E) {
    }
  }, updateUBOMapping: function(E, B) {
    let F = s.get(B);
    F === void 0 && (F = /* @__PURE__ */ new WeakMap(), s.set(B, F));
    let re = F.get(E);
    re === void 0 && (re = n.getUniformBlockIndex(B, E.name), F.set(E, re));
  }, uniformBlockBinding: function(E, B) {
    const F = s.get(B).get(E);
    r.get(B) !== F && (n.uniformBlockBinding(B, F, E.Bt), r.set(B, F));
  }, texStorage2D: function() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (E) {
    }
  }, texStorage3D: function() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (E) {
    }
  }, texSubImage2D: function() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (E) {
    }
  }, texSubImage3D: function() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (E) {
    }
  }, compressedTexSubImage2D: function() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (E) {
    }
  }, compressedTexSubImage3D: function() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (E) {
    }
  }, scissor: function(E) {
    ve.equals(E) === !1 && (n.scissor(E.x, E.y, E.z, E.w), ve.copy(E));
  }, viewport: function(E) {
    Se.equals(E) === !1 && (n.viewport(E.x, E.y, E.z, E.w), Se.copy(E));
  }, reset: function() {
    n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), a = {}, H = null, Z = {}, o = {}, l = /* @__PURE__ */ new WeakMap(), h = [], c = null, u = !1, d = null, p = null, m = null, g = null, f = null, v = null, y = null, x = new oe(0, 0, 0), M = 0, b = !1, S = null, w = null, T = null, C = null, I = null, ve.set(0, 0, n.canvas.width, n.canvas.height), Se.set(0, 0, n.canvas.width, n.canvas.height), e.reset(), t.reset(), i.reset();
  } };
}
function _T(n, e, t, i, r, s, a) {
  const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator != "undefined" && /OculusBrowser/g.test(navigator.userAgent), h = new X(), c = /* @__PURE__ */ new WeakMap();
  let u;
  const d = /* @__PURE__ */ new WeakMap();
  let p = !1;
  try {
    p = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (N) {
  }
  function m(N, R) {
    return p ? new OffscreenCanvas(N, R) : dh("canvas");
  }
  function g(N, R, j) {
    let K = 1;
    const O = ie(N);
    if ((O.width > j || O.height > j) && (K = j / Math.max(O.width, O.height)), K < 1) {
      if (typeof HTMLImageElement != "undefined" && N instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && N instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && N instanceof ImageBitmap || typeof VideoFrame != "undefined" && N instanceof VideoFrame) {
        const k = Math.floor(K * O.width), E = Math.floor(K * O.height);
        u === void 0 && (u = m(k, E));
        const B = R ? m(k, E) : u;
        return B.width = k, B.height = E, B.getContext("2d").drawImage(N, 0, 0, k, E), B;
      }
      return N;
    }
    return N;
  }
  function f(N) {
    return N.generateMipmaps && N.minFilter !== at && N.minFilter !== Vt;
  }
  function v(N) {
    n.generateMipmap(N);
  }
  function y(N, R, j, K, O = !1) {
    if (N !== null && n[N] !== void 0)
      return n[N];
    let k = R;
    if (R === n.RED && (j === n.FLOAT && (k = n.R32F), j === n.HALF_FLOAT && (k = n.R16F), j === n.UNSIGNED_BYTE && (k = n.R8)), R === n.RED_INTEGER && (j === n.UNSIGNED_BYTE && (k = n.R8UI), j === n.UNSIGNED_SHORT && (k = n.R16UI), j === n.UNSIGNED_INT && (k = n.R32UI), j === n.BYTE && (k = n.R8I), j === n.SHORT && (k = n.R16I), j === n.INT && (k = n.R32I)), R === n.RG && (j === n.FLOAT && (k = n.RG32F), j === n.HALF_FLOAT && (k = n.RG16F), j === n.UNSIGNED_BYTE && (k = n.RG8)), R === n.RG_INTEGER && (j === n.UNSIGNED_BYTE && (k = n.RG8UI), j === n.UNSIGNED_SHORT && (k = n.RG16UI), j === n.UNSIGNED_INT && (k = n.RG32UI), j === n.BYTE && (k = n.RG8I), j === n.SHORT && (k = n.RG16I), j === n.INT && (k = n.RG32I)), R === n.RGB && j === n.UNSIGNED_INT_5_9_9_9_REV && (k = n.RGB9_E5), R === n.RGBA) {
      const E = O ? oh : it.getTransfer(K);
      j === n.FLOAT && (k = n.RGBA32F), j === n.HALF_FLOAT && (k = n.RGBA16F), j === n.UNSIGNED_BYTE && (k = E === ft ? n.SRGB8_ALPHA8 : n.RGBA8), j === n.UNSIGNED_SHORT_4_4_4_4 && (k = n.RGBA4), j === n.UNSIGNED_SHORT_5_5_5_1 && (k = n.RGB5_A1);
    }
    return k !== n.R16F && k !== n.R32F && k !== n.RG16F && k !== n.RG32F && k !== n.RGBA16F && k !== n.RGBA32F || e.get("EXT_color_buffer_float"), k;
  }
  function x(N, R) {
    let j;
    return N ? R === null || R === Sa || R === ms ? j = n.DEPTH24_STENCIL8 : R === ni ? j = n.DEPTH32F_STENCIL8 : R === No && (j = n.DEPTH24_STENCIL8) : R === null || R === Sa || R === ms ? j = n.DEPTH_COMPONENT24 : R === ni ? j = n.DEPTH_COMPONENT32F : R === No && (j = n.DEPTH_COMPONENT16), j;
  }
  function M(N, R) {
    return f(N) === !0 || N.isFramebufferTexture && N.minFilter !== at && N.minFilter !== Vt ? Math.log2(Math.max(R.width, R.height)) + 1 : N.mipmaps !== void 0 && N.mipmaps.length > 0 ? N.mipmaps.length : N.isCompressedTexture && Array.isArray(N.image) ? R.mipmaps.length : 1;
  }
  function b(N) {
    const R = N.target;
    R.removeEventListener("dispose", b), function(j) {
      const K = i.get(j);
      if (K.Ht === void 0)
        return;
      const O = j.source, k = d.get(O);
      if (k) {
        const E = k[K.zt];
        E.usedTimes--, E.usedTimes === 0 && w(j), Object.keys(k).length === 0 && d.delete(O);
      }
      i.remove(j);
    }(R), R.isVideoTexture && c.delete(R);
  }
  function S(N) {
    const R = N.target;
    R.removeEventListener("dispose", S), function(j) {
      const K = i.get(j);
      if (j.depthTexture && j.depthTexture.dispose(), j.isWebGLCubeRenderTarget)
        for (let k = 0; k < 6; k++) {
          if (Array.isArray(K.Vt[k]))
            for (let E = 0; E < K.Vt[k].length; E++)
              n.deleteFramebuffer(K.Vt[k][E]);
          else
            n.deleteFramebuffer(K.Vt[k]);
          K.Wt && n.deleteRenderbuffer(K.Wt[k]);
        }
      else {
        if (Array.isArray(K.Vt))
          for (let k = 0; k < K.Vt.length; k++)
            n.deleteFramebuffer(K.Vt[k]);
        else
          n.deleteFramebuffer(K.Vt);
        if (K.Wt && n.deleteRenderbuffer(K.Wt), K.jt && n.deleteFramebuffer(K.jt), K.Xt)
          for (let k = 0; k < K.Xt.length; k++)
            K.Xt[k] && n.deleteRenderbuffer(K.Xt[k]);
        K.Yt && n.deleteRenderbuffer(K.Yt);
      }
      const O = j.textures;
      for (let k = 0, E = O.length; k < E; k++) {
        const B = i.get(O[k]);
        B.qt && (n.deleteTexture(B.qt), a.memory.textures--), i.remove(O[k]);
      }
      i.remove(j);
    }(R);
  }
  function w(N) {
    const R = i.get(N);
    n.deleteTexture(R.qt);
    const j = N.source;
    delete d.get(j)[R.zt], a.memory.textures--;
  }
  let T = 0;
  function C(N, R) {
    const j = i.get(N);
    if (N.isVideoTexture && function(K) {
      const O = a.render.frame;
      c.get(K) !== O && (c.set(K, O), K.update());
    }(N), N.isRenderTargetTexture === !1 && N.version > 0 && j.Zt !== N.version) {
      const K = N.image;
      if (K !== null) {
        if (K.complete !== !1)
          return void H(j, N, R);
      }
    }
    t.bindTexture(n.TEXTURE_2D, j.qt, n.TEXTURE0 + R);
  }
  const I = { [jt]: n.REPEAT, [vn]: n.CLAMP_TO_EDGE, [fs]: n.MIRRORED_REPEAT }, A = { [at]: n.NEAREST, [Pd]: n.NEAREST_MIPMAP_NEAREST, [sa]: n.NEAREST_MIPMAP_LINEAR, [Vt]: n.LINEAR, [xo]: n.LINEAR_MIPMAP_NEAREST, [er]: n.LINEAR_MIPMAP_LINEAR }, L = { [Ew]: n.NEVER, [Nw]: n.ALWAYS, [Aw]: n.LESS, [Pw]: n.LEQUAL, [Cw]: n.EQUAL, [Lw]: n.GEQUAL, [Rw]: n.GREATER, [Iw]: n.NOTEQUAL };
  function D(N, R) {
    if (R.type === ni && e.has("OES_texture_float_linear") === !1 && (R.magFilter === Vt || R.magFilter === xo || R.magFilter === sa || R.magFilter === er || R.minFilter === Vt || R.minFilter === xo || R.minFilter === sa || R.minFilter), n.texParameteri(N, n.TEXTURE_WRAP_S, I[R.wrapS]), n.texParameteri(N, n.TEXTURE_WRAP_T, I[R.wrapT]), N !== n.TEXTURE_3D && N !== n.TEXTURE_2D_ARRAY || n.texParameteri(N, n.TEXTURE_WRAP_R, I[R.wrapR]), n.texParameteri(N, n.TEXTURE_MAG_FILTER, A[R.magFilter]), n.texParameteri(N, n.TEXTURE_MIN_FILTER, A[R.minFilter]), R.compareFunction && (n.texParameteri(N, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(N, n.TEXTURE_COMPARE_FUNC, L[R.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (R.magFilter === at || R.minFilter !== sa && R.minFilter !== er || R.type === ni && e.has("OES_texture_float_linear") === !1)
        return;
      if (R.anisotropy > 1 || i.get(R).Jt) {
        const j = e.get("EXT_texture_filter_anisotropic");
        n.texParameterf(N, j.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(R.anisotropy, r.getMaxAnisotropy())), i.get(R).Jt = R.anisotropy;
      }
    }
  }
  function U(N, R) {
    let j = !1;
    N.Ht === void 0 && (N.Ht = !0, R.addEventListener("dispose", b));
    const K = R.source;
    let O = d.get(K);
    O === void 0 && (O = {}, d.set(K, O));
    const k = function(E) {
      const B = [];
      return B.push(E.wrapS), B.push(E.wrapT), B.push(E.wrapR || 0), B.push(E.magFilter), B.push(E.minFilter), B.push(E.anisotropy), B.push(E.internalFormat), B.push(E.format), B.push(E.type), B.push(E.generateMipmaps), B.push(E.premultiplyAlpha), B.push(E.flipY), B.push(E.unpackAlignment), B.push(E.colorSpace), B.join();
    }(R);
    if (k !== N.zt) {
      O[k] === void 0 && (O[k] = { texture: n.createTexture(), usedTimes: 0 }, a.memory.textures++, j = !0), O[k].usedTimes++;
      const E = O[N.zt];
      E !== void 0 && (O[N.zt].usedTimes--, E.usedTimes === 0 && w(R)), N.zt = k, N.qt = O[k].texture;
    }
    return j;
  }
  function H(N, R, j) {
    let K = n.TEXTURE_2D;
    (R.isDataArrayTexture || R.isCompressedArrayTexture) && (K = n.TEXTURE_2D_ARRAY), R.isData3DTexture && (K = n.TEXTURE_3D);
    const O = U(N, R), k = R.source;
    t.bindTexture(K, N.qt, n.TEXTURE0 + j);
    const E = i.get(k);
    if (k.version !== E.Zt || O === !0) {
      t.activeTexture(n.TEXTURE0 + j);
      const B = it.getPrimaries(it.workingColorSpace), F = R.colorSpace === ea ? null : it.getPrimaries(R.colorSpace), re = R.colorSpace === ea || B === F ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, R.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, R.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, re);
      let V = g(R.image, !1, r.maxTextureSize);
      V = de(R, V);
      const se = s.convert(R.format, R.colorSpace), Me = s.convert(R.type);
      let ue, z = y(R.internalFormat, se, Me, R.colorSpace, R.isVideoTexture);
      D(K, R);
      const W = R.mipmaps, ee = R.isVideoTexture !== !0, ge = E.Zt === void 0 || O === !0, Le = k.dataReady, Fe = M(R, V);
      if (R.isDepthTexture)
        z = x(R.format === gs, R.type), ge && (ee ? t.texStorage2D(n.TEXTURE_2D, 1, z, V.width, V.height) : t.texImage2D(n.TEXTURE_2D, 0, z, V.width, V.height, 0, se, Me, null));
      else if (R.isDataTexture)
        if (W.length > 0) {
          ee && ge && t.texStorage2D(n.TEXTURE_2D, Fe, z, W[0].width, W[0].height);
          for (let _e = 0, Be = W.length; _e < Be; _e++)
            ue = W[_e], ee ? Le && t.texSubImage2D(n.TEXTURE_2D, _e, 0, 0, ue.width, ue.height, se, Me, ue.data) : t.texImage2D(n.TEXTURE_2D, _e, z, ue.width, ue.height, 0, se, Me, ue.data);
          R.generateMipmaps = !1;
        } else
          ee ? (ge && t.texStorage2D(n.TEXTURE_2D, Fe, z, V.width, V.height), Le && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, V.width, V.height, se, Me, V.data)) : t.texImage2D(n.TEXTURE_2D, 0, z, V.width, V.height, 0, se, Me, V.data);
      else if (R.isCompressedTexture)
        if (R.isCompressedArrayTexture) {
          ee && ge && t.texStorage3D(n.TEXTURE_2D_ARRAY, Fe, z, W[0].width, W[0].height, V.depth);
          for (let _e = 0, Be = W.length; _e < Be; _e++)
            if (ue = W[_e], R.format !== yi) {
              if (se !== null)
                if (ee) {
                  if (Le)
                    if (R.layerUpdates.size > 0) {
                      for (const He of R.layerUpdates) {
                        const nt = ue.width * ue.height;
                        t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, _e, 0, 0, He, ue.width, ue.height, 1, se, ue.data.slice(nt * He, nt * (He + 1)), 0, 0);
                      }
                      R.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, _e, 0, 0, 0, ue.width, ue.height, V.depth, se, ue.data, 0, 0);
                } else
                  t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, _e, z, ue.width, ue.height, V.depth, 0, ue.data, 0, 0);
            } else
              ee ? Le && t.texSubImage3D(n.TEXTURE_2D_ARRAY, _e, 0, 0, 0, ue.width, ue.height, V.depth, se, Me, ue.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, _e, z, ue.width, ue.height, V.depth, 0, se, Me, ue.data);
        } else {
          ee && ge && t.texStorage2D(n.TEXTURE_2D, Fe, z, W[0].width, W[0].height);
          for (let _e = 0, Be = W.length; _e < Be; _e++)
            ue = W[_e], R.format !== yi ? se !== null && (ee ? Le && t.compressedTexSubImage2D(n.TEXTURE_2D, _e, 0, 0, ue.width, ue.height, se, ue.data) : t.compressedTexImage2D(n.TEXTURE_2D, _e, z, ue.width, ue.height, 0, ue.data)) : ee ? Le && t.texSubImage2D(n.TEXTURE_2D, _e, 0, 0, ue.width, ue.height, se, Me, ue.data) : t.texImage2D(n.TEXTURE_2D, _e, z, ue.width, ue.height, 0, se, Me, ue.data);
        }
      else if (R.isDataArrayTexture)
        if (ee) {
          if (ge && t.texStorage3D(n.TEXTURE_2D_ARRAY, Fe, z, V.width, V.height, V.depth), Le)
            if (R.layerUpdates.size > 0) {
              let _e;
              switch (Me) {
                case n.UNSIGNED_BYTE:
                  switch (se) {
                    case n.ALPHA:
                    case n.LUMINANCE:
                      _e = 1;
                      break;
                    case n.LUMINANCE_ALPHA:
                      _e = 2;
                      break;
                    case n.RGB:
                      _e = 3;
                      break;
                    case n.RGBA:
                      _e = 4;
                      break;
                    default:
                      throw new Error(`Unknown texel size for format ${se}.`);
                  }
                  break;
                case n.UNSIGNED_SHORT_4_4_4_4:
                case n.UNSIGNED_SHORT_5_5_5_1:
                case n.UNSIGNED_SHORT_5_6_5:
                  _e = 1;
                  break;
                default:
                  throw new Error(`Unknown texel size for type ${Me}.`);
              }
              const Be = V.width * V.height * _e;
              for (const He of R.layerUpdates)
                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, He, V.width, V.height, 1, se, Me, V.data.slice(Be * He, Be * (He + 1)));
              R.clearLayerUpdates();
            } else
              t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, V.width, V.height, V.depth, se, Me, V.data);
        } else
          t.texImage3D(n.TEXTURE_2D_ARRAY, 0, z, V.width, V.height, V.depth, 0, se, Me, V.data);
      else if (R.isData3DTexture)
        ee ? (ge && t.texStorage3D(n.TEXTURE_3D, Fe, z, V.width, V.height, V.depth), Le && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, V.width, V.height, V.depth, se, Me, V.data)) : t.texImage3D(n.TEXTURE_3D, 0, z, V.width, V.height, V.depth, 0, se, Me, V.data);
      else if (R.isFramebufferTexture) {
        if (ge)
          if (ee)
            t.texStorage2D(n.TEXTURE_2D, Fe, z, V.width, V.height);
          else {
            let _e = V.width, Be = V.height;
            for (let He = 0; He < Fe; He++)
              t.texImage2D(n.TEXTURE_2D, He, z, _e, Be, 0, se, Me, null), _e >>= 1, Be >>= 1;
          }
      } else if (W.length > 0) {
        if (ee && ge) {
          const _e = ie(W[0]);
          t.texStorage2D(n.TEXTURE_2D, Fe, z, _e.width, _e.height);
        }
        for (let _e = 0, Be = W.length; _e < Be; _e++)
          ue = W[_e], ee ? Le && t.texSubImage2D(n.TEXTURE_2D, _e, 0, 0, se, Me, ue) : t.texImage2D(n.TEXTURE_2D, _e, z, se, Me, ue);
        R.generateMipmaps = !1;
      } else if (ee) {
        if (ge) {
          const _e = ie(V);
          t.texStorage2D(n.TEXTURE_2D, Fe, z, _e.width, _e.height);
        }
        Le && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, se, Me, V);
      } else
        t.texImage2D(n.TEXTURE_2D, 0, z, se, Me, V);
      f(R) && v(K), E.Zt = k.version, R.onUpdate && R.onUpdate(R);
    }
    N.Zt = R.version;
  }
  function Z(N, R, j, K, O, k) {
    const E = s.convert(j.format, j.colorSpace), B = s.convert(j.type), F = y(j.internalFormat, E, B, j.colorSpace);
    if (!i.get(R).Kt) {
      const re = Math.max(1, R.width >> k), V = Math.max(1, R.height >> k);
      O === n.TEXTURE_3D || O === n.TEXTURE_2D_ARRAY ? t.texImage3D(O, k, F, re, V, R.depth, 0, E, B, null) : t.texImage2D(O, k, F, re, V, 0, E, B, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, N), ae(R) ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, K, O, i.get(j).qt, 0, Q(R)) : (O === n.TEXTURE_2D || O >= n.TEXTURE_CUBE_MAP_POSITIVE_X && O <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, K, O, i.get(j).qt, k), t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function te(N, R, j) {
    if (n.bindRenderbuffer(n.RENDERBUFFER, N), R.depthBuffer) {
      const K = R.depthTexture, O = K && K.isDepthTexture ? K.type : null, k = x(R.stencilBuffer, O), E = R.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, B = Q(R);
      ae(R) ? o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, B, k, R.width, R.height) : j ? n.renderbufferStorageMultisample(n.RENDERBUFFER, B, k, R.width, R.height) : n.renderbufferStorage(n.RENDERBUFFER, k, R.width, R.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, E, n.RENDERBUFFER, N);
    } else {
      const K = R.textures;
      for (let O = 0; O < K.length; O++) {
        const k = K[O], E = s.convert(k.format, k.colorSpace), B = s.convert(k.type), F = y(k.internalFormat, E, B, k.colorSpace), re = Q(R);
        j && ae(R) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, re, F, R.width, R.height) : ae(R) ? o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, re, F, R.width, R.height) : n.renderbufferStorage(n.RENDERBUFFER, F, R.width, R.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function ne(N) {
    const R = i.get(N), j = N.isWebGLCubeRenderTarget === !0;
    if (N.depthTexture && !R.$t) {
      if (j)
        throw new Error("target.depthTexture not supported in Cube render targets");
      (function(K, O) {
        if (O && O.isWebGLCubeRenderTarget)
          throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, K), !O.depthTexture || !O.depthTexture.isDepthTexture)
          throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        i.get(O.depthTexture).qt && O.depthTexture.image.width === O.width && O.depthTexture.image.height === O.height || (O.depthTexture.image.width = O.width, O.depthTexture.image.height = O.height, O.depthTexture.needsUpdate = !0), C(O.depthTexture, 0);
        const k = i.get(O.depthTexture).qt, E = Q(O);
        if (O.depthTexture.format === Do)
          ae(O) ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, k, 0, E) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, k, 0);
        else {
          if (O.depthTexture.format !== gs)
            throw new Error("Unknown depthTexture format");
          ae(O) ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, k, 0, E) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, k, 0);
        }
      })(R.Vt, N);
    } else if (j) {
      R.Wt = [];
      for (let K = 0; K < 6; K++)
        t.bindFramebuffer(n.FRAMEBUFFER, R.Vt[K]), R.Wt[K] = n.createRenderbuffer(), te(R.Wt[K], N, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, R.Vt), R.Wt = n.createRenderbuffer(), te(R.Wt, N, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  const ve = [], Se = [];
  function Q(N) {
    return Math.min(r.maxSamples, N.samples);
  }
  function ae(N) {
    const R = i.get(N);
    return N.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && R.Qt !== !1;
  }
  function de(N, R) {
    const j = N.colorSpace;
    return N.format, N.type, N.isCompressedTexture === !0 || N.isVideoTexture === !0 || j !== Jt && j !== ea && it.getTransfer(j), R;
  }
  function ie(N) {
    return typeof HTMLImageElement != "undefined" && N instanceof HTMLImageElement ? (h.width = N.naturalWidth || N.width, h.height = N.naturalHeight || N.height) : typeof VideoFrame != "undefined" && N instanceof VideoFrame ? (h.width = N.displayWidth, h.height = N.displayHeight) : (h.width = N.width, h.height = N.height), h;
  }
  this.allocateTextureUnit = function() {
    const N = T;
    return r.maxTextures, T += 1, N;
  }, this.resetTextureUnits = function() {
    T = 0;
  }, this.setTexture2D = C, this.setTexture2DArray = function(N, R) {
    const j = i.get(N);
    N.version > 0 && j.Zt !== N.version ? H(j, N, R) : t.bindTexture(n.TEXTURE_2D_ARRAY, j.qt, n.TEXTURE0 + R);
  }, this.setTexture3D = function(N, R) {
    const j = i.get(N);
    N.version > 0 && j.Zt !== N.version ? H(j, N, R) : t.bindTexture(n.TEXTURE_3D, j.qt, n.TEXTURE0 + R);
  }, this.setTextureCube = function(N, R) {
    const j = i.get(N);
    N.version > 0 && j.Zt !== N.version ? function(K, O, k) {
      if (O.image.length !== 6)
        return;
      const E = U(K, O), B = O.source;
      t.bindTexture(n.TEXTURE_CUBE_MAP, K.qt, n.TEXTURE0 + k);
      const F = i.get(B);
      if (B.version !== F.Zt || E === !0) {
        t.activeTexture(n.TEXTURE0 + k);
        const re = it.getPrimaries(it.workingColorSpace), V = O.colorSpace === ea ? null : it.getPrimaries(O.colorSpace), se = O.colorSpace === ea || re === V ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
        n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, O.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, O.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, se);
        const Me = O.isCompressedTexture || O.image[0].isCompressedTexture, ue = O.image[0] && O.image[0].isDataTexture, z = [];
        for (let Ce = 0; Ce < 6; Ce++)
          z[Ce] = Me || ue ? ue ? O.image[Ce].image : O.image[Ce] : g(O.image[Ce], !0, r.maxCubemapSize), z[Ce] = de(O, z[Ce]);
        const W = z[0], ee = s.convert(O.format, O.colorSpace), ge = s.convert(O.type), Le = y(O.internalFormat, ee, ge, O.colorSpace), Fe = O.isVideoTexture !== !0, _e = F.Zt === void 0 || E === !0, Be = B.dataReady;
        let He, nt = M(O, W);
        if (D(n.TEXTURE_CUBE_MAP, O), Me) {
          Fe && _e && t.texStorage2D(n.TEXTURE_CUBE_MAP, nt, Le, W.width, W.height);
          for (let Ce = 0; Ce < 6; Ce++) {
            He = z[Ce].mipmaps;
            for (let rt = 0; rt < He.length; rt++) {
              const ze = He[rt];
              O.format !== yi ? ee !== null && (Fe ? Be && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, rt, 0, 0, ze.width, ze.height, ee, ze.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, rt, Le, ze.width, ze.height, 0, ze.data)) : Fe ? Be && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, rt, 0, 0, ze.width, ze.height, ee, ge, ze.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, rt, Le, ze.width, ze.height, 0, ee, ge, ze.data);
            }
          }
        } else {
          if (He = O.mipmaps, Fe && _e) {
            He.length > 0 && nt++;
            const Ce = ie(z[0]);
            t.texStorage2D(n.TEXTURE_CUBE_MAP, nt, Le, Ce.width, Ce.height);
          }
          for (let Ce = 0; Ce < 6; Ce++)
            if (ue) {
              Fe ? Be && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, 0, 0, 0, z[Ce].width, z[Ce].height, ee, ge, z[Ce].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, 0, Le, z[Ce].width, z[Ce].height, 0, ee, ge, z[Ce].data);
              for (let rt = 0; rt < He.length; rt++) {
                const ze = He[rt].image[Ce].image;
                Fe ? Be && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, rt + 1, 0, 0, ze.width, ze.height, ee, ge, ze.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, rt + 1, Le, ze.width, ze.height, 0, ee, ge, ze.data);
              }
            } else {
              Fe ? Be && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, 0, 0, 0, ee, ge, z[Ce]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, 0, Le, ee, ge, z[Ce]);
              for (let rt = 0; rt < He.length; rt++) {
                const ze = He[rt];
                Fe ? Be && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, rt + 1, 0, 0, ee, ge, ze.image[Ce]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ce, rt + 1, Le, ee, ge, ze.image[Ce]);
              }
            }
        }
        f(O) && v(n.TEXTURE_CUBE_MAP), F.Zt = B.version, O.onUpdate && O.onUpdate(O);
      }
      K.Zt = O.version;
    }(j, N, R) : t.bindTexture(n.TEXTURE_CUBE_MAP, j.qt, n.TEXTURE0 + R);
  }, this.rebindTextures = function(N, R, j) {
    const K = i.get(N);
    R !== void 0 && Z(K.Vt, N, N.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), j !== void 0 && ne(N);
  }, this.setupRenderTarget = function(N) {
    const R = N.texture, j = i.get(N), K = i.get(R);
    N.addEventListener("dispose", S);
    const O = N.textures, k = N.isWebGLCubeRenderTarget === !0, E = O.length > 1;
    if (E || (K.qt === void 0 && (K.qt = n.createTexture()), K.Zt = R.version, a.memory.textures++), k) {
      j.Vt = [];
      for (let B = 0; B < 6; B++)
        if (R.mipmaps && R.mipmaps.length > 0) {
          j.Vt[B] = [];
          for (let F = 0; F < R.mipmaps.length; F++)
            j.Vt[B][F] = n.createFramebuffer();
        } else
          j.Vt[B] = n.createFramebuffer();
    } else {
      if (R.mipmaps && R.mipmaps.length > 0) {
        j.Vt = [];
        for (let B = 0; B < R.mipmaps.length; B++)
          j.Vt[B] = n.createFramebuffer();
      } else
        j.Vt = n.createFramebuffer();
      if (E)
        for (let B = 0, F = O.length; B < F; B++) {
          const re = i.get(O[B]);
          re.qt === void 0 && (re.qt = n.createTexture(), a.memory.textures++);
        }
      if (N.samples > 0 && ae(N) === !1) {
        j.jt = n.createFramebuffer(), j.Xt = [], t.bindFramebuffer(n.FRAMEBUFFER, j.jt);
        for (let B = 0; B < O.length; B++) {
          const F = O[B];
          j.Xt[B] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, j.Xt[B]);
          const re = s.convert(F.format, F.colorSpace), V = s.convert(F.type), se = y(F.internalFormat, re, V, F.colorSpace, N.isXRRenderTarget === !0), Me = Q(N);
          n.renderbufferStorageMultisample(n.RENDERBUFFER, Me, se, N.width, N.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + B, n.RENDERBUFFER, j.Xt[B]);
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null), N.depthBuffer && (j.Yt = n.createRenderbuffer(), te(j.Yt, N, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (k) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, K.qt), D(n.TEXTURE_CUBE_MAP, R);
      for (let B = 0; B < 6; B++)
        if (R.mipmaps && R.mipmaps.length > 0)
          for (let F = 0; F < R.mipmaps.length; F++)
            Z(j.Vt[B][F], N, R, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + B, F);
        else
          Z(j.Vt[B], N, R, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + B, 0);
      f(R) && v(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (E) {
      for (let B = 0, F = O.length; B < F; B++) {
        const re = O[B], V = i.get(re);
        t.bindTexture(n.TEXTURE_2D, V.qt), D(n.TEXTURE_2D, re), Z(j.Vt, N, re, n.COLOR_ATTACHMENT0 + B, n.TEXTURE_2D, 0), f(re) && v(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let B = n.TEXTURE_2D;
      if ((N.isWebGL3DRenderTarget || N.isWebGLArrayRenderTarget) && (B = N.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY), t.bindTexture(B, K.qt), D(B, R), R.mipmaps && R.mipmaps.length > 0)
        for (let F = 0; F < R.mipmaps.length; F++)
          Z(j.Vt[F], N, R, n.COLOR_ATTACHMENT0, B, F);
      else
        Z(j.Vt, N, R, n.COLOR_ATTACHMENT0, B, 0);
      f(R) && v(B), t.unbindTexture();
    }
    N.depthBuffer && ne(N);
  }, this.updateRenderTargetMipmap = function(N) {
    const R = N.textures;
    for (let j = 0, K = R.length; j < K; j++) {
      const O = R[j];
      if (f(O)) {
        const k = N.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D, E = i.get(O).qt;
        t.bindTexture(k, E), v(k), t.unbindTexture();
      }
    }
  }, this.updateMultisampleRenderTarget = function(N) {
    if (N.samples > 0) {
      if (ae(N) === !1) {
        const R = N.textures, j = N.width, K = N.height;
        let O = n.COLOR_BUFFER_BIT;
        const k = N.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, E = i.get(N), B = R.length > 1;
        if (B)
          for (let F = 0; F < R.length; F++)
            t.bindFramebuffer(n.FRAMEBUFFER, E.jt), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + F, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, E.Vt), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + F, n.TEXTURE_2D, null, 0);
        t.bindFramebuffer(n.READ_FRAMEBUFFER, E.jt), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, E.Vt);
        for (let F = 0; F < R.length; F++) {
          if (N.resolveDepthBuffer && (N.depthBuffer && (O |= n.DEPTH_BUFFER_BIT), N.stencilBuffer && N.resolveStencilBuffer && (O |= n.STENCIL_BUFFER_BIT)), B) {
            n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, E.Xt[F]);
            const re = i.get(R[F]).qt;
            n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, re, 0);
          }
          n.blitFramebuffer(0, 0, j, K, 0, 0, j, K, O, n.NEAREST), l === !0 && (ve.length = 0, Se.length = 0, ve.push(n.COLOR_ATTACHMENT0 + F), N.depthBuffer && N.resolveDepthBuffer === !1 && (ve.push(k), Se.push(k), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, Se)), n.invalidateFramebuffer(n.READ_FRAMEBUFFER, ve));
        }
        if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), B)
          for (let F = 0; F < R.length; F++) {
            t.bindFramebuffer(n.FRAMEBUFFER, E.jt), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + F, n.RENDERBUFFER, E.Xt[F]);
            const re = i.get(R[F]).qt;
            t.bindFramebuffer(n.FRAMEBUFFER, E.Vt), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + F, n.TEXTURE_2D, re, 0);
          }
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, E.jt);
      } else if (N.depthBuffer && N.resolveDepthBuffer === !1 && l) {
        const R = N.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [R]);
      }
    }
  }, this.setupDepthRenderbuffer = ne, this.setupFrameBufferTexture = Z, this.useMultisampledRTT = ae;
}
function rM(n, e) {
  return { convert: function(t, i = "") {
    let r;
    const s = it.getTransfer(i);
    if (t === ba)
      return n.UNSIGNED_BYTE;
    if (t === vg)
      return n.UNSIGNED_SHORT_4_4_4_4;
    if (t === yg)
      return n.UNSIGNED_SHORT_5_5_5_1;
    if (t === 35902)
      return n.UNSIGNED_INT_5_9_9_9_REV;
    if (t === 1010)
      return n.BYTE;
    if (t === 1011)
      return n.SHORT;
    if (t === No)
      return n.UNSIGNED_SHORT;
    if (t === gg)
      return n.INT;
    if (t === Sa)
      return n.UNSIGNED_INT;
    if (t === ni)
      return n.FLOAT;
    if (t === Ht)
      return n.HALF_FLOAT;
    if (t === 1021)
      return n.ALPHA;
    if (t === 1022)
      return n.RGB;
    if (t === yi)
      return n.RGBA;
    if (t === 1024)
      return n.LUMINANCE;
    if (t === 1025)
      return n.LUMINANCE_ALPHA;
    if (t === Do)
      return n.DEPTH_COMPONENT;
    if (t === gs)
      return n.DEPTH_STENCIL;
    if (t === xg)
      return n.RED;
    if (t === Mg)
      return n.RED_INTEGER;
    if (t === 1030)
      return n.RG;
    if (t === bg)
      return n.RG_INTEGER;
    if (t === Sg)
      return n.RGBA_INTEGER;
    if (t === Tu || t === Eu || t === Au || t === Cu)
      if (s === ft) {
        if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r === null)
          return null;
        if (t === Tu)
          return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (t === Eu)
          return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (t === Au)
          return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (t === Cu)
          return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else {
        if (r = e.get("WEBGL_compressed_texture_s3tc"), r === null)
          return null;
        if (t === Tu)
          return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (t === Eu)
          return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (t === Au)
          return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (t === Cu)
          return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    if (t === qf || t === Yf || t === Zf || t === Kf) {
      if (r = e.get("WEBGL_compressed_texture_pvrtc"), r === null)
        return null;
      if (t === qf)
        return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (t === Yf)
        return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (t === Zf)
        return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (t === Kf)
        return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (t === Jf || t === Qf || t === $f) {
      if (r = e.get("WEBGL_compressed_texture_etc"), r === null)
        return null;
      if (t === Jf || t === Qf)
        return s === ft ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
      if (t === $f)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (t === em || t === tm || t === nm || t === im || t === rm || t === sm || t === am || t === om || t === lm || t === hm || t === cm || t === um || t === dm || t === pm) {
      if (r = e.get("WEBGL_compressed_texture_astc"), r === null)
        return null;
      if (t === em)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (t === tm)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (t === nm)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (t === im)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (t === rm)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (t === sm)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (t === am)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (t === om)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (t === lm)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (t === hm)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (t === cm)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (t === um)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (t === dm)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (t === pm)
        return s === ft ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
    }
    if (t === Pu || t === fm || t === mm) {
      if (r = e.get("EXT_texture_compression_bptc"), r === null)
        return null;
      if (t === Pu)
        return s === ft ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      if (t === fm)
        return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
      if (t === mm)
        return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
    }
    if (t === 36283 || t === gm || t === vm || t === ym) {
      if (r = e.get("EXT_texture_compression_rgtc"), r === null)
        return null;
      if (t === Pu)
        return r.COMPRESSED_RED_RGTC1_EXT;
      if (t === gm)
        return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
      if (t === vm)
        return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
      if (t === ym)
        return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
    }
    return t === ms ? n.UNSIGNED_INT_24_8 : n[t] !== void 0 ? n[t] : null;
  } };
}
class sM extends Gt {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class yn extends Ue {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const TT = { type: "move" };
class Up {
  constructor() {
    this.te = null, this.ee = null, this.ne = null;
  }
  getHandSpace() {
    return this.ne === null && (this.ne = new yn(), this.ne.matrixAutoUpdate = !1, this.ne.visible = !1, this.ne.joints = {}, this.ne.inputState = { pinching: !1 }), this.ne;
  }
  getTargetRaySpace() {
    return this.te === null && (this.te = new yn(), this.te.matrixAutoUpdate = !1, this.te.visible = !1, this.te.hasLinearVelocity = !1, this.te.linearVelocity = new _(), this.te.hasAngularVelocity = !1, this.te.angularVelocity = new _()), this.te;
  }
  getGripSpace() {
    return this.ee === null && (this.ee = new yn(), this.ee.matrixAutoUpdate = !1, this.ee.visible = !1, this.ee.hasLinearVelocity = !1, this.ee.linearVelocity = new _(), this.ee.hasAngularVelocity = !1, this.ee.angularVelocity = new _()), this.ee;
  }
  dispatchEvent(e) {
    return this.te !== null && this.te.dispatchEvent(e), this.ee !== null && this.ee.dispatchEvent(e), this.ne !== null && this.ne.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this.ne;
      if (t)
        for (const i of e.hand.values())
          this.ie(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this.te !== null && (this.te.visible = !1), this.ee !== null && (this.ee.visible = !1), this.ne !== null && (this.ne.visible = !1), this;
  }
  update(e, t, i) {
    let r = null, s = null, a = null;
    const o = this.te, l = this.ee, h = this.ne;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (h && e.hand) {
        a = !0;
        for (const g of e.hand.values()) {
          const f = t.getJointPose(g, i), v = this.ie(h, g);
          f !== null && (v.matrix.fromArray(f.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.matrixWorldNeedsUpdate = !0, v.jointRadius = f.radius), v.visible = f !== null;
        }
        const c = h.joints["index-finger-tip"], u = h.joints["thumb-tip"], d = c.position.distanceTo(u.position), p = 0.02, m = 5e-3;
        h.inputState.pinching && d > p + m ? (h.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !h.inputState.pinching && d <= p - m && (h.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
      } else
        l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
      o !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(TT)));
    }
    return o !== null && (o.visible = r !== null), l !== null && (l.visible = s !== null), h !== null && (h.visible = a !== null), this;
  }
  ie(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new yn();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class ET {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, i) {
    if (this.texture === null) {
      const r = new pt();
      e.properties.get(r).qt = t.texture, t.depthNear == i.depthNear && t.depthFar == i.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, i = new tt({ vertexShader: `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, fragmentShader: `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: t.z }, depthHeight: { value: t.w } } });
      this.mesh = new ce(new or(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
}
class AT extends rr {
  constructor(e, t) {
    super();
    const i = this;
    let r = null, s = 1, a = null, o = "local-floor", l = 1, h = null, c = null, u = null, d = null, p = null, m = null;
    const g = new ET(), f = t.getContextAttributes();
    let v = null, y = null;
    const x = [], M = [], b = new X();
    let S = null;
    const w = new Gt();
    w.layers.enable(1), w.viewport = new Ve();
    const T = new Gt();
    T.layers.enable(2), T.viewport = new Ve();
    const C = [w, T], I = new sM();
    I.layers.enable(1), I.layers.enable(2);
    let A = null, L = null;
    function D(Q) {
      const ae = M.indexOf(Q.inputSource);
      if (ae === -1)
        return;
      const de = x[ae];
      de !== void 0 && (de.update(Q.inputSource, Q.frame, h || a), de.dispatchEvent({ type: Q.type, data: Q.inputSource }));
    }
    function U() {
      r.removeEventListener("select", D), r.removeEventListener("selectstart", D), r.removeEventListener("selectend", D), r.removeEventListener("squeeze", D), r.removeEventListener("squeezestart", D), r.removeEventListener("squeezeend", D), r.removeEventListener("end", U), r.removeEventListener("inputsourceschange", H);
      for (let Q = 0; Q < x.length; Q++) {
        const ae = M[Q];
        ae !== null && (M[Q] = null, x[Q].disconnect(ae));
      }
      A = null, L = null, g.reset(), e.setRenderTarget(v), p = null, d = null, u = null, r = null, y = null, Se.stop(), i.isPresenting = !1, e.setPixelRatio(S), e.setSize(b.width, b.height, !1), i.dispatchEvent({ type: "sessionend" });
    }
    function H(Q) {
      for (let ae = 0; ae < Q.removed.length; ae++) {
        const de = Q.removed[ae], ie = M.indexOf(de);
        ie >= 0 && (M[ie] = null, x[ie].disconnect(de));
      }
      for (let ae = 0; ae < Q.added.length; ae++) {
        const de = Q.added[ae];
        let ie = M.indexOf(de);
        if (ie === -1) {
          for (let R = 0; R < x.length; R++) {
            if (R >= M.length) {
              M.push(de), ie = R;
              break;
            }
            if (M[R] === null) {
              M[R] = de, ie = R;
              break;
            }
          }
          if (ie === -1)
            break;
        }
        const N = x[ie];
        N && N.connect(de);
      }
    }
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(Q) {
      let ae = x[Q];
      return ae === void 0 && (ae = new Up(), x[Q] = ae), ae.getTargetRaySpace();
    }, this.getControllerGrip = function(Q) {
      let ae = x[Q];
      return ae === void 0 && (ae = new Up(), x[Q] = ae), ae.getGripSpace();
    }, this.getHand = function(Q) {
      let ae = x[Q];
      return ae === void 0 && (ae = new Up(), x[Q] = ae), ae.getHandSpace();
    }, this.setFramebufferScaleFactor = function(Q) {
      s = Q, i.isPresenting;
    }, this.setReferenceSpaceType = function(Q) {
      o = Q, i.isPresenting;
    }, this.getReferenceSpace = function() {
      return h || a;
    }, this.setReferenceSpace = function(Q) {
      h = Q;
    }, this.getBaseLayer = function() {
      return d !== null ? d : p;
    }, this.getBinding = function() {
      return u;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return r;
    }, this.setSession = function(Q) {
      return li(this, null, function* () {
        if (r = Q, r !== null) {
          if (v = e.getRenderTarget(), r.addEventListener("select", D), r.addEventListener("selectstart", D), r.addEventListener("selectend", D), r.addEventListener("squeeze", D), r.addEventListener("squeezestart", D), r.addEventListener("squeezeend", D), r.addEventListener("end", U), r.addEventListener("inputsourceschange", H), f.xrCompatible !== !0 && (yield t.makeXRCompatible()), S = e.getPixelRatio(), e.getSize(b), r.renderState.layers === void 0) {
            const ae = { antialias: f.antialias, alpha: !0, depth: f.depth, stencil: f.stencil, framebufferScaleFactor: s };
            p = new XRWebGLLayer(r, t, ae), r.updateRenderState({ baseLayer: p }), e.setPixelRatio(1), e.setSize(p.framebufferWidth, p.framebufferHeight, !1), y = new ht(p.framebufferWidth, p.framebufferHeight, { format: yi, type: ba, colorSpace: e.outputColorSpace, stencilBuffer: f.stencil });
          } else {
            let ae = null, de = null, ie = null;
            f.depth && (ie = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ae = f.stencil ? gs : Do, de = f.stencil ? ms : Sa);
            const N = { colorFormat: t.RGBA8, depthFormat: ie, scaleFactor: s };
            u = new XRWebGLBinding(r, t), d = u.createProjectionLayer(N), r.updateRenderState({ layers: [d] }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), y = new ht(d.textureWidth, d.textureHeight, { format: yi, type: ba, depthTexture: new Wh(d.textureWidth, d.textureHeight, de, void 0, void 0, void 0, void 0, void 0, void 0, ae), stencilBuffer: f.stencil, colorSpace: e.outputColorSpace, samples: f.antialias ? 4 : 0, resolveDepthBuffer: d.ignoreDepthValues === !1 });
          }
          y.isXRRenderTarget = !0, this.setFoveation(l), h = null, a = yield r.requestReferenceSpace(o), Se.setContext(r), Se.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
        }
      });
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    };
    const Z = new _(), te = new _();
    function ne(Q, ae) {
      ae === null ? Q.matrixWorld.copy(Q.matrix) : Q.matrixWorld.multiplyMatrices(ae.matrixWorld, Q.matrix), Q.matrixWorldInverse.copy(Q.matrixWorld).invert();
    }
    this.updateCamera = function(Q) {
      if (r === null)
        return;
      g.texture !== null && (Q.near = g.depthNear, Q.far = g.depthFar), I.near = T.near = w.near = Q.near, I.far = T.far = w.far = Q.far, A === I.near && L === I.far || (r.updateRenderState({ depthNear: I.near, depthFar: I.far }), A = I.near, L = I.far, w.near = A, w.far = L, T.near = A, T.far = L, w.updateProjectionMatrix(), T.updateProjectionMatrix(), Q.updateProjectionMatrix());
      const ae = Q.parent, de = I.cameras;
      ne(I, ae);
      for (let ie = 0; ie < de.length; ie++)
        ne(de[ie], ae);
      de.length === 2 ? function(ie, N, R) {
        Z.setFromMatrixPosition(N.matrixWorld), te.setFromMatrixPosition(R.matrixWorld);
        const j = Z.distanceTo(te), K = N.projectionMatrix.elements, O = R.projectionMatrix.elements, k = K[14] / (K[10] - 1), E = K[14] / (K[10] + 1), B = (K[9] + 1) / K[5], F = (K[9] - 1) / K[5], re = (K[8] - 1) / K[0], V = (O[8] + 1) / O[0], se = k * re, Me = k * V, ue = j / (-re + V), z = ue * -re;
        N.matrixWorld.decompose(ie.position, ie.quaternion, ie.scale), ie.translateX(z), ie.translateZ(ue), ie.matrixWorld.compose(ie.position, ie.quaternion, ie.scale), ie.matrixWorldInverse.copy(ie.matrixWorld).invert();
        const W = k + ue, ee = E + ue, ge = se - z, Le = Me + (j - z), Fe = B * E / ee * W, _e = F * E / ee * W;
        ie.projectionMatrix.makePerspective(ge, Le, Fe, _e, W, ee), ie.projectionMatrixInverse.copy(ie.projectionMatrix).invert();
      }(I, w, T) : I.projectionMatrix.copy(w.projectionMatrix), function(ie, N, R) {
        R === null ? ie.matrix.copy(N.matrixWorld) : (ie.matrix.copy(R.matrixWorld), ie.matrix.invert(), ie.matrix.multiply(N.matrixWorld)), ie.matrix.decompose(ie.position, ie.quaternion, ie.scale), ie.updateMatrixWorld(!0), ie.projectionMatrix.copy(N.projectionMatrix), ie.projectionMatrixInverse.copy(N.projectionMatrixInverse), ie.isPerspectiveCamera && (ie.fov = 2 * Fo * Math.atan(1 / ie.projectionMatrix.elements[5]), ie.zoom = 1);
      }(Q, I, ae);
    }, this.getCamera = function() {
      return I;
    }, this.getFoveation = function() {
      return d === null && p === null ? void 0 : l;
    }, this.setFoveation = function(Q) {
      l = Q, d !== null && (d.fixedFoveation = Q), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = Q);
    }, this.hasDepthSensing = function() {
      return g.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return g.getMesh(I);
    };
    let ve = null;
    const Se = new Q1();
    Se.setAnimationLoop(function(Q, ae) {
      if (c = ae.getViewerPose(h || a), m = ae, c !== null) {
        const de = c.views;
        p !== null && (e.setRenderTargetFramebuffer(y, p.framebuffer), e.setRenderTarget(y));
        let ie = !1;
        de.length !== I.cameras.length && (I.cameras.length = 0, ie = !0);
        for (let R = 0; R < de.length; R++) {
          const j = de[R];
          let K = null;
          if (p !== null)
            K = p.getViewport(j);
          else {
            const k = u.getViewSubImage(d, j);
            K = k.viewport, R === 0 && (e.setRenderTargetTextures(y, k.colorTexture, d.ignoreDepthValues ? void 0 : k.depthStencilTexture), e.setRenderTarget(y));
          }
          let O = C[R];
          O === void 0 && (O = new Gt(), O.layers.enable(R), O.viewport = new Ve(), C[R] = O), O.matrix.fromArray(j.transform.matrix), O.matrix.decompose(O.position, O.quaternion, O.scale), O.projectionMatrix.fromArray(j.projectionMatrix), O.projectionMatrixInverse.copy(O.projectionMatrix).invert(), O.viewport.set(K.x, K.y, K.width, K.height), R === 0 && (I.matrix.copy(O.matrix), I.matrix.decompose(I.position, I.quaternion, I.scale)), ie === !0 && I.cameras.push(O);
        }
        const N = r.enabledFeatures;
        if (N && N.includes("depth-sensing")) {
          const R = u.getDepthInformation(de[0]);
          R && R.isValid && R.texture && g.init(e, R, r.renderState);
        }
      }
      for (let de = 0; de < x.length; de++) {
        const ie = M[de], N = x[de];
        ie !== null && N !== void 0 && N.update(ie, ae, h || a);
      }
      ve && ve(Q, ae), ae.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: ae }), m = null;
    }), this.setAnimationLoop = function(Q) {
      ve = Q;
    }, this.dispose = function() {
    };
  }
}
const Os = new gt(), CT = new fe();
function PT(n, e) {
  function t(r, s) {
    r.matrixAutoUpdate === !0 && r.updateMatrix(), s.value.copy(r.matrix);
  }
  function i(r, s) {
    r.opacity.value = s.opacity, s.color && r.diffuse.value.copy(s.color), s.emissive && r.emissive.value.copy(s.emissive).multiplyScalar(s.emissiveIntensity), s.map && (r.map.value = s.map, t(s.map, r.mapTransform)), s.alphaMap && (r.alphaMap.value = s.alphaMap, t(s.alphaMap, r.alphaMapTransform)), s.bumpMap && (r.bumpMap.value = s.bumpMap, t(s.bumpMap, r.bumpMapTransform), r.bumpScale.value = s.bumpScale, s.side === Tn && (r.bumpScale.value *= -1)), s.normalMap && (r.normalMap.value = s.normalMap, t(s.normalMap, r.normalMapTransform), r.normalScale.value.copy(s.normalScale), s.side === Tn && r.normalScale.value.negate()), s.displacementMap && (r.displacementMap.value = s.displacementMap, t(s.displacementMap, r.displacementMapTransform), r.displacementScale.value = s.displacementScale, r.displacementBias.value = s.displacementBias), s.emissiveMap && (r.emissiveMap.value = s.emissiveMap, t(s.emissiveMap, r.emissiveMapTransform)), s.specularMap && (r.specularMap.value = s.specularMap, t(s.specularMap, r.specularMapTransform)), s.alphaTest > 0 && (r.alphaTest.value = s.alphaTest);
    const a = e.get(s), o = a.envMap, l = a.envMapRotation;
    o && (r.envMap.value = o, Os.copy(l), Os.x *= -1, Os.y *= -1, Os.z *= -1, o.isCubeTexture && o.isRenderTargetTexture === !1 && (Os.y *= -1, Os.z *= -1), r.envMapRotation.value.setFromMatrix4(CT.makeRotationFromEuler(Os)), r.flipEnvMap.value = o.isCubeTexture && o.isRenderTargetTexture === !1 ? -1 : 1, r.reflectivity.value = s.reflectivity, r.ior.value = s.ior, r.refractionRatio.value = s.refractionRatio), s.lightMap && (r.lightMap.value = s.lightMap, r.lightMapIntensity.value = s.lightMapIntensity, t(s.lightMap, r.lightMapTransform)), s.aoMap && (r.aoMap.value = s.aoMap, r.aoMapIntensity.value = s.aoMapIntensity, t(s.aoMap, r.aoMapTransform));
  }
  return { refreshFogUniforms: function(r, s) {
    s.color.getRGB(r.fogColor.value, Z1(n)), s.isFog ? (r.fogNear.value = s.near, r.fogFar.value = s.far) : s.isFogExp2 && (r.fogDensity.value = s.density);
  }, refreshMaterialUniforms: function(r, s, a, o, l) {
    s.isMeshBasicMaterial || s.isMeshLambertMaterial ? i(r, s) : s.isMeshToonMaterial ? (i(r, s), function(h, c) {
      c.gradientMap && (h.gradientMap.value = c.gradientMap);
    }(r, s)) : s.isMeshPhongMaterial ? (i(r, s), function(h, c) {
      h.specular.value.copy(c.specular), h.shininess.value = Math.max(c.shininess, 1e-4);
    }(r, s)) : s.isMeshStandardMaterial ? (i(r, s), function(h, c) {
      h.metalness.value = c.metalness, c.metalnessMap && (h.metalnessMap.value = c.metalnessMap, t(c.metalnessMap, h.metalnessMapTransform)), h.roughness.value = c.roughness, c.roughnessMap && (h.roughnessMap.value = c.roughnessMap, t(c.roughnessMap, h.roughnessMapTransform)), c.envMap && (h.envMapIntensity.value = c.envMapIntensity);
    }(r, s), s.isMeshPhysicalMaterial && function(h, c, u) {
      h.ior.value = c.ior, c.sheen > 0 && (h.sheenColor.value.copy(c.sheenColor).multiplyScalar(c.sheen), h.sheenRoughness.value = c.sheenRoughness, c.sheenColorMap && (h.sheenColorMap.value = c.sheenColorMap, t(c.sheenColorMap, h.sheenColorMapTransform)), c.sheenRoughnessMap && (h.sheenRoughnessMap.value = c.sheenRoughnessMap, t(c.sheenRoughnessMap, h.sheenRoughnessMapTransform))), c.clearcoat > 0 && (h.clearcoat.value = c.clearcoat, h.clearcoatRoughness.value = c.clearcoatRoughness, c.clearcoatMap && (h.clearcoatMap.value = c.clearcoatMap, t(c.clearcoatMap, h.clearcoatMapTransform)), c.clearcoatRoughnessMap && (h.clearcoatRoughnessMap.value = c.clearcoatRoughnessMap, t(c.clearcoatRoughnessMap, h.clearcoatRoughnessMapTransform)), c.clearcoatNormalMap && (h.clearcoatNormalMap.value = c.clearcoatNormalMap, t(c.clearcoatNormalMap, h.clearcoatNormalMapTransform), h.clearcoatNormalScale.value.copy(c.clearcoatNormalScale), c.side === Tn && h.clearcoatNormalScale.value.negate())), c.dispersion > 0 && (h.dispersion.value = c.dispersion), c.iridescence > 0 && (h.iridescence.value = c.iridescence, h.iridescenceIOR.value = c.iridescenceIOR, h.iridescenceThicknessMinimum.value = c.iridescenceThicknessRange[0], h.iridescenceThicknessMaximum.value = c.iridescenceThicknessRange[1], c.iridescenceMap && (h.iridescenceMap.value = c.iridescenceMap, t(c.iridescenceMap, h.iridescenceMapTransform)), c.iridescenceThicknessMap && (h.iridescenceThicknessMap.value = c.iridescenceThicknessMap, t(c.iridescenceThicknessMap, h.iridescenceThicknessMapTransform))), c.transmission > 0 && (h.transmission.value = c.transmission, h.transmissionSamplerMap.value = u.texture, h.transmissionSamplerSize.value.set(u.width, u.height), c.transmissionMap && (h.transmissionMap.value = c.transmissionMap, t(c.transmissionMap, h.transmissionMapTransform)), h.thickness.value = c.thickness, c.thicknessMap && (h.thicknessMap.value = c.thicknessMap, t(c.thicknessMap, h.thicknessMapTransform)), h.attenuationDistance.value = c.attenuationDistance, h.attenuationColor.value.copy(c.attenuationColor)), c.anisotropy > 0 && (h.anisotropyVector.value.set(c.anisotropy * Math.cos(c.anisotropyRotation), c.anisotropy * Math.sin(c.anisotropyRotation)), c.anisotropyMap && (h.anisotropyMap.value = c.anisotropyMap, t(c.anisotropyMap, h.anisotropyMapTransform))), h.specularIntensity.value = c.specularIntensity, h.specularColor.value.copy(c.specularColor), c.specularColorMap && (h.specularColorMap.value = c.specularColorMap, t(c.specularColorMap, h.specularColorMapTransform)), c.specularIntensityMap && (h.specularIntensityMap.value = c.specularIntensityMap, t(c.specularIntensityMap, h.specularIntensityMapTransform));
    }(r, s, l)) : s.isMeshMatcapMaterial ? (i(r, s), function(h, c) {
      c.matcap && (h.matcap.value = c.matcap);
    }(r, s)) : s.isMeshDepthMaterial ? i(r, s) : s.isMeshDistanceMaterial ? (i(r, s), function(h, c) {
      const u = e.get(c).light;
      h.referencePosition.value.setFromMatrixPosition(u.matrixWorld), h.nearDistance.value = u.shadow.camera.near, h.farDistance.value = u.shadow.camera.far;
    }(r, s)) : s.isMeshNormalMaterial ? i(r, s) : s.isLineBasicMaterial ? (function(h, c) {
      h.diffuse.value.copy(c.color), h.opacity.value = c.opacity, c.map && (h.map.value = c.map, t(c.map, h.mapTransform));
    }(r, s), s.isLineDashedMaterial && function(h, c) {
      h.dashSize.value = c.dashSize, h.totalSize.value = c.dashSize + c.gapSize, h.scale.value = c.scale;
    }(r, s)) : s.isPointsMaterial ? function(h, c, u, d) {
      h.diffuse.value.copy(c.color), h.opacity.value = c.opacity, h.size.value = c.size * u, h.scale.value = 0.5 * d, c.map && (h.map.value = c.map, t(c.map, h.uvTransform)), c.alphaMap && (h.alphaMap.value = c.alphaMap, t(c.alphaMap, h.alphaMapTransform)), c.alphaTest > 0 && (h.alphaTest.value = c.alphaTest);
    }(r, s, a, o) : s.isSpriteMaterial ? function(h, c) {
      h.diffuse.value.copy(c.color), h.opacity.value = c.opacity, h.rotation.value = c.rotation, c.map && (h.map.value = c.map, t(c.map, h.mapTransform)), c.alphaMap && (h.alphaMap.value = c.alphaMap, t(c.alphaMap, h.alphaMapTransform)), c.alphaTest > 0 && (h.alphaTest.value = c.alphaTest);
    }(r, s) : s.isShadowMaterial ? (r.color.value.copy(s.color), r.opacity.value = s.opacity) : s.isShaderMaterial && (s.uniformsNeedUpdate = !1);
  } };
}
function RT(n, e, t, i) {
  let r = {}, s = {}, a = [];
  const o = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(u, d, p, m) {
    const g = u.value, f = d + "_" + p;
    if (m[f] === void 0)
      return m[f] = typeof g == "number" || typeof g == "boolean" ? g : g.clone(), !0;
    {
      const v = m[f];
      if (typeof g == "number" || typeof g == "boolean") {
        if (v !== g)
          return m[f] = g, !0;
      } else if (v.equals(g) === !1)
        return v.copy(g), !0;
    }
    return !1;
  }
  function h(u) {
    const d = { boundary: 0, storage: 0 };
    return typeof u == "number" || typeof u == "boolean" ? (d.boundary = 4, d.storage = 4) : u.isVector2 ? (d.boundary = 8, d.storage = 8) : u.isVector3 || u.isColor ? (d.boundary = 16, d.storage = 12) : u.isVector4 ? (d.boundary = 16, d.storage = 16) : u.isMatrix3 ? (d.boundary = 48, d.storage = 48) : u.isMatrix4 ? (d.boundary = 64, d.storage = 64) : u.isTexture, d;
  }
  function c(u) {
    const d = u.target;
    d.removeEventListener("dispose", c);
    const p = a.indexOf(d.Bt);
    a.splice(p, 1), n.deleteBuffer(r[d.id]), delete r[d.id], delete s[d.id];
  }
  return { bind: function(u, d) {
    const p = d.program;
    i.uniformBlockBinding(u, p);
  }, update: function(u, d) {
    let p = r[u.id];
    p === void 0 && (function(f) {
      const v = f.uniforms;
      let y = 0;
      const x = 16;
      for (let b = 0, S = v.length; b < S; b++) {
        const w = Array.isArray(v[b]) ? v[b] : [v[b]];
        for (let T = 0, C = w.length; T < C; T++) {
          const I = w[T], A = Array.isArray(I.value) ? I.value : [I.value];
          for (let L = 0, D = A.length; L < D; L++) {
            const U = h(A[L]), H = y % x;
            H !== 0 && x - H < U.boundary && (y += x - H), I.se = new Float32Array(U.storage / Float32Array.BYTES_PER_ELEMENT), I.re = y, y += U.storage;
          }
        }
      }
      const M = y % x;
      M > 0 && (y += x - M), f.oe = y, f.ae = {};
    }(u), p = function(f) {
      const v = function() {
        for (let b = 0; b < o; b++)
          if (a.indexOf(b) === -1)
            return a.push(b), b;
        return 0;
      }();
      f.Bt = v;
      const y = n.createBuffer(), x = f.oe, M = f.usage;
      return n.bindBuffer(n.UNIFORM_BUFFER, y), n.bufferData(n.UNIFORM_BUFFER, x, M), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, v, y), y;
    }(u), r[u.id] = p, u.addEventListener("dispose", c));
    const m = d.program;
    i.updateUBOMapping(u, m);
    const g = e.render.frame;
    s[u.id] !== g && (function(f) {
      const v = r[f.id], y = f.uniforms, x = f.ae;
      n.bindBuffer(n.UNIFORM_BUFFER, v);
      for (let M = 0, b = y.length; M < b; M++) {
        const S = Array.isArray(y[M]) ? y[M] : [y[M]];
        for (let w = 0, T = S.length; w < T; w++) {
          const C = S[w];
          if (l(C, M, w, x) === !0) {
            const I = C.re, A = Array.isArray(C.value) ? C.value : [C.value];
            let L = 0;
            for (let D = 0; D < A.length; D++) {
              const U = A[D], H = h(U);
              typeof U == "number" || typeof U == "boolean" ? (C.se[0] = U, n.bufferSubData(n.UNIFORM_BUFFER, I + L, C.se)) : U.isMatrix3 ? (C.se[0] = U.elements[0], C.se[1] = U.elements[1], C.se[2] = U.elements[2], C.se[3] = 0, C.se[4] = U.elements[3], C.se[5] = U.elements[4], C.se[6] = U.elements[5], C.se[7] = 0, C.se[8] = U.elements[6], C.se[9] = U.elements[7], C.se[10] = U.elements[8], C.se[11] = 0) : (U.toArray(C.se, L), L += H.storage / Float32Array.BYTES_PER_ELEMENT);
            }
            n.bufferSubData(n.UNIFORM_BUFFER, I, C.se);
          }
        }
      }
      n.bindBuffer(n.UNIFORM_BUFFER, null);
    }(u), s[u.id] = g);
  }, dispose: function() {
    for (const u in r)
      n.deleteBuffer(r[u]);
    a = [], r = {}, s = {};
  } };
}
class aM {
  constructor(e = {}) {
    const { canvas: t = W1(), context: i = null, depth: r = !0, stencil: s = !1, alpha: a = !1, antialias: o = !1, premultipliedAlpha: l = !0, preserveDrawingBuffer: h = !1, powerPreference: c = "default", failIfMajorPerformanceCaveat: u = !1 } = e;
    let d;
    if (this.isWebGLRenderer = !0, i !== null) {
      if (typeof WebGLRenderingContext != "undefined" && i instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      d = i.getContextAttributes().alpha;
    } else
      d = a;
    const p = new Uint32Array(4), m = new Int32Array(4);
    let g = null, f = null;
    const v = [], y = [];
    this.domElement = t, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.he = mt, this.toneMapping = $i, this.toneMappingExposure = 1;
    const x = this;
    let M = !1, b = 0, S = 0, w = null, T = -1, C = null;
    const I = new Ve(), A = new Ve();
    let L = null;
    const D = new oe(0);
    let U = 0, H = t.width, Z = t.height, te = 1, ne = null, ve = null;
    const Se = new Ve(0, 0, H, Z), Q = new Ve(0, 0, H, Z);
    let ae = !1;
    const de = new jh();
    let ie = !1, N = !1;
    const R = new fe(), j = new _(), K = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let O = !1;
    function k() {
      return w === null ? te : 1;
    }
    let E, B, F, re, V, se, Me, ue, z, W, ee, ge, Le, Fe, _e, Be, He, nt, Ce, rt, ze, Nt, Un, lr, G = i;
    function il(P, q) {
      return t.getContext(P, q);
    }
    try {
      const P = { alpha: !0, depth: r, stencil: s, antialias: o, premultipliedAlpha: l, preserveDrawingBuffer: h, powerPreference: c, failIfMajorPerformanceCaveat: u };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Hu}`), t.addEventListener("webglcontextlost", I0, !1), t.addEventListener("webglcontextrestored", L0, !1), t.addEventListener("webglcontextcreationerror", N0, !1), G === null) {
        const q = "webgl2";
        if (G = il(q, P), G === null)
          throw il(q) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (P) {
      throw P;
    }
    function As() {
      E = new a_(G), E.init(), Nt = new rM(G, E), B = new n_(G, E, e, Nt), F = new wT(G), re = new h_(G), V = new fT(), se = new _T(G, E, F, V, B, Nt, re), Me = new r_(x), ue = new s_(x), z = new Jw(G), Un = new e_(G, z), W = new o_(G, z, re, Un), ee = new u_(G, W, z, re), Ce = new c_(G, B, se), Be = new i_(V), ge = new pT(x, Me, ue, E, B, Un, Be), Le = new PT(x, V), Fe = new gT(), _e = new bT(E), nt = new $w(x, Me, ue, F, ee, d, l), He = new ST(x, ee, B), lr = new RT(G, re, B, F), rt = new t_(G, E, re), ze = new l_(G, E, re), re.programs = ge.programs, x.capabilities = B, x.extensions = E, x.properties = V, x.renderLists = Fe, x.shadowMap = He, x.state = F, x.info = re;
    }
    As();
    const Dt = new AT(x, G);
    function I0(P) {
      P.preventDefault(), M = !0;
    }
    function L0() {
      M = !1;
      const P = re.autoReset, q = He.enabled, J = He.autoUpdate, le = He.needsUpdate, $ = He.type;
      As(), re.autoReset = P, He.enabled = q, He.autoUpdate = J, He.needsUpdate = le, He.type = $;
    }
    function N0(P) {
    }
    function D0(P) {
      const q = P.target;
      q.removeEventListener("dispose", D0), function(J) {
        (function(le) {
          const $ = V.get(le).programs;
          $ !== void 0 && ($.forEach(function(me) {
            ge.releaseProgram(me);
          }), le.isShaderMaterial && ge.releaseShaderCache(le));
        })(J), V.remove(J);
      }(q);
    }
    function O0(P, q, J) {
      P.transparent === !0 && P.side === bt && P.forceSinglePass === !1 ? (P.side = Tn, P.needsUpdate = !0, ic(P, q, J), P.side = Mi, P.needsUpdate = !0, ic(P, q, J), P.side = bt) : ic(P, q, J);
    }
    this.xr = Dt, this.getContext = function() {
      return G;
    }, this.getContextAttributes = function() {
      return G.getContextAttributes();
    }, this.forceContextLoss = function() {
      const P = E.get("WEBGL_lose_context");
      P && P.loseContext();
    }, this.forceContextRestore = function() {
      const P = E.get("WEBGL_lose_context");
      P && P.restoreContext();
    }, this.getPixelRatio = function() {
      return te;
    }, this.setPixelRatio = function(P) {
      P !== void 0 && (te = P, this.setSize(H, Z, !1));
    }, this.getSize = function(P) {
      return P.set(H, Z);
    }, this.setSize = function(P, q, J = !0) {
      Dt.isPresenting || (H = P, Z = q, t.width = Math.floor(P * te), t.height = Math.floor(q * te), J === !0 && (t.style.width = P + "px", t.style.height = q + "px"), this.setViewport(0, 0, P, q));
    }, this.getDrawingBufferSize = function(P) {
      return P.set(H * te, Z * te).floor();
    }, this.setDrawingBufferSize = function(P, q, J) {
      H = P, Z = q, te = J, t.width = Math.floor(P * J), t.height = Math.floor(q * J), this.setViewport(0, 0, P, q);
    }, this.getCurrentViewport = function(P) {
      return P.copy(I);
    }, this.getViewport = function(P) {
      return P.copy(Se);
    }, this.setViewport = function(P, q, J, le) {
      P.isVector4 ? Se.set(P.x, P.y, P.z, P.w) : Se.set(P, q, J, le), F.viewport(I.copy(Se).multiplyScalar(te).round());
    }, this.getScissor = function(P) {
      return P.copy(Q);
    }, this.setScissor = function(P, q, J, le) {
      P.isVector4 ? Q.set(P.x, P.y, P.z, P.w) : Q.set(P, q, J, le), F.scissor(A.copy(Q).multiplyScalar(te).round());
    }, this.getScissorTest = function() {
      return ae;
    }, this.setScissorTest = function(P) {
      F.setScissorTest(ae = P);
    }, this.setOpaqueSort = function(P) {
      ne = P;
    }, this.setTransparentSort = function(P) {
      ve = P;
    }, this.getClearColor = function(P) {
      return P.copy(nt.getClearColor());
    }, this.setClearColor = function() {
      nt.setClearColor.apply(nt, arguments);
    }, this.getClearAlpha = function() {
      return nt.getClearAlpha();
    }, this.setClearAlpha = function() {
      nt.setClearAlpha.apply(nt, arguments);
    }, this.clear = function(P = !0, q = !0, J = !0) {
      let le = 0;
      if (P) {
        let $ = !1;
        if (w !== null) {
          const me = w.texture.format;
          $ = me === Sg || me === bg || me === Mg;
        }
        if ($) {
          const me = w.texture.type, Ee = me === ba || me === Sa || me === No || me === ms || me === vg || me === yg, Ae = nt.getClearColor(), Re = nt.getClearAlpha(), Ne = Ae.r, Ge = Ae.g, Ie = Ae.b;
          Ee ? (p[0] = Ne, p[1] = Ge, p[2] = Ie, p[3] = Re, G.clearBufferuiv(G.COLOR, 0, p)) : (m[0] = Ne, m[1] = Ge, m[2] = Ie, m[3] = Re, G.clearBufferiv(G.COLOR, 0, m));
        } else
          le |= G.COLOR_BUFFER_BIT;
      }
      q && (le |= G.DEPTH_BUFFER_BIT), J && (le |= G.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), G.clear(le);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", I0, !1), t.removeEventListener("webglcontextrestored", L0, !1), t.removeEventListener("webglcontextcreationerror", N0, !1), Fe.dispose(), _e.dispose(), V.dispose(), Me.dispose(), ue.dispose(), ee.dispose(), Un.dispose(), lr.dispose(), ge.dispose(), Dt.dispose(), Dt.removeEventListener("sessionstart", U0), Dt.removeEventListener("sessionend", F0), Cs.stop();
    }, this.renderBufferDirect = function(P, q, J, le, $, me) {
      q === null && (q = K);
      const Ee = $.isMesh && $.matrixWorld.determinant() < 0, Ae = function(st, Ot, Xn, Ze, je) {
        Ot.isScene !== !0 && (Ot = K), se.resetTextureUnits();
        const rl = Ot.fog, rw = Ze.isMeshStandardMaterial ? Ot.environment : null, sw = w === null ? x.outputColorSpace : w.isXRRenderTarget === !0 ? w.texture.colorSpace : Jt, rc = (Ze.isMeshStandardMaterial ? ue : Me).get(Ze.envMap || rw), aw = Ze.vertexColors === !0 && !!Xn.attributes.color && Xn.attributes.color.itemSize === 4, ow = !!Xn.attributes.tangent && (!!Ze.normalMap || Ze.anisotropy > 0), lw = !!Xn.morphAttributes.position, hw = !!Xn.morphAttributes.normal, cw = !!Xn.morphAttributes.color;
        let G0 = $i;
        Ze.toneMapped && (w !== null && w.isXRRenderTarget !== !0 || (G0 = x.toneMapping));
        const j0 = Xn.morphAttributes.position || Xn.morphAttributes.normal || Xn.morphAttributes.color, uw = j0 !== void 0 ? j0.length : 0, Qe = V.get(Ze), dw = f.state.lights;
        if (ie === !0 && (N === !0 || st !== C)) {
          const oi = st === C && Ze.id === T;
          Be.setState(Ze, st, oi);
        }
        let wi = !1;
        Ze.version === Qe.Zt ? Qe.needsLights && Qe.lightsStateVersion !== dw.state.version || Qe.outputColorSpace !== sw || je.isBatchedMesh && Qe.batching === !1 ? wi = !0 : je.isBatchedMesh || Qe.batching !== !0 ? je.isBatchedMesh && Qe.batchingColor === !0 && je.colorTexture === null || je.isBatchedMesh && Qe.batchingColor === !1 && je.colorTexture !== null || je.isInstancedMesh && Qe.instancing === !1 ? wi = !0 : je.isInstancedMesh || Qe.instancing !== !0 ? je.isSkinnedMesh && Qe.skinning === !1 ? wi = !0 : je.isSkinnedMesh || Qe.skinning !== !0 ? je.isInstancedMesh && Qe.instancingColor === !0 && je.instanceColor === null || je.isInstancedMesh && Qe.instancingColor === !1 && je.instanceColor !== null || je.isInstancedMesh && Qe.instancingMorph === !0 && je.morphTexture === null || je.isInstancedMesh && Qe.instancingMorph === !1 && je.morphTexture !== null || Qe.envMap !== rc || Ze.fog === !0 && Qe.fog !== rl ? wi = !0 : Qe.numClippingPlanes === void 0 || Qe.numClippingPlanes === Be.numPlanes && Qe.numIntersection === Be.numIntersection ? (Qe.vertexAlphas !== aw || Qe.vertexTangents !== ow || Qe.morphTargets !== lw || Qe.morphNormals !== hw || Qe.morphColors !== cw || Qe.toneMapping !== G0 || Qe.morphTargetsCount !== uw) && (wi = !0) : wi = !0 : wi = !0 : wi = !0 : wi = !0 : (wi = !0, Qe.Zt = Ze.version);
        let Ps = Qe.currentProgram;
        wi === !0 && (Ps = ic(Ze, Ot, je));
        let W0 = !1, sl = !1, op = !1;
        const on = Ps.getUniforms(), Ur = Qe.uniforms;
        if (F.useProgram(Ps.program) && (W0 = !0, sl = !0, op = !0), Ze.id !== T && (T = Ze.id, sl = !0), W0 || C !== st) {
          on.setValue(G, "projectionMatrix", st.projectionMatrix), on.setValue(G, "viewMatrix", st.matrixWorldInverse);
          const oi = on.map.cameraPosition;
          oi !== void 0 && oi.setValue(G, j.setFromMatrixPosition(st.matrixWorld)), B.logarithmicDepthBuffer && on.setValue(G, "logDepthBufFC", 2 / (Math.log(st.far + 1) / Math.LN2)), (Ze.isMeshPhongMaterial || Ze.isMeshToonMaterial || Ze.isMeshLambertMaterial || Ze.isMeshBasicMaterial || Ze.isMeshStandardMaterial || Ze.isShaderMaterial) && on.setValue(G, "isOrthographic", st.isOrthographicCamera === !0), C !== st && (C = st, sl = !0, op = !0);
        }
        if (je.isSkinnedMesh) {
          on.setOptional(G, je, "bindMatrix"), on.setOptional(G, je, "bindMatrixInverse");
          const oi = je.skeleton;
          oi && (oi.boneTexture === null && oi.computeBoneTexture(), on.setValue(G, "boneTexture", oi.boneTexture, se));
        }
        je.isBatchedMesh && (on.setOptional(G, je, "batchingTexture"), on.setValue(G, "batchingTexture", je.ht, se), on.setOptional(G, je, "batchingColorTexture"), je.ct !== null && on.setValue(G, "batchingColorTexture", je.ct, se));
        const lp = Xn.morphAttributes;
        lp.position === void 0 && lp.normal === void 0 && lp.color === void 0 || Ce.update(je, Xn, Ps), (sl || Qe.receiveShadow !== je.receiveShadow) && (Qe.receiveShadow = je.receiveShadow, on.setValue(G, "receiveShadow", je.receiveShadow)), Ze.isMeshGouraudMaterial && Ze.envMap !== null && (Ur.envMap.value = rc, Ur.flipEnvMap.value = rc.isCubeTexture && rc.isRenderTargetTexture === !1 ? -1 : 1), Ze.isMeshStandardMaterial && Ze.envMap === null && Ot.environment !== null && (Ur.envMapIntensity.value = Ot.environmentIntensity), sl && (on.setValue(G, "toneMappingExposure", x.toneMappingExposure), Qe.needsLights && (_i = op, (ki = Ur).ambientLightColor.needsUpdate = _i, ki.lightProbe.needsUpdate = _i, ki.directionalLights.needsUpdate = _i, ki.directionalLightShadows.needsUpdate = _i, ki.pointLights.needsUpdate = _i, ki.pointLightShadows.needsUpdate = _i, ki.spotLights.needsUpdate = _i, ki.spotLightShadows.needsUpdate = _i, ki.rectAreaLights.needsUpdate = _i, ki.hemisphereLights.needsUpdate = _i), rl && Ze.fog === !0 && Le.refreshFogUniforms(Ur, rl), Le.refreshMaterialUniforms(Ur, Ze, te, Z, f.state.transmissionRenderTarget[st.id]), Iu.upload(G, V0(Qe), Ur, se));
        var ki, _i;
        if (Ze.isShaderMaterial && Ze.uniformsNeedUpdate === !0 && (Iu.upload(G, V0(Qe), Ur, se), Ze.uniformsNeedUpdate = !1), Ze.isSpriteMaterial && on.setValue(G, "center", je.center), on.setValue(G, "modelViewMatrix", je.modelViewMatrix), on.setValue(G, "normalMatrix", je.normalMatrix), on.setValue(G, "modelMatrix", je.matrixWorld), Ze.isShaderMaterial || Ze.isRawShaderMaterial) {
          const oi = Ze.uniformsGroups;
          for (let hp = 0, pw = oi.length; hp < pw; hp++) {
            const X0 = oi[hp];
            lr.update(X0, Ps), lr.bind(X0, Ps);
          }
        }
        return Ps;
      }(P, q, J, le, $);
      F.setMaterial(le, Ee);
      let Re = J.index, Ne = 1;
      if (le.wireframe === !0) {
        if (Re = W.getWireframeAttribute(J), Re === void 0)
          return;
        Ne = 2;
      }
      const Ge = J.drawRange, Ie = J.attributes.position;
      let $e = Ge.start * Ne, St = (Ge.start + Ge.count) * Ne;
      me !== null && ($e = Math.max($e, me.start * Ne), St = Math.min(St, (me.start + me.count) * Ne)), Re !== null ? ($e = Math.max($e, 0), St = Math.min(St, Re.count)) : Ie != null && ($e = Math.max($e, 0), St = Math.min(St, Ie.count));
      const qt = St - $e;
      if (qt < 0 || qt === 1 / 0)
        return;
      let Qt;
      Un.setup($, le, Ae, J, Re);
      let wt = rt;
      if (Re !== null && (Qt = z.get(Re), wt = ze, wt.setIndex(Qt)), $.isMesh)
        le.wireframe === !0 ? (F.setLineWidth(le.wireframeLinewidth * k()), wt.setMode(G.LINES)) : wt.setMode(G.TRIANGLES);
      else if ($.isLine) {
        let st = le.linewidth;
        st === void 0 && (st = 1), F.setLineWidth(st * k()), $.isLineSegments ? wt.setMode(G.LINES) : $.isLineLoop ? wt.setMode(G.LINE_LOOP) : wt.setMode(G.LINE_STRIP);
      } else
        $.isPoints ? wt.setMode(G.POINTS) : $.isSprite && wt.setMode(G.TRIANGLES);
      if ($.isBatchedMesh)
        $.ce !== null ? wt.renderMultiDrawInstances($.le, $.ue, $.fe, $.ce) : wt.renderMultiDraw($.le, $.ue, $.fe);
      else if ($.isInstancedMesh)
        wt.renderInstances($e, qt, $.count);
      else if (J.isInstancedBufferGeometry) {
        const st = J.vt !== void 0 ? J.vt : 1 / 0, Ot = Math.min(J.instanceCount, st);
        wt.renderInstances($e, qt, Ot);
      } else
        wt.render($e, qt);
    }, this.compile = function(P, q, J = null) {
      J === null && (J = P), f = _e.get(J), f.init(q), y.push(f), J.traverseVisible(function($) {
        $.isLight && $.layers.test(q.layers) && (f.pushLight($), $.castShadow && f.pushShadow($));
      }), P !== J && P.traverseVisible(function($) {
        $.isLight && $.layers.test(q.layers) && (f.pushLight($), $.castShadow && f.pushShadow($));
      }), f.setupLights();
      const le = /* @__PURE__ */ new Set();
      return P.traverse(function($) {
        const me = $.material;
        if (me)
          if (Array.isArray(me))
            for (let Ee = 0; Ee < me.length; Ee++) {
              const Ae = me[Ee];
              O0(Ae, J, $), le.add(Ae);
            }
          else
            O0(me, J, $), le.add(me);
      }), y.pop(), f = null, le;
    }, this.compileAsync = function(P, q, J = null) {
      const le = this.compile(P, q, J);
      return new Promise(($) => {
        function me() {
          le.forEach(function(Ee) {
            V.get(Ee).currentProgram.isReady() && le.delete(Ee);
          }), le.size !== 0 ? setTimeout(me, 10) : $(P);
        }
        E.get("KHR_parallel_shader_compile") !== null ? me() : setTimeout(me, 10);
      });
    };
    let sp = null;
    function U0() {
      Cs.stop();
    }
    function F0() {
      Cs.start();
    }
    const Cs = new Q1();
    function ap(P, q, J, le) {
      if (P.visible === !1)
        return;
      if (P.layers.test(q.layers)) {
        if (P.isGroup)
          J = P.renderOrder;
        else if (P.isLOD)
          P.autoUpdate === !0 && P.update(q);
        else if (P.isLight)
          f.pushLight(P), P.castShadow && f.pushShadow(P);
        else if (P.isSprite) {
          if (!P.frustumCulled || de.intersectsSprite(P)) {
            le && j.setFromMatrixPosition(P.matrixWorld).applyMatrix4(R);
            const me = ee.update(P), Ee = P.material;
            Ee.visible && g.push(P, me, Ee, J, j.z, null);
          }
        } else if ((P.isMesh || P.isLine || P.isPoints) && (!P.frustumCulled || de.intersectsObject(P))) {
          const me = ee.update(P), Ee = P.material;
          if (le && (P.boundingSphere !== void 0 ? (P.boundingSphere === null && P.computeBoundingSphere(), j.copy(P.boundingSphere.center)) : (me.boundingSphere === null && me.computeBoundingSphere(), j.copy(me.boundingSphere.center)), j.applyMatrix4(P.matrixWorld).applyMatrix4(R)), Array.isArray(Ee)) {
            const Ae = me.groups;
            for (let Re = 0, Ne = Ae.length; Re < Ne; Re++) {
              const Ge = Ae[Re], Ie = Ee[Ge.materialIndex];
              Ie && Ie.visible && g.push(P, me, Ie, J, j.z, Ge);
            }
          } else
            Ee.visible && g.push(P, me, Ee, J, j.z, null);
        }
      }
      const $ = P.children;
      for (let me = 0, Ee = $.length; me < Ee; me++)
        ap($[me], q, J, le);
    }
    function B0(P, q, J, le) {
      const $ = P.opaque, me = P.transmissive, Ee = P.transparent;
      f.setupLightsView(J), ie === !0 && Be.setGlobalState(x.clippingPlanes, J), le && F.viewport(I.copy(le)), $.length > 0 && nc($, q, J), me.length > 0 && nc(me, q, J), Ee.length > 0 && nc(Ee, q, J), F.buffers.depth.setTest(!0), F.buffers.depth.setMask(!0), F.buffers.color.setMask(!0), F.setPolygonOffset(!1);
    }
    function k0(P, q, J, le) {
      if ((J.isScene === !0 ? J.overrideMaterial : null) !== null)
        return;
      f.state.transmissionRenderTarget[le.id] === void 0 && (f.state.transmissionRenderTarget[le.id] = new ht(1, 1, { generateMipmaps: !0, type: E.has("EXT_color_buffer_half_float") || E.has("EXT_color_buffer_float") ? Ht : ba, minFilter: er, samples: 4, stencilBuffer: s, resolveDepthBuffer: !1, resolveStencilBuffer: !1, colorSpace: it.workingColorSpace }));
      const $ = f.state.transmissionRenderTarget[le.id], me = le.viewport || I;
      $.setSize(me.z, me.w);
      const Ee = x.getRenderTarget();
      x.setRenderTarget($), x.getClearColor(D), U = x.getClearAlpha(), U < 1 && x.setClearColor(16777215, 0.5), O ? nt.render(J) : x.clear();
      const Ae = x.toneMapping;
      x.toneMapping = $i;
      const Re = le.viewport;
      if (le.viewport !== void 0 && (le.viewport = void 0), f.setupLightsView(le), ie === !0 && Be.setGlobalState(x.clippingPlanes, le), nc(P, J, le), se.updateMultisampleRenderTarget($), se.updateRenderTargetMipmap($), E.has("WEBGL_multisampled_render_to_texture") === !1) {
        let Ne = !1;
        for (let Ge = 0, Ie = q.length; Ge < Ie; Ge++) {
          const $e = q[Ge], St = $e.object, qt = $e.geometry, Qt = $e.material, wt = $e.group;
          if (Qt.side === bt && St.layers.test(le.layers)) {
            const st = Qt.side;
            Qt.side = Tn, Qt.needsUpdate = !0, z0(St, J, le, qt, Qt, wt), Qt.side = st, Qt.needsUpdate = !0, Ne = !0;
          }
        }
        Ne === !0 && (se.updateMultisampleRenderTarget($), se.updateRenderTargetMipmap($));
      }
      x.setRenderTarget(Ee), x.setClearColor(D, U), Re !== void 0 && (le.viewport = Re), x.toneMapping = Ae;
    }
    function nc(P, q, J) {
      const le = q.isScene === !0 ? q.overrideMaterial : null;
      for (let $ = 0, me = P.length; $ < me; $++) {
        const Ee = P[$], Ae = Ee.object, Re = Ee.geometry, Ne = le === null ? Ee.material : le, Ge = Ee.group;
        Ae.layers.test(J.layers) && z0(Ae, q, J, Re, Ne, Ge);
      }
    }
    function z0(P, q, J, le, $, me) {
      P.onBeforeRender(x, q, J, le, $, me), P.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse, P.matrixWorld), P.normalMatrix.getNormalMatrix(P.modelViewMatrix), $.onBeforeRender(x, q, J, le, P, me), $.transparent === !0 && $.side === bt && $.forceSinglePass === !1 ? ($.side = Tn, $.needsUpdate = !0, x.renderBufferDirect(J, q, le, $, P, me), $.side = Mi, $.needsUpdate = !0, x.renderBufferDirect(J, q, le, $, P, me), $.side = bt) : x.renderBufferDirect(J, q, le, $, P, me), P.onAfterRender(x, q, J, le, $, me);
    }
    function ic(P, q, J) {
      q.isScene !== !0 && (q = K);
      const le = V.get(P), $ = f.state.lights, me = f.state.shadowsArray, Ee = $.state.version, Ae = ge.getParameters(P, $.state, me, q, J), Re = ge.getProgramCacheKey(Ae);
      let Ne = le.programs;
      le.environment = P.isMeshStandardMaterial ? q.environment : null, le.fog = q.fog, le.envMap = (P.isMeshStandardMaterial ? ue : Me).get(P.envMap || le.environment), le.envMapRotation = le.environment !== null && P.envMap === null ? q.environmentRotation : P.envMapRotation, Ne === void 0 && (P.addEventListener("dispose", D0), Ne = /* @__PURE__ */ new Map(), le.programs = Ne);
      let Ge = Ne.get(Re);
      if (Ge !== void 0) {
        if (le.currentProgram === Ge && le.lightsStateVersion === Ee)
          return H0(P, Ae), Ge;
      } else
        Ae.uniforms = ge.getUniforms(P), P.onBuild(J, Ae, x), P.onBeforeCompile(Ae, x), Ge = ge.acquireProgram(Ae, Re), Ne.set(Re, Ge), le.uniforms = Ae.uniforms;
      const Ie = le.uniforms;
      return (P.isShaderMaterial || P.isRawShaderMaterial) && P.clipping !== !0 || (Ie.clippingPlanes = Be.uniform), H0(P, Ae), le.needsLights = function($e) {
        return $e.isMeshLambertMaterial || $e.isMeshToonMaterial || $e.isMeshPhongMaterial || $e.isMeshStandardMaterial || $e.isShadowMaterial || $e.isShaderMaterial && $e.lights === !0;
      }(P), le.lightsStateVersion = Ee, le.needsLights && (Ie.ambientLightColor.value = $.state.ambient, Ie.lightProbe.value = $.state.probe, Ie.directionalLights.value = $.state.directional, Ie.directionalLightShadows.value = $.state.directionalShadow, Ie.spotLights.value = $.state.spot, Ie.spotLightShadows.value = $.state.spotShadow, Ie.rectAreaLights.value = $.state.rectArea, Ie.ltc_1.value = $.state.rectAreaLTC1, Ie.ltc_2.value = $.state.rectAreaLTC2, Ie.pointLights.value = $.state.point, Ie.pointLightShadows.value = $.state.pointShadow, Ie.hemisphereLights.value = $.state.hemi, Ie.directionalShadowMap.value = $.state.directionalShadowMap, Ie.directionalShadowMatrix.value = $.state.directionalShadowMatrix, Ie.spotShadowMap.value = $.state.spotShadowMap, Ie.spotLightMatrix.value = $.state.spotLightMatrix, Ie.spotLightMap.value = $.state.spotLightMap, Ie.pointShadowMap.value = $.state.pointShadowMap, Ie.pointShadowMatrix.value = $.state.pointShadowMatrix), le.currentProgram = Ge, le.uniformsList = null, Ge;
    }
    function V0(P) {
      if (P.uniformsList === null) {
        const q = P.currentProgram.getUniforms();
        P.uniformsList = Iu.seqWithValue(q.seq, P.uniforms);
      }
      return P.uniformsList;
    }
    function H0(P, q) {
      const J = V.get(P);
      J.outputColorSpace = q.outputColorSpace, J.batching = q.batching, J.batchingColor = q.batchingColor, J.instancing = q.instancing, J.instancingColor = q.instancingColor, J.instancingMorph = q.instancingMorph, J.skinning = q.skinning, J.morphTargets = q.morphTargets, J.morphNormals = q.morphNormals, J.morphColors = q.morphColors, J.morphTargetsCount = q.morphTargetsCount, J.numClippingPlanes = q.numClippingPlanes, J.numIntersection = q.numClipIntersection, J.vertexAlphas = q.vertexAlphas, J.vertexTangents = q.vertexTangents, J.toneMapping = q.toneMapping;
    }
    Cs.setAnimationLoop(function(P) {
      sp && sp(P);
    }), typeof self != "undefined" && Cs.setContext(self), this.setAnimationLoop = function(P) {
      sp = P, Dt.setAnimationLoop(P), P === null ? Cs.stop() : Cs.start();
    }, Dt.addEventListener("sessionstart", U0), Dt.addEventListener("sessionend", F0), this.render = function(P, q) {
      if (q !== void 0 && q.isCamera !== !0 || M === !0)
        return;
      if (P.matrixWorldAutoUpdate === !0 && P.updateMatrixWorld(), q.parent === null && q.matrixWorldAutoUpdate === !0 && q.updateMatrixWorld(), Dt.enabled === !0 && Dt.isPresenting === !0 && (Dt.cameraAutoUpdate === !0 && Dt.updateCamera(q), q = Dt.getCamera()), P.isScene === !0 && P.onBeforeRender(x, P, q, w), f = _e.get(P, y.length), f.init(q), y.push(f), R.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse), de.setFromProjectionMatrix(R), N = this.localClippingEnabled, ie = Be.init(this.clippingPlanes, N), g = Fe.get(P, v.length), g.init(), v.push(g), Dt.enabled === !0 && Dt.isPresenting === !0) {
        const me = x.xr.getDepthSensingMesh();
        me !== null && ap(me, q, -1 / 0, x.sortObjects);
      }
      ap(P, q, 0, x.sortObjects), g.finish(), x.sortObjects === !0 && g.sort(ne, ve), O = Dt.enabled === !1 || Dt.isPresenting === !1 || Dt.hasDepthSensing() === !1, O && nt.addToRenderList(g, P), this.info.render.frame++, ie === !0 && Be.beginShadows();
      const J = f.state.shadowsArray;
      He.render(J, P, q), ie === !0 && Be.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const le = g.opaque, $ = g.transmissive;
      if (f.setupLights(), q.isArrayCamera) {
        const me = q.cameras;
        if ($.length > 0)
          for (let Ee = 0, Ae = me.length; Ee < Ae; Ee++)
            k0(le, $, P, me[Ee]);
        O && nt.render(P);
        for (let Ee = 0, Ae = me.length; Ee < Ae; Ee++) {
          const Re = me[Ee];
          B0(g, P, Re, Re.viewport);
        }
      } else
        $.length > 0 && k0(le, $, P, q), O && nt.render(P), B0(g, P, q);
      w !== null && (se.updateMultisampleRenderTarget(w), se.updateRenderTargetMipmap(w)), P.isScene === !0 && P.onAfterRender(x, P, q), Un.resetDefaultState(), T = -1, C = null, y.pop(), y.length > 0 ? (f = y[y.length - 1], ie === !0 && Be.setGlobalState(x.clippingPlanes, f.state.camera)) : f = null, v.pop(), g = v.length > 0 ? v[v.length - 1] : null;
    }, this.getActiveCubeFace = function() {
      return b;
    }, this.getActiveMipmapLevel = function() {
      return S;
    }, this.getRenderTarget = function() {
      return w;
    }, this.setRenderTargetTextures = function(P, q, J) {
      V.get(P.texture).qt = q, V.get(P.depthTexture).qt = J;
      const le = V.get(P);
      le.Kt = !0, le.$t = J === void 0, le.$t || E.has("WEBGL_multisampled_render_to_texture") === !0 && (le.Qt = !1);
    }, this.setRenderTargetFramebuffer = function(P, q) {
      const J = V.get(P);
      J.Vt = q, J.de = q === void 0;
    }, this.setRenderTarget = function(P, q = 0, J = 0) {
      w = P, b = q, S = J;
      let le = !0, $ = null, me = !1, Ee = !1;
      if (P) {
        const Ae = V.get(P);
        Ae.de !== void 0 ? (F.bindFramebuffer(G.FRAMEBUFFER, null), le = !1) : Ae.Vt === void 0 ? se.setupRenderTarget(P) : Ae.Kt && se.rebindTextures(P, V.get(P.texture).qt, V.get(P.depthTexture).qt);
        const Re = P.texture;
        (Re.isData3DTexture || Re.isDataArrayTexture || Re.isCompressedArrayTexture) && (Ee = !0);
        const Ne = V.get(P).Vt;
        P.isWebGLCubeRenderTarget ? ($ = Array.isArray(Ne[q]) ? Ne[q][J] : Ne[q], me = !0) : $ = P.samples > 0 && se.useMultisampledRTT(P) === !1 ? V.get(P).jt : Array.isArray(Ne) ? Ne[J] : Ne, I.copy(P.viewport), A.copy(P.scissor), L = P.scissorTest;
      } else
        I.copy(Se).multiplyScalar(te).floor(), A.copy(Q).multiplyScalar(te).floor(), L = ae;
      if (F.bindFramebuffer(G.FRAMEBUFFER, $) && le && F.drawBuffers(P, $), F.viewport(I), F.scissor(A), F.setScissorTest(L), me) {
        const Ae = V.get(P.texture);
        G.framebufferTexture2D(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, G.TEXTURE_CUBE_MAP_POSITIVE_X + q, Ae.qt, J);
      } else if (Ee) {
        const Ae = V.get(P.texture), Re = q || 0;
        G.framebufferTextureLayer(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, Ae.qt, J || 0, Re);
      }
      T = -1;
    }, this.readRenderTargetPixels = function(P, q, J, le, $, me, Ee) {
      if (!P || !P.isWebGLRenderTarget)
        return;
      let Ae = V.get(P).Vt;
      if (P.isWebGLCubeRenderTarget && Ee !== void 0 && (Ae = Ae[Ee]), Ae) {
        F.bindFramebuffer(G.FRAMEBUFFER, Ae);
        try {
          const Re = P.texture, Ne = Re.format, Ge = Re.type;
          if (!B.textureFormatReadable(Ne) || !B.textureTypeReadable(Ge))
            return;
          q >= 0 && q <= P.width - le && J >= 0 && J <= P.height - $ && G.readPixels(q, J, le, $, Nt.convert(Ne), Nt.convert(Ge), me);
        } finally {
          const Re = w !== null ? V.get(w).Vt : null;
          F.bindFramebuffer(G.FRAMEBUFFER, Re);
        }
      }
    }, this.readRenderTargetPixelsAsync = function(P, q, J, le, $, me, Ee) {
      return li(this, null, function* () {
        if (!P || !P.isWebGLRenderTarget)
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let Ae = V.get(P).Vt;
        if (P.isWebGLCubeRenderTarget && Ee !== void 0 && (Ae = Ae[Ee]), Ae) {
          F.bindFramebuffer(G.FRAMEBUFFER, Ae);
          try {
            const Re = P.texture, Ne = Re.format, Ge = Re.type;
            if (!B.textureFormatReadable(Ne))
              throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
            if (!B.textureTypeReadable(Ge))
              throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
            if (q >= 0 && q <= P.width - le && J >= 0 && J <= P.height - $) {
              const Ie = G.createBuffer();
              G.bindBuffer(G.PIXEL_PACK_BUFFER, Ie), G.bufferData(G.PIXEL_PACK_BUFFER, me.byteLength, G.STREAM_READ), G.readPixels(q, J, le, $, Nt.convert(Ne), Nt.convert(Ge), 0), G.flush();
              const $e = G.fenceSync(G.SYNC_GPU_COMMANDS_COMPLETE, 0);
              yield function(St, qt, Qt) {
                return new Promise(function(wt, st) {
                  setTimeout(function Ot() {
                    switch (St.clientWaitSync(qt, St.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                      case St.WAIT_FAILED:
                        st();
                        break;
                      case St.TIMEOUT_EXPIRED:
                        setTimeout(Ot, Qt);
                        break;
                      default:
                        wt();
                    }
                  }, Qt);
                });
              }(G, $e, 4);
              try {
                G.bindBuffer(G.PIXEL_PACK_BUFFER, Ie), G.getBufferSubData(G.PIXEL_PACK_BUFFER, 0, me);
              } finally {
                G.deleteBuffer(Ie), G.deleteSync($e);
              }
              return me;
            }
          } finally {
            const Re = w !== null ? V.get(w).Vt : null;
            F.bindFramebuffer(G.FRAMEBUFFER, Re);
          }
        }
      });
    }, this.copyFramebufferToTexture = function(P, q = null, J = 0) {
      P.isTexture !== !0 && (q = arguments[0] || null, P = arguments[1]);
      const le = Math.pow(2, -J), $ = Math.floor(P.image.width * le), me = Math.floor(P.image.height * le), Ee = q !== null ? q.x : 0, Ae = q !== null ? q.y : 0;
      se.setTexture2D(P, 0), G.copyTexSubImage2D(G.TEXTURE_2D, J, 0, 0, Ee, Ae, $, me), F.unbindTexture();
    }, this.copyTextureToTexture = function(P, q, J = null, le = null, $ = 0) {
      let me, Ee, Ae, Re, Ne, Ge;
      P.isTexture !== !0 && (le = arguments[0] || null, P = arguments[1], q = arguments[2], $ = arguments[3] || 0, J = null), J !== null ? (me = J.max.x - J.min.x, Ee = J.max.y - J.min.y, Ae = J.min.x, Re = J.min.y) : (me = P.image.width, Ee = P.image.height, Ae = 0, Re = 0), le !== null ? (Ne = le.x, Ge = le.y) : (Ne = 0, Ge = 0);
      const Ie = Nt.convert(q.format), $e = Nt.convert(q.type);
      se.setTexture2D(q, 0), G.pixelStorei(G.UNPACK_FLIP_Y_WEBGL, q.flipY), G.pixelStorei(G.UNPACK_PREMULTIPLY_ALPHA_WEBGL, q.premultiplyAlpha), G.pixelStorei(G.UNPACK_ALIGNMENT, q.unpackAlignment);
      const St = G.getParameter(G.UNPACK_ROW_LENGTH), qt = G.getParameter(G.UNPACK_IMAGE_HEIGHT), Qt = G.getParameter(G.UNPACK_SKIP_PIXELS), wt = G.getParameter(G.UNPACK_SKIP_ROWS), st = G.getParameter(G.UNPACK_SKIP_IMAGES), Ot = P.isCompressedTexture ? P.mipmaps[$] : P.image;
      G.pixelStorei(G.UNPACK_ROW_LENGTH, Ot.width), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, Ot.height), G.pixelStorei(G.UNPACK_SKIP_PIXELS, Ae), G.pixelStorei(G.UNPACK_SKIP_ROWS, Re), P.isDataTexture ? G.texSubImage2D(G.TEXTURE_2D, $, Ne, Ge, me, Ee, Ie, $e, Ot.data) : P.isCompressedTexture ? G.compressedTexSubImage2D(G.TEXTURE_2D, $, Ne, Ge, Ot.width, Ot.height, Ie, Ot.data) : G.texSubImage2D(G.TEXTURE_2D, $, Ne, Ge, Ie, $e, Ot), G.pixelStorei(G.UNPACK_ROW_LENGTH, St), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, qt), G.pixelStorei(G.UNPACK_SKIP_PIXELS, Qt), G.pixelStorei(G.UNPACK_SKIP_ROWS, wt), G.pixelStorei(G.UNPACK_SKIP_IMAGES, st), $ === 0 && q.generateMipmaps && G.generateMipmap(G.TEXTURE_2D), F.unbindTexture();
    }, this.copyTextureToTexture3D = function(P, q, J = null, le = null, $ = 0) {
      let me, Ee, Ae, Re, Ne, Ge, Ie, $e, St;
      P.isTexture !== !0 && (J = arguments[0] || null, le = arguments[1] || null, P = arguments[2], q = arguments[3], $ = arguments[4] || 0);
      const qt = P.isCompressedTexture ? P.mipmaps[$] : P.image;
      J !== null ? (me = J.max.x - J.min.x, Ee = J.max.y - J.min.y, Ae = J.max.z - J.min.z, Re = J.min.x, Ne = J.min.y, Ge = J.min.z) : (me = qt.width, Ee = qt.height, Ae = qt.depth, Re = 0, Ne = 0, Ge = 0), le !== null ? (Ie = le.x, $e = le.y, St = le.z) : (Ie = 0, $e = 0, St = 0);
      const Qt = Nt.convert(q.format), wt = Nt.convert(q.type);
      let st;
      if (q.isData3DTexture)
        se.setTexture3D(q, 0), st = G.TEXTURE_3D;
      else {
        if (!q.isDataArrayTexture && !q.isCompressedArrayTexture)
          return;
        se.setTexture2DArray(q, 0), st = G.TEXTURE_2D_ARRAY;
      }
      G.pixelStorei(G.UNPACK_FLIP_Y_WEBGL, q.flipY), G.pixelStorei(G.UNPACK_PREMULTIPLY_ALPHA_WEBGL, q.premultiplyAlpha), G.pixelStorei(G.UNPACK_ALIGNMENT, q.unpackAlignment);
      const Ot = G.getParameter(G.UNPACK_ROW_LENGTH), Xn = G.getParameter(G.UNPACK_IMAGE_HEIGHT), Ze = G.getParameter(G.UNPACK_SKIP_PIXELS), je = G.getParameter(G.UNPACK_SKIP_ROWS), rl = G.getParameter(G.UNPACK_SKIP_IMAGES);
      G.pixelStorei(G.UNPACK_ROW_LENGTH, qt.width), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, qt.height), G.pixelStorei(G.UNPACK_SKIP_PIXELS, Re), G.pixelStorei(G.UNPACK_SKIP_ROWS, Ne), G.pixelStorei(G.UNPACK_SKIP_IMAGES, Ge), P.isDataTexture || P.isData3DTexture ? G.texSubImage3D(st, $, Ie, $e, St, me, Ee, Ae, Qt, wt, qt.data) : q.isCompressedArrayTexture ? G.compressedTexSubImage3D(st, $, Ie, $e, St, me, Ee, Ae, Qt, qt.data) : G.texSubImage3D(st, $, Ie, $e, St, me, Ee, Ae, Qt, wt, qt), G.pixelStorei(G.UNPACK_ROW_LENGTH, Ot), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, Xn), G.pixelStorei(G.UNPACK_SKIP_PIXELS, Ze), G.pixelStorei(G.UNPACK_SKIP_ROWS, je), G.pixelStorei(G.UNPACK_SKIP_IMAGES, rl), $ === 0 && q.generateMipmaps && G.generateMipmap(st), F.unbindTexture();
    }, this.initRenderTarget = function(P) {
      V.get(P).Vt === void 0 && se.setupRenderTarget(P);
    }, this.initTexture = function(P) {
      P.isCubeTexture ? se.setTextureCube(P, 0) : P.isData3DTexture ? se.setTexture3D(P, 0) : P.isDataArrayTexture || P.isCompressedArrayTexture ? se.setTexture2DArray(P, 0) : se.setTexture2D(P, 0), F.unbindTexture();
    }, this.resetState = function() {
      b = 0, S = 0, w = null, F.reset(), Un.reset();
    }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return wa;
  }
  get outputColorSpace() {
    return this.he;
  }
  set outputColorSpace(e) {
    this.he = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === Rd ? "display-p3" : "srgb", t.unpackColorSpace = it.workingColorSpace === Gh ? "display-p3" : "srgb";
  }
}
class ko {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new oe(e), this.density = t;
  }
  clone() {
    return new ko(this.color, this.density);
  }
  toJSON() {
    return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density };
  }
}
class zo {
  constructor(e, t = 1, i = 1e3) {
    this.isFog = !0, this.name = "", this.color = new oe(e), this.near = t, this.far = i;
  }
  clone() {
    return new zo(this.color, this.near, this.far);
  }
  toJSON() {
    return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far };
  }
}
class _m extends Ue {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new gt(), this.environmentIntensity = 1, this.environmentRotation = new gt(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
}
class Xh {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = ch, this.ut = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = ri();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return Ag("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this.ut;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer.pe === void 0 && (this.array.buffer.pe = ri()), e.arrayBuffers[this.array.buffer.pe] === void 0 && (e.arrayBuffers[this.array.buffer.pe] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer.pe]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer.pe === void 0 && (this.array.buffer.pe = ri()), e.arrayBuffers[this.array.buffer.pe] === void 0 && (e.arrayBuffers[this.array.buffer.pe] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer.pe, type: this.array.constructor.name, stride: this.stride };
  }
}
const An = new _();
class zn {
  constructor(e, t, i, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      An.fromBufferAttribute(this, t), An.applyMatrix4(e), this.setXYZ(t, An.x, An.y, An.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      An.fromBufferAttribute(this, t), An.applyNormalMatrix(e), this.setXYZ(t, An.x, An.y, An.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      An.fromBufferAttribute(this, t), An.transformDirection(e), this.setXYZ(t, An.x, An.y, An.z);
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (i = Nn(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = Oe(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this;
  }
  setX(e, t) {
    return this.normalized && (t = Oe(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = Oe(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = Oe(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = Oe(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Nn(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Nn(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Nn(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Nn(t, this.array)), t;
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Oe(t, this.array), i = Oe(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Oe(t, this.array), i = Oe(i, this.array), r = Oe(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Oe(t, this.array), i = Oe(i, this.array), r = Oe(r, this.array), s = Oe(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return new Ke(new this.array.constructor(t), this.itemSize, this.normalized);
    }
    return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new zn(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
    }
    return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
}
class Ud extends Xt {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new oe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let Za;
const ul = new _(), Ka = new _(), Ja = new _(), Qa = new X(), dl = new X(), oM = new fe(), Ac = new _(), pl = new _(), Cc = new _(), Uv = new X(), Fp = new X(), Fv = new X();
class Tm extends Ue {
  constructor(e = new Ud()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", Za === void 0) {
      Za = new Pe();
      const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), i = new Xh(t, 5);
      Za.setIndex([0, 1, 2, 0, 2, 3]), Za.setAttribute("position", new zn(i, 3, 0, !1)), Za.setAttribute("uv", new zn(i, 2, 3, !1));
    }
    this.geometry = Za, this.material = e, this.center = new X(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera, Ka.setFromMatrixScale(this.matrixWorld), oM.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Ja.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Ka.multiplyScalar(-Ja.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && (s = Math.cos(i), r = Math.sin(i));
    const a = this.center;
    Pc(Ac.set(-0.5, -0.5, 0), Ja, a, Ka, r, s), Pc(pl.set(0.5, -0.5, 0), Ja, a, Ka, r, s), Pc(Cc.set(0.5, 0.5, 0), Ja, a, Ka, r, s), Uv.set(0, 0), Fp.set(1, 0), Fv.set(1, 1);
    let o = e.ray.intersectTriangle(Ac, pl, Cc, !1, ul);
    if (o === null && (Pc(pl.set(-0.5, 0.5, 0), Ja, a, Ka, r, s), Fp.set(0, 1), o = e.ray.intersectTriangle(Ac, Cc, pl, !1, ul), o === null))
      return;
    const l = e.ray.origin.distanceTo(ul);
    l < e.near || l > e.far || t.push({ distance: l, point: ul.clone(), uv: ei.getInterpolation(ul, Ac, pl, Cc, Uv, Fp, Fv, new X()), face: null, object: this });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Pc(n, e, t, i, r, s) {
  Qa.subVectors(n, t).addScalar(0.5).multiply(i), r !== void 0 ? (dl.x = s * Qa.x - r * Qa.y, dl.y = r * Qa.x + s * Qa.y) : dl.copy(Qa), n.copy(e), n.x += dl.x, n.y += dl.y, n.applyMatrix4(oM);
}
const Rc = new _(), Bv = new _();
class kv extends Ue {
  constructor() {
    super(), this.me = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++)
      ;
    return r.splice(s, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this.me;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if (t[i].object.visible && (s -= s * t[i].hysteresis), e < s)
          break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Rc.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(Rc);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Rc.setFromMatrixPosition(e.matrixWorld), Bv.setFromMatrixPosition(this.matrixWorld);
      const i = Rc.distanceTo(Bv) / e.zoom;
      let r, s;
      for (t[0].object.visible = !0, r = 1, s = t.length; r < s; r++) {
        let a = t[r].distance;
        if (t[r].object.visible && (a -= a * t[r].hysteresis), !(i >= a))
          break;
        t[r - 1].object.visible = !1, t[r].object.visible = !0;
      }
      for (this.me = r - 1; r < s; r++)
        t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const a = i[r];
      t.object.levels.push({ object: a.object.uuid, distance: a.distance, hysteresis: a.hysteresis });
    }
    return t;
  }
}
const zv = new _(), Vv = new Ve(), Hv = new Ve(), IT = new _(), Gv = new fe(), Ic = new _(), Bp = new rn(), jv = new fe(), kp = new Ra();
class ju extends ce {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Xf, this.bindMatrix = new fe(), this.bindMatrixInverse = new fe(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new yt()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, Ic), this.boundingBox.expandByPoint(Ic);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new rn()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, Ic), this.boundingSphere.expandByPoint(Ic);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const i = this.material, r = this.matrixWorld;
    i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Bp.copy(this.boundingSphere), Bp.applyMatrix4(r), e.ray.intersectsSphere(Bp) !== !1 && (jv.copy(r).invert(), kp.copy(e.ray).applyMatrix4(jv), this.boundingBox !== null && kp.intersectsBox(this.boundingBox) === !1 || this.dt(e, t, kp)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Ve(), t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === Xf ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === H1 && this.bindMatrixInverse.copy(this.bindMatrix).invert();
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton, r = this.geometry;
    Vv.fromBufferAttribute(r.attributes.skinIndex, e), Hv.fromBufferAttribute(r.attributes.skinWeight, e), zv.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const a = Hv.getComponent(s);
      if (a !== 0) {
        const o = Vv.getComponent(s);
        Gv.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]), t.addScaledVector(IT.copy(zv).applyMatrix4(Gv), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Vo extends Ue {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Sr extends pt {
  constructor(e = null, t = 1, i = 1, r, s, a, o, l, h = 1003, c = 1003, u, d) {
    super(null, a, o, l, h, c, r, s, u, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const Wv = new fe(), LT = new fe();
class Ho {
  constructor(e = [], t = []) {
    this.uuid = ri(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(16 * e.length), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      this.boneInverses = [];
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new fe());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new fe();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s] ? e[s].matrixWorld : LT;
      Wv.multiplyMatrices(o, t[s]), Wv.toArray(i, 16 * s);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Ho(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(4 * this.bones.length);
    e = 4 * Math.ceil(e / 4), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Sr(t, e, e, yi, ni);
    return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this;
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e)
        return r;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      let s = t[e.bones[i]];
      s === void 0 && (s = new Vo()), this.bones.push(s), this.boneInverses.push(new fe().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    e.uuid = this.uuid;
    const t = this.bones, i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const a = t[r];
      e.bones.push(a.uuid);
      const o = i[r];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class da extends Ke {
  constructor(e, t, i, r = 1) {
    super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const $a = new fe(), Xv = new fe(), Lc = [], qv = new yt(), NT = new fe(), fl = new ce(), ml = new rn();
class Em extends ce {
  constructor(e, t, i) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new da(new Float32Array(16 * i), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
    for (let r = 0; r < i; r++)
      this.setMatrixAt(r, NT);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new yt()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, $a), qv.copy(e.boundingBox).applyMatrix4($a), this.boundingBox.union(qv);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new rn()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, $a), ml.copy(e.boundingSphere).applyMatrix4($a), this.boundingSphere.union(ml);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, 3 * e);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, 16 * e);
  }
  getMorphAt(e, t) {
    const i = t.morphTargetInfluences, r = this.morphTexture.source.data.data, s = e * (i.length + 1) + 1;
    for (let a = 0; a < i.length; a++)
      i[a] = r[s + a];
  }
  raycast(e, t) {
    const i = this.matrixWorld, r = this.count;
    if (fl.geometry = this.geometry, fl.material = this.material, fl.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), ml.copy(this.boundingSphere), ml.applyMatrix4(i), e.ray.intersectsSphere(ml) !== !1))
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, $a), Xv.multiplyMatrices(i, $a), fl.matrixWorld = Xv, fl.raycast(e, Lc);
        for (let a = 0, o = Lc.length; a < o; a++) {
          const l = Lc[a];
          l.instanceId = s, l.object = this, t.push(l);
        }
        Lc.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new da(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, 16 * e);
  }
  setMorphAt(e, t) {
    const i = t.morphTargetInfluences, r = i.length + 1;
    this.morphTexture === null && (this.morphTexture = new Sr(new Float32Array(r * this.count), r, this.count, xg, ni));
    const s = this.morphTexture.source.data.data;
    let a = 0;
    for (let h = 0; h < i.length; h++)
      a += i[h];
    const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, l = r * e;
    s[l] = o, s.set(i, l + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
}
function DT(n, e) {
  return n.z - e.z;
}
function OT(n, e) {
  return e.z - n.z;
}
class UT {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t) {
    const i = this.pool, r = this.list;
    this.index >= i.length && i.push({ start: -1, count: -1, z: -1 });
    const s = i[this.index];
    r.push(s), this.index++, s.start = e.start, s.count = e.count, s.z = t;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const eo = "batchId", Gr = new fe(), zp = new fe(), FT = new fe(), BT = new oe(1, 1, 1), Yv = new fe(), Vp = new jh(), Nc = new yt(), Us = new rn(), gl = new _(), Zv = new _(), kT = new _(), Hp = new UT(), bn = new ce(), Dc = [];
function zT(n, e, t = 0) {
  const i = e.itemSize;
  if (n.isInterleavedBufferAttribute || n.array.constructor !== e.array.constructor) {
    const r = n.count;
    for (let s = 0; s < r; s++)
      for (let a = 0; a < i; a++)
        e.setComponent(s + t, a, n.getComponent(s, a));
  } else
    e.array.set(n.array, t * i);
  e.needsUpdate = !0;
}
class Kv extends ce {
  get maxGeometryCount() {
    return this.nt;
  }
  constructor(e, t, i = 2 * t, r) {
    super(new Pe(), r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this.j = [], this.J = [], this.$ = [], this.tt = [], this.et = [], this.nt = e, this.it = t, this.st = i, this.rt = !1, this.ot = 0, this.ue = new Int32Array(e), this.le = new Int32Array(e), this.fe = 0, this.ce = null, this.ve = !0, this.ht = null, this.ge(), this.ct = null;
  }
  ge() {
    let e = Math.sqrt(4 * this.nt);
    e = 4 * Math.ceil(e / 4), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), i = new Sr(t, e, e, yi, ni);
    this.ht = i;
  }
  we() {
    let e = Math.sqrt(this.nt);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1), i = new Sr(t, e, e, yi, ni);
    i.colorSpace = it.workingColorSpace, this.ct = i;
  }
  Me(e) {
    const t = this.geometry, i = this.it, r = this.nt, s = this.st;
    if (this.rt === !1) {
      for (const o in e.attributes) {
        const l = e.getAttribute(o), { array: h, itemSize: c, normalized: u } = l, d = new h.constructor(i * c), p = new Ke(d, c, u);
        t.setAttribute(o, p);
      }
      if (e.getIndex() !== null) {
        const o = i > 65536 ? new Uint32Array(s) : new Uint16Array(s);
        t.setIndex(new Ke(o, 1));
      }
      const a = r > 65536 ? new Uint32Array(i) : new Uint16Array(i);
      t.setAttribute(eo, new Ke(a, 1)), this.rt = !0;
    }
  }
  _e(e) {
    if (e.getAttribute(eo))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${eo}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const i in t.attributes) {
      if (i === eo)
        continue;
      if (!e.hasAttribute(i))
        throw new Error(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
      const r = e.getAttribute(i), s = t.getAttribute(i);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new yt());
    const e = this.ot, t = this.boundingBox, i = this.tt;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      i[r] !== !1 && (this.getMatrixAt(r, Gr), this.getBoundingBoxAt(r, Nc).applyMatrix4(Gr), t.union(Nc));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new rn());
    const e = this.ot, t = this.boundingSphere, i = this.tt;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      i[r] !== !1 && (this.getMatrixAt(r, Gr), this.getBoundingSphereAt(r, Us).applyMatrix4(Gr), t.union(Us));
  }
  addGeometry(e, t = -1, i = -1) {
    if (this.Me(e), this._e(e), this.ot >= this.nt)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const r = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 };
    let s = null;
    const a = this.J, o = this.j, l = this.et;
    this.ot !== 0 && (s = a[a.length - 1]), r.vertexCount = t === -1 ? e.getAttribute("position").count : t, r.vertexStart = s === null ? 0 : s.vertexStart + s.vertexCount;
    const h = e.getIndex(), c = h !== null;
    if (c && (r.indexCount = i === -1 ? h.count : i, r.indexStart = s === null ? 0 : s.indexStart + s.indexCount), r.indexStart !== -1 && r.indexStart + r.indexCount > this.st || r.vertexStart + r.vertexCount > this.it)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const u = this.$, d = this.tt, p = this.ht, m = this.ht.image.data, g = this.ct;
    u.push(!0), d.push(!0);
    const f = this.ot;
    this.ot++, FT.toArray(m, 16 * f), p.needsUpdate = !0, g !== null && (BT.toArray(g.image.data, 4 * f), g.needsUpdate = !0), a.push(r), o.push({ start: c ? r.indexStart : r.vertexStart, count: -1 }), l.push({ boxInitialized: !1, box: new yt(), sphereInitialized: !1, sphere: new rn() });
    const v = this.geometry.getAttribute(eo);
    for (let y = 0; y < r.vertexCount; y++)
      v.setX(r.vertexStart + y, f);
    return v.needsUpdate = !0, this.setGeometryAt(f, e), f;
  }
  setGeometryAt(e, t) {
    if (e >= this.ot)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._e(t);
    const i = this.geometry, r = i.getIndex() !== null, s = i.getIndex(), a = t.getIndex(), o = this.J[e];
    if (r && a.count > o.indexCount || t.attributes.position.count > o.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const l = o.vertexStart, h = o.vertexCount;
    for (const p in i.attributes) {
      if (p === eo)
        continue;
      const m = t.getAttribute(p), g = i.getAttribute(p);
      zT(m, g, l);
      const f = m.itemSize;
      for (let v = m.count, y = h; v < y; v++) {
        const x = l + v;
        for (let M = 0; M < f; M++)
          g.setComponent(x, M, 0);
      }
      g.needsUpdate = !0, g.addUpdateRange(l * f, h * f);
    }
    if (r) {
      const p = o.indexStart;
      for (let m = 0; m < a.count; m++)
        s.setX(p + m, l + a.getX(m));
      for (let m = a.count, g = o.indexCount; m < g; m++)
        s.setX(p + m, l);
      s.needsUpdate = !0, s.addUpdateRange(p, o.indexCount);
    }
    const c = this.et[e];
    t.boundingBox !== null ? (c.box.copy(t.boundingBox), c.boxInitialized = !0) : c.boxInitialized = !1, t.boundingSphere !== null ? (c.sphere.copy(t.boundingSphere), c.sphereInitialized = !0) : c.sphereInitialized = !1;
    const u = this.j[e], d = t.getAttribute("position");
    return u.count = r ? a.count : d.count, this.ve = !0, e;
  }
  deleteGeometry(e) {
    const t = this.tt;
    return e >= t.length || t[e] === !1 || (t[e] = !1, this.ve = !0), this;
  }
  getInstanceCountAt(e) {
    return this.ce === null ? null : this.ce[e];
  }
  setInstanceCountAt(e, t) {
    return this.ce === null && (this.ce = new Int32Array(this.nt).fill(1)), this.ce[e] = t, e;
  }
  getBoundingBoxAt(e, t) {
    if (this.tt[e] === !1)
      return null;
    const i = this.et[e], r = i.box, s = this.geometry;
    if (i.boxInitialized === !1) {
      r.makeEmpty();
      const a = s.index, o = s.attributes.position, l = this.j[e];
      for (let h = l.start, c = l.start + l.count; h < c; h++) {
        let u = h;
        a && (u = a.getX(u)), r.expandByPoint(gl.fromBufferAttribute(o, u));
      }
      i.boxInitialized = !0;
    }
    return t.copy(r), t;
  }
  getBoundingSphereAt(e, t) {
    if (this.tt[e] === !1)
      return null;
    const i = this.et[e], r = i.sphere, s = this.geometry;
    if (i.sphereInitialized === !1) {
      r.makeEmpty(), this.getBoundingBoxAt(e, Nc), Nc.getCenter(r.center);
      const a = s.index, o = s.attributes.position, l = this.j[e];
      let h = 0;
      for (let c = l.start, u = l.start + l.count; c < u; c++) {
        let d = c;
        a && (d = a.getX(d)), gl.fromBufferAttribute(o, d), h = Math.max(h, r.center.distanceToSquared(gl));
      }
      r.radius = Math.sqrt(h), i.sphereInitialized = !0;
    }
    return t.copy(r), t;
  }
  setMatrixAt(e, t) {
    const i = this.tt, r = this.ht, s = this.ht.image.data;
    return e >= this.ot || i[e] === !1 || (t.toArray(s, 16 * e), r.needsUpdate = !0), this;
  }
  getMatrixAt(e, t) {
    const i = this.tt, r = this.ht.image.data;
    return e >= this.ot || i[e] === !1 ? null : t.fromArray(r, 16 * e);
  }
  setColorAt(e, t) {
    this.ct === null && this.we();
    const i = this.tt, r = this.ct, s = this.ct.image.data;
    return e >= this.ot || i[e] === !1 || (t.toArray(s, 4 * e), r.needsUpdate = !0), this;
  }
  getColorAt(e, t) {
    const i = this.tt, r = this.ct.image.data;
    return e >= this.ot || i[e] === !1 ? null : t.fromArray(r, 4 * e);
  }
  setVisibleAt(e, t) {
    const i = this.$, r = this.tt;
    return e >= this.ot || r[e] === !1 || i[e] === t || (i[e] = t, this.ve = !0), this;
  }
  getVisibleAt(e) {
    const t = this.$, i = this.tt;
    return !(e >= this.ot || i[e] === !1) && t[e];
  }
  raycast(e, t) {
    const i = this.$, r = this.tt, s = this.j, a = this.ot, o = this.matrixWorld, l = this.geometry;
    bn.material = this.material, bn.geometry.index = l.index, bn.geometry.attributes = l.attributes, bn.geometry.boundingBox === null && (bn.geometry.boundingBox = new yt()), bn.geometry.boundingSphere === null && (bn.geometry.boundingSphere = new rn());
    for (let h = 0; h < a; h++) {
      if (!i[h] || !r[h])
        continue;
      const c = s[h];
      bn.geometry.setDrawRange(c.start, c.count), this.getMatrixAt(h, bn.matrixWorld).premultiply(o), this.getBoundingBoxAt(h, bn.geometry.boundingBox), this.getBoundingSphereAt(h, bn.geometry.boundingSphere), bn.raycast(e, Dc);
      for (let u = 0, d = Dc.length; u < d; u++) {
        const p = Dc[u];
        p.object = this, p.batchId = h, t.push(p);
      }
      Dc.length = 0;
    }
    bn.material = null, bn.geometry.index = null, bn.geometry.attributes = {}, bn.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this.j = e.j.map((t) => Te({}, t)), this.J = e.J.map((t) => Te({}, t)), this.$ = e.$.slice(), this.tt = e.tt.slice(), this.et = e.et.map((t) => ({ boxInitialized: t.boxInitialized, box: t.box.clone(), sphereInitialized: t.sphereInitialized, sphere: t.sphere.clone() })), this.nt = e.nt, this.it = e.it, this.st = e.st, this.rt = e.rt, this.ot = e.ot, this.ue = e.ue.slice(), this.le = e.le.slice(), this.ht = e.ht.clone(), this.ht.image.data = this.ht.image.slice(), this.ct !== null && (this.ct = e.ct.clone(), this.ct.image.data = this.ct.image.slice()), this;
  }
  dispose() {
    return this.geometry.dispose(), this.ht.dispose(), this.ht = null, this.ct !== null && (this.ct.dispose(), this.ct = null), this;
  }
  onBeforeRender(e, t, i, r, s) {
    if (!this.ve && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const a = r.getIndex(), o = a === null ? 1 : a.array.BYTES_PER_ELEMENT, l = this.tt, h = this.$, c = this.le, u = this.ue, d = this.j, p = this.perObjectFrustumCulled;
    p && (Yv.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld), Vp.setFromProjectionMatrix(Yv, e.coordinateSystem));
    let m = 0;
    if (this.sortObjects) {
      zp.copy(this.matrixWorld).invert(), gl.setFromMatrixPosition(i.matrixWorld).applyMatrix4(zp), Zv.set(0, 0, -1).transformDirection(i.matrixWorld).transformDirection(zp);
      for (let v = 0, y = h.length; v < y; v++)
        if (h[v] && l[v]) {
          this.getMatrixAt(v, Gr), this.getBoundingSphereAt(v, Us).applyMatrix4(Gr);
          let x = !1;
          if (p && (x = !Vp.intersectsSphere(Us)), !x) {
            const M = kT.subVectors(Us.center, gl).dot(Zv);
            Hp.push(d[v], M);
          }
        }
      const g = Hp.list, f = this.customSort;
      f === null ? g.sort(s.transparent ? OT : DT) : f.call(this, g, i);
      for (let v = 0, y = g.length; v < y; v++) {
        const x = g[v];
        c[m] = x.start * o, u[m] = x.count, m++;
      }
      Hp.reset();
    } else
      for (let g = 0, f = h.length; g < f; g++)
        if (h[g] && l[g]) {
          let v = !1;
          if (p && (this.getMatrixAt(g, Gr), this.getBoundingSphereAt(g, Us).applyMatrix4(Gr), v = !Vp.intersectsSphere(Us)), !v) {
            const y = d[g];
            c[m] = y.start * o, u[m] = y.count, m++;
          }
        }
    this.fe = m, this.ve = !1;
  }
  onBeforeShadow(e, t, i, r, s, a) {
    this.onBeforeRender(e, null, r, s, a);
  }
}
class kt extends Xt {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new oe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const Wu = new _(), Xu = new _(), Jv = new fe(), vl = new Ra(), Oc = new rn(), Gp = new _(), Qv = new _();
class hn extends Ue {
  constructor(e = new Pe(), t = new kt()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        Wu.fromBufferAttribute(t, r - 1), Xu.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += Wu.distanceTo(Xu);
      e.setAttribute("lineDistance", new ye(i, 1));
    }
    return this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, a = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Oc.copy(i.boundingSphere), Oc.applyMatrix4(r), Oc.radius += s, e.ray.intersectsSphere(Oc) === !1)
      return;
    Jv.copy(r).invert(), vl.copy(e.ray).applyMatrix4(Jv);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, h = this.isLineSegments ? 2 : 1, c = i.index, u = i.attributes.position;
    if (c !== null) {
      const d = Math.max(0, a.start), p = Math.min(c.count, a.start + a.count);
      for (let m = d, g = p - 1; m < g; m += h) {
        const f = c.getX(m), v = c.getX(m + 1), y = Uc(this, e, vl, l, f, v);
        y && t.push(y);
      }
      if (this.isLineLoop) {
        const m = c.getX(p - 1), g = c.getX(d), f = Uc(this, e, vl, l, m, g);
        f && t.push(f);
      }
    } else {
      const d = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count);
      for (let m = d, g = p - 1; m < g; m += h) {
        const f = Uc(this, e, vl, l, m, m + 1);
        f && t.push(f);
      }
      if (this.isLineLoop) {
        const m = Uc(this, e, vl, l, p - 1, d);
        m && t.push(m);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const i = e[t[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, s = i.length; r < s; r++) {
          const a = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function Uc(n, e, t, i, r, s) {
  const a = n.geometry.attributes.position;
  if (Wu.fromBufferAttribute(a, r), Xu.fromBufferAttribute(a, s), t.distanceSqToSegment(Wu, Xu, Gp, Qv) > i)
    return;
  Gp.applyMatrix4(n.matrixWorld);
  const o = e.ray.origin.distanceTo(Gp);
  return o < e.near || o > e.far ? void 0 : { distance: o, point: Qv.clone().applyMatrix4(n.matrixWorld), index: r, face: null, faceIndex: null, object: n };
}
const $v = new _(), ey = new _();
class Zn extends hn {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        $v.fromBufferAttribute(t, r), ey.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + $v.distanceTo(ey);
      e.setAttribute("lineDistance", new ye(i, 1));
    }
    return this;
  }
}
class Am extends hn {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class Jr extends Xt {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new oe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const ty = new fe(), Cm = new Ra(), Fc = new rn(), Bc = new _();
class os extends Ue {
  constructor(e = new Pe(), t = new Jr()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, a = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Fc.copy(i.boundingSphere), Fc.applyMatrix4(r), Fc.radius += s, e.ray.intersectsSphere(Fc) === !1)
      return;
    ty.copy(r).invert(), Cm.copy(e.ray).applyMatrix4(ty);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, h = i.index, c = i.attributes.position;
    if (h !== null)
      for (let u = Math.max(0, a.start), d = Math.min(h.count, a.start + a.count); u < d; u++) {
        const p = h.getX(u);
        Bc.fromBufferAttribute(c, p), ny(Bc, p, l, r, e, t, this);
      }
    else
      for (let u = Math.max(0, a.start), d = Math.min(c.count, a.start + a.count); u < d; u++)
        Bc.fromBufferAttribute(c, u), ny(Bc, u, l, r, e, t, this);
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const i = e[t[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, s = i.length; r < s; r++) {
          const a = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function ny(n, e, t, i, r, s, a) {
  const o = Cm.distanceSqToPoint(n);
  if (o < t) {
    const l = new _();
    Cm.closestPointToPoint(n, l), l.applyMatrix4(i);
    const h = r.ray.origin.distanceTo(l);
    if (h < r.near || h > r.far)
      return;
    s.push({ distance: h, distanceToRay: Math.sqrt(o), point: l, index: e, face: null, object: a });
  }
}
class lM extends pt {
  constructor(e, t, i, r, s, a, o, l, h) {
    super(e, t, i, r, s, a, o, l, h), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : Vt, this.magFilter = s !== void 0 ? s : Vt, this.generateMipmaps = !1;
    const c = this;
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function u() {
      c.needsUpdate = !0, e.requestVideoFrameCallback(u);
    });
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    !("requestVideoFrameCallback" in e) && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class kc extends pt {
  constructor(e, t, i, r, s, a, o, l, h, c, u, d) {
    super(null, a, o, l, h, c, r, s, u, d), this.isCompressedTexture = !0, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class hM extends pt {
  constructor(e, t, i, r, s, a, o, l, h) {
    super(e, t, i, r, s, a, o, l, h), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Si {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i, r = this.getPoint(0), s = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      i = this.getPoint(a / e), s += i.distanceTo(r), t.push(s), r = i;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let a;
    a = t || e * i[s - 1];
    let o, l = 0, h = s - 1;
    for (; l <= h; )
      if (r = Math.floor(l + (h - l) / 2), o = i[r] - a, o < 0)
        l = r + 1;
      else {
        if (!(o > 0)) {
          h = r;
          break;
        }
        h = r - 1;
      }
    if (r = h, i[r] === a)
      return r / (s - 1);
    const c = i[r];
    return (r + (a - c) / (i[r + 1] - c)) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4, s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const a = this.getPoint(r), o = this.getPoint(s), l = t || (a.isVector2 ? new X() : new _());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new _(), r = [], s = [], a = [], o = new _(), l = new fe();
    for (let p = 0; p <= e; p++) {
      const m = p / e;
      r[p] = this.getTangentAt(m, new _());
    }
    s[0] = new _(), a[0] = new _();
    let h = Number.MAX_VALUE;
    const c = Math.abs(r[0].x), u = Math.abs(r[0].y), d = Math.abs(r[0].z);
    c <= h && (h = c, i.set(1, 0, 0)), u <= h && (h = u, i.set(0, 1, 0)), d <= h && i.set(0, 0, 1), o.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], o), a[0].crossVectors(r[0], s[0]);
    for (let p = 1; p <= e; p++) {
      if (s[p] = s[p - 1].clone(), a[p] = a[p - 1].clone(), o.crossVectors(r[p - 1], r[p]), o.length() > Number.EPSILON) {
        o.normalize();
        const m = Math.acos(Rt(r[p - 1].dot(r[p]), -1, 1));
        s[p].applyMatrix4(l.makeRotationAxis(o, m));
      }
      a[p].crossVectors(r[p], s[p]);
    }
    if (t === !0) {
      let p = Math.acos(Rt(s[0].dot(s[e]), -1, 1));
      p /= e, r[0].dot(o.crossVectors(s[0], s[e])) > 0 && (p = -p);
      for (let m = 1; m <= e; m++)
        s[m].applyMatrix4(l.makeRotationAxis(r[m], p * m)), a[m].crossVectors(r[m], s[m]);
    }
    return { tangents: r, normals: s, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Fd extends Si {
  constructor(e = 0, t = 0, i = 1, r = 1, s = 0, a = 2 * Math.PI, o = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = a, this.aClockwise = o, this.aRotation = l;
  }
  getPoint(e, t = new X()) {
    const i = t, r = 2 * Math.PI;
    let s = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += r;
    for (; s > r; )
      s -= r;
    s < Number.EPSILON && (s = a ? 0 : r), this.aClockwise !== !0 || a || (s === r ? s = -r : s -= r);
    const o = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(o), h = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const c = Math.cos(this.aRotation), u = Math.sin(this.aRotation), d = l - this.aX, p = h - this.aY;
      l = d * c - p * u + this.aX, h = d * u + p * c + this.aY;
    }
    return i.set(l, h);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class cM extends Fd {
  constructor(e, t, i, r, s, a) {
    super(e, t, i, i, r, s, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Ig() {
  let n = 0, e = 0, t = 0, i = 0;
  function r(s, a, o, l) {
    n = s, e = o, t = -3 * s + 3 * a - 2 * o - l, i = 2 * s - 2 * a + o + l;
  }
  return { initCatmullRom: function(s, a, o, l, h) {
    r(a, o, h * (o - s), h * (l - a));
  }, initNonuniformCatmullRom: function(s, a, o, l, h, c, u) {
    let d = (a - s) / h - (o - s) / (h + c) + (o - a) / c, p = (o - a) / c - (l - a) / (c + u) + (l - o) / u;
    d *= c, p *= c, r(a, o, d, p);
  }, calc: function(s) {
    const a = s * s;
    return n + e * s + t * a + i * (a * s);
  } };
}
const zc = new _(), jp = new Ig(), Wp = new Ig(), Xp = new Ig();
class Bd extends Si {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r;
  }
  getPoint(e, t = new _()) {
    const i = t, r = this.points, s = r.length, a = (s - (this.closed ? 0 : 1)) * e;
    let o, l, h = Math.floor(a), c = a - h;
    this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / s) + 1) * s : c === 0 && h === s - 1 && (h = s - 2, c = 1), this.closed || h > 0 ? o = r[(h - 1) % s] : (zc.subVectors(r[0], r[1]).add(r[0]), o = zc);
    const u = r[h % s], d = r[(h + 1) % s];
    if (this.closed || h + 2 < s ? l = r[(h + 2) % s] : (zc.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), l = zc), this.curveType === "centripetal" || this.curveType === "chordal") {
      const p = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(o.distanceToSquared(u), p), g = Math.pow(u.distanceToSquared(d), p), f = Math.pow(d.distanceToSquared(l), p);
      g < 1e-4 && (g = 1), m < 1e-4 && (m = g), f < 1e-4 && (f = g), jp.initNonuniformCatmullRom(o.x, u.x, d.x, l.x, m, g, f), Wp.initNonuniformCatmullRom(o.y, u.y, d.y, l.y, m, g, f), Xp.initNonuniformCatmullRom(o.z, u.z, d.z, l.z, m, g, f);
    } else
      this.curveType === "catmullrom" && (jp.initCatmullRom(o.x, u.x, d.x, l.x, this.tension), Wp.initCatmullRom(o.y, u.y, d.y, l.y, this.tension), Xp.initCatmullRom(o.z, u.z, d.z, l.z, this.tension));
    return i.set(jp.calc(c), Wp.calc(c), Xp.calc(c)), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new _().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function iy(n, e, t, i, r) {
  const s = 0.5 * (i - e), a = 0.5 * (r - t), o = n * n;
  return (2 * t - 2 * i + s + a) * (n * o) + (-3 * t + 3 * i - 2 * s - a) * o + s * n + t;
}
function Xl(n, e, t, i) {
  return function(r, s) {
    const a = 1 - r;
    return a * a * s;
  }(n, e) + function(r, s) {
    return 2 * (1 - r) * r * s;
  }(n, t) + function(r, s) {
    return r * r * s;
  }(n, i);
}
function ql(n, e, t, i, r) {
  return function(s, a) {
    const o = 1 - s;
    return o * o * o * a;
  }(n, e) + function(s, a) {
    const o = 1 - s;
    return 3 * o * o * s * a;
  }(n, t) + function(s, a) {
    return 3 * (1 - s) * s * s * a;
  }(n, i) + function(s, a) {
    return s * s * s * a;
  }(n, r);
}
class Lg extends Si {
  constructor(e = new X(), t = new X(), i = new X(), r = new X()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new X()) {
    const i = t, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
    return i.set(ql(e, r.x, s.x, a.x, o.x), ql(e, r.y, s.y, a.y, o.y)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class uM extends Si {
  constructor(e = new _(), t = new _(), i = new _(), r = new _()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new _()) {
    const i = t, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
    return i.set(ql(e, r.x, s.x, a.x, o.x), ql(e, r.y, s.y, a.y, o.y), ql(e, r.z, s.z, a.z, o.z)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Ng extends Si {
  constructor(e = new X(), t = new X()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new X()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new X()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class dM extends Si {
  constructor(e = new _(), t = new _()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new _()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new _()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Dg extends Si {
  constructor(e = new X(), t = new X(), i = new X()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new X()) {
    const i = t, r = this.v0, s = this.v1, a = this.v2;
    return i.set(Xl(e, r.x, s.x, a.x), Xl(e, r.y, s.y, a.y)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Og extends Si {
  constructor(e = new _(), t = new _(), i = new _()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new _()) {
    const i = t, r = this.v0, s = this.v1, a = this.v2;
    return i.set(Xl(e, r.x, s.x, a.x), Xl(e, r.y, s.y, a.y), Xl(e, r.z, s.z, a.z)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Ug extends Si {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new X()) {
    const i = t, r = this.points, s = (r.length - 1) * e, a = Math.floor(s), o = s - a, l = r[a === 0 ? a : a - 1], h = r[a], c = r[a > r.length - 2 ? r.length - 1 : a + 1], u = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return i.set(iy(o, l.x, h.x, c.x, u.x), iy(o, l.y, h.y, c.y, u.y)), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new X().fromArray(r));
    }
    return this;
  }
}
var qu = Object.freeze({ __proto__: null, ArcCurve: cM, CatmullRomCurve3: Bd, CubicBezierCurve: Lg, CubicBezierCurve3: uM, EllipseCurve: Fd, LineCurve: Ng, LineCurve3: dM, QuadraticBezierCurve: Dg, QuadraticBezierCurve3: Og, SplineCurve: Ug });
class pM extends Si {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new qu[i](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const i = e * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const a = r[s] - i, o = this.curves[s], l = o.getLength(), h = l === 0 ? 0 : 1 - a / l;
        return o.getPointAt(h, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const a = s[r], o = a.isEllipseCurve ? 2 * e : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, l = a.getPoints(o);
      for (let h = 0; h < l.length; h++) {
        const c = l[h];
        i && i.equals(c) || (t.push(c), i = c);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new qu[r.type]().fromJSON(r));
    }
    return this;
  }
}
class Go extends pM {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new X(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new Ng(this.currentPoint.clone(), new X(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new Dg(this.currentPoint.clone(), new X(e, t), new X(i, r));
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, a) {
    const o = new Lg(this.currentPoint.clone(), new X(e, t), new X(i, r), new X(s, a));
    return this.curves.push(o), this.currentPoint.set(s, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new Ug(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, a) {
    const o = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(e + o, t + l, i, r, s, a), this;
  }
  absarc(e, t, i, r, s, a) {
    return this.absellipse(e, t, i, i, r, s, a), this;
  }
  ellipse(e, t, i, r, s, a, o, l) {
    const h = this.currentPoint.x, c = this.currentPoint.y;
    return this.absellipse(e + h, t + c, i, r, s, a, o, l), this;
  }
  absellipse(e, t, i, r, s, a, o, l) {
    const h = new Fd(e, t, i, r, s, a, o, l);
    if (this.curves.length > 0) {
      const u = h.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(h);
    const c = h.getPoint(1);
    return this.currentPoint.copy(c), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class qh extends Pe {
  constructor(e = [new X(0, -0.5), new X(0.5, 0), new X(0, 0.5)], t = 12, i = 0, r = 2 * Math.PI) {
    super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }, t = Math.floor(t), r = Rt(r, 0, 2 * Math.PI);
    const s = [], a = [], o = [], l = [], h = [], c = 1 / t, u = new _(), d = new X(), p = new _(), m = new _(), g = new _();
    let f = 0, v = 0;
    for (let y = 0; y <= e.length - 1; y++)
      switch (y) {
        case 0:
          f = e[y + 1].x - e[y].x, v = e[y + 1].y - e[y].y, p.x = 1 * v, p.y = -f, p.z = 0 * v, g.copy(p), p.normalize(), l.push(p.x, p.y, p.z);
          break;
        case e.length - 1:
          l.push(g.x, g.y, g.z);
          break;
        default:
          f = e[y + 1].x - e[y].x, v = e[y + 1].y - e[y].y, p.x = 1 * v, p.y = -f, p.z = 0 * v, m.copy(p), p.x += g.x, p.y += g.y, p.z += g.z, p.normalize(), l.push(p.x, p.y, p.z), g.copy(m);
      }
    for (let y = 0; y <= t; y++) {
      const x = i + y * c * r, M = Math.sin(x), b = Math.cos(x);
      for (let S = 0; S <= e.length - 1; S++) {
        u.x = e[S].x * M, u.y = e[S].y, u.z = e[S].x * b, a.push(u.x, u.y, u.z), d.x = y / t, d.y = S / (e.length - 1), o.push(d.x, d.y);
        const w = l[3 * S + 0] * M, T = l[3 * S + 1], C = l[3 * S + 0] * b;
        h.push(w, T, C);
      }
    }
    for (let y = 0; y < t; y++)
      for (let x = 0; x < e.length - 1; x++) {
        const M = x + y * e.length, b = M, S = M + e.length, w = M + e.length + 1, T = M + 1;
        s.push(b, S, T), s.push(w, T, S);
      }
    this.setIndex(s), this.setAttribute("position", new ye(a, 3)), this.setAttribute("uv", new ye(o, 2)), this.setAttribute("normal", new ye(h, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new qh(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Yh extends qh {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new Go();
    s.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), s.absarc(0, t / 2, e, 0, 0.5 * Math.PI), super(s.getPoints(i), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: i, radialSegments: r };
  }
  static fromJSON(e) {
    return new Yh(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Zh extends Pe {
  constructor(e = 1, t = 32, i = 0, r = 2 * Math.PI) {
    super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }, t = Math.max(3, t);
    const s = [], a = [], o = [], l = [], h = new _(), c = new X();
    a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5);
    for (let u = 0, d = 3; u <= t; u++, d += 3) {
      const p = i + u / t * r;
      h.x = e * Math.cos(p), h.y = e * Math.sin(p), a.push(h.x, h.y, h.z), o.push(0, 0, 1), c.x = (a[d] / e + 1) / 2, c.y = (a[d + 1] / e + 1) / 2, l.push(c.x, c.y);
    }
    for (let u = 1; u <= t; u++)
      s.push(u, u + 1, 0);
    this.setIndex(s), this.setAttribute("position", new ye(a, 3)), this.setAttribute("normal", new ye(o, 3)), this.setAttribute("uv", new ye(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Zh(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Pt extends Pe {
  constructor(e = 1, t = 1, i = 1, r = 32, s = 1, a = !1, o = 0, l = 2 * Math.PI) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: r, heightSegments: s, openEnded: a, thetaStart: o, thetaLength: l };
    const h = this;
    r = Math.floor(r), s = Math.floor(s);
    const c = [], u = [], d = [], p = [];
    let m = 0;
    const g = [], f = i / 2;
    let v = 0;
    function y(x) {
      const M = m, b = new X(), S = new _();
      let w = 0;
      const T = x === !0 ? e : t, C = x === !0 ? 1 : -1;
      for (let A = 1; A <= r; A++)
        u.push(0, f * C, 0), d.push(0, C, 0), p.push(0.5, 0.5), m++;
      const I = m;
      for (let A = 0; A <= r; A++) {
        const L = A / r * l + o, D = Math.cos(L), U = Math.sin(L);
        S.x = T * U, S.y = f * C, S.z = T * D, u.push(S.x, S.y, S.z), d.push(0, C, 0), b.x = 0.5 * D + 0.5, b.y = 0.5 * U * C + 0.5, p.push(b.x, b.y), m++;
      }
      for (let A = 0; A < r; A++) {
        const L = M + A, D = I + A;
        x === !0 ? c.push(D, D + 1, L) : c.push(D + 1, D, L), w += 3;
      }
      h.addGroup(v, w, x === !0 ? 1 : 2), v += w;
    }
    (function() {
      const x = new _(), M = new _();
      let b = 0;
      const S = (t - e) / i;
      for (let w = 0; w <= s; w++) {
        const T = [], C = w / s, I = C * (t - e) + e;
        for (let A = 0; A <= r; A++) {
          const L = A / r, D = L * l + o, U = Math.sin(D), H = Math.cos(D);
          M.x = I * U, M.y = -C * i + f, M.z = I * H, u.push(M.x, M.y, M.z), x.set(U, S, H).normalize(), d.push(x.x, x.y, x.z), p.push(L, 1 - C), T.push(m++);
        }
        g.push(T);
      }
      for (let w = 0; w < r; w++)
        for (let T = 0; T < s; T++) {
          const C = g[T][w], I = g[T + 1][w], A = g[T + 1][w + 1], L = g[T][w + 1];
          c.push(C, I, L), c.push(I, A, L), b += 6;
        }
      h.addGroup(v, b, 0), v += b;
    })(), a === !1 && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(c), this.setAttribute("position", new ye(u, 3)), this.setAttribute("normal", new ye(d, 3)), this.setAttribute("uv", new ye(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Pt(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Kh extends Pt {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, a = 0, o = 2 * Math.PI) {
    super(0, e, t, i, r, s, a, o), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: a, thetaLength: o };
  }
  static fromJSON(e) {
    return new Kh(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class ws extends Pe {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: r };
    const s = [], a = [];
    function o(d, p, m, g) {
      const f = g + 1, v = [];
      for (let y = 0; y <= f; y++) {
        v[y] = [];
        const x = d.clone().lerp(m, y / f), M = p.clone().lerp(m, y / f), b = f - y;
        for (let S = 0; S <= b; S++)
          v[y][S] = S === 0 && y === f ? x : x.clone().lerp(M, S / b);
      }
      for (let y = 0; y < f; y++)
        for (let x = 0; x < 2 * (f - y) - 1; x++) {
          const M = Math.floor(x / 2);
          x % 2 == 0 ? (l(v[y][M + 1]), l(v[y + 1][M]), l(v[y][M])) : (l(v[y][M + 1]), l(v[y + 1][M + 1]), l(v[y + 1][M]));
        }
    }
    function l(d) {
      s.push(d.x, d.y, d.z);
    }
    function h(d, p) {
      const m = 3 * d;
      p.x = e[m + 0], p.y = e[m + 1], p.z = e[m + 2];
    }
    function c(d, p, m, g) {
      g < 0 && d.x === 1 && (a[p] = d.x - 1), m.x === 0 && m.z === 0 && (a[p] = g / 2 / Math.PI + 0.5);
    }
    function u(d) {
      return Math.atan2(d.z, -d.x);
    }
    (function(d) {
      const p = new _(), m = new _(), g = new _();
      for (let f = 0; f < t.length; f += 3)
        h(t[f + 0], p), h(t[f + 1], m), h(t[f + 2], g), o(p, m, g, d);
    })(r), function(d) {
      const p = new _();
      for (let m = 0; m < s.length; m += 3)
        p.x = s[m + 0], p.y = s[m + 1], p.z = s[m + 2], p.normalize().multiplyScalar(d), s[m + 0] = p.x, s[m + 1] = p.y, s[m + 2] = p.z;
    }(i), function() {
      const d = new _();
      for (let m = 0; m < s.length; m += 3) {
        d.x = s[m + 0], d.y = s[m + 1], d.z = s[m + 2];
        const g = u(d) / 2 / Math.PI + 0.5, f = (p = d, Math.atan2(-p.y, Math.sqrt(p.x * p.x + p.z * p.z)) / Math.PI + 0.5);
        a.push(g, 1 - f);
      }
      var p;
      (function() {
        const m = new _(), g = new _(), f = new _(), v = new _(), y = new X(), x = new X(), M = new X();
        for (let b = 0, S = 0; b < s.length; b += 9, S += 6) {
          m.set(s[b + 0], s[b + 1], s[b + 2]), g.set(s[b + 3], s[b + 4], s[b + 5]), f.set(s[b + 6], s[b + 7], s[b + 8]), y.set(a[S + 0], a[S + 1]), x.set(a[S + 2], a[S + 3]), M.set(a[S + 4], a[S + 5]), v.copy(m).add(g).add(f).divideScalar(3);
          const w = u(v);
          c(y, S + 0, m, w), c(x, S + 2, g, w), c(M, S + 4, f, w);
        }
      })(), function() {
        for (let m = 0; m < a.length; m += 6) {
          const g = a[m + 0], f = a[m + 2], v = a[m + 4], y = Math.max(g, f, v), x = Math.min(g, f, v);
          y > 0.9 && x < 0.1 && (g < 0.2 && (a[m + 0] += 1), f < 0.2 && (a[m + 2] += 1), v < 0.2 && (a[m + 4] += 1));
        }
      }();
    }(), this.setAttribute("position", new ye(s, 3)), this.setAttribute("normal", new ye(s.slice(), 3)), this.setAttribute("uv", new ye(a, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ws(e.vertices, e.indices, e.radius, e.details);
  }
}
class kd extends ws {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, r = 1 / i;
    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new kd(e.radius, e.detail);
  }
}
const Vc = new _(), Hc = new _(), qp = new _(), Gc = new ei();
class fM extends Pe {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) {
      const r = Math.pow(10, 4), s = Math.cos(ua * t), a = e.getIndex(), o = e.getAttribute("position"), l = a ? a.count : o.count, h = [0, 0, 0], c = ["a", "b", "c"], u = new Array(3), d = {}, p = [];
      for (let m = 0; m < l; m += 3) {
        a ? (h[0] = a.getX(m), h[1] = a.getX(m + 1), h[2] = a.getX(m + 2)) : (h[0] = m, h[1] = m + 1, h[2] = m + 2);
        const { a: g, b: f, c: v } = Gc;
        if (g.fromBufferAttribute(o, h[0]), f.fromBufferAttribute(o, h[1]), v.fromBufferAttribute(o, h[2]), Gc.getNormal(qp), u[0] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(g.z * r)}`, u[1] = `${Math.round(f.x * r)},${Math.round(f.y * r)},${Math.round(f.z * r)}`, u[2] = `${Math.round(v.x * r)},${Math.round(v.y * r)},${Math.round(v.z * r)}`, u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0])
          for (let y = 0; y < 3; y++) {
            const x = (y + 1) % 3, M = u[y], b = u[x], S = Gc[c[y]], w = Gc[c[x]], T = `${M}_${b}`, C = `${b}_${M}`;
            C in d && d[C] ? (qp.dot(d[C].normal) <= s && (p.push(S.x, S.y, S.z), p.push(w.x, w.y, w.z)), d[C] = null) : T in d || (d[T] = { index0: h[y], index1: h[x], normal: qp.clone() });
          }
      }
      for (const m in d)
        if (d[m]) {
          const { index0: g, index1: f } = d[m];
          Vc.fromBufferAttribute(o, g), Hc.fromBufferAttribute(o, f), p.push(Vc.x, Vc.y, Vc.z), p.push(Hc.x, Hc.y, Hc.z);
        }
      this.setAttribute("position", new ye(p, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class ls extends Go {
  constructor(e) {
    super(e), this.uuid = ri(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new Go().fromJSON(r));
    }
    return this;
  }
}
const VT = function(n, e, t = 2) {
  const i = e && e.length, r = i ? e[0] * t : n.length;
  let s = ry(n, 0, r, t, !0);
  const a = [];
  if (!s || s.next === s.prev)
    return a;
  let o, l, h, c, u, d, p;
  if (i && (s = function(m, g, f, v) {
    const y = [];
    let x, M, b, S, w;
    for (x = 0, M = g.length; x < M; x++)
      b = g[x] * v, S = x < M - 1 ? g[x + 1] * v : m.length, w = ry(m, b, S, v, !1), w === w.next && (w.steiner = !0), y.push(ZT(w));
    for (y.sort(XT), x = 0; x < y.length; x++)
      f = qT(y[x], f);
    return f;
  }(n, e, s, t)), n.length > 80 * t) {
    o = h = n[0], l = c = n[1];
    for (let m = t; m < r; m += t)
      u = n[m], d = n[m + 1], u < o && (o = u), d < l && (l = d), u > h && (h = u), d > c && (c = d);
    p = Math.max(h - o, c - l), p = p !== 0 ? 32767 / p : 0;
  }
  return fh(s, a, t, o, l, p, 0), a;
};
function ry(n, e, t, i, r) {
  let s, a;
  if (r === function(o, l, h, c) {
    let u = 0;
    for (let d = l, p = h - c; d < h; d += c)
      u += (o[p] - o[d]) * (o[d + 1] + o[p + 1]), p = d;
    return u;
  }(n, e, t, i) > 0)
    for (s = e; s < t; s += i)
      a = sy(s, n[s], n[s + 1], a);
  else
    for (s = t - i; s >= e; s -= i)
      a = sy(s, n[s], n[s + 1], a);
  return a && zd(a, a.next) && (gh(a), a = a.next), a;
}
function Ta(n, e) {
  if (!n)
    return n;
  e || (e = n);
  let t, i = n;
  do
    if (t = !1, i.steiner || !zd(i, i.next) && Et(i.prev, i, i.next) !== 0)
      i = i.next;
    else {
      if (gh(i), i = e = i.prev, i === i.next)
        break;
      t = !0;
    }
  while (t || i !== e);
  return e;
}
function fh(n, e, t, i, r, s, a) {
  if (!n)
    return;
  !a && s && function(c, u, d, p) {
    let m = c;
    do
      m.z === 0 && (m.z = Pm(m.x, m.y, u, d, p)), m.prevZ = m.prev, m.nextZ = m.next, m = m.next;
    while (m !== c);
    m.prevZ.nextZ = null, m.prevZ = null, function(g) {
      let f, v, y, x, M, b, S, w, T = 1;
      do {
        for (v = g, g = null, M = null, b = 0; v; ) {
          for (b++, y = v, S = 0, f = 0; f < T && (S++, y = y.nextZ, y); f++)
            ;
          for (w = T; S > 0 || w > 0 && y; )
            S !== 0 && (w === 0 || !y || v.z <= y.z) ? (x = v, v = v.nextZ, S--) : (x = y, y = y.nextZ, w--), M ? M.nextZ = x : g = x, x.prevZ = M, M = x;
          v = y;
        }
        M.nextZ = null, T *= 2;
      } while (b > 1);
    }(m);
  }(n, i, r, s);
  let o, l, h = n;
  for (; n.prev !== n.next; )
    if (o = n.prev, l = n.next, s ? GT(n, i, r, s) : HT(n))
      e.push(o.i / t | 0), e.push(n.i / t | 0), e.push(l.i / t | 0), gh(n), n = l.next, h = l.next;
    else if ((n = l) === h) {
      a ? a === 1 ? fh(n = jT(Ta(n), e, t), e, t, i, r, s, 2) : a === 2 && WT(n, e, t, i, r, s) : fh(Ta(n), e, t, i, r, s, 1);
      break;
    }
}
function HT(n) {
  const e = n.prev, t = n, i = n.next;
  if (Et(e, t, i) >= 0)
    return !1;
  const r = e.x, s = t.x, a = i.x, o = e.y, l = t.y, h = i.y, c = r < s ? r < a ? r : a : s < a ? s : a, u = o < l ? o < h ? o : h : l < h ? l : h, d = r > s ? r > a ? r : a : s > a ? s : a, p = o > l ? o > h ? o : h : l > h ? l : h;
  let m = i.next;
  for (; m !== e; ) {
    if (m.x >= c && m.x <= d && m.y >= u && m.y <= p && ho(r, o, s, l, a, h, m.x, m.y) && Et(m.prev, m, m.next) >= 0)
      return !1;
    m = m.next;
  }
  return !0;
}
function GT(n, e, t, i) {
  const r = n.prev, s = n, a = n.next;
  if (Et(r, s, a) >= 0)
    return !1;
  const o = r.x, l = s.x, h = a.x, c = r.y, u = s.y, d = a.y, p = o < l ? o < h ? o : h : l < h ? l : h, m = c < u ? c < d ? c : d : u < d ? u : d, g = o > l ? o > h ? o : h : l > h ? l : h, f = c > u ? c > d ? c : d : u > d ? u : d, v = Pm(p, m, e, t, i), y = Pm(g, f, e, t, i);
  let x = n.prevZ, M = n.nextZ;
  for (; x && x.z >= v && M && M.z <= y; ) {
    if (x.x >= p && x.x <= g && x.y >= m && x.y <= f && x !== r && x !== a && ho(o, c, l, u, h, d, x.x, x.y) && Et(x.prev, x, x.next) >= 0 || (x = x.prevZ, M.x >= p && M.x <= g && M.y >= m && M.y <= f && M !== r && M !== a && ho(o, c, l, u, h, d, M.x, M.y) && Et(M.prev, M, M.next) >= 0))
      return !1;
    M = M.nextZ;
  }
  for (; x && x.z >= v; ) {
    if (x.x >= p && x.x <= g && x.y >= m && x.y <= f && x !== r && x !== a && ho(o, c, l, u, h, d, x.x, x.y) && Et(x.prev, x, x.next) >= 0)
      return !1;
    x = x.prevZ;
  }
  for (; M && M.z <= y; ) {
    if (M.x >= p && M.x <= g && M.y >= m && M.y <= f && M !== r && M !== a && ho(o, c, l, u, h, d, M.x, M.y) && Et(M.prev, M, M.next) >= 0)
      return !1;
    M = M.nextZ;
  }
  return !0;
}
function jT(n, e, t) {
  let i = n;
  do {
    const r = i.prev, s = i.next.next;
    !zd(r, s) && mM(r, i, i.next, s) && mh(r, s) && mh(s, r) && (e.push(r.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), gh(i), gh(i.next), i = n = s), i = i.next;
  } while (i !== n);
  return Ta(i);
}
function WT(n, e, t, i, r, s) {
  let a = n;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && KT(a, o)) {
        let l = gM(a, o);
        return a = Ta(a, a.next), l = Ta(l, l.next), fh(a, e, t, i, r, s, 0), void fh(l, e, t, i, r, s, 0);
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== n);
}
function XT(n, e) {
  return n.x - e.x;
}
function qT(n, e) {
  const t = function(r, s) {
    let a, o = s, l = -1 / 0;
    const h = r.x, c = r.y;
    do {
      if (c <= o.y && c >= o.next.y && o.next.y !== o.y) {
        const f = o.x + (c - o.y) * (o.next.x - o.x) / (o.next.y - o.y);
        if (f <= h && f > l && (l = f, a = o.x < o.next.x ? o : o.next, f === h))
          return a;
      }
      o = o.next;
    } while (o !== s);
    if (!a)
      return null;
    const u = a, d = a.x, p = a.y;
    let m, g = 1 / 0;
    o = a;
    do
      h >= o.x && o.x >= d && h !== o.x && ho(c < p ? h : l, c, d, p, c < p ? l : h, c, o.x, o.y) && (m = Math.abs(c - o.y) / (h - o.x), mh(o, r) && (m < g || m === g && (o.x > a.x || o.x === a.x && YT(a, o))) && (a = o, g = m)), o = o.next;
    while (o !== u);
    return a;
  }(n, e);
  if (!t)
    return e;
  const i = gM(t, n);
  return Ta(i, i.next), Ta(t, t.next);
}
function YT(n, e) {
  return Et(n.prev, n, e.prev) < 0 && Et(e.next, n, n.next) < 0;
}
function Pm(n, e, t, i, r) {
  return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - t) * r | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - i) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
}
function ZT(n) {
  let e = n, t = n;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== n);
  return t;
}
function ho(n, e, t, i, r, s, a, o) {
  return (r - a) * (e - o) >= (n - a) * (s - o) && (n - a) * (i - o) >= (t - a) * (e - o) && (t - a) * (s - o) >= (r - a) * (i - o);
}
function KT(n, e) {
  return n.next.i !== e.i && n.prev.i !== e.i && !function(t, i) {
    let r = t;
    do {
      if (r.i !== t.i && r.next.i !== t.i && r.i !== i.i && r.next.i !== i.i && mM(r, r.next, t, i))
        return !0;
      r = r.next;
    } while (r !== t);
    return !1;
  }(n, e) && (mh(n, e) && mh(e, n) && function(t, i) {
    let r = t, s = !1;
    const a = (t.x + i.x) / 2, o = (t.y + i.y) / 2;
    do
      r.y > o != r.next.y > o && r.next.y !== r.y && a < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (s = !s), r = r.next;
    while (r !== t);
    return s;
  }(n, e) && (Et(n.prev, n, e.prev) || Et(n, e.prev, e)) || zd(n, e) && Et(n.prev, n, n.next) > 0 && Et(e.prev, e, e.next) > 0);
}
function Et(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function zd(n, e) {
  return n.x === e.x && n.y === e.y;
}
function mM(n, e, t, i) {
  const r = Wc(Et(n, e, t)), s = Wc(Et(n, e, i)), a = Wc(Et(t, i, n)), o = Wc(Et(t, i, e));
  return r !== s && a !== o || !(r !== 0 || !jc(n, t, e)) || !(s !== 0 || !jc(n, i, e)) || !(a !== 0 || !jc(t, n, i)) || !(o !== 0 || !jc(t, e, i));
}
function jc(n, e, t) {
  return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y);
}
function Wc(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function mh(n, e) {
  return Et(n.prev, n, n.next) < 0 ? Et(n, e, n.next) >= 0 && Et(n, n.prev, e) >= 0 : Et(n, e, n.prev) < 0 || Et(n, n.next, e) < 0;
}
function gM(n, e) {
  const t = new Rm(n.i, n.x, n.y), i = new Rm(e.i, e.x, e.y), r = n.next, s = e.prev;
  return n.next = e, e.prev = n, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i;
}
function sy(n, e, t, i) {
  const r = new Rm(n, e, t);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function gh(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function Rm(n, e, t) {
  this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
class Di {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return 0.5 * i;
  }
  static isClockWise(e) {
    return Di.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [], r = [], s = [];
    ay(e), oy(i, e);
    let a = e.length;
    t.forEach(ay);
    for (let l = 0; l < t.length; l++)
      r.push(a), a += t[l].length, oy(i, t[l]);
    const o = VT(i, r);
    for (let l = 0; l < o.length; l += 3)
      s.push(o.slice(l, l + 3));
    return s;
  }
}
function ay(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function oy(n, e) {
  for (let t = 0; t < e.length; t++)
    n.push(e[t].x), n.push(e[t].y);
}
class Ia extends Pe {
  constructor(e = new ls([new X(0.5, 0.5), new X(-0.5, 0.5), new X(-0.5, -0.5), new X(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e];
    const i = this, r = [], s = [];
    for (let o = 0, l = e.length; o < l; o++)
      a(e[o]);
    function a(o) {
      const l = [], h = t.curveSegments !== void 0 ? t.curveSegments : 12, c = t.steps !== void 0 ? t.steps : 1, u = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled === void 0 || t.bevelEnabled, p = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, m = t.bevelSize !== void 0 ? t.bevelSize : p - 0.1, g = t.bevelOffset !== void 0 ? t.bevelOffset : 0, f = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const v = t.extrudePath, y = t.UVGenerator !== void 0 ? t.UVGenerator : JT;
      let x, M, b, S, w, T = !1;
      v && (x = v.getSpacedPoints(c), T = !0, d = !1, M = v.computeFrenetFrames(c, !1), b = new _(), S = new _(), w = new _()), d || (f = 0, p = 0, m = 0, g = 0);
      const C = o.extractPoints(h);
      let I = C.shape;
      const A = C.holes;
      if (!Di.isClockWise(I)) {
        I = I.reverse();
        for (let O = 0, k = A.length; O < k; O++) {
          const E = A[O];
          Di.isClockWise(E) && (A[O] = E.reverse());
        }
      }
      const L = Di.triangulateShape(I, A), D = I;
      for (let O = 0, k = A.length; O < k; O++) {
        const E = A[O];
        I = I.concat(E);
      }
      function U(O, k, E) {
        return O.clone().addScaledVector(k, E);
      }
      const H = I.length, Z = L.length;
      function te(O, k, E) {
        let B, F, re;
        const V = O.x - k.x, se = O.y - k.y, Me = E.x - O.x, ue = E.y - O.y, z = V * V + se * se, W = V * ue - se * Me;
        if (Math.abs(W) > Number.EPSILON) {
          const ee = Math.sqrt(z), ge = Math.sqrt(Me * Me + ue * ue), Le = k.x - se / ee, Fe = k.y + V / ee, _e = ((E.x - ue / ge - Le) * ue - (E.y + Me / ge - Fe) * Me) / (V * ue - se * Me);
          B = Le + V * _e - O.x, F = Fe + se * _e - O.y;
          const Be = B * B + F * F;
          if (Be <= 2)
            return new X(B, F);
          re = Math.sqrt(Be / 2);
        } else {
          let ee = !1;
          V > Number.EPSILON ? Me > Number.EPSILON && (ee = !0) : V < -Number.EPSILON ? Me < -Number.EPSILON && (ee = !0) : Math.sign(se) === Math.sign(ue) && (ee = !0), ee ? (B = -se, F = V, re = Math.sqrt(z)) : (B = V, F = se, re = Math.sqrt(z / 2));
        }
        return new X(B / re, F / re);
      }
      const ne = [];
      for (let O = 0, k = D.length, E = k - 1, B = O + 1; O < k; O++, E++, B++)
        E === k && (E = 0), B === k && (B = 0), ne[O] = te(D[O], D[E], D[B]);
      const ve = [];
      let Se, Q = ne.concat();
      for (let O = 0, k = A.length; O < k; O++) {
        const E = A[O];
        Se = [];
        for (let B = 0, F = E.length, re = F - 1, V = B + 1; B < F; B++, re++, V++)
          re === F && (re = 0), V === F && (V = 0), Se[B] = te(E[B], E[re], E[V]);
        ve.push(Se), Q = Q.concat(Se);
      }
      for (let O = 0; O < f; O++) {
        const k = O / f, E = p * Math.cos(k * Math.PI / 2), B = m * Math.sin(k * Math.PI / 2) + g;
        for (let F = 0, re = D.length; F < re; F++) {
          const V = U(D[F], ne[F], B);
          ie(V.x, V.y, -E);
        }
        for (let F = 0, re = A.length; F < re; F++) {
          const V = A[F];
          Se = ve[F];
          for (let se = 0, Me = V.length; se < Me; se++) {
            const ue = U(V[se], Se[se], B);
            ie(ue.x, ue.y, -E);
          }
        }
      }
      const ae = m + g;
      for (let O = 0; O < H; O++) {
        const k = d ? U(I[O], Q[O], ae) : I[O];
        T ? (S.copy(M.normals[0]).multiplyScalar(k.x), b.copy(M.binormals[0]).multiplyScalar(k.y), w.copy(x[0]).add(S).add(b), ie(w.x, w.y, w.z)) : ie(k.x, k.y, 0);
      }
      for (let O = 1; O <= c; O++)
        for (let k = 0; k < H; k++) {
          const E = d ? U(I[k], Q[k], ae) : I[k];
          T ? (S.copy(M.normals[O]).multiplyScalar(E.x), b.copy(M.binormals[O]).multiplyScalar(E.y), w.copy(x[O]).add(S).add(b), ie(w.x, w.y, w.z)) : ie(E.x, E.y, u / c * O);
        }
      for (let O = f - 1; O >= 0; O--) {
        const k = O / f, E = p * Math.cos(k * Math.PI / 2), B = m * Math.sin(k * Math.PI / 2) + g;
        for (let F = 0, re = D.length; F < re; F++) {
          const V = U(D[F], ne[F], B);
          ie(V.x, V.y, u + E);
        }
        for (let F = 0, re = A.length; F < re; F++) {
          const V = A[F];
          Se = ve[F];
          for (let se = 0, Me = V.length; se < Me; se++) {
            const ue = U(V[se], Se[se], B);
            T ? ie(ue.x, ue.y + x[c - 1].y, x[c - 1].x + E) : ie(ue.x, ue.y, u + E);
          }
        }
      }
      function de(O, k) {
        let E = O.length;
        for (; --E >= 0; ) {
          const B = E;
          let F = E - 1;
          F < 0 && (F = O.length - 1);
          for (let re = 0, V = c + 2 * f; re < V; re++) {
            const se = H * re, Me = H * (re + 1);
            R(k + B + se, k + F + se, k + F + Me, k + B + Me);
          }
        }
      }
      function ie(O, k, E) {
        l.push(O), l.push(k), l.push(E);
      }
      function N(O, k, E) {
        j(O), j(k), j(E);
        const B = r.length / 3, F = y.generateTopUV(i, r, B - 3, B - 2, B - 1);
        K(F[0]), K(F[1]), K(F[2]);
      }
      function R(O, k, E, B) {
        j(O), j(k), j(B), j(k), j(E), j(B);
        const F = r.length / 3, re = y.generateSideWallUV(i, r, F - 6, F - 3, F - 2, F - 1);
        K(re[0]), K(re[1]), K(re[3]), K(re[1]), K(re[2]), K(re[3]);
      }
      function j(O) {
        r.push(l[3 * O + 0]), r.push(l[3 * O + 1]), r.push(l[3 * O + 2]);
      }
      function K(O) {
        s.push(O.x), s.push(O.y);
      }
      (function() {
        const O = r.length / 3;
        if (d) {
          let k = 0, E = H * k;
          for (let B = 0; B < Z; B++) {
            const F = L[B];
            N(F[2] + E, F[1] + E, F[0] + E);
          }
          k = c + 2 * f, E = H * k;
          for (let B = 0; B < Z; B++) {
            const F = L[B];
            N(F[0] + E, F[1] + E, F[2] + E);
          }
        } else {
          for (let k = 0; k < Z; k++) {
            const E = L[k];
            N(E[2], E[1], E[0]);
          }
          for (let k = 0; k < Z; k++) {
            const E = L[k];
            N(E[0] + H * c, E[1] + H * c, E[2] + H * c);
          }
        }
        i.addGroup(O, r.length / 3 - O, 0);
      })(), function() {
        const O = r.length / 3;
        let k = 0;
        de(D, k), k += D.length;
        for (let E = 0, B = A.length; E < B; E++) {
          const F = A[E];
          de(F, k), k += F.length;
        }
        i.addGroup(O, r.length / 3 - O, 1);
      }();
    }
    this.setAttribute("position", new ye(r, 3)), this.setAttribute("uv", new ye(s, 2)), this.computeVertexNormals();
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return function(t, i, r) {
      if (r.shapes = [], Array.isArray(t))
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s];
          r.shapes.push(o.uuid);
        }
      else
        r.shapes.push(t.uuid);
      return r.options = Object.assign({}, i), i.extrudePath !== void 0 && (r.options.extrudePath = i.extrudePath.toJSON()), r;
    }(this.parameters.shapes, this.parameters.options, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, a = e.shapes.length; s < a; s++) {
      const o = t[e.shapes[s]];
      i.push(o);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new qu[r.type]().fromJSON(r)), new Ia(i, e.options);
  }
}
const JT = { generateTopUV: function(n, e, t, i, r) {
  const s = e[3 * t], a = e[3 * t + 1], o = e[3 * i], l = e[3 * i + 1], h = e[3 * r], c = e[3 * r + 1];
  return [new X(s, a), new X(o, l), new X(h, c)];
}, generateSideWallUV: function(n, e, t, i, r, s) {
  const a = e[3 * t], o = e[3 * t + 1], l = e[3 * t + 2], h = e[3 * i], c = e[3 * i + 1], u = e[3 * i + 2], d = e[3 * r], p = e[3 * r + 1], m = e[3 * r + 2], g = e[3 * s], f = e[3 * s + 1], v = e[3 * s + 2];
  return Math.abs(o - c) < Math.abs(a - h) ? [new X(a, 1 - l), new X(h, 1 - u), new X(d, 1 - m), new X(g, 1 - v)] : [new X(o, 1 - l), new X(c, 1 - u), new X(p, 1 - m), new X(f, 1 - v)];
} };
class Vd extends ws {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2;
    super([-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new Vd(e.radius, e.detail);
  }
}
class wr extends ws {
  constructor(e = 1, t = 0) {
    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new wr(e.radius, e.detail);
  }
}
class Jh extends Pe {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, a = 2 * Math.PI) {
    super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: r, thetaStart: s, thetaLength: a }, i = Math.max(3, i);
    const o = [], l = [], h = [], c = [];
    let u = e;
    const d = (t - e) / (r = Math.max(1, r)), p = new _(), m = new X();
    for (let g = 0; g <= r; g++) {
      for (let f = 0; f <= i; f++) {
        const v = s + f / i * a;
        p.x = u * Math.cos(v), p.y = u * Math.sin(v), l.push(p.x, p.y, p.z), h.push(0, 0, 1), m.x = (p.x / t + 1) / 2, m.y = (p.y / t + 1) / 2, c.push(m.x, m.y);
      }
      u += d;
    }
    for (let g = 0; g < r; g++) {
      const f = g * (i + 1);
      for (let v = 0; v < i; v++) {
        const y = v + f, x = y, M = y + i + 1, b = y + i + 2, S = y + 1;
        o.push(x, M, S), o.push(M, b, S);
      }
    }
    this.setIndex(o), this.setAttribute("position", new ye(l, 3)), this.setAttribute("normal", new ye(h, 3)), this.setAttribute("uv", new ye(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Jh(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class Hd extends Pe {
  constructor(e = new ls([new X(0, 0.5), new X(-0.5, -0.5), new X(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t };
    const i = [], r = [], s = [], a = [];
    let o = 0, l = 0;
    if (Array.isArray(e) === !1)
      h(e);
    else
      for (let c = 0; c < e.length; c++)
        h(e[c]), this.addGroup(o, l, c), o += l, l = 0;
    function h(c) {
      const u = r.length / 3, d = c.extractPoints(t);
      let p = d.shape;
      const m = d.holes;
      Di.isClockWise(p) === !1 && (p = p.reverse());
      for (let f = 0, v = m.length; f < v; f++) {
        const y = m[f];
        Di.isClockWise(y) === !0 && (m[f] = y.reverse());
      }
      const g = Di.triangulateShape(p, m);
      for (let f = 0, v = m.length; f < v; f++) {
        const y = m[f];
        p = p.concat(y);
      }
      for (let f = 0, v = p.length; f < v; f++) {
        const y = p[f];
        r.push(y.x, y.y, 0), s.push(0, 0, 1), a.push(y.x, y.y);
      }
      for (let f = 0, v = g.length; f < v; f++) {
        const y = g[f], x = y[0] + u, M = y[1] + u, b = y[2] + u;
        i.push(x, M, b), l += 3;
      }
    }
    this.setIndex(i), this.setAttribute("position", new ye(r, 3)), this.setAttribute("normal", new ye(s, 3)), this.setAttribute("uv", new ye(a, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return function(t, i) {
      if (i.shapes = [], Array.isArray(t))
        for (let r = 0, s = t.length; r < s; r++) {
          const a = t[r];
          i.shapes.push(a.uuid);
        }
      else
        i.shapes.push(t.uuid);
      return i;
    }(this.parameters.shapes, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const a = t[e.shapes[r]];
      i.push(a);
    }
    return new Hd(i, e.curveSegments);
  }
}
class Ea extends Pe {
  constructor(e = 1, t = 32, i = 16, r = 0, s = 2 * Math.PI, a = 0, o = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: r, phiLength: s, thetaStart: a, thetaLength: o }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
    const l = Math.min(a + o, Math.PI);
    let h = 0;
    const c = [], u = new _(), d = new _(), p = [], m = [], g = [], f = [];
    for (let v = 0; v <= i; v++) {
      const y = [], x = v / i;
      let M = 0;
      v === 0 && a === 0 ? M = 0.5 / t : v === i && l === Math.PI && (M = -0.5 / t);
      for (let b = 0; b <= t; b++) {
        const S = b / t;
        u.x = -e * Math.cos(r + S * s) * Math.sin(a + x * o), u.y = e * Math.cos(a + x * o), u.z = e * Math.sin(r + S * s) * Math.sin(a + x * o), m.push(u.x, u.y, u.z), d.copy(u).normalize(), g.push(d.x, d.y, d.z), f.push(S + M, 1 - x), y.push(h++);
      }
      c.push(y);
    }
    for (let v = 0; v < i; v++)
      for (let y = 0; y < t; y++) {
        const x = c[v][y + 1], M = c[v][y], b = c[v + 1][y], S = c[v + 1][y + 1];
        (v !== 0 || a > 0) && p.push(x, M, S), (v !== i - 1 || l < Math.PI) && p.push(M, b, S);
      }
    this.setIndex(p), this.setAttribute("position", new ye(m, 3)), this.setAttribute("normal", new ye(g, 3)), this.setAttribute("uv", new ye(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ea(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Gd extends ws {
  constructor(e = 1, t = 0) {
    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new Gd(e.radius, e.detail);
  }
}
class Ki extends Pe {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = 2 * Math.PI) {
    super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: r, arc: s }, i = Math.floor(i), r = Math.floor(r);
    const a = [], o = [], l = [], h = [], c = new _(), u = new _(), d = new _();
    for (let p = 0; p <= i; p++)
      for (let m = 0; m <= r; m++) {
        const g = m / r * s, f = p / i * Math.PI * 2;
        u.x = (e + t * Math.cos(f)) * Math.cos(g), u.y = (e + t * Math.cos(f)) * Math.sin(g), u.z = t * Math.sin(f), o.push(u.x, u.y, u.z), c.x = e * Math.cos(g), c.y = e * Math.sin(g), d.subVectors(u, c).normalize(), l.push(d.x, d.y, d.z), h.push(m / r), h.push(p / i);
      }
    for (let p = 1; p <= i; p++)
      for (let m = 1; m <= r; m++) {
        const g = (r + 1) * p + m - 1, f = (r + 1) * (p - 1) + m - 1, v = (r + 1) * (p - 1) + m, y = (r + 1) * p + m;
        a.push(g, f, y), a.push(f, v, y);
      }
    this.setIndex(a), this.setAttribute("position", new ye(o, 3)), this.setAttribute("normal", new ye(l, 3)), this.setAttribute("uv", new ye(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ki(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class jd extends Pe {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, a = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: r, p: s, q: a }, i = Math.floor(i), r = Math.floor(r);
    const o = [], l = [], h = [], c = [], u = new _(), d = new _(), p = new _(), m = new _(), g = new _(), f = new _(), v = new _();
    for (let x = 0; x <= i; ++x) {
      const M = x / i * s * Math.PI * 2;
      y(M, s, a, e, p), y(M + 0.01, s, a, e, m), f.subVectors(m, p), v.addVectors(m, p), g.crossVectors(f, v), v.crossVectors(g, f), g.normalize(), v.normalize();
      for (let b = 0; b <= r; ++b) {
        const S = b / r * Math.PI * 2, w = -t * Math.cos(S), T = t * Math.sin(S);
        u.x = p.x + (w * v.x + T * g.x), u.y = p.y + (w * v.y + T * g.y), u.z = p.z + (w * v.z + T * g.z), l.push(u.x, u.y, u.z), d.subVectors(u, p).normalize(), h.push(d.x, d.y, d.z), c.push(x / i), c.push(b / r);
      }
    }
    for (let x = 1; x <= i; x++)
      for (let M = 1; M <= r; M++) {
        const b = (r + 1) * (x - 1) + (M - 1), S = (r + 1) * x + (M - 1), w = (r + 1) * x + M, T = (r + 1) * (x - 1) + M;
        o.push(b, S, T), o.push(S, w, T);
      }
    function y(x, M, b, S, w) {
      const T = Math.cos(x), C = Math.sin(x), I = b / M * x, A = Math.cos(I);
      w.x = S * (2 + A) * 0.5 * T, w.y = S * (2 + A) * C * 0.5, w.z = S * Math.sin(I) * 0.5;
    }
    this.setIndex(o), this.setAttribute("position", new ye(l, 3)), this.setAttribute("normal", new ye(h, 3)), this.setAttribute("uv", new ye(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new jd(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Pr extends Pe {
  constructor(e = new Og(new _(-1, -1, 0), new _(-1, 1, 0), new _(1, 1, 0)), t = 64, i = 1, r = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: r, closed: s };
    const a = e.computeFrenetFrames(t, s);
    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
    const o = new _(), l = new _(), h = new X();
    let c = new _();
    const u = [], d = [], p = [], m = [];
    function g(f) {
      c = e.getPointAt(f / t, c);
      const v = a.normals[f], y = a.binormals[f];
      for (let x = 0; x <= r; x++) {
        const M = x / r * Math.PI * 2, b = Math.sin(M), S = -Math.cos(M);
        l.x = S * v.x + b * y.x, l.y = S * v.y + b * y.y, l.z = S * v.z + b * y.z, l.normalize(), d.push(l.x, l.y, l.z), o.x = c.x + i * l.x, o.y = c.y + i * l.y, o.z = c.z + i * l.z, u.push(o.x, o.y, o.z);
      }
    }
    (function() {
      for (let f = 0; f < t; f++)
        g(f);
      g(s === !1 ? t : 0), function() {
        for (let f = 0; f <= t; f++)
          for (let v = 0; v <= r; v++)
            h.x = f / t, h.y = v / r, p.push(h.x, h.y);
      }(), function() {
        for (let f = 1; f <= t; f++)
          for (let v = 1; v <= r; v++) {
            const y = (r + 1) * (f - 1) + (v - 1), x = (r + 1) * f + (v - 1), M = (r + 1) * f + v, b = (r + 1) * (f - 1) + v;
            m.push(y, x, b), m.push(x, M, b);
          }
      }();
    })(), this.setIndex(m), this.setAttribute("position", new ye(u, 3)), this.setAttribute("normal", new ye(d, 3)), this.setAttribute("uv", new ye(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new Pr(new qu[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
  }
}
class Fg extends Pe {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) {
      const t = [], i = /* @__PURE__ */ new Set(), r = new _(), s = new _();
      if (e.index !== null) {
        const a = e.attributes.position, o = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let h = 0, c = l.length; h < c; ++h) {
          const u = l[h], d = u.start;
          for (let p = d, m = d + u.count; p < m; p += 3)
            for (let g = 0; g < 3; g++) {
              const f = o.getX(p + g), v = o.getX(p + (g + 1) % 3);
              r.fromBufferAttribute(a, f), s.fromBufferAttribute(a, v), ly(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let o = 0, l = a.count / 3; o < l; o++)
          for (let h = 0; h < 3; h++) {
            const c = 3 * o + h, u = 3 * o + (h + 1) % 3;
            r.fromBufferAttribute(a, c), s.fromBufferAttribute(a, u), ly(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new ye(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function ly(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) !== !0 && t.has(r) !== !0 && (t.add(i), t.add(r), !0);
}
var hy = Object.freeze({ __proto__: null, BoxGeometry: _t, CapsuleGeometry: Yh, CircleGeometry: Zh, ConeGeometry: Kh, CylinderGeometry: Pt, DodecahedronGeometry: kd, EdgesGeometry: fM, ExtrudeGeometry: Ia, IcosahedronGeometry: Vd, LatheGeometry: qh, OctahedronGeometry: wr, PlaneGeometry: or, PolyhedronGeometry: ws, RingGeometry: Jh, ShapeGeometry: Hd, SphereGeometry: Ea, TetrahedronGeometry: Gd, TorusGeometry: Ki, TorusKnotGeometry: jd, TubeGeometry: Pr, WireframeGeometry: Fg });
class vM extends Xt {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new oe(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class Bg extends tt {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class jo extends Xt {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new oe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new gt(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class ai extends jo {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new X(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      return Rt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, set: function(t) {
      this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
    } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new oe(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new oe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new oe(1, 1, 1), this.specularColorMap = null, this.xe = 0, this.ye = 0, this.Se = 0, this.be = 0, this.Ae = 0, this.Ee = 0, this.setValues(e);
  }
  get anisotropy() {
    return this.xe;
  }
  set anisotropy(e) {
    this.xe > 0 != e > 0 && this.version++, this.xe = e;
  }
  get clearcoat() {
    return this.ye;
  }
  set clearcoat(e) {
    this.ye > 0 != e > 0 && this.version++, this.ye = e;
  }
  get iridescence() {
    return this.be;
  }
  set iridescence(e) {
    this.be > 0 != e > 0 && this.version++, this.be = e;
  }
  get dispersion() {
    return this.Se;
  }
  set dispersion(e) {
    this.Se > 0 != e > 0 && this.version++, this.Se = e;
  }
  get sheen() {
    return this.Ae;
  }
  set sheen(e) {
    this.Ae > 0 != e > 0 && this.version++, this.Ae = e;
  }
  get transmission() {
    return this.Ee;
  }
  set transmission(e) {
    this.Ee > 0 != e > 0 && this.version++, this.Ee = e;
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class Aa extends Xt {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new oe(16777215), this.specular = new oe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new gt(), this.combine = Hh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class kg extends Xt {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new oe(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class Wd extends Xt {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class Xd extends Xt {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new oe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new gt(), this.combine = Hh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class yM extends Xt {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new oe(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new X(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class xM extends kt {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function la(n, e, t) {
  return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n);
}
function MM(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function bM(n) {
  const e = n.length, t = new Array(e);
  for (let i = 0; i !== e; ++i)
    t[i] = i;
  return t.sort(function(i, r) {
    return n[i] - n[r];
  }), t;
}
function Im(n, e, t) {
  const i = n.length, r = new n.constructor(i);
  for (let s = 0, a = 0; a !== i; ++s) {
    const o = t[s] * e;
    for (let l = 0; l !== e; ++l)
      r[a++] = n[o + l];
  }
  return r;
}
function zg(n, e, t, i) {
  let r = 1, s = n[0];
  for (; s !== void 0 && s[i] === void 0; )
    s = n[r++];
  if (s === void 0)
    return;
  let a = s[i];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        a = s[i], a !== void 0 && (e.push(s.time), t.push.apply(t, a)), s = n[r++];
      while (s !== void 0);
    else if (a.toArray !== void 0)
      do
        a = s[i], a !== void 0 && (e.push(s.time), a.toArray(t, t.length)), s = n[r++];
      while (s !== void 0);
    else
      do
        a = s[i], a !== void 0 && (e.push(s.time), t.push(a)), s = n[r++];
      while (s !== void 0);
}
const QT = { convertArray: la, isTypedArray: MM, getKeyframeOrder: bM, sortedArray: Im, flattenJSON: zg, subclip: function(n, e, t, i, r = 30) {
  const s = n.clone();
  s.name = e;
  const a = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const h = s.tracks[l], c = h.getValueSize(), u = [], d = [];
    for (let p = 0; p < h.times.length; ++p) {
      const m = h.times[p] * r;
      if (!(m < t || m >= i)) {
        u.push(h.times[p]);
        for (let g = 0; g < c; ++g)
          d.push(h.values[p * c + g]);
      }
    }
    u.length !== 0 && (h.times = la(u, h.times.constructor), h.values = la(d, h.values.constructor), a.push(h));
  }
  s.tracks = a;
  let o = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l)
    s.tracks[l].shift(-1 * o);
  return s.resetDuration(), s;
}, makeClipAdditive: function(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length, s = e / i;
  for (let a = 0; a < r; ++a) {
    const o = t.tracks[a], l = o.ValueTypeName;
    if (l === "bool" || l === "string")
      continue;
    const h = n.tracks.find(function(v) {
      return v.name === o.name && v.ValueTypeName === l;
    });
    if (h === void 0)
      continue;
    let c = 0;
    const u = o.getValueSize();
    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
    let d = 0;
    const p = h.getValueSize();
    h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = p / 3);
    const m = o.times.length - 1;
    let g;
    if (s <= o.times[0]) {
      const v = c, y = u - c;
      g = o.values.slice(v, y);
    } else if (s >= o.times[m]) {
      const v = m * u + c, y = v + u - c;
      g = o.values.slice(v, y);
    } else {
      const v = o.createInterpolant(), y = c, x = u - c;
      v.evaluate(s), g = v.resultBuffer.slice(y, x);
    }
    l === "quaternion" && new Ye().fromArray(g).normalize().conjugate().toArray(g);
    const f = h.times.length;
    for (let v = 0; v < f; ++v) {
      const y = v * p + d;
      if (l === "quaternion")
        Ye.multiplyQuaternionsFlat(h.values, y, g, 0, h.values, y);
      else {
        const x = p - 2 * d;
        for (let M = 0; M < x; ++M)
          h.values[y + M] -= g[M];
      }
    }
  }
  return n.blendMode = Tg, n;
} };
class tl {
  constructor(e, t, i, r) {
    this.parameterPositions = e, this.Te = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this.Te, r = t[i], s = t[i - 1];
    e: {
      t: {
        let a;
        n: {
          i:
            if (!(e < r)) {
              for (let o = i + 2; ; ) {
                if (r === void 0) {
                  if (e < s)
                    break i;
                  return i = t.length, this.Te = i, this.copySampleValue_(i - 1);
                }
                if (i === o)
                  break;
                if (s = r, r = t[++i], e < r)
                  break t;
              }
              a = t.length;
              break n;
            }
          if (e >= s)
            break e;
          {
            const o = t[1];
            e < o && (i = 2, s = o);
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return this.Te = 0, this.copySampleValue_(0);
              if (i === l)
                break;
              if (r = s, s = t[--i - 1], e >= s)
                break t;
            }
            a = i, i = 0;
          }
        }
        for (; i < a; ) {
          const o = i + a >>> 1;
          e < t[o] ? a = o : i = o + 1;
        }
        if (r = t[i], s = t[i - 1], s === void 0)
          return this.Te = 0, this.copySampleValue_(0);
        if (r === void 0)
          return i = t.length, this.Te = i, this.copySampleValue_(i - 1);
      }
      this.Te = i, this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r;
    for (let a = 0; a !== r; ++a)
      t[a] = i[s + a];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class SM extends tl {
  constructor(e, t, i, r) {
    super(e, t, i, r), this.Ce = -0, this.Pe = -0, this.Le = -0, this.Ne = -0, this.DefaultSettings_ = { endingStart: aa, endingEnd: aa };
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2, a = e + 1, o = r[s], l = r[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case oa:
          s = e, o = 2 * t - i;
          break;
        case ah:
          s = r.length - 2, o = t + r[s] - r[s + 1];
          break;
        default:
          s = e, o = i;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case oa:
          a = e, l = 2 * i - t;
          break;
        case ah:
          a = 1, l = i + r[1] - r[0];
          break;
        default:
          a = e - 1, l = t;
      }
    const h = 0.5 * (i - t), c = this.valueSize;
    this.Ce = h / (t - o), this.Le = h / (l - i), this.Pe = s * c, this.Ne = a * c;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, h = l - o, c = this.Pe, u = this.Ne, d = this.Ce, p = this.Le, m = (i - t) / (r - t), g = m * m, f = g * m, v = -d * f + 2 * d * g - d * m, y = (1 + d) * f + (-1.5 - 2 * d) * g + (-0.5 + d) * m + 1, x = (-1 - p) * f + (1.5 + p) * g + 0.5 * m, M = p * f - p * g;
    for (let b = 0; b !== o; ++b)
      s[b] = v * a[c + b] + y * a[h + b] + x * a[l + b] + M * a[u + b];
    return s;
  }
}
class Vg extends tl {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, h = l - o, c = (i - t) / (r - t), u = 1 - c;
    for (let d = 0; d !== o; ++d)
      s[d] = a[h + d] * u + a[l + d] * c;
    return s;
  }
}
class wM extends tl {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Oi {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = la(t, this.TimeBufferType), this.values = la(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON)
      i = t.toJSON(e);
    else {
      i = { name: e.name, times: la(e.times, Array), values: la(e.values, Array) };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return i.type = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new wM(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new Vg(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new SM(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Oo:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Uo:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Ru:
        t = this.InterpolantFactoryMethodSmooth;
    }
    if (t === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (e === this.DefaultInterpolation)
          throw new Error(i);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Oo;
      case this.InterpolantFactoryMethodLinear:
        return Uo;
      case this.InterpolantFactoryMethodSmooth:
        return Ru;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i)
        t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i)
        t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times, r = i.length;
    let s = 0, a = r - 1;
    for (; s !== r && i[s] < e; )
      ++s;
    for (; a !== -1 && i[a] > t; )
      --a;
    if (++a, s !== 0 || a !== r) {
      s >= a && (a = Math.max(a, 1), s = a - 1);
      const o = this.getValueSize();
      this.times = i.slice(s, a), this.values = this.values.slice(s * o, a * o);
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) != 0 && (e = !1);
    const i = this.times, r = this.values, s = i.length;
    s === 0 && (e = !1);
    let a = null;
    for (let o = 0; o !== s; o++) {
      const l = i[o];
      if (typeof l == "number" && isNaN(l)) {
        e = !1;
        break;
      }
      if (a !== null && a > l) {
        e = !1;
        break;
      }
      a = l;
    }
    if (r !== void 0 && MM(r))
      for (let o = 0, l = r.length; o !== l; ++o) {
        const h = r[o];
        if (isNaN(h)) {
          e = !1;
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), r = this.getInterpolation() === Ru, s = e.length - 1;
    let a = 1;
    for (let o = 1; o < s; ++o) {
      let l = !1;
      const h = e[o];
      if (h !== e[o + 1] && (o !== 1 || h !== e[0]))
        if (r)
          l = !0;
        else {
          const c = o * i, u = c - i, d = c + i;
          for (let p = 0; p !== i; ++p) {
            const m = t[c + p];
            if (m !== t[u + p] || m !== t[d + p]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const c = o * i, u = a * i;
          for (let d = 0; d !== i; ++d)
            t[u + d] = t[c + d];
        }
        ++a;
      }
    }
    if (s > 0) {
      e[a] = e[s];
      for (let o = s * i, l = a * i, h = 0; h !== i; ++h)
        t[l + h] = t[o + h];
      ++a;
    }
    return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * i)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), i = new this.constructor(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
Oi.prototype.TimeBufferType = Float32Array, Oi.prototype.ValueBufferType = Float32Array, Oi.prototype.DefaultInterpolation = Uo;
class na extends Oi {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
na.prototype.ValueTypeName = "bool", na.prototype.ValueBufferType = Array, na.prototype.DefaultInterpolation = Oo, na.prototype.InterpolantFactoryMethodLinear = void 0, na.prototype.InterpolantFactoryMethodSmooth = void 0;
class Hg extends Oi {
}
Hg.prototype.ValueTypeName = "color";
class vs extends Oi {
}
vs.prototype.ValueTypeName = "number";
class _M extends tl {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (i - t) / (r - t);
    let h = e * o;
    for (let c = h + o; h !== c; h += 4)
      Ye.slerpFlat(s, 0, a, h - o, a, h, l);
    return s;
  }
}
class Rr extends Oi {
  InterpolantFactoryMethodLinear(e) {
    return new _M(this.times, this.values, this.getValueSize(), e);
  }
}
Rr.prototype.ValueTypeName = "quaternion", Rr.prototype.InterpolantFactoryMethodSmooth = void 0;
class ia extends Oi {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
ia.prototype.ValueTypeName = "string", ia.prototype.ValueBufferType = Array, ia.prototype.DefaultInterpolation = Oo, ia.prototype.InterpolantFactoryMethodLinear = void 0, ia.prototype.InterpolantFactoryMethodSmooth = void 0;
class ys extends Oi {
}
ys.prototype.ValueTypeName = "vector";
class pa {
  constructor(e = "", t = -1, i = [], r = 2500) {
    this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = ri(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], i = e.tracks, r = 1 / (e.fps || 1);
    for (let a = 0, o = i.length; a !== o; ++a)
      t.push($T(i[a]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], i = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode };
    for (let s = 0, a = i.length; s !== a; ++s)
      t.push(Oi.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length, a = [];
    for (let o = 0; o < s; o++) {
      let l = [], h = [];
      l.push((o + s - 1) % s, o, (o + 1) % s), h.push(0, 1, 0);
      const c = bM(l);
      l = Im(l, 1, c), h = Im(h, 1, c), r || l[0] !== 0 || (l.push(s), h.push(h[0])), a.push(new vs(".morphTargetInfluences[" + t[o].name + "]", l, h).scale(1 / i));
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < i.length; r++)
      if (i[r].name === t)
        return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const h = e[o], c = h.name.match(s);
      if (c && c.length > 1) {
        const u = c[1];
        let d = r[u];
        d || (r[u] = d = []), d.push(h);
      }
    }
    const a = [];
    for (const o in r)
      a.push(this.CreateFromMorphTargetSequence(o, r[o], t, i));
    return a;
  }
  static parseAnimation(e, t) {
    if (!e)
      return null;
    const i = function(c, u, d, p, m) {
      if (d.length !== 0) {
        const g = [], f = [];
        zg(d, g, f, p), g.length !== 0 && m.push(new c(u, g, f));
      }
    }, r = [], s = e.name || "default", a = e.fps || 30, o = e.blendMode;
    let l = e.length || -1;
    const h = e.hierarchy || [];
    for (let c = 0; c < h.length; c++) {
      const u = h[c].keys;
      if (u && u.length !== 0)
        if (u[0].morphTargets) {
          const d = {};
          let p;
          for (p = 0; p < u.length; p++)
            if (u[p].morphTargets)
              for (let m = 0; m < u[p].morphTargets.length; m++)
                d[u[p].morphTargets[m]] = -1;
          for (const m in d) {
            const g = [], f = [];
            for (let v = 0; v !== u[p].morphTargets.length; ++v) {
              const y = u[p];
              g.push(y.time), f.push(y.morphTarget === m ? 1 : 0);
            }
            r.push(new vs(".morphTargetInfluence[" + m + "]", g, f));
          }
          l = d.length * a;
        } else {
          const d = ".bones[" + t[c].name + "]";
          i(ys, d + ".position", u, "pos", r), i(Rr, d + ".quaternion", u, "rot", r), i(ys, d + ".scale", u, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, l, r, o);
  }
  resetDuration() {
    let e = 0;
    for (let t = 0, i = this.tracks.length; t !== i; ++t) {
      const r = this.tracks[t];
      e = Math.max(e, r.times[r.times.length - 1]);
    }
    return this.duration = e, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function $T(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = function(t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return vs;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ys;
      case "color":
        return Hg;
      case "quaternion":
        return Rr;
      case "bool":
      case "boolean":
        return na;
      case "string":
        return ia;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  }(n.type);
  if (n.times === void 0) {
    const t = [], i = [];
    zg(n.keys, t, i, "value"), n.times = t, n.values = i;
  }
  return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation);
}
const _r = { enabled: !1, files: {}, add: function(n, e) {
  this.enabled !== !1 && (this.files[n] = e);
}, get: function(n) {
  if (this.enabled !== !1)
    return this.files[n];
}, remove: function(n) {
  delete this.files[n];
}, clear: function() {
  this.files = {};
} };
class Lm {
  constructor(e, t, i) {
    const r = this;
    let s = !1, a = 0, o = 0, l;
    const h = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(c) {
      o++, s === !1 && r.onStart !== void 0 && r.onStart(c, a, o), s = !0;
    }, this.itemEnd = function(c) {
      a++, r.onProgress !== void 0 && r.onProgress(c, a, o), a === o && (s = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(c) {
      r.onError !== void 0 && r.onError(c);
    }, this.resolveURL = function(c) {
      return l ? l(c) : c;
    }, this.setURLModifier = function(c) {
      return l = c, this;
    }, this.addHandler = function(c, u) {
      return h.push(c, u), this;
    }, this.removeHandler = function(c) {
      const u = h.indexOf(c);
      return u !== -1 && h.splice(u, 2), this;
    }, this.getHandler = function(c) {
      for (let u = 0, d = h.length; u < d; u += 2) {
        const p = h[u], m = h[u + 1];
        if (p.global && (p.lastIndex = 0), p.test(c))
          return m;
      }
      return null;
    };
  }
}
const Gg = new Lm();
class It {
  constructor(e) {
    this.manager = e !== void 0 ? e : Gg, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const i = this;
    return new Promise(function(r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
It.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const fr = {};
class eE extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class gn extends It {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = _r.get(e);
    if (s !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
    if (fr[e] !== void 0)
      return void fr[e].push({ onLoad: t, onProgress: i, onError: r });
    fr[e] = [], fr[e].push({ onLoad: t, onProgress: i, onError: r });
    const a = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o = this.mimeType, l = this.responseType;
    fetch(a).then((h) => {
      if (h.status === 200 || h.status === 0) {
        if (h.status, typeof ReadableStream == "undefined" || h.body === void 0 || h.body.getReader === void 0)
          return h;
        const c = fr[e], u = h.body.getReader(), d = h.headers.get("X-File-Size") || h.headers.get("Content-Length"), p = d ? parseInt(d) : 0, m = p !== 0;
        let g = 0;
        const f = new ReadableStream({ start(v) {
          (function y() {
            u.read().then(({ done: x, value: M }) => {
              if (x)
                v.close();
              else {
                g += M.byteLength;
                const b = new ProgressEvent("progress", { lengthComputable: m, loaded: g, total: p });
                for (let S = 0, w = c.length; S < w; S++) {
                  const T = c[S];
                  T.onProgress && T.onProgress(b);
                }
                v.enqueue(M), y();
              }
            }, (x) => {
              v.error(x);
            });
          })();
        } });
        return new Response(f);
      }
      throw new eE(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`, h);
    }).then((h) => {
      switch (l) {
        case "arraybuffer":
          return h.arrayBuffer();
        case "blob":
          return h.blob();
        case "document":
          return h.text().then((c) => new DOMParser().parseFromString(c, o));
        case "json":
          return h.json();
        default:
          if (o === void 0)
            return h.text();
          {
            const c = /charset="?([^;"\s]*)"?/i.exec(o), u = c && c[1] ? c[1].toLowerCase() : void 0, d = new TextDecoder(u);
            return h.arrayBuffer().then((p) => d.decode(p));
          }
      }
    }).then((h) => {
      _r.add(e, h);
      const c = fr[e];
      delete fr[e];
      for (let u = 0, d = c.length; u < d; u++) {
        const p = c[u];
        p.onLoad && p.onLoad(h);
      }
    }).catch((h) => {
      const c = fr[e];
      if (c === void 0)
        throw this.manager.itemError(e), h;
      delete fr[e];
      for (let u = 0, d = c.length; u < d; u++) {
        const p = c[u];
        p.onError && p.onError(h);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class Yl extends It {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, a = _r.get(e);
    if (a !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(a), s.manager.itemEnd(e);
      }, 0), a;
    const o = dh("img");
    function l() {
      c(), _r.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function h(u) {
      c(), r && r(u), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function c() {
      o.removeEventListener("load", l, !1), o.removeEventListener("error", h, !1);
    }
    return o.addEventListener("load", l, !1), o.addEventListener("error", h, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(e), o.src = e, o;
  }
}
class Nm extends It {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new ph();
    s.colorSpace = mt;
    const a = new Yl(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let o = 0;
    function l(h) {
      a.load(e[h], function(c) {
        s.images[h] = c, o++, o === 6 && (s.needsUpdate = !0, t && t(s));
      }, void 0, r);
    }
    for (let h = 0; h < e.length; ++h)
      l(h);
    return s;
  }
}
class Ui extends It {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new pt(), a = new Yl(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
      s.image = o, s.needsUpdate = !0, t !== void 0 && t(s);
    }, i, r), s;
  }
}
class Nr extends Ue {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new oe(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class Dm extends Nr {
  constructor(e, t, i) {
    super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Ue.DEFAULT_UP), this.updateMatrix(), this.groundColor = new oe(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Yp = new fe(), cy = new _(), uy = new _();
class jg {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new X(512, 512), this.map = null, this.mapPass = null, this.matrix = new fe(), this.autoUpdate = !0, this.needsUpdate = !1, this.Re = new jh(), this.De = new X(1, 1), this.Ie = 1, this.Ue = [new Ve(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this.Ie;
  }
  getFrustum() {
    return this.Re;
  }
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    cy.setFromMatrixPosition(e.matrixWorld), t.position.copy(cy), uy.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(uy), t.updateMatrixWorld(), Yp.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this.Re.setFromProjectionMatrix(Yp), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(Yp);
  }
  getViewport(e) {
    return this.Ue[e];
  }
  getFrameExtents() {
    return this.De;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class tE extends jg {
  constructor() {
    super(new Gt(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, i = 2 * Fo * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    i === t.fov && r === t.aspect && s === t.far || (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class vh extends Nr {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, a = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Ue.DEFAULT_UP), this.updateMatrix(), this.target = new Ue(), this.distance = i, this.angle = r, this.penumbra = s, this.decay = a, this.map = null, this.shadow = new tE();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const dy = new fe(), yl = new _(), Zp = new _();
class nE extends jg {
  constructor() {
    super(new Gt(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this.De = new X(4, 2), this.Ie = 6, this.Ue = [new Ve(2, 1, 1, 1), new Ve(0, 1, 1, 1), new Ve(3, 1, 1, 1), new Ve(1, 1, 1, 1), new Ve(3, 0, 1, 1), new Ve(1, 0, 1, 1)], this.Oe = [new _(1, 0, 0), new _(-1, 0, 0), new _(0, 0, 1), new _(0, 0, -1), new _(0, 1, 0), new _(0, -1, 0)], this.ke = [new _(0, 1, 0), new _(0, 1, 0), new _(0, 1, 0), new _(0, 1, 0), new _(0, 0, 1), new _(0, 0, -1)];
  }
  updateMatrices(e, t = 0) {
    const i = this.camera, r = this.matrix, s = e.distance || i.far;
    s !== i.far && (i.far = s, i.updateProjectionMatrix()), yl.setFromMatrixPosition(e.matrixWorld), i.position.copy(yl), Zp.copy(i.position), Zp.add(this.Oe[t]), i.up.copy(this.ke[t]), i.lookAt(Zp), i.updateMatrixWorld(), r.makeTranslation(-yl.x, -yl.y, -yl.z), dy.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this.Re.setFromProjectionMatrix(dy);
  }
}
class Wo extends Nr {
  constructor(e, t, i = 0, r = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new nE();
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class iE extends jg {
  constructor() {
    super(new _a(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class yh extends Nr {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Ue.DEFAULT_UP), this.updateMatrix(), this.target = new Ue(), this.shadow = new iE();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Yu extends Nr {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class Om extends Nr {
  constructor(e, t, i = 10, r = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = r;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class TM {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new _());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x, r = e.y, s = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.282095), t.addScaledVector(a[1], 0.488603 * r), t.addScaledVector(a[2], 0.488603 * s), t.addScaledVector(a[3], 0.488603 * i), t.addScaledVector(a[4], i * r * 1.092548), t.addScaledVector(a[5], r * s * 1.092548), t.addScaledVector(a[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(a[7], i * s * 1.092548), t.addScaledVector(a[8], 0.546274 * (i * i - r * r)), t;
  }
  getIrradianceAt(e, t) {
    const i = e.x, r = e.y, s = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.886227), t.addScaledVector(a[1], 1.023328 * r), t.addScaledVector(a[2], 1.023328 * s), t.addScaledVector(a[3], 1.023328 * i), t.addScaledVector(a[4], 0.858086 * i * r), t.addScaledVector(a[5], 0.858086 * r * s), t.addScaledVector(a[6], 0.743125 * s * s - 0.247708), t.addScaledVector(a[7], 0.858086 * i * s), t.addScaledVector(a[8], 0.429043 * (i * i - r * r)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++)
      i[r].fromArray(e, t + 3 * r);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++)
      i[r].toArray(e, t + 3 * r);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x, r = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * r, t[2] = 0.488603 * s, t[3] = 0.488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * i * s, t[8] = 0.546274 * (i * i - r * r);
  }
}
class py extends Nr {
  constructor(e = new TM(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class Zu extends It {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, i, r) {
    const s = this, a = new gn(s.manager);
    a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(o) {
      try {
        t(s.parse(JSON.parse(o)));
      } catch (l) {
        r && r(l), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return t[s], t[s];
    }
    const r = Zu.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new oe().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (r.dispersion = e.dispersion), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc), e.blendDst !== void 0 && (r.blendDst = e.blendDst), e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== void 0 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const s in e.uniforms) {
        const a = e.uniforms[s];
        switch (r.uniforms[s] = {}, a.type) {
          case "t":
            r.uniforms[s].value = i(a.value);
            break;
          case "c":
            r.uniforms[s].value = new oe().setHex(a.value);
            break;
          case "v2":
            r.uniforms[s].value = new X().fromArray(a.value);
            break;
          case "v3":
            r.uniforms[s].value = new _().fromArray(a.value);
            break;
          case "v4":
            r.uniforms[s].value = new Ve().fromArray(a.value);
            break;
          case "m3":
            r.uniforms[s].value = new De().fromArray(a.value);
            break;
          case "m4":
            r.uniforms[s].value = new fe().fromArray(a.value);
            break;
          default:
            r.uniforms[s].value = a.value;
        }
      }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const s in e.extensions)
        r.extensions[s] = e.extensions[s];
    if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = i(e.map)), e.matcap !== void 0 && (r.matcap = i(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new X().fromArray(s);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = i(e.envMap)), e.envMapRotation !== void 0 && r.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new X().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    return new { ShadowMaterial: vM, SpriteMaterial: Ud, RawShaderMaterial: Bg, ShaderMaterial: tt, PointsMaterial: Jr, MeshPhysicalMaterial: ai, MeshStandardMaterial: jo, MeshPhongMaterial: Aa, MeshToonMaterial: kg, MeshNormalMaterial: Wd, MeshLambertMaterial: Xd, MeshDepthMaterial: Od, MeshDistanceMaterial: Rg, MeshBasicMaterial: Wt, MeshMatcapMaterial: yM, LineDashedMaterial: xM, LineBasicMaterial: kt, Material: Xt }[e]();
  }
}
class tr {
  static decodeText(e) {
    if (typeof TextDecoder != "undefined")
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++)
      t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch (i) {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class Wg extends Pe {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class fy extends It {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, a = new gn(s.manager);
    a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(o) {
      try {
        t(s.parse(JSON.parse(o)));
      } catch (l) {
        r && r(l), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = {}, i = {};
    function r(u, d) {
      if (t[d] !== void 0)
        return t[d];
      const p = u.interleavedBuffers[d], m = function(v, y) {
        if (i[y] !== void 0)
          return i[y];
        const x = v.arrayBuffers, M = x[y], b = new Uint32Array(M).buffer;
        return i[y] = b, b;
      }(u, p.buffer), g = lo(p.type, m), f = new Xh(g, p.stride);
      return f.uuid = p.uuid, t[d] = f, f;
    }
    const s = e.isInstancedBufferGeometry ? new Wg() : new Pe(), a = e.data.index;
    if (a !== void 0) {
      const u = lo(a.type, a.array);
      s.setIndex(new Ke(u, 1));
    }
    const o = e.data.attributes;
    for (const u in o) {
      const d = o[u];
      let p;
      if (d.isInterleavedBufferAttribute) {
        const m = r(e.data, d.data);
        p = new zn(m, d.itemSize, d.offset, d.normalized);
      } else {
        const m = lo(d.type, d.array);
        p = new (d.isInstancedBufferAttribute ? da : Ke)(m, d.itemSize, d.normalized);
      }
      d.name !== void 0 && (p.name = d.name), d.usage !== void 0 && p.setUsage(d.usage), s.setAttribute(u, p);
    }
    const l = e.data.morphAttributes;
    if (l)
      for (const u in l) {
        const d = l[u], p = [];
        for (let m = 0, g = d.length; m < g; m++) {
          const f = d[m];
          let v;
          if (f.isInterleavedBufferAttribute) {
            const y = r(e.data, f.data);
            v = new zn(y, f.itemSize, f.offset, f.normalized);
          } else {
            const y = lo(f.type, f.array);
            v = new Ke(y, f.itemSize, f.normalized);
          }
          f.name !== void 0 && (v.name = f.name), p.push(v);
        }
        s.morphAttributes[u] = p;
      }
    e.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
    const h = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (h !== void 0)
      for (let u = 0, d = h.length; u !== d; ++u) {
        const p = h[u];
        s.addGroup(p.start, p.count, p.materialIndex);
      }
    const c = e.data.boundingSphere;
    if (c !== void 0) {
      const u = new _();
      c.center !== void 0 && u.fromArray(c.center), s.boundingSphere = new rn(u, c.radius);
    }
    return e.name && (s.name = e.name), e.userData && (s.userData = e.userData), s;
  }
}
const rE = { UVMapping: Cd, CubeReflectionMapping: Cr, CubeRefractionMapping: ps, EquirectangularReflectionMapping: Lo, EquirectangularRefractionMapping: sh, CubeUVReflectionMapping: $o }, my = { RepeatWrapping: jt, ClampToEdgeWrapping: vn, MirroredRepeatWrapping: fs }, gy = { NearestFilter: at, NearestMipmapNearestFilter: Pd, NearestMipmapLinearFilter: sa, LinearFilter: Vt, LinearMipmapNearestFilter: xo, LinearMipmapLinearFilter: er };
class EM extends It {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, a = _r.get(e);
    if (a !== void 0)
      return s.manager.itemStart(e), a.then ? void a.then((h) => {
        t && t(h), s.manager.itemEnd(e);
      }).catch((h) => {
        r && r(h);
      }) : (setTimeout(function() {
        t && t(a), s.manager.itemEnd(e);
      }, 0), a);
    const o = {};
    o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
    const l = fetch(e, o).then(function(h) {
      return h.blob();
    }).then(function(h) {
      return createImageBitmap(h, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(h) {
      return _r.add(e, h), t && t(h), s.manager.itemEnd(e), h;
    }).catch(function(h) {
      r && r(h), _r.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
    });
    _r.add(e, l), s.manager.itemStart(e);
  }
}
let Xc;
class Kp {
  static getContext() {
    return Xc === void 0 && (Xc = new (window.AudioContext || window.webkitAudioContext)()), Xc;
  }
  static setContext(e) {
    Xc = e;
  }
}
const vy = new fe(), yy = new fe(), Fs = new fe();
class xh {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = xy(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = xy();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function xy() {
  return (typeof performance == "undefined" ? Date : performance).now();
}
const Bs = new _(), My = new Ye(), sE = new _(), ks = new _();
class by extends Ue {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this.Fe = 0, this.Ge = 0, this.Be = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0 || this.hasPlaybackControl === !1)
      return;
    this.Fe = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this.Fe, this.Ge + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl !== !1)
      return this.isPlaying === !0 && (this.Ge += Math.max(this.context.currentTime - this.Fe, 0) * this.playbackRate, this.loop === !0 && (this.Ge = this.Ge % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl !== !1)
      return this.Ge = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this.Be = !0, this;
  }
  disconnect() {
    if (this.Be !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this.Be = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this.Be === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl !== !1)
      return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl !== !1 && this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl !== !1)
      return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const zs = new _(), Sy = new Ye(), aE = new _(), Vs = new _();
class AM {
  constructor(e, t, i) {
    let r, s, a;
    switch (this.binding = e, this.valueSize = i, t) {
      case "quaternion":
        r = this.He, s = this.ze, a = this.Ve, this.buffer = new Float64Array(6 * i), this.We = 5;
        break;
      case "string":
      case "bool":
        r = this.je, s = this.je, a = this.Xe, this.buffer = new Array(5 * i);
        break;
      default:
        r = this.Ye, s = this.qe, a = this.Ze, this.buffer = new Float64Array(5 * i);
    }
    this.Je = r, this.Ke = s, this.$e = a, this.Qe = 3, this.tn = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(e, t) {
    const i = this.buffer, r = this.valueSize, s = e * r + r;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let o = 0; o !== r; ++o)
        i[s + o] = i[o];
      a = t;
    } else {
      a += t;
      const o = t / a;
      this.Je(i, s, 0, o, r);
    }
    this.cumulativeWeight = a;
  }
  accumulateAdditive(e) {
    const t = this.buffer, i = this.valueSize, r = i * this.tn;
    this.cumulativeWeightAdditive === 0 && this.$e(), this.Ke(t, r, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  apply(e) {
    const t = this.valueSize, i = this.buffer, r = e * t + t, s = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const l = t * this.Qe;
      this.Je(i, r, l, 1 - s, t);
    }
    a > 0 && this.Ke(i, r, this.tn * t, 1, t);
    for (let l = t, h = t + t; l !== h; ++l)
      if (i[l] !== i[l + t]) {
        o.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding, t = this.buffer, i = this.valueSize, r = i * this.Qe;
    e.getValue(t, r);
    for (let s = i, a = r; s !== a; ++s)
      t[s] = t[r + s % i];
    this.$e(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const e = 3 * this.valueSize;
    this.binding.setValue(this.buffer, e);
  }
  Ze() {
    const e = this.tn * this.valueSize, t = e + this.valueSize;
    for (let i = e; i < t; i++)
      this.buffer[i] = 0;
  }
  Ve() {
    this.Ze(), this.buffer[this.tn * this.valueSize + 3] = 1;
  }
  Xe() {
    const e = this.Qe * this.valueSize, t = this.tn * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  je(e, t, i, r, s) {
    if (r >= 0.5)
      for (let a = 0; a !== s; ++a)
        e[t + a] = e[i + a];
  }
  He(e, t, i, r) {
    Ye.slerpFlat(e, t, e, t, e, i, r);
  }
  ze(e, t, i, r, s) {
    const a = this.We * s;
    Ye.multiplyQuaternionsFlat(e, a, e, t, e, i), Ye.slerpFlat(e, t, e, t, e, a, r);
  }
  Ye(e, t, i, r, s) {
    const a = 1 - r;
    for (let o = 0; o !== s; ++o) {
      const l = t + o;
      e[l] = e[l] * a + e[i + o] * r;
    }
  }
  qe(e, t, i, r, s) {
    for (let a = 0; a !== s; ++a) {
      const o = t + a;
      e[o] = e[o] + e[i + a] * r;
    }
  }
}
const Xg = "\\[\\]\\.:\\/", oE = new RegExp("[" + Xg + "]", "g"), Jp = "[^" + Xg + "]", lE = "[^" + Xg.replace("\\.", "") + "]", hE = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Jp) + /(WCOD+)?/.source.replace("WCOD", lE) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Jp) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Jp) + "$"), cE = ["material", "materials", "bones", "map"];
class qe {
  constructor(e, t, i) {
    this.path = t, this.parsedPath = i || qe.parseTrackName(t), this.node = qe.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this.nn, this.setValue = this.sn;
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new qe.Composite(e, t, i) : new qe(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(oE, "");
  }
  static parseTrackName(e) {
    const t = hE.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      cE.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s);
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      const i = function(s) {
        for (let a = 0; a < s.length; a++) {
          const o = s[a];
          if (o.name === t || o.uuid === t)
            return o;
          const l = i(o.children);
          if (l)
            return l;
        }
        return null;
      }, r = i(e.children);
      if (r)
        return r;
    }
    return null;
  }
  rn() {
  }
  an() {
  }
  hn(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  cn(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      e[t++] = i[r];
  }
  ln(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  un(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  dn(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  pn(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  mn(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  vn(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = e[t++];
  }
  gn(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  wn(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  Mn(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _n(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  xn(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  yn(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  Sn(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  bn(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  nn(e, t) {
    this.bind(), this.getValue(e, t);
  }
  sn(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath, i = t.objectName, r = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = qe.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this.rn, this.setValue = this.an, !e)
      return;
    if (i) {
      let h = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material || !e.material.materials)
            return;
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton)
            return;
          e = e.skeleton.bones;
          for (let c = 0; c < e.length; c++)
            if (e[c].name === h) {
              h = c;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material || !e.material.map)
            return;
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0)
            return;
          e = e[i];
      }
      if (h !== void 0) {
        if (e[h] === void 0)
          return;
        e = e[h];
      }
    }
    const a = e[r];
    if (a === void 0) {
      t.nodeName;
      return;
    }
    let o = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry || !e.geometry.morphAttributes)
          return;
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s;
    } else
      a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
  }
  unbind() {
    this.node = null, this.getValue = this.nn, this.setValue = this.sn;
  }
}
qe.Composite = class {
  constructor(n, e, t) {
    const i = t || qe.parseTrackName(e);
    this.An = n, this.En = n.subscribe_(e, i);
  }
  getValue(n, e) {
    this.bind();
    const t = this.An.nCachedObjects_, i = this.En[t];
    i !== void 0 && i.getValue(n, e);
  }
  setValue(n, e) {
    const t = this.En;
    for (let i = this.An.nCachedObjects_, r = t.length; i !== r; ++i)
      t[i].setValue(n, e);
  }
  bind() {
    const n = this.En;
    for (let e = this.An.nCachedObjects_, t = n.length; e !== t; ++e)
      n[e].bind();
  }
  unbind() {
    const n = this.En;
    for (let e = this.An.nCachedObjects_, t = n.length; e !== t; ++e)
      n[e].unbind();
  }
}, qe.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, qe.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, qe.prototype.GetterByBindingType = [qe.prototype.hn, qe.prototype.cn, qe.prototype.ln, qe.prototype.un], qe.prototype.SetterByBindingTypeAndVersioning = [[qe.prototype.dn, qe.prototype.pn, qe.prototype.mn], [qe.prototype.vn, qe.prototype.gn, qe.prototype.wn], [qe.prototype.Mn, qe.prototype._n, qe.prototype.xn], [qe.prototype.yn, qe.prototype.Sn, qe.prototype.bn]];
class CM {
  constructor(e, t, i = null, r = t.blendMode) {
    this.Tn = e, this.Cn = t, this.Pn = i, this.blendMode = r;
    const s = t.tracks, a = s.length, o = new Array(a), l = { endingStart: aa, endingEnd: aa };
    for (let h = 0; h !== a; ++h) {
      const c = s[h].createInterpolant(null);
      o[h] = c, c.settings = l;
    }
    this.Ln = l, this.Nn = o, this.Rn = new Array(a), this.Dn = null, this.In = null, this.Un = null, this.On = null, this.loop = _g, this.kn = -1, this.Fn = null, this.time = 0, this.timeScale = 1, this.Gn = 1, this.weight = 1, this.Bn = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  play() {
    return this.Tn.Hn(this), this;
  }
  stop() {
    return this.Tn.zn(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this.kn = -1, this.Fn = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this.Fn === null && this.Tn.Vn(this);
  }
  isScheduled() {
    return this.Tn.Vn(this);
  }
  startAt(e) {
    return this.Fn = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  setEffectiveWeight(e) {
    return this.weight = e, this.Bn = this.enabled ? e : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this.Bn;
  }
  fadeIn(e) {
    return this.Wn(e, 0, 1);
  }
  fadeOut(e) {
    return this.Wn(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      const r = this.Cn.duration, s = e.Cn.duration, a = s / r, o = r / s;
      e.warp(1, a, t), this.warp(o, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this.On;
    return e !== null && (this.On = null, this.Tn.jn(e)), this;
  }
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this.Gn = this.paused ? 0 : e, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this.Gn;
  }
  setDuration(e) {
    return this.timeScale = this.Cn.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this.Gn, 0, e);
  }
  warp(e, t, i) {
    const r = this.Tn, s = r.time, a = this.timeScale;
    let o = this.Un;
    o === null && (o = r.Xn(), this.Un = o);
    const l = o.parameterPositions, h = o.sampleValues;
    return l[0] = s, l[1] = s + i, h[0] = e / a, h[1] = t / a, this;
  }
  stopWarping() {
    const e = this.Un;
    return e !== null && (this.Un = null, this.Tn.jn(e)), this;
  }
  getMixer() {
    return this.Tn;
  }
  getClip() {
    return this.Cn;
  }
  getRoot() {
    return this.Pn || this.Tn.Yn;
  }
  qn(e, t, i, r) {
    if (!this.enabled)
      return void this.Zn(e);
    const s = this.Fn;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? t = 0 : (this.Fn = null, t = i * l);
    }
    t *= this.Jn(e);
    const a = this.Kn(t), o = this.Zn(e);
    if (o > 0) {
      const l = this.Nn, h = this.Rn;
      if (this.blendMode === Tg)
        for (let c = 0, u = l.length; c !== u; ++c)
          l[c].evaluate(a), h[c].accumulateAdditive(o);
      else
        for (let c = 0, u = l.length; c !== u; ++c)
          l[c].evaluate(a), h[c].accumulate(r, o);
    }
  }
  Zn(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this.On;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        t *= r, e > i.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this.Bn = t, t;
  }
  Jn(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this.Un;
      i !== null && (t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t));
    }
    return this.Gn = t, t;
  }
  Kn(e) {
    const t = this.Cn.duration, i = this.loop;
    let r = this.time + e, s = this.kn;
    const a = i === 2202;
    if (e === 0)
      return s === -1 || !a || 1 & ~s ? r : t - r;
    if (i === wg) {
      s === -1 && (this.kn = 0, this.$n(!0, !0, !1));
      e: {
        if (r >= t)
          r = t;
        else {
          if (!(r < 0)) {
            this.time = r;
            break e;
          }
          r = 0;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this.Tn.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this.$n(!0, this.repetitions === 0, a)) : this.$n(this.repetitions === 0, !0, a)), r >= t || r < 0) {
        const o = Math.floor(r / t);
        r -= t * o, s += Math.abs(o);
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this.Tn.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 });
        else {
          if (l === 1) {
            const h = e < 0;
            this.$n(h, !h, a);
          } else
            this.$n(!1, !1, a);
          this.kn = s, this.time = r, this.Tn.dispatchEvent({ type: "loop", action: this, loopDelta: o });
        }
      } else
        this.time = r;
      if (a && !(1 & ~s))
        return t - r;
    }
    return r;
  }
  $n(e, t, i) {
    const r = this.Ln;
    i ? (r.endingStart = oa, r.endingEnd = oa) : (r.endingStart = e ? this.zeroSlopeAtStart ? oa : aa : ah, r.endingEnd = t ? this.zeroSlopeAtEnd ? oa : aa : ah);
  }
  Wn(e, t, i) {
    const r = this.Tn, s = r.time;
    let a = this.On;
    a === null && (a = r.Xn(), this.On = a);
    const o = a.parameterPositions, l = a.sampleValues;
    return o[0] = s, l[0] = t, o[1] = s + e, l[1] = i, this;
  }
}
const uE = new Float32Array(1);
class PM extends rr {
  constructor(e) {
    super(), this.Yn = e, this.ti(), this.ei = 0, this.time = 0, this.timeScale = 1;
  }
  ni(e, t) {
    const i = e.Pn || this.Yn, r = e.Cn.tracks, s = r.length, a = e.Rn, o = e.Nn, l = i.uuid, h = this.ii;
    let c = h[l];
    c === void 0 && (c = {}, h[l] = c);
    for (let u = 0; u !== s; ++u) {
      const d = r[u], p = d.name;
      let m = c[p];
      if (m !== void 0)
        ++m.referenceCount, a[u] = m;
      else {
        if (m = a[u], m !== void 0) {
          m.Dn === null && (++m.referenceCount, this.si(m, l, p));
          continue;
        }
        const g = t && t.Rn[u].binding.parsedPath;
        m = new AM(qe.create(i, p, g), d.ValueTypeName, d.getValueSize()), ++m.referenceCount, this.si(m, l, p), a[u] = m;
      }
      o[u].resultBuffer = m.buffer;
    }
  }
  Hn(e) {
    if (!this.Vn(e)) {
      if (e.Dn === null) {
        const i = (e.Pn || this.Yn).uuid, r = e.Cn.uuid, s = this.ri[r];
        this.ni(e, s && s.knownActions[0]), this.oi(e, r, i);
      }
      const t = e.Rn;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ == 0 && (this.ai(s), s.saveOriginalState());
      }
      this.hi(e);
    }
  }
  zn(e) {
    if (this.Vn(e)) {
      const t = e.Rn;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount == 0 && (s.restoreOriginalState(), this.ci(s));
      }
      this.li(e);
    }
  }
  ti() {
    this.ui = [], this.fi = 0, this.ri = {}, this.En = [], this.di = 0, this.ii = {}, this.pi = [], this.mi = 0;
    const e = this;
    this.stats = { actions: { get total() {
      return e.ui.length;
    }, get inUse() {
      return e.fi;
    } }, bindings: { get total() {
      return e.En.length;
    }, get inUse() {
      return e.di;
    } }, controlInterpolants: { get total() {
      return e.pi.length;
    }, get inUse() {
      return e.mi;
    } } };
  }
  Vn(e) {
    const t = e.Dn;
    return t !== null && t < this.fi;
  }
  oi(e, t, i) {
    const r = this.ui, s = this.ri;
    let a = s[t];
    if (a === void 0)
      a = { knownActions: [e], actionByRoot: {} }, e.In = 0, s[t] = a;
    else {
      const o = a.knownActions;
      e.In = o.length, o.push(e);
    }
    e.Dn = r.length, r.push(e), a.actionByRoot[i] = e;
  }
  gi(e) {
    const t = this.ui, i = t[t.length - 1], r = e.Dn;
    i.Dn = r, t[r] = i, t.pop(), e.Dn = null;
    const s = e.Cn.uuid, a = this.ri, o = a[s], l = o.knownActions, h = l[l.length - 1], c = e.In;
    h.In = c, l[c] = h, l.pop(), e.In = null, delete o.actionByRoot[(e.Pn || this.Yn).uuid], l.length === 0 && delete a[s], this.wi(e);
  }
  wi(e) {
    const t = e.Rn;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount == 0 && this.Mi(s);
    }
  }
  hi(e) {
    const t = this.ui, i = e.Dn, r = this.fi++, s = t[r];
    e.Dn = r, t[r] = e, s.Dn = i, t[i] = s;
  }
  li(e) {
    const t = this.ui, i = e.Dn, r = --this.fi, s = t[r];
    e.Dn = r, t[r] = e, s.Dn = i, t[i] = s;
  }
  si(e, t, i) {
    const r = this.ii, s = this.En;
    let a = r[t];
    a === void 0 && (a = {}, r[t] = a), a[i] = e, e.Dn = s.length, s.push(e);
  }
  Mi(e) {
    const t = this.En, i = e.binding, r = i.rootNode.uuid, s = i.path, a = this.ii, o = a[r], l = t[t.length - 1], h = e.Dn;
    l.Dn = h, t[h] = l, t.pop(), delete o[s], Object.keys(o).length === 0 && delete a[r];
  }
  ai(e) {
    const t = this.En, i = e.Dn, r = this.di++, s = t[r];
    e.Dn = r, t[r] = e, s.Dn = i, t[i] = s;
  }
  ci(e) {
    const t = this.En, i = e.Dn, r = --this.di, s = t[r];
    e.Dn = r, t[r] = e, s.Dn = i, t[i] = s;
  }
  Xn() {
    const e = this.pi, t = this.mi++;
    let i = e[t];
    return i === void 0 && (i = new Vg(new Float32Array(2), new Float32Array(2), 1, uE), i._i = t, e[t] = i), i;
  }
  jn(e) {
    const t = this.pi, i = e._i, r = --this.mi, s = t[r];
    e._i = r, t[r] = e, s._i = i, t[i] = s;
  }
  clipAction(e, t, i) {
    const r = t || this.Yn, s = r.uuid;
    let a = typeof e == "string" ? pa.findByName(r, e) : e;
    const o = a !== null ? a.uuid : e, l = this.ri[o];
    let h = null;
    if (i === void 0 && (i = a !== null ? a.blendMode : G1), l !== void 0) {
      const u = l.actionByRoot[s];
      if (u !== void 0 && u.blendMode === i)
        return u;
      h = l.knownActions[0], a === null && (a = h.Cn);
    }
    if (a === null)
      return null;
    const c = new CM(this, a, t, i);
    return this.ni(c, h), this.oi(c, o, s), c;
  }
  existingAction(e, t) {
    const i = t || this.Yn, r = i.uuid, s = typeof e == "string" ? pa.findByName(i, e) : e, a = s ? s.uuid : e, o = this.ri[a];
    return o !== void 0 && o.actionByRoot[r] || null;
  }
  stopAllAction() {
    const e = this.ui;
    for (let t = this.fi - 1; t >= 0; --t)
      e[t].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this.ui, i = this.fi, r = this.time += e, s = Math.sign(e), a = this.ei ^= 1;
    for (let h = 0; h !== i; ++h)
      t[h].qn(r, e, s, a);
    const o = this.En, l = this.di;
    for (let h = 0; h !== l; ++h)
      o[h].apply(a);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this.ui.length; t++)
      this.ui[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this.Yn;
  }
  uncacheClip(e) {
    const t = this.ui, i = e.uuid, r = this.ri, s = r[i];
    if (s !== void 0) {
      const a = s.knownActions;
      for (let o = 0, l = a.length; o !== l; ++o) {
        const h = a[o];
        this.zn(h);
        const c = h.Dn, u = t[t.length - 1];
        h.Dn = null, h.In = null, u.Dn = c, t[c] = u, t.pop(), this.wi(h);
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid, i = this.ri;
    for (const s in i) {
      const a = i[s].actionByRoot[t];
      a !== void 0 && (this.zn(a), this.gi(a));
    }
    const r = this.ii[t];
    if (r !== void 0)
      for (const s in r) {
        const a = r[s];
        a.restoreOriginalState(), this.Mi(a);
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this.zn(i), this.gi(i));
  }
}
class qg {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new qg(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let dE = 0;
class Ku extends Xh {
  constructor(e, t, i = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
const wy = new fe();
class qd {
  constructor(e, t, i = 0, r = 1 / 0) {
    this.ray = new Ra(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new Id(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera && (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t);
  }
  setFromXRController(e) {
    return wy.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(wy), this;
  }
  intersectObject(e, t = !0, i = []) {
    return Um(e, this, i, t), i.sort(_y), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++)
      Um(e[r], this, i, t);
    return i.sort(_y), i;
  }
}
function _y(n, e) {
  return n.distance - e.distance;
}
function Um(n, e, t, i) {
  let r = !0;
  if (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (r = !1), r === !0 && i === !0) {
    const s = n.children;
    for (let a = 0, o = s.length; a < o; a++)
      Um(s[a], e, t, !0);
  }
}
class Fm {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(Rt(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ty = new X(), Ey = new _(), qc = new _();
class RM {
  constructor(e = new _(), t = new _()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    Ey.subVectors(e, this.start), qc.subVectors(this.end, this.start);
    const i = qc.dot(qc);
    let r = qc.dot(Ey) / i;
    return t && (r = Rt(r, 0, 1)), r;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ay = new _(), jr = new _(), Yc = new fe(), Qp = new fe();
function IM(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, IM(n.children[t]));
  return e;
}
const pE = new _(), Cy = new oe(), Py = new oe();
class LM extends Zn {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    i = new oe(i), r = new oe(r);
    const s = t / 2, a = e / t, o = e / 2, l = [], h = [];
    for (let u = 0, d = 0, p = -o; u <= t; u++, p += a) {
      l.push(-o, 0, p, o, 0, p), l.push(p, 0, -o, p, 0, o);
      const m = u === s ? i : r;
      m.toArray(h, d), d += 3, m.toArray(h, d), d += 3, m.toArray(h, d), d += 3, m.toArray(h, d), d += 3;
    }
    const c = new Pe();
    c.setAttribute("position", new ye(l, 3)), c.setAttribute("color", new ye(h, 3)), super(c, new kt({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Ry = new _(), Zc = new _(), Iy = new _(), Kc = new _(), Ct = new Nd();
function Ut(n, e, t, i, r, s, a) {
  Kc.set(r, s, a).unproject(i);
  const o = e[n];
  if (o !== void 0) {
    const l = t.getAttribute("position");
    for (let h = 0, c = o.length; h < c; h++)
      l.setXYZ(o[h], Kc.x, Kc.y, Kc.z);
  }
}
const Jc = new yt();
class NM extends Zn {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Pe();
    r.setIndex(new Ke(i, 1)), r.setAttribute("position", new ye([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new kt({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class DM extends hn {
  constructor(e, t = 1, i = 16776960) {
    const r = i, s = new Pe();
    s.setAttribute("position", new ye([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), s.computeBoundingSphere(), super(s, new kt({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const a = new Pe();
    a.setAttribute("position", new ye([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), a.computeBoundingSphere(), this.add(new ce(a, new Wt({ color: r, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const Ly = new _();
let Qc, $p;
class OM extends Zn {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = new Pe();
    i.setAttribute("position", new ye(t, 3)), i.setAttribute("color", new ye([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)), super(i, new kt({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper";
  }
  setColors(e, t, i) {
    const r = new oe(), s = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(i), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class UM {
  constructor() {
    this.type = "ShapePath", this.color = new oe(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new Go(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, a) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(f, v) {
      const y = v.length;
      let x = !1;
      for (let M = y - 1, b = 0; b < y; M = b++) {
        let S = v[M], w = v[b], T = w.x - S.x, C = w.y - S.y;
        if (Math.abs(C) > Number.EPSILON) {
          if (C < 0 && (S = v[b], T = -T, w = v[M], C = -C), f.y < S.y || f.y > w.y)
            continue;
          if (f.y === S.y) {
            if (f.x === S.x)
              return !0;
          } else {
            const I = C * (f.x - S.x) - T * (f.y - S.y);
            if (I === 0)
              return !0;
            if (I < 0)
              continue;
            x = !x;
          }
        } else {
          if (f.y !== S.y)
            continue;
          if (w.x <= f.x && f.x <= S.x || S.x <= f.x && f.x <= w.x)
            return !0;
        }
      }
      return x;
    }
    const i = Di.isClockWise, r = this.subPaths;
    if (r.length === 0)
      return [];
    let s, a, o;
    const l = [];
    if (r.length === 1)
      return a = r[0], o = new ls(), o.curves = a.curves, l.push(o), l;
    let h = !i(r[0].getPoints());
    h = e ? !h : h;
    const c = [], u = [];
    let d, p, m = [], g = 0;
    u[g] = void 0, m[g] = [];
    for (let f = 0, v = r.length; f < v; f++)
      a = r[f], d = a.getPoints(), s = i(d), s = e ? !s : s, s ? (!h && u[g] && g++, u[g] = { s: new ls(), p: d }, u[g].s.curves = a.curves, h && g++, m[g] = []) : m[g].push({ h: a, p: d[0] });
    if (!u[0])
      return function(f) {
        const v = [];
        for (let y = 0, x = f.length; y < x; y++) {
          const M = f[y], b = new ls();
          b.curves = M.curves, v.push(b);
        }
        return v;
      }(r);
    if (u.length > 1) {
      let f = !1, v = 0;
      for (let y = 0, x = u.length; y < x; y++)
        c[y] = [];
      for (let y = 0, x = u.length; y < x; y++) {
        const M = m[y];
        for (let b = 0; b < M.length; b++) {
          const S = M[b];
          let w = !0;
          for (let T = 0; T < u.length; T++)
            t(S.p, u[T].p) && (y !== T && v++, w ? (w = !1, c[T].push(S)) : f = !0);
          w && c[y].push(S);
        }
      }
      v > 0 && f === !1 && (m = c);
    }
    for (let f = 0, v = u.length; f < v; f++) {
      o = u[f].s, l.push(o), p = m[f];
      for (let y = 0, x = p.length; y < x; y++)
        o.holes.push(p[y].h);
    }
    return l;
  }
}
typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: Hu } })), typeof window != "undefined" && (window.__THREE__ || (window.__THREE__ = Hu));
const C3 = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: Ed, AddEquation: $n, AddOperation: V1, AdditiveAnimationBlendMode: Tg, AdditiveBlending: Ar, AgXToneMapping: Ad, AlphaFormat: 1021, AlwaysCompare: 519, AlwaysDepth: 1, AlwaysStencilFunc: 519, AmbientLight: Yu, AnimationAction: CM, AnimationClip: pa, AnimationLoader: class extends It {
  constructor(n) {
    super(n);
  }
  load(n, e, t, i) {
    const r = this, s = new gn(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(n, function(a) {
      try {
        e(r.parse(JSON.parse(a)));
      } catch (o) {
        i && i(o), r.manager.itemError(n);
      }
    }, t, i);
  }
  parse(n) {
    const e = [];
    for (let t = 0; t < n.length; t++) {
      const i = pa.parse(n[t]);
      e.push(i);
    }
    return e;
  }
}, AnimationMixer: PM, AnimationObjectGroup: class {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = ri(), this.xi = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const n = {};
    this.yi = n;
    for (let t = 0, i = arguments.length; t !== i; ++t)
      n[arguments[t].uuid] = t;
    this.Si = [], this.bi = [], this.En = [], this.Ai = {};
    const e = this;
    this.stats = { objects: { get total() {
      return e.xi.length;
    }, get inUse() {
      return this.total - e.nCachedObjects_;
    } }, get bindingsPerObject() {
      return e.En.length;
    } };
  }
  add() {
    const n = this.xi, e = this.yi, t = this.Si, i = this.bi, r = this.En, s = r.length;
    let a, o = n.length, l = this.nCachedObjects_;
    for (let h = 0, c = arguments.length; h !== c; ++h) {
      const u = arguments[h], d = u.uuid;
      let p = e[d];
      if (p === void 0) {
        p = o++, e[d] = p, n.push(u);
        for (let m = 0, g = s; m !== g; ++m)
          r[m].push(new qe(u, t[m], i[m]));
      } else if (p < l) {
        a = n[p];
        const m = --l, g = n[m];
        e[g.uuid] = p, n[p] = g, e[d] = m, n[m] = u;
        for (let f = 0, v = s; f !== v; ++f) {
          const y = r[f], x = y[m];
          let M = y[p];
          y[p] = x, M === void 0 && (M = new qe(u, t[f], i[f])), y[m] = M;
        }
      } else
        n[p];
    }
    this.nCachedObjects_ = l;
  }
  remove() {
    const n = this.xi, e = this.yi, t = this.En, i = t.length;
    let r = this.nCachedObjects_;
    for (let s = 0, a = arguments.length; s !== a; ++s) {
      const o = arguments[s], l = o.uuid, h = e[l];
      if (h !== void 0 && h >= r) {
        const c = r++, u = n[c];
        e[u.uuid] = h, n[h] = u, e[l] = c, n[c] = o;
        for (let d = 0, p = i; d !== p; ++d) {
          const m = t[d], g = m[c], f = m[h];
          m[h] = g, m[c] = f;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  uncache() {
    const n = this.xi, e = this.yi, t = this.En, i = t.length;
    let r = this.nCachedObjects_, s = n.length;
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const l = arguments[a].uuid, h = e[l];
      if (h !== void 0)
        if (delete e[l], h < r) {
          const c = --r, u = n[c], d = --s, p = n[d];
          e[u.uuid] = h, n[h] = u, e[p.uuid] = c, n[c] = p, n.pop();
          for (let m = 0, g = i; m !== g; ++m) {
            const f = t[m], v = f[c], y = f[d];
            f[h] = v, f[c] = y, f.pop();
          }
        } else {
          const c = --s, u = n[c];
          c > 0 && (e[u.uuid] = h), n[h] = u, n.pop();
          for (let d = 0, p = i; d !== p; ++d) {
            const m = t[d];
            m[h] = m[c], m.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  subscribe_(n, e) {
    const t = this.Ai;
    let i = t[n];
    const r = this.En;
    if (i !== void 0)
      return r[i];
    const s = this.Si, a = this.bi, o = this.xi, l = o.length, h = this.nCachedObjects_, c = new Array(l);
    i = r.length, t[n] = i, s.push(n), a.push(e), r.push(c);
    for (let u = h, d = o.length; u !== d; ++u) {
      const p = o[u];
      c[u] = new qe(p, n, e);
    }
    return c;
  }
  unsubscribe_(n) {
    const e = this.Ai, t = e[n];
    if (t !== void 0) {
      const i = this.Si, r = this.bi, s = this.En, a = s.length - 1, o = s[a];
      e[n[a]] = t, s[t] = o, s.pop(), r[t] = r[a], r.pop(), i[t] = i[a], i.pop();
    }
  }
}, AnimationUtils: QT, ArcCurve: cM, ArrayCamera: sM, ArrowHelper: class extends Ue {
  constructor(n = new _(0, 0, 1), e = new _(0, 0, 0), t = 1, i = 16776960, r = 0.2 * t, s = 0.2 * r) {
    super(), this.type = "ArrowHelper", Qc === void 0 && (Qc = new Pe(), Qc.setAttribute("position", new ye([0, 0, 0, 0, 1, 0], 3)), $p = new Pt(0, 0.5, 1, 5, 1), $p.translate(0, -0.5, 0)), this.position.copy(e), this.line = new hn(Qc, new kt({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ce($p, new Wt({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(n), this.setLength(t, r, s);
  }
  setDirection(n) {
    if (n.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (n.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      Ly.set(n.z, 0, -n.x).normalize();
      const e = Math.acos(n.y);
      this.quaternion.setFromAxisAngle(Ly, e);
    }
  }
  setLength(n, e = 0.2 * n, t = 0.2 * e) {
    this.line.scale.set(1, Math.max(1e-4, n - e), 1), this.line.updateMatrix(), this.cone.scale.set(t, e, t), this.cone.position.y = n, this.cone.updateMatrix();
  }
  setColor(n) {
    this.line.material.color.set(n), this.cone.material.color.set(n);
  }
  copy(n) {
    return super.copy(n, !1), this.line.copy(n.line), this.cone.copy(n.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}, AttachedBindMode: Xf, Audio: by, AudioAnalyser: class {
  constructor(n, e = 2048) {
    this.analyser = n.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), n.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let n = 0;
    const e = this.getFrequencyData();
    for (let t = 0; t < e.length; t++)
      n += e[t];
    return n / e.length;
  }
}, AudioContext: Kp, AudioListener: class extends Ue {
  constructor() {
    super(), this.type = "AudioListener", this.context = Kp.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this.Ei = new xh();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(n) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = n, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(n) {
    return this.gain.gain.setTargetAtTime(n, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(n) {
    super.updateMatrixWorld(n);
    const e = this.context.listener, t = this.up;
    if (this.timeDelta = this.Ei.getDelta(), this.matrixWorld.decompose(Bs, My, sE), ks.set(0, 0, -1).applyQuaternion(My), e.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      e.positionX.linearRampToValueAtTime(Bs.x, i), e.positionY.linearRampToValueAtTime(Bs.y, i), e.positionZ.linearRampToValueAtTime(Bs.z, i), e.forwardX.linearRampToValueAtTime(ks.x, i), e.forwardY.linearRampToValueAtTime(ks.y, i), e.forwardZ.linearRampToValueAtTime(ks.z, i), e.upX.linearRampToValueAtTime(t.x, i), e.upY.linearRampToValueAtTime(t.y, i), e.upZ.linearRampToValueAtTime(t.z, i);
    } else
      e.setPosition(Bs.x, Bs.y, Bs.z), e.setOrientation(ks.x, ks.y, ks.z, t.x, t.y, t.z);
  }
}, AudioLoader: class extends It {
  constructor(n) {
    super(n);
  }
  load(n, e, t, i) {
    const r = this, s = new gn(this.manager);
    function a(o) {
      i && i(o), r.manager.itemError(n);
    }
    s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(n, function(o) {
      try {
        const l = o.slice(0);
        Kp.getContext().decodeAudioData(l, function(h) {
          e(h);
        }).catch(a);
      } catch (l) {
        a(l);
      }
    }, t, i);
  }
}, AxesHelper: OM, BackSide: Tn, BasicDepthPacking: 3200, BasicShadowMap: 0, BatchedMesh: Kv, Bone: Vo, BooleanKeyframeTrack: na, Box2: class {
  constructor(n = new X(1 / 0, 1 / 0), e = new X(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = n, this.max = e;
  }
  set(n, e) {
    return this.min.copy(n), this.max.copy(e), this;
  }
  setFromPoints(n) {
    this.makeEmpty();
    for (let e = 0, t = n.length; e < t; e++)
      this.expandByPoint(n[e]);
    return this;
  }
  setFromCenterAndSize(n, e) {
    const t = Ty.copy(e).multiplyScalar(0.5);
    return this.min.copy(n).sub(t), this.max.copy(n).add(t), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(n) {
    return this.min.copy(n.min), this.max.copy(n.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(n) {
    return this.isEmpty() ? n.set(0, 0) : n.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(n) {
    return this.isEmpty() ? n.set(0, 0) : n.subVectors(this.max, this.min);
  }
  expandByPoint(n) {
    return this.min.min(n), this.max.max(n), this;
  }
  expandByVector(n) {
    return this.min.sub(n), this.max.add(n), this;
  }
  expandByScalar(n) {
    return this.min.addScalar(-n), this.max.addScalar(n), this;
  }
  containsPoint(n) {
    return !(n.x < this.min.x || n.x > this.max.x || n.y < this.min.y || n.y > this.max.y);
  }
  containsBox(n) {
    return this.min.x <= n.min.x && n.max.x <= this.max.x && this.min.y <= n.min.y && n.max.y <= this.max.y;
  }
  getParameter(n, e) {
    return e.set((n.x - this.min.x) / (this.max.x - this.min.x), (n.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(n) {
    return !(n.max.x < this.min.x || n.min.x > this.max.x || n.max.y < this.min.y || n.min.y > this.max.y);
  }
  clampPoint(n, e) {
    return e.copy(n).clamp(this.min, this.max);
  }
  distanceToPoint(n) {
    return this.clampPoint(n, Ty).distanceTo(n);
  }
  intersect(n) {
    return this.min.max(n.min), this.max.min(n.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(n) {
    return this.min.min(n.min), this.max.max(n.max), this;
  }
  translate(n) {
    return this.min.add(n), this.max.add(n), this;
  }
  equals(n) {
    return n.min.equals(this.min) && n.max.equals(this.max);
  }
}, Box3: yt, Box3Helper: NM, BoxGeometry: _t, BoxHelper: class extends Zn {
  constructor(n, e = 16776960) {
    const t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(24), r = new Pe();
    r.setIndex(new Ke(t, 1)), r.setAttribute("position", new Ke(i, 3)), super(r, new kt({ color: e, toneMapped: !1 })), this.object = n, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(n) {
    if (this.object !== void 0 && Jc.setFromObject(this.object), Jc.isEmpty())
      return;
    const e = Jc.min, t = Jc.max, i = this.geometry.attributes.position, r = i.array;
    r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = e.x, r[4] = t.y, r[5] = t.z, r[6] = e.x, r[7] = e.y, r[8] = t.z, r[9] = t.x, r[10] = e.y, r[11] = t.z, r[12] = t.x, r[13] = t.y, r[14] = e.z, r[15] = e.x, r[16] = t.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = t.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(n) {
    return this.object = n, this.update(), this;
  }
  copy(n, e) {
    return super.copy(n, e), this.object = n.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, BufferAttribute: Ke, BufferGeometry: Pe, BufferGeometryLoader: fy, ByteType: 1010, Cache: _r, Camera: Nd, CameraHelper: class extends Zn {
  constructor(n) {
    const e = new Pe(), t = new kt({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], r = [], s = {};
    function a(p, m) {
      o(p), o(m);
    }
    function o(p) {
      i.push(0, 0, 0), r.push(0, 0, 0), s[p] === void 0 && (s[p] = []), s[p].push(i.length / 3 - 1);
    }
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"), e.setAttribute("position", new ye(i, 3)), e.setAttribute("color", new ye(r, 3)), super(e, t), this.type = "CameraHelper", this.camera = n, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = n.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update();
    const l = new oe(16755200), h = new oe(16711680), c = new oe(43775), u = new oe(16777215), d = new oe(3355443);
    this.setColors(l, h, c, u, d);
  }
  setColors(n, e, t, i, r) {
    const s = this.geometry.getAttribute("color");
    s.setXYZ(0, n.r, n.g, n.b), s.setXYZ(1, n.r, n.g, n.b), s.setXYZ(2, n.r, n.g, n.b), s.setXYZ(3, n.r, n.g, n.b), s.setXYZ(4, n.r, n.g, n.b), s.setXYZ(5, n.r, n.g, n.b), s.setXYZ(6, n.r, n.g, n.b), s.setXYZ(7, n.r, n.g, n.b), s.setXYZ(8, n.r, n.g, n.b), s.setXYZ(9, n.r, n.g, n.b), s.setXYZ(10, n.r, n.g, n.b), s.setXYZ(11, n.r, n.g, n.b), s.setXYZ(12, n.r, n.g, n.b), s.setXYZ(13, n.r, n.g, n.b), s.setXYZ(14, n.r, n.g, n.b), s.setXYZ(15, n.r, n.g, n.b), s.setXYZ(16, n.r, n.g, n.b), s.setXYZ(17, n.r, n.g, n.b), s.setXYZ(18, n.r, n.g, n.b), s.setXYZ(19, n.r, n.g, n.b), s.setXYZ(20, n.r, n.g, n.b), s.setXYZ(21, n.r, n.g, n.b), s.setXYZ(22, n.r, n.g, n.b), s.setXYZ(23, n.r, n.g, n.b), s.setXYZ(24, e.r, e.g, e.b), s.setXYZ(25, e.r, e.g, e.b), s.setXYZ(26, e.r, e.g, e.b), s.setXYZ(27, e.r, e.g, e.b), s.setXYZ(28, e.r, e.g, e.b), s.setXYZ(29, e.r, e.g, e.b), s.setXYZ(30, e.r, e.g, e.b), s.setXYZ(31, e.r, e.g, e.b), s.setXYZ(32, t.r, t.g, t.b), s.setXYZ(33, t.r, t.g, t.b), s.setXYZ(34, t.r, t.g, t.b), s.setXYZ(35, t.r, t.g, t.b), s.setXYZ(36, t.r, t.g, t.b), s.setXYZ(37, t.r, t.g, t.b), s.setXYZ(38, i.r, i.g, i.b), s.setXYZ(39, i.r, i.g, i.b), s.setXYZ(40, r.r, r.g, r.b), s.setXYZ(41, r.r, r.g, r.b), s.setXYZ(42, r.r, r.g, r.b), s.setXYZ(43, r.r, r.g, r.b), s.setXYZ(44, r.r, r.g, r.b), s.setXYZ(45, r.r, r.g, r.b), s.setXYZ(46, r.r, r.g, r.b), s.setXYZ(47, r.r, r.g, r.b), s.setXYZ(48, r.r, r.g, r.b), s.setXYZ(49, r.r, r.g, r.b), s.needsUpdate = !0;
  }
  update() {
    const n = this.geometry, e = this.pointMap;
    Ct.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Ut("c", e, n, Ct, 0, 0, -1), Ut("t", e, n, Ct, 0, 0, 1), Ut("n1", e, n, Ct, -1, -1, -1), Ut("n2", e, n, Ct, 1, -1, -1), Ut("n3", e, n, Ct, -1, 1, -1), Ut("n4", e, n, Ct, 1, 1, -1), Ut("f1", e, n, Ct, -1, -1, 1), Ut("f2", e, n, Ct, 1, -1, 1), Ut("f3", e, n, Ct, -1, 1, 1), Ut("f4", e, n, Ct, 1, 1, 1), Ut("u1", e, n, Ct, 0.7, 1.1, -1), Ut("u2", e, n, Ct, -0.7, 1.1, -1), Ut("u3", e, n, Ct, 0, 2, -1), Ut("cf1", e, n, Ct, -1, 0, 1), Ut("cf2", e, n, Ct, 1, 0, 1), Ut("cf3", e, n, Ct, 0, -1, 1), Ut("cf4", e, n, Ct, 0, 1, 1), Ut("cn1", e, n, Ct, -1, 0, -1), Ut("cn2", e, n, Ct, 1, 0, -1), Ut("cn3", e, n, Ct, 0, -1, -1), Ut("cn4", e, n, Ct, 0, 1, -1), n.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, CanvasTexture: hM, CapsuleGeometry: Yh, CatmullRomCurve3: Bd, CineonToneMapping: Td, CircleGeometry: Zh, ClampToEdgeWrapping: vn, Clock: xh, Color: oe, ColorKeyframeTrack: Hg, ColorManagement: it, CompressedArrayTexture: class extends kc {
  constructor(n, e, t, i, r, s) {
    super(n, e, t, r, s), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = vn, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdates(n) {
    this.layerUpdates.add(n);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}, CompressedCubeTexture: class extends kc {
  constructor(n, e, t) {
    super(void 0, n[0].width, n[0].height, e, t, Cr), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = n;
  }
}, CompressedTexture: kc, CompressedTextureLoader: class extends It {
  constructor(n) {
    super(n);
  }
  load(n, e, t, i) {
    const r = this, s = [], a = new kc(), o = new gn(this.manager);
    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials);
    let l = 0;
    function h(c) {
      o.load(n[c], function(u) {
        const d = r.parse(u, !0);
        s[c] = { width: d.width, height: d.height, format: d.format, mipmaps: d.mipmaps }, l += 1, l === 6 && (d.mipmapCount === 1 && (a.minFilter = Vt), a.image = s, a.format = d.format, a.needsUpdate = !0, e && e(a));
      }, t, i);
    }
    if (Array.isArray(n))
      for (let c = 0, u = n.length; c < u; ++c)
        h(c);
    else
      o.load(n, function(c) {
        const u = r.parse(c, !0);
        if (u.isCubemap) {
          const d = u.mipmaps.length / u.mipmapCount;
          for (let p = 0; p < d; p++) {
            s[p] = { mipmaps: [] };
            for (let m = 0; m < u.mipmapCount; m++)
              s[p].mipmaps.push(u.mipmaps[p * u.mipmapCount + m]), s[p].format = u.format, s[p].width = u.width, s[p].height = u.height;
          }
          a.image = s;
        } else
          a.image.width = u.width, a.image.height = u.height, a.mipmaps = u.mipmaps;
        u.mipmapCount === 1 && (a.minFilter = Vt), a.format = u.format, a.needsUpdate = !0, e && e(a);
      }, t, i);
    return a;
  }
}, ConeGeometry: Kh, ConstantAlphaFactor: 213, ConstantColorFactor: 211, CubeCamera: K1, CubeReflectionMapping: Cr, CubeRefractionMapping: ps, CubeTexture: ph, CubeTextureLoader: Nm, CubeUVReflectionMapping: $o, CubicBezierCurve: Lg, CubicBezierCurve3: uM, CubicInterpolant: SM, CullFaceBack: 1, CullFaceFront: 2, CullFaceFrontBack: 3, CullFaceNone: 0, Curve: Si, CurvePath: pM, CustomBlending: Ro, CustomToneMapping: fg, CylinderGeometry: Pt, Cylindrical: class {
  constructor(n = 1, e = 0, t = 0) {
    return this.radius = n, this.theta = e, this.y = t, this;
  }
  set(n, e, t) {
    return this.radius = n, this.theta = e, this.y = t, this;
  }
  copy(n) {
    return this.radius = n.radius, this.theta = n.theta, this.y = n.y, this;
  }
  setFromVector3(n) {
    return this.setFromCartesianCoords(n.x, n.y, n.z);
  }
  setFromCartesianCoords(n, e, t) {
    return this.radius = Math.sqrt(n * n + t * t), this.theta = Math.atan2(n, t), this.y = e, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, Data3DTexture: bm, DataArrayTexture: Gu, DataTexture: Sr, DataTextureLoader: class extends It {
  constructor(n) {
    super(n);
  }
  load(n, e, t, i) {
    const r = this, s = new Sr(), a = new gn(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(n, function(o) {
      let l;
      try {
        l = r.parse(o);
      } catch (h) {
        if (i === void 0)
          return;
        i(h);
      }
      l.image !== void 0 ? s.image = l.image : l.data !== void 0 && (s.image.width = l.width, s.image.height = l.height, s.image.data = l.data), s.wrapS = l.wrapS !== void 0 ? l.wrapS : vn, s.wrapT = l.wrapT !== void 0 ? l.wrapT : vn, s.magFilter = l.magFilter !== void 0 ? l.magFilter : Vt, s.minFilter = l.minFilter !== void 0 ? l.minFilter : Vt, s.anisotropy = l.anisotropy !== void 0 ? l.anisotropy : 1, l.colorSpace !== void 0 && (s.colorSpace = l.colorSpace), l.flipY !== void 0 && (s.flipY = l.flipY), l.format !== void 0 && (s.format = l.format), l.type !== void 0 && (s.type = l.type), l.mipmaps !== void 0 && (s.mipmaps = l.mipmaps, s.minFilter = er), l.mipmapCount === 1 && (s.minFilter = Vt), l.generateMipmaps !== void 0 && (s.generateMipmaps = l.generateMipmaps), s.needsUpdate = !0, e && e(s, l);
    }, t, i), s;
  }
}, DataUtils: qw, DecrementStencilOp: 7683, DecrementWrapStencilOp: 34056, DefaultLoadingManager: Gg, DepthFormat: Do, DepthStencilFormat: gs, DepthTexture: Wh, DetachedBindMode: H1, DirectionalLight: yh, DirectionalLightHelper: class extends Ue {
  constructor(n, e, t) {
    super(), this.light = n, this.matrix = n.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "DirectionalLightHelper", e === void 0 && (e = 1);
    let i = new Pe();
    i.setAttribute("position", new ye([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
    const r = new kt({ fog: !1, toneMapped: !1 });
    this.lightPlane = new hn(i, r), this.add(this.lightPlane), i = new Pe(), i.setAttribute("position", new ye([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new hn(i, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Ry.setFromMatrixPosition(this.light.matrixWorld), Zc.setFromMatrixPosition(this.light.target.matrixWorld), Iy.subVectors(Zc, Ry), this.lightPlane.lookAt(Zc), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Zc), this.targetLine.scale.z = Iy.length();
  }
}, DiscreteInterpolant: wM, DisplayP3ColorSpace: Rd, DodecahedronGeometry: kd, DoubleSide: bt, DstAlphaFactor: zh, DstColorFactor: Vh, DynamicCopyUsage: 35050, DynamicDrawUsage: 35048, DynamicReadUsage: 35049, EdgesGeometry: fM, EllipseCurve: Fd, EqualCompare: 514, EqualDepth: 4, EqualStencilFunc: 514, EquirectangularReflectionMapping: Lo, EquirectangularRefractionMapping: sh, Euler: gt, EventDispatcher: rr, ExtrudeGeometry: Ia, FileLoader: gn, Float16BufferAttribute: class extends Ke {
  constructor(n, e, t) {
    super(new Uint16Array(n), e, t), this.isFloat16BufferAttribute = !0;
  }
  getX(n) {
    let e = Ol(this.array[n * this.itemSize]);
    return this.normalized && (e = Nn(e, this.array)), e;
  }
  setX(n, e) {
    return this.normalized && (e = Oe(e, this.array)), this.array[n * this.itemSize] = Fn(e), this;
  }
  getY(n) {
    let e = Ol(this.array[n * this.itemSize + 1]);
    return this.normalized && (e = Nn(e, this.array)), e;
  }
  setY(n, e) {
    return this.normalized && (e = Oe(e, this.array)), this.array[n * this.itemSize + 1] = Fn(e), this;
  }
  getZ(n) {
    let e = Ol(this.array[n * this.itemSize + 2]);
    return this.normalized && (e = Nn(e, this.array)), e;
  }
  setZ(n, e) {
    return this.normalized && (e = Oe(e, this.array)), this.array[n * this.itemSize + 2] = Fn(e), this;
  }
  getW(n) {
    let e = Ol(this.array[n * this.itemSize + 3]);
    return this.normalized && (e = Nn(e, this.array)), e;
  }
  setW(n, e) {
    return this.normalized && (e = Oe(e, this.array)), this.array[n * this.itemSize + 3] = Fn(e), this;
  }
  setXY(n, e, t) {
    return n *= this.itemSize, this.normalized && (e = Oe(e, this.array), t = Oe(t, this.array)), this.array[n + 0] = Fn(e), this.array[n + 1] = Fn(t), this;
  }
  setXYZ(n, e, t, i) {
    return n *= this.itemSize, this.normalized && (e = Oe(e, this.array), t = Oe(t, this.array), i = Oe(i, this.array)), this.array[n + 0] = Fn(e), this.array[n + 1] = Fn(t), this.array[n + 2] = Fn(i), this;
  }
  setXYZW(n, e, t, i, r) {
    return n *= this.itemSize, this.normalized && (e = Oe(e, this.array), t = Oe(t, this.array), i = Oe(i, this.array), r = Oe(r, this.array)), this.array[n + 0] = Fn(e), this.array[n + 1] = Fn(t), this.array[n + 2] = Fn(i), this.array[n + 3] = Fn(r), this;
  }
}, Float32BufferAttribute: ye, FloatType: ni, Fog: zo, FogExp2: ko, FramebufferTexture: class extends pt {
  constructor(n, e) {
    super({ width: n, height: e }), this.isFramebufferTexture = !0, this.magFilter = at, this.minFilter = at, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}, FrontSide: Mi, Frustum: jh, GLBufferAttribute: class {
  constructor(n, e, t, i, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = n, this.type = e, this.itemSize = t, this.elementSize = i, this.count = r, this.version = 0;
  }
  set needsUpdate(n) {
    n === !0 && this.version++;
  }
  setBuffer(n) {
    return this.buffer = n, this;
  }
  setType(n, e) {
    return this.type = n, this.elementSize = e, this;
  }
  setItemSize(n) {
    return this.itemSize = n, this;
  }
  setCount(n) {
    return this.count = n, this;
  }
}, GLSL1: "100", GLSL3: xm, GreaterCompare: 516, GreaterDepth: 6, GreaterEqualCompare: 518, GreaterEqualDepth: 5, GreaterEqualStencilFunc: 518, GreaterStencilFunc: 516, GridHelper: LM, Group: yn, HalfFloatType: Ht, HemisphereLight: Dm, HemisphereLightHelper: class extends Ue {
  constructor(n, e, t) {
    super(), this.light = n, this.matrix = n.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "HemisphereLightHelper";
    const i = new wr(e);
    i.rotateY(0.5 * Math.PI), this.material = new Wt({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = i.getAttribute("position"), s = new Float32Array(3 * r.count);
    i.setAttribute("color", new Ke(s, 3)), this.add(new ce(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const n = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const e = n.geometry.getAttribute("color");
      Cy.copy(this.light.color), Py.copy(this.light.groundColor);
      for (let t = 0, i = e.count; t < i; t++) {
        const r = t < i / 2 ? Cy : Py;
        e.setXYZ(t, r.r, r.g, r.b);
      }
      e.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), n.lookAt(pE.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}, IcosahedronGeometry: Vd, ImageBitmapLoader: EM, ImageLoader: Yl, ImageUtils: X1, IncrementStencilOp: 7682, IncrementWrapStencilOp: 34055, InstancedBufferAttribute: da, InstancedBufferGeometry: Wg, InstancedInterleavedBuffer: Ku, InstancedMesh: Em, Int16BufferAttribute: class extends Ke {
  constructor(n, e, t) {
    super(new Int16Array(n), e, t);
  }
}, Int32BufferAttribute: class extends Ke {
  constructor(n, e, t) {
    super(new Int32Array(n), e, t);
  }
}, Int8BufferAttribute: class extends Ke {
  constructor(n, e, t) {
    super(new Int8Array(n), e, t);
  }
}, IntType: gg, InterleavedBuffer: Xh, InterleavedBufferAttribute: zn, Interpolant: tl, InterpolateDiscrete: Oo, InterpolateLinear: Uo, InterpolateSmooth: Ru, InvertStencilOp: 5386, KeepStencilOp: Ks, KeyframeTrack: Oi, LOD: kv, LatheGeometry: qh, Layers: Id, LessCompare: 513, LessDepth: 2, LessEqualCompare: 515, LessEqualDepth: 3, LessEqualStencilFunc: 515, LessStencilFunc: 513, Light: Nr, LightProbe: py, Line: hn, Line3: RM, LineBasicMaterial: kt, LineCurve: Ng, LineCurve3: dM, LineDashedMaterial: xM, LineLoop: Am, LineSegments: Zn, LinearDisplayP3ColorSpace: Gh, LinearFilter: Vt, LinearInterpolant: Vg, LinearMipMapLinearFilter: 1008, LinearMipMapNearestFilter: 1007, LinearMipmapLinearFilter: er, LinearMipmapNearestFilter: xo, LinearSRGBColorSpace: Jt, LinearToneMapping: wd, LinearTransfer: oh, Loader: It, LoaderUtils: tr, LoadingManager: Lm, LoopOnce: wg, LoopPingPong: 2202, LoopRepeat: _g, LuminanceAlphaFormat: 1025, LuminanceFormat: 1024, MOUSE: Ys, Material: Xt, MaterialLoader: Zu, MathUtils: nn, Matrix3: De, Matrix4: fe, MaxEquation: 104, Mesh: ce, MeshBasicMaterial: Wt, MeshDepthMaterial: Od, MeshDistanceMaterial: Rg, MeshLambertMaterial: Xd, MeshMatcapMaterial: yM, MeshNormalMaterial: Wd, MeshPhongMaterial: Aa, MeshPhysicalMaterial: ai, MeshStandardMaterial: jo, MeshToonMaterial: kg, MinEquation: 103, MirroredRepeatWrapping: fs, MixOperation: z1, MultiplyBlending: 4, MultiplyOperation: Hh, NearestFilter: at, NearestMipMapLinearFilter: 1005, NearestMipMapNearestFilter: 1004, NearestMipmapLinearFilter: sa, NearestMipmapNearestFilter: Pd, NeutralToneMapping: mg, NeverCompare: 512, NeverDepth: 0, NeverStencilFunc: 512, NoBlending: 0, NoColorSpace: ea, NoToneMapping: $i, NormalAnimationBlendMode: G1, NormalBlending: 1, NotEqualCompare: 517, NotEqualDepth: 7, NotEqualStencilFunc: 517, NumberKeyframeTrack: vs, Object3D: Ue, ObjectLoader: class extends It {
  constructor(n) {
    super(n);
  }
  load(n, e, t, i) {
    const r = this, s = this.path === "" ? tr.extractUrlBase(n) : this.path;
    this.resourcePath = this.resourcePath || s;
    const a = new gn(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(n, function(o) {
      let l = null;
      try {
        l = JSON.parse(o);
      } catch (c) {
        return void (i !== void 0 && i(c));
      }
      const h = l.metadata;
      h !== void 0 && h.type !== void 0 && h.type.toLowerCase() !== "geometry" ? r.parse(l, e) : i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + n));
    }, t, i);
  }
  loadAsync(n, e) {
    return li(this, null, function* () {
      const t = this.path === "" ? tr.extractUrlBase(n) : this.path;
      this.resourcePath = this.resourcePath || t;
      const i = new gn(this.manager);
      i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials);
      const r = yield i.loadAsync(n, e), s = JSON.parse(r), a = s.metadata;
      if (a === void 0 || a.type === void 0 || a.type.toLowerCase() === "geometry")
        throw new Error("THREE.ObjectLoader: Can't load " + n);
      return yield this.parseAsync(s);
    });
  }
  parse(n, e) {
    const t = this.parseAnimations(n.animations), i = this.parseShapes(n.shapes), r = this.parseGeometries(n.geometries, i), s = this.parseImages(n.images, function() {
      e !== void 0 && e(l);
    }), a = this.parseTextures(n.textures, s), o = this.parseMaterials(n.materials, a), l = this.parseObject(n.object, r, o, a, t), h = this.parseSkeletons(n.skeletons, l);
    if (this.bindSkeletons(l, h), e !== void 0) {
      let c = !1;
      for (const u in s)
        if (s[u].data instanceof HTMLImageElement) {
          c = !0;
          break;
        }
      c === !1 && e(l);
    }
    return l;
  }
  parseAsync(n) {
    return li(this, null, function* () {
      const e = this.parseAnimations(n.animations), t = this.parseShapes(n.shapes), i = this.parseGeometries(n.geometries, t), r = yield this.parseImagesAsync(n.images), s = this.parseTextures(n.textures, r), a = this.parseMaterials(n.materials, s), o = this.parseObject(n.object, i, a, s, e), l = this.parseSkeletons(n.skeletons, o);
      return this.bindSkeletons(o, l), o;
    });
  }
  parseShapes(n) {
    const e = {};
    if (n !== void 0)
      for (let t = 0, i = n.length; t < i; t++) {
        const r = new ls().fromJSON(n[t]);
        e[r.uuid] = r;
      }
    return e;
  }
  parseSkeletons(n, e) {
    const t = {}, i = {};
    if (e.traverse(function(r) {
      r.isBone && (i[r.uuid] = r);
    }), n !== void 0)
      for (let r = 0, s = n.length; r < s; r++) {
        const a = new Ho().fromJSON(n[r], i);
        t[a.uuid] = a;
      }
    return t;
  }
  parseGeometries(n, e) {
    const t = {};
    if (n !== void 0) {
      const i = new fy();
      for (let r = 0, s = n.length; r < s; r++) {
        let a;
        const o = n[r];
        switch (o.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = i.parse(o);
            break;
          default:
            o.type in hy && (a = hy[o.type].fromJSON(o, e));
        }
        a.uuid = o.uuid, o.name !== void 0 && (a.name = o.name), o.userData !== void 0 && (a.userData = o.userData), t[o.uuid] = a;
      }
    }
    return t;
  }
  parseMaterials(n, e) {
    const t = {}, i = {};
    if (n !== void 0) {
      const r = new Zu();
      r.setTextures(e);
      for (let s = 0, a = n.length; s < a; s++) {
        const o = n[s];
        t[o.uuid] === void 0 && (t[o.uuid] = r.parse(o)), i[o.uuid] = t[o.uuid];
      }
    }
    return i;
  }
  parseAnimations(n) {
    const e = {};
    if (n !== void 0)
      for (let t = 0; t < n.length; t++) {
        const i = n[t], r = pa.parse(i);
        e[r.uuid] = r;
      }
    return e;
  }
  parseImages(n, e) {
    const t = this, i = {};
    let r;
    function s(a) {
      if (typeof a == "string") {
        const o = a;
        return function(l) {
          return t.manager.itemStart(l), r.load(l, function() {
            t.manager.itemEnd(l);
          }, void 0, function() {
            t.manager.itemError(l), t.manager.itemEnd(l);
          });
        }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o);
      }
      return a.data ? { data: lo(a.type, a.data), width: a.width, height: a.height } : null;
    }
    if (n !== void 0 && n.length > 0) {
      const a = new Lm(e);
      r = new Yl(a), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, l = n.length; o < l; o++) {
        const h = n[o], c = h.url;
        if (Array.isArray(c)) {
          const u = [];
          for (let d = 0, p = c.length; d < p; d++) {
            const m = s(c[d]);
            m !== null && (m instanceof HTMLImageElement ? u.push(m) : u.push(new Sr(m.data, m.width, m.height)));
          }
          i[h.uuid] = new ta(u);
        } else {
          const u = s(h.url);
          i[h.uuid] = new ta(u);
        }
      }
    }
    return i;
  }
  parseImagesAsync(n) {
    return li(this, null, function* () {
      const e = this, t = {};
      let i;
      function r(s) {
        return li(this, null, function* () {
          if (typeof s == "string") {
            const a = s, o = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : e.resourcePath + a;
            return yield i.loadAsync(o);
          }
          return s.data ? { data: lo(s.type, s.data), width: s.width, height: s.height } : null;
        });
      }
      if (n !== void 0 && n.length > 0) {
        i = new Yl(this.manager), i.setCrossOrigin(this.crossOrigin);
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s], l = o.url;
          if (Array.isArray(l)) {
            const h = [];
            for (let c = 0, u = l.length; c < u; c++) {
              const d = l[c], p = yield r(d);
              p !== null && (p instanceof HTMLImageElement ? h.push(p) : h.push(new Sr(p.data, p.width, p.height)));
            }
            t[o.uuid] = new ta(h);
          } else {
            const h = yield r(o.url);
            t[o.uuid] = new ta(h);
          }
        }
      }
      return t;
    });
  }
  parseTextures(n, e) {
    function t(r, s) {
      return typeof r == "number" ? r : s[r];
    }
    const i = {};
    if (n !== void 0)
      for (let r = 0, s = n.length; r < s; r++) {
        const a = n[r];
        a.image, e[a.image];
        const o = e[a.image], l = o.data;
        let h;
        Array.isArray(l) ? (h = new ph(), l.length === 6 && (h.needsUpdate = !0)) : (h = l && l.data ? new Sr() : new pt(), l && (h.needsUpdate = !0)), h.source = o, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = t(a.mapping, rE)), a.channel !== void 0 && (h.channel = a.channel), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = t(a.wrap[0], my), h.wrapT = t(a.wrap[1], my)), a.format !== void 0 && (h.format = a.format), a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat), a.type !== void 0 && (h.type = a.type), a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace), a.minFilter !== void 0 && (h.minFilter = t(a.minFilter, gy)), a.magFilter !== void 0 && (h.magFilter = t(a.magFilter, gy)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction), a.userData !== void 0 && (h.userData = a.userData), i[a.uuid] = h;
      }
    return i;
  }
  parseObject(n, e, t, i, r) {
    let s, a, o;
    function l(u) {
      return e[u], e[u];
    }
    function h(u) {
      if (u !== void 0) {
        if (Array.isArray(u)) {
          const d = [];
          for (let p = 0, m = u.length; p < m; p++) {
            const g = u[p];
            t[g], d.push(t[g]);
          }
          return d;
        }
        return t[u], t[u];
      }
    }
    function c(u) {
      return i[u], i[u];
    }
    switch (n.type) {
      case "Scene":
        s = new _m(), n.background !== void 0 && (Number.isInteger(n.background) ? s.background = new oe(n.background) : s.background = c(n.background)), n.environment !== void 0 && (s.environment = c(n.environment)), n.fog !== void 0 && (n.fog.type === "Fog" ? s.fog = new zo(n.fog.color, n.fog.near, n.fog.far) : n.fog.type === "FogExp2" && (s.fog = new ko(n.fog.color, n.fog.density)), n.fog.name !== "" && (s.fog.name = n.fog.name)), n.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = n.backgroundBlurriness), n.backgroundIntensity !== void 0 && (s.backgroundIntensity = n.backgroundIntensity), n.backgroundRotation !== void 0 && s.backgroundRotation.fromArray(n.backgroundRotation), n.environmentIntensity !== void 0 && (s.environmentIntensity = n.environmentIntensity), n.environmentRotation !== void 0 && s.environmentRotation.fromArray(n.environmentRotation);
        break;
      case "PerspectiveCamera":
        s = new Gt(n.fov, n.aspect, n.near, n.far), n.focus !== void 0 && (s.focus = n.focus), n.zoom !== void 0 && (s.zoom = n.zoom), n.filmGauge !== void 0 && (s.filmGauge = n.filmGauge), n.filmOffset !== void 0 && (s.filmOffset = n.filmOffset), n.view !== void 0 && (s.view = Object.assign({}, n.view));
        break;
      case "OrthographicCamera":
        s = new _a(n.left, n.right, n.top, n.bottom, n.near, n.far), n.zoom !== void 0 && (s.zoom = n.zoom), n.view !== void 0 && (s.view = Object.assign({}, n.view));
        break;
      case "AmbientLight":
        s = new Yu(n.color, n.intensity);
        break;
      case "DirectionalLight":
        s = new yh(n.color, n.intensity);
        break;
      case "PointLight":
        s = new Wo(n.color, n.intensity, n.distance, n.decay);
        break;
      case "RectAreaLight":
        s = new Om(n.color, n.intensity, n.width, n.height);
        break;
      case "SpotLight":
        s = new vh(n.color, n.intensity, n.distance, n.angle, n.penumbra, n.decay);
        break;
      case "HemisphereLight":
        s = new Dm(n.color, n.groundColor, n.intensity);
        break;
      case "LightProbe":
        s = new py().fromJSON(n);
        break;
      case "SkinnedMesh":
        a = l(n.geometry), o = h(n.material), s = new ju(a, o), n.bindMode !== void 0 && (s.bindMode = n.bindMode), n.bindMatrix !== void 0 && s.bindMatrix.fromArray(n.bindMatrix), n.skeleton !== void 0 && (s.skeleton = n.skeleton);
        break;
      case "Mesh":
        a = l(n.geometry), o = h(n.material), s = new ce(a, o);
        break;
      case "InstancedMesh":
        a = l(n.geometry), o = h(n.material);
        const u = n.count, d = n.instanceMatrix, p = n.instanceColor;
        s = new Em(a, o, u), s.instanceMatrix = new da(new Float32Array(d.array), 16), p !== void 0 && (s.instanceColor = new da(new Float32Array(p.array), p.itemSize));
        break;
      case "BatchedMesh":
        a = l(n.geometry), o = h(n.material), s = new Kv(n.maxGeometryCount, n.maxVertexCount, n.maxIndexCount, o), s.geometry = a, s.perObjectFrustumCulled = n.perObjectFrustumCulled, s.sortObjects = n.sortObjects, s.j = n.drawRanges, s.J = n.reservedRanges, s.$ = n.visibility, s.tt = n.active, s.et = n.bounds.map((m) => {
          const g = new yt();
          g.min.fromArray(m.boxMin), g.max.fromArray(m.boxMax);
          const f = new rn();
          return f.radius = m.sphereRadius, f.center.fromArray(m.sphereCenter), { boxInitialized: m.boxInitialized, box: g, sphereInitialized: m.sphereInitialized, sphere: f };
        }), s.nt = n.maxGeometryCount, s.it = n.maxVertexCount, s.st = n.maxIndexCount, s.rt = n.geometryInitialized, s.ot = n.geometryCount, s.ht = c(n.matricesTexture.uuid), n.colorsTexture !== void 0 && (s.ct = c(n.colorsTexture.uuid));
        break;
      case "LOD":
        s = new kv();
        break;
      case "Line":
        s = new hn(l(n.geometry), h(n.material));
        break;
      case "LineLoop":
        s = new Am(l(n.geometry), h(n.material));
        break;
      case "LineSegments":
        s = new Zn(l(n.geometry), h(n.material));
        break;
      case "PointCloud":
      case "Points":
        s = new os(l(n.geometry), h(n.material));
        break;
      case "Sprite":
        s = new Tm(h(n.material));
        break;
      case "Group":
        s = new yn();
        break;
      case "Bone":
        s = new Vo();
        break;
      default:
        s = new Ue();
    }
    if (s.uuid = n.uuid, n.name !== void 0 && (s.name = n.name), n.matrix !== void 0 ? (s.matrix.fromArray(n.matrix), n.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = n.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (n.position !== void 0 && s.position.fromArray(n.position), n.rotation !== void 0 && s.rotation.fromArray(n.rotation), n.quaternion !== void 0 && s.quaternion.fromArray(n.quaternion), n.scale !== void 0 && s.scale.fromArray(n.scale)), n.up !== void 0 && s.up.fromArray(n.up), n.castShadow !== void 0 && (s.castShadow = n.castShadow), n.receiveShadow !== void 0 && (s.receiveShadow = n.receiveShadow), n.shadow && (n.shadow.bias !== void 0 && (s.shadow.bias = n.shadow.bias), n.shadow.normalBias !== void 0 && (s.shadow.normalBias = n.shadow.normalBias), n.shadow.radius !== void 0 && (s.shadow.radius = n.shadow.radius), n.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(n.shadow.mapSize), n.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(n.shadow.camera))), n.visible !== void 0 && (s.visible = n.visible), n.frustumCulled !== void 0 && (s.frustumCulled = n.frustumCulled), n.renderOrder !== void 0 && (s.renderOrder = n.renderOrder), n.userData !== void 0 && (s.userData = n.userData), n.layers !== void 0 && (s.layers.mask = n.layers), n.children !== void 0) {
      const u = n.children;
      for (let d = 0; d < u.length; d++)
        s.add(this.parseObject(u[d], e, t, i, r));
    }
    if (n.animations !== void 0) {
      const u = n.animations;
      for (let d = 0; d < u.length; d++) {
        const p = u[d];
        s.animations.push(r[p]);
      }
    }
    if (n.type === "LOD") {
      n.autoUpdate !== void 0 && (s.autoUpdate = n.autoUpdate);
      const u = n.levels;
      for (let d = 0; d < u.length; d++) {
        const p = u[d], m = s.getObjectByProperty("uuid", p.object);
        m !== void 0 && s.addLevel(m, p.distance, p.hysteresis);
      }
    }
    return s;
  }
  bindSkeletons(n, e) {
    Object.keys(e).length !== 0 && n.traverse(function(t) {
      if (t.isSkinnedMesh === !0 && t.skeleton !== void 0) {
        const i = e[t.skeleton];
        i === void 0 || t.bind(i, t.bindMatrix);
      }
    });
  }
}, ObjectSpaceNormalMap: 1, OctahedronGeometry: wr, OneFactor: kh, OneMinusConstantAlphaFactor: 214, OneMinusConstantColorFactor: 212, OneMinusDstAlphaFactor: bd, OneMinusDstColorFactor: Sd, OneMinusSrcAlphaFactor: ds, OneMinusSrcColorFactor: Md, OrthographicCamera: _a, P3Primaries: hh, PCFShadowMap: yd, PCFSoftShadowMap: pg, PMREMGenerator: Sm, Path: Go, PerspectiveCamera: Gt, Plane: Li, PlaneGeometry: or, PlaneHelper: DM, PointLight: Wo, PointLightHelper: class extends ce {
  constructor(n, e, t) {
    super(new Ea(e, 4, 2), new Wt({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = n, this.color = t, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}, Points: os, PointsMaterial: Jr, PolarGridHelper: class extends Zn {
  constructor(n = 10, e = 16, t = 8, i = 64, r = 4473924, s = 8947848) {
    r = new oe(r), s = new oe(s);
    const a = [], o = [];
    if (e > 1)
      for (let h = 0; h < e; h++) {
        const c = h / e * (2 * Math.PI), u = Math.sin(c) * n, d = Math.cos(c) * n;
        a.push(0, 0, 0), a.push(u, 0, d);
        const p = 1 & h ? r : s;
        o.push(p.r, p.g, p.b), o.push(p.r, p.g, p.b);
      }
    for (let h = 0; h < t; h++) {
      const c = 1 & h ? r : s, u = n - n / t * h;
      for (let d = 0; d < i; d++) {
        let p = d / i * (2 * Math.PI), m = Math.sin(p) * u, g = Math.cos(p) * u;
        a.push(m, 0, g), o.push(c.r, c.g, c.b), p = (d + 1) / i * (2 * Math.PI), m = Math.sin(p) * u, g = Math.cos(p) * u, a.push(m, 0, g), o.push(c.r, c.g, c.b);
      }
    }
    const l = new Pe();
    l.setAttribute("position", new ye(a, 3)), l.setAttribute("color", new ye(o, 3)), super(l, new kt({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, PolyhedronGeometry: ws, PositionalAudio: class extends by {
  constructor(n) {
    super(n), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(n) {
    return this.panner.refDistance = n, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(n) {
    return this.panner.rolloffFactor = n, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(n) {
    return this.panner.distanceModel = n, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(n) {
    return this.panner.maxDistance = n, this;
  }
  setDirectionalCone(n, e, t) {
    return this.panner.coneInnerAngle = n, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = t, this;
  }
  updateMatrixWorld(n) {
    if (super.updateMatrixWorld(n), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(zs, Sy, aE), Vs.set(0, 0, 1).applyQuaternion(Sy);
    const e = this.panner;
    if (e.positionX) {
      const t = this.context.currentTime + this.listener.timeDelta;
      e.positionX.linearRampToValueAtTime(zs.x, t), e.positionY.linearRampToValueAtTime(zs.y, t), e.positionZ.linearRampToValueAtTime(zs.z, t), e.orientationX.linearRampToValueAtTime(Vs.x, t), e.orientationY.linearRampToValueAtTime(Vs.y, t), e.orientationZ.linearRampToValueAtTime(Vs.z, t);
    } else
      e.setPosition(zs.x, zs.y, zs.z), e.setOrientation(Vs.x, Vs.y, Vs.z);
  }
}, PropertyBinding: qe, PropertyMixer: AM, QuadraticBezierCurve: Dg, QuadraticBezierCurve3: Og, Quaternion: Ye, QuaternionKeyframeTrack: Rr, QuaternionLinearInterpolant: _M, RED_GREEN_RGTC2_Format: vm, RED_RGTC1_Format: 36283, REVISION: Hu, RGBADepthPacking: Eg, RGBAFormat: yi, RGBAIntegerFormat: Sg, RGBA_ASTC_10x10_Format: um, RGBA_ASTC_10x5_Format: lm, RGBA_ASTC_10x6_Format: hm, RGBA_ASTC_10x8_Format: cm, RGBA_ASTC_12x10_Format: dm, RGBA_ASTC_12x12_Format: pm, RGBA_ASTC_4x4_Format: em, RGBA_ASTC_5x4_Format: tm, RGBA_ASTC_5x5_Format: nm, RGBA_ASTC_6x5_Format: im, RGBA_ASTC_6x6_Format: rm, RGBA_ASTC_8x5_Format: sm, RGBA_ASTC_8x6_Format: am, RGBA_ASTC_8x8_Format: om, RGBA_BPTC_Format: Pu, RGBA_ETC2_EAC_Format: $f, RGBA_PVRTC_2BPPV1_Format: Kf, RGBA_PVRTC_4BPPV1_Format: Zf, RGBA_S3TC_DXT1_Format: Eu, RGBA_S3TC_DXT3_Format: Au, RGBA_S3TC_DXT5_Format: Cu, RGBFormat: 1022, RGB_BPTC_SIGNED_Format: fm, RGB_BPTC_UNSIGNED_Format: mm, RGB_ETC1_Format: Jf, RGB_ETC2_Format: Qf, RGB_PVRTC_2BPPV1_Format: Yf, RGB_PVRTC_4BPPV1_Format: qf, RGB_S3TC_DXT1_Format: Tu, RGFormat: 1030, RGIntegerFormat: bg, RawShaderMaterial: Bg, Ray: Ra, Raycaster: qd, Rec709Primaries: lh, RectAreaLight: Om, RedFormat: xg, RedIntegerFormat: Mg, ReinhardToneMapping: _d, RenderTarget: q1, RepeatWrapping: jt, ReplaceStencilOp: 7681, ReverseSubtractEquation: 102, RingGeometry: Jh, SIGNED_RED_GREEN_RGTC2_Format: ym, SIGNED_RED_RGTC1_Format: gm, SRGBColorSpace: mt, SRGBTransfer: ft, Scene: _m, ShaderChunk: ke, ShaderLib: In, ShaderMaterial: tt, ShadowMaterial: vM, Shape: ls, ShapeGeometry: Hd, ShapePath: UM, ShapeUtils: Di, ShortType: 1011, Skeleton: Ho, SkeletonHelper: class extends Zn {
  constructor(n) {
    const e = IM(n), t = new Pe(), i = [], r = [], s = new oe(0, 0, 1), a = new oe(0, 1, 0);
    for (let o = 0; o < e.length; o++) {
      const l = e[o];
      l.parent && l.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b));
    }
    t.setAttribute("position", new ye(i, 3)), t.setAttribute("color", new ye(r, 3)), super(t, new kt({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = n, this.bones = e, this.matrix = n.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(n) {
    const e = this.bones, t = this.geometry, i = t.getAttribute("position");
    Qp.copy(this.root.matrixWorld).invert();
    for (let r = 0, s = 0; r < e.length; r++) {
      const a = e[r];
      a.parent && a.parent.isBone && (Yc.multiplyMatrices(Qp, a.matrixWorld), jr.setFromMatrixPosition(Yc), i.setXYZ(s, jr.x, jr.y, jr.z), Yc.multiplyMatrices(Qp, a.parent.matrixWorld), jr.setFromMatrixPosition(Yc), i.setXYZ(s + 1, jr.x, jr.y, jr.z), s += 2);
    }
    t.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(n);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}, SkinnedMesh: ju, Source: ta, Sphere: rn, SphereGeometry: Ea, Spherical: Fm, SphericalHarmonics3: TM, SplineCurve: Ug, SpotLight: vh, SpotLightHelper: class extends Ue {
  constructor(n, e) {
    super(), this.light = n, this.matrixAutoUpdate = !1, this.color = e, this.type = "SpotLightHelper";
    const t = new Pe(), i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (let s = 0, a = 1, o = 32; s < o; s++, a++) {
      const l = s / o * Math.PI * 2, h = a / o * Math.PI * 2;
      i.push(Math.cos(l), Math.sin(l), 1, Math.cos(h), Math.sin(h), 1);
    }
    t.setAttribute("position", new ye(i, 3));
    const r = new kt({ fog: !1, toneMapped: !1 });
    this.cone = new Zn(t, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const n = this.light.distance ? this.light.distance : 1e3, e = n * Math.tan(this.light.angle);
    this.cone.scale.set(e, e, n), Ay.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Ay), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}, Sprite: Tm, SpriteMaterial: Ud, SrcAlphaFactor: us, SrcAlphaSaturateFactor: 210, SrcColorFactor: xd, StaticCopyUsage: 35046, StaticDrawUsage: ch, StaticReadUsage: 35045, StereoCamera: class {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Gt(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Gt(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this.Ti = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }
  update(n) {
    const e = this.Ti;
    if (e.focus !== n.focus || e.fov !== n.fov || e.aspect !== n.aspect * this.aspect || e.near !== n.near || e.far !== n.far || e.zoom !== n.zoom || e.eyeSep !== this.eyeSep) {
      e.focus = n.focus, e.fov = n.fov, e.aspect = n.aspect * this.aspect, e.near = n.near, e.far = n.far, e.zoom = n.zoom, e.eyeSep = this.eyeSep, Fs.copy(n.projectionMatrix);
      const t = e.eyeSep / 2, i = t * e.near / e.focus, r = e.near * Math.tan(ua * e.fov * 0.5) / e.zoom;
      let s, a;
      yy.elements[12] = -t, vy.elements[12] = t, s = -r * e.aspect + i, a = r * e.aspect + i, Fs.elements[0] = 2 * e.near / (a - s), Fs.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(Fs), s = -r * e.aspect - i, a = r * e.aspect - i, Fs.elements[0] = 2 * e.near / (a - s), Fs.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(Fs);
    }
    this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(yy), this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(vy);
  }
}, StreamCopyUsage: 35042, StreamDrawUsage: 35040, StreamReadUsage: 35041, StringKeyframeTrack: ia, SubtractEquation: 101, SubtractiveBlending: 3, TOUCH: Zs, TangentSpaceNormalMap: 0, TetrahedronGeometry: Gd, Texture: pt, TextureLoader: Ui, TorusGeometry: Ki, TorusKnotGeometry: jd, Triangle: ei, TriangleFanDrawMode: 2, TriangleStripDrawMode: 1, TrianglesDrawMode: 0, TubeGeometry: Pr, UVMapping: Cd, Uint16BufferAttribute: Ld, Uint32BufferAttribute: Cg, Uint8BufferAttribute: class extends Ke {
  constructor(n, e, t) {
    super(new Uint8Array(n), e, t);
  }
}, Uint8ClampedBufferAttribute: class extends Ke {
  constructor(n, e, t) {
    super(new Uint8ClampedArray(n), e, t);
  }
}, Uniform: qg, UniformsGroup: class extends rr {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: dE++ }), this.name = "", this.usage = ch, this.uniforms = [];
  }
  add(n) {
    return this.uniforms.push(n), this;
  }
  remove(n) {
    const e = this.uniforms.indexOf(n);
    return e !== -1 && this.uniforms.splice(e, 1), this;
  }
  setName(n) {
    return this.name = n, this;
  }
  setUsage(n) {
    return this.usage = n, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(n) {
    this.name = n.name, this.usage = n.usage;
    const e = n.uniforms;
    this.uniforms.length = 0;
    for (let t = 0, i = e.length; t < i; t++) {
      const r = Array.isArray(e[t]) ? e[t] : [e[t]];
      for (let s = 0; s < r.length; s++)
        this.uniforms.push(r[s].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, UniformsLib: xe, UniformsUtils: Kt, UnsignedByteType: ba, UnsignedInt248Type: ms, UnsignedInt5999Type: 35902, UnsignedIntType: Sa, UnsignedShort4444Type: vg, UnsignedShort5551Type: yg, UnsignedShortType: No, VSMShadowMap: Ri, Vector2: X, Vector3: _, Vector4: Ve, VectorKeyframeTrack: ys, VideoTexture: lM, WebGL3DRenderTarget: class extends ht {
  constructor(n = 1, e = 1, t = 1, i = {}) {
    super(n, e, i), this.isWebGL3DRenderTarget = !0, this.depth = t, this.texture = new bm(null, n, e, t), this.texture.isRenderTargetTexture = !0;
  }
}, WebGLArrayRenderTarget: class extends ht {
  constructor(n = 1, e = 1, t = 1, i = {}) {
    super(n, e, i), this.isWebGLArrayRenderTarget = !0, this.depth = t, this.texture = new Gu(null, n, e, t), this.texture.isRenderTargetTexture = !0;
  }
}, WebGLCoordinateSystem: wa, WebGLCubeRenderTarget: J1, WebGLMultipleRenderTargets: class extends ht {
  constructor(n = 1, e = 1, t = 1, i = {}) {
    super(n, e, $t(Te({}, i), { count: t })), this.isWebGLMultipleRenderTargets = !0;
  }
  get texture() {
    return this.textures;
  }
}, WebGLRenderTarget: ht, WebGLRenderer: aM, WebGLUtils: rM, WebGPUCoordinateSystem: uh, WireframeGeometry: Fg, WrapAroundEnding: ah, ZeroCurvatureEnding: aa, ZeroFactor: Io, ZeroSlopeEnding: oa, ZeroStencilOp: 0, createCanvasElement: W1 }, Symbol.toStringTag, { value: "Module" }));
function gr(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function FM(n, e) {
  n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e;
}
var Yg, En, Mt, Tt, Zi, Bm, Zg, BM, kM, co, Mh, xl, $c, ef, Ny, Dy, Oy, si = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, Xo = { duration: 0.5, overwrite: !1, delay: 0 }, Tr = 1e8, On = 1e-8, km = 2 * Math.PI, fE = km / 4, mE = 0, zM = Math.sqrt, gE = Math.cos, vE = Math.sin, un = function(n) {
  return typeof n == "string";
}, Lt = function(n) {
  return typeof n == "function";
}, Ir = function(n) {
  return typeof n == "number";
}, Kg = function(n) {
  return n === void 0;
}, sr = function(n) {
  return typeof n == "object";
}, Hn = function(n) {
  return n !== !1;
}, Jg = function() {
  return typeof window != "undefined";
}, eu = function(n) {
  return Lt(n) || un(n);
}, VM = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, wn = Array.isArray, zm = /(?:-?\.?\d|\.)+/gi, HM = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, uo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, tf = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, GM = /[+-]=-?[.\d]+/, jM = /[^,'"\[\]\s]+/gi, yE = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, ii = {}, Ju = {}, WM = function(n) {
  return (Ju = Ca(n, ii)) && jn;
}, bh = function(n, e) {
  return !e && void 0;
}, XM = function(n, e) {
  return n && (ii[n] = e) && Ju && (Ju[n] = e) || ii;
}, Sh = function() {
  return 0;
}, xE = { suppressEvents: !0, isStart: !0, kill: !1 }, Lu = { suppressEvents: !0, kill: !1 }, ME = { suppressEvents: !0 }, Qg = {}, hs = [], Vm = {}, Kn = {}, nf = {}, Uy = 30, Nu = [], $g = "", e0 = function(n) {
  var e, t, i = n[0];
  if (sr(i) || Lt(i) || (n = [n]), !(e = (i.Ci || {}).harness)) {
    for (t = Nu.length; t-- && !Nu[t].targetTest(i); )
      ;
    e = Nu[t];
  }
  for (t = n.length; t--; )
    n[t] && (n[t].Ci || (n[t].Ci = new pb(n[t], e))) || n.splice(t, 1);
  return n;
}, fa = function(n) {
  return n.Ci || e0(vi(n))[0].Ci;
}, qM = function(n, e, t) {
  return (t = n[e]) && Lt(t) ? n[e]() : Kg(t) && n.getAttribute && n.getAttribute(e) || t;
}, Vn = function(n, e) {
  return (n = n.split(",")).forEach(e) || n;
}, zt = function(n) {
  return Math.round(1e5 * n) / 1e5 || 0;
}, cn = function(n) {
  return Math.round(1e7 * n) / 1e7 || 0;
}, bo = function(n, e) {
  var t = e.charAt(0), i = parseFloat(e.substr(2));
  return n = parseFloat(n), t === "+" ? n + i : t === "-" ? n - i : t === "*" ? n * i : n / i;
}, bE = function(n, e) {
  for (var t = e.length, i = 0; n.indexOf(e[i]) < 0 && ++i < t; )
    ;
  return i < t;
}, Qu = function() {
  var n, e, t = hs.length, i = hs.slice(0);
  for (Vm = {}, hs.length = 0, n = 0; n < t; n++)
    (e = i[n]) && e.Pi && (e.render(e.Pi[0], e.Pi[1], !0).Pi = 0);
}, YM = function(n, e, t, i) {
  hs.length && !En && Qu(), n.render(e, t, En && e < 0 && (n.Li || n.Ni)), hs.length && !En && Qu();
}, ZM = function(n) {
  var e = parseFloat(n);
  return (e || e === 0) && (n + "").match(jM).length < 2 ? e : un(n) ? n.trim() : n;
}, KM = function(n) {
  return n;
}, bi = function(n, e) {
  for (var t in e)
    t in n || (n[t] = e[t]);
  return n;
}, Ca = function(n, e) {
  for (var t in e)
    n[t] = e[t];
  return n;
}, Fy = function n(e, t) {
  for (var i in t)
    i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = sr(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
  return e;
}, $u = function(n, e) {
  var t, i = {};
  for (t in n)
    t in e || (i[t] = n[t]);
  return i;
}, Zl = function(n) {
  var e, t = n.parent || Tt, i = n.keyframes ? (e = wn(n.keyframes), function(r, s) {
    for (var a in s)
      a in r || a === "duration" && e || a === "ease" || (r[a] = s[a]);
  }) : bi;
  if (Hn(n.inherit))
    for (; t; )
      i(n, t.vars.defaults), t = t.parent || t.Ri;
  return n;
}, JM = function(n, e, t, i, r) {
  var s, a = n[i];
  if (r)
    for (s = e[r]; a && a[r] > s; )
      a = a.Di;
  return a ? (e.Ii = a.Ii, a.Ii = e) : (e.Ii = n[t], n[t] = e), e.Ii ? e.Ii.Di = e : n[i] = e, e.Di = a, e.parent = e.Ri = n, e;
}, Yd = function(n, e, t, i) {
  t === void 0 && (t = "_first"), i === void 0 && (i = "_last");
  var r = e.Di, s = e.Ii;
  r ? r.Ii = s : n[t] === e && (n[t] = s), s ? s.Di = r : n[i] === e && (n[i] = r), e.Ii = e.Di = e.parent = null;
}, xs = function(n, e) {
  n.parent && (!e || n.parent.autoRemoveChildren) && n.parent.remove && n.parent.remove(n), n.Ui = 0;
}, ma = function(n, e) {
  if (n && (!e || e.Oi > n.ki || e.Fi < 0))
    for (var t = n; t; )
      t.Gi = 1, t = t.parent;
  return n;
}, rf = function(n, e, t, i) {
  return n.Ni && (En ? n.Ni.revert(Lu) : n.vars.immediateRender && !n.vars.autoRevert || n.Ni.render(e, !0, i));
}, SE = function n(e) {
  return !e || e.Bi && n(e.parent);
}, By = function(n) {
  return n.Hi ? So(n.zi, n = n.duration() + n.Vi) * n : 0;
}, So = function(n, e) {
  var t = Math.floor(n /= e);
  return n && t === n ? t - 1 : t;
}, ed = function(n, e) {
  return (n - e.Fi) * e.Bi + (e.Bi >= 0 ? 0 : e.Gi ? e.totalDuration() : e.Wi);
}, Zd = function(n) {
  return n.Oi = cn(n.Fi + (n.Wi / Math.abs(n.Bi || n.ji || On) || 0));
}, Kd = function(n, e) {
  var t = n.Ri;
  return t && t.smoothChildTiming && n.Bi && (n.Fi = cn(t.Xi - (n.Bi > 0 ? e / n.Bi : ((n.Gi ? n.totalDuration() : n.Wi) - e) / -n.Bi)), Zd(n), t.Gi || ma(t, n)), n;
}, QM = function(n, e) {
  var t;
  if ((e.Xi || !e.ki && e.Li || e.Fi < n.Xi && (e.ki || !e.add)) && (t = ed(n.rawTime(), e), (!e.ki || Qh(0, e.totalDuration(), t) - e.zi > On) && e.render(t, !0)), ma(n, e).Ri && n.Li && n.Xi >= n.ki && n.Bi) {
    if (n.ki < n.duration())
      for (t = n; t.Ri; )
        t.rawTime() >= 0 && t.totalTime(t.zi), t = t.Ri;
    n.Yi = -1e-8;
  }
}, Ji = function(n, e, t, i) {
  return e.parent && xs(e), e.Fi = cn((Ir(t) ? t : t || n !== Tt ? ui(n, t, e) : n.Xi) + e.qi), e.Oi = cn(e.Fi + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), JM(n, e, "_first", "_last", n.Zi ? "_start" : 0), Hm(e) || (n.Ji = e), i || QM(n, e), n.Bi < 0 && Kd(n, n.zi), n;
}, $M = function(n, e) {
  return ii.ScrollTrigger ? ii.ScrollTrigger.create(e, n) : void 0;
}, ky = function(n, e, t, i, r) {
  return qm(n, e, r), n.Li ? !t && n.Ki && !En && (n.ki && n.vars.lazy !== !1 || !n.ki && n.vars.lazy) && kM !== ti.frame ? (hs.push(n), n.Pi = [r, i], 1) : void 0 : 1;
}, wE = function n(e) {
  var t = e.parent;
  return t && t.Bi && t.Li && !t.$i && (t.rawTime() < 0 || n(t));
}, Hm = function(n) {
  var e = n.data;
  return e === "isFromStart" || e === "isStart";
}, qo = function(n, e, t, i) {
  var r = n.Hi, s = cn(e) || 0, a = n.zi / n.Wi;
  return a && !i && (n.Xi *= s / n.ki), n.ki = s, n.Wi = r ? r < 0 ? 1e10 : cn(s * (r + 1) + n.Vi * r) : s, a > 0 && !i && Kd(n, n.zi = n.Wi * a), n.parent && Zd(n), t || ma(n.parent, n), n;
}, zy = function(n) {
  return n instanceof Dn ? ma(n) : qo(n, n.ki);
}, _E = { Fi: 0, endTime: Sh, totalDuration: Sh }, ui = function n(e, t, i) {
  var r, s, a, o = e.labels, l = e.Ji || _E, h = e.duration() >= Tr ? l.endTime(!1) : e.ki;
  return un(t) && (isNaN(t) || t in o) ? (s = t.charAt(0), a = t.substr(-1) === "%", r = t.indexOf("="), s === "<" || s === ">" ? (r >= 0 && (t = t.replace(/=/, "")), (s === "<" ? l.Fi : l.endTime(l.Hi >= 0)) + (parseFloat(t.substr(1)) || 0) * (a ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (t in o || (o[t] = h), o[t]) : (s = parseFloat(t.charAt(r - 1) + t.substr(r + 1)), a && i && (s = s / 100 * (wn(i) ? i[0] : i).totalDuration()), r > 1 ? n(e, t.substr(0, r - 1), i) + s : h + s)) : t == null ? h : +t;
}, Kl = function(n, e, t) {
  var i, r, s = Ir(e[1]), a = (s ? 2 : 1) + (n < 2 ? 0 : 1), o = e[a];
  if (s && (o.duration = e[1]), o.parent = t, n) {
    for (i = o, r = t; r && !("immediateRender" in i); )
      i = r.vars.defaults || {}, r = Hn(r.vars.inherit) && r.parent;
    o.immediateRender = Hn(i.immediateRender), n < 2 ? o.runBackwards = 1 : o.startAt = e[a - 1];
  }
  return new Zt(e[0], o, e[a + 1]);
}, Qr = function(n, e) {
  return n || n === 0 ? e(n) : e;
}, Qh = function(n, e, t) {
  return t < n ? n : t > e ? e : t;
}, _n = function(n, e) {
  return un(n) && (e = yE.exec(n)) ? e[1] : "";
}, Gm = [].slice, eb = function(n, e) {
  return n && sr(n) && "length" in n && (!e && !n.length || n.length - 1 in n && sr(n[0])) && !n.nodeType && n !== Zi;
}, TE = function(n, e, t) {
  return t === void 0 && (t = []), n.forEach(function(i) {
    var r;
    return un(i) && !e || eb(i, 1) ? (r = t).push.apply(r, vi(i)) : t.push(i);
  }) || t;
}, vi = function(n, e, t) {
  return Mt && !e && Mt.selector ? Mt.selector(n) : !un(n) || t || !Bm && Yo() ? wn(n) ? TE(n, t) : eb(n) ? Gm.call(n, 0) : n ? [n] : [] : Gm.call((e || Zg).querySelectorAll(n), 0);
}, jm = function(n) {
  return n = vi(n)[0] || bh() || {}, function(e) {
    var t = n.current || n.nativeElement || n;
    return vi(e, t.querySelectorAll ? t : t === n ? bh() || Zg.createElement("div") : n);
  };
}, tb = function(n) {
  return n.sort(function() {
    return 0.5 - Math.random();
  });
}, nb = function(n) {
  if (Lt(n))
    return n;
  var e = sr(n) ? n : { each: n }, t = ga(e.ease), i = e.from || 0, r = parseFloat(e.base) || 0, s = {}, a = i > 0 && i < 1, o = isNaN(i) || a, l = e.axis, h = i, c = i;
  return un(i) ? h = c = { center: 0.5, edges: 0.5, end: 1 }[i] || 0 : !a && o && (h = i[0], c = i[1]), function(u, d, p) {
    var m, g, f, v, y, x, M, b, S, w = (p || e).length, T = s[w];
    if (!T) {
      if (!(S = e.grid === "auto" ? 0 : (e.grid || [1, Tr])[1])) {
        for (M = -1e8; M < (M = p[S++].getBoundingClientRect().left) && S < w; )
          ;
        S < w && S--;
      }
      for (T = s[w] = [], m = o ? Math.min(S, w) * h - 0.5 : i % S, g = S === Tr ? 0 : o ? w * c / S - 0.5 : i / S | 0, M = 0, b = Tr, x = 0; x < w; x++)
        f = x % S - m, v = g - (x / S | 0), T[x] = y = l ? Math.abs(l === "y" ? v : f) : zM(f * f + v * v), y > M && (M = y), y < b && (b = y);
      i === "random" && tb(T), T.max = M - b, T.min = b, T.v = w = (parseFloat(e.amount) || parseFloat(e.each) * (S > w ? w - 1 : l ? l === "y" ? w / S : S : Math.max(S, w / S)) || 0) * (i === "edges" ? -1 : 1), T.b = w < 0 ? r - w : r, T.u = _n(e.amount || e.each) || 0, t = t && w < 0 ? cb(t) : t;
    }
    return w = (T[u] - T.min) / T.max || 0, cn(T.b + (t ? t(w) : w) * T.v) + T.u;
  };
}, Wm = function(n) {
  var e = Math.pow(10, ((n + "").split(".")[1] || "").length);
  return function(t) {
    var i = cn(Math.round(parseFloat(t) / n) * n * e);
    return (i - i % 1) / e + (Ir(t) ? 0 : _n(t));
  };
}, ib = function(n, e) {
  var t, i, r = wn(n);
  return !r && sr(n) && (t = r = n.radius || Tr, n.values ? (n = vi(n.values), (i = !Ir(n[0])) && (t *= t)) : n = Wm(n.increment)), Qr(e, r ? Lt(n) ? function(s) {
    return i = n(s), Math.abs(i - s) <= t ? i : s;
  } : function(s) {
    for (var a, o, l = parseFloat(i ? s.x : s), h = parseFloat(i ? s.y : 0), c = Tr, u = 0, d = n.length; d--; )
      (a = i ? (a = n[d].x - l) * a + (o = n[d].y - h) * o : Math.abs(n[d] - l)) < c && (c = a, u = d);
    return u = !t || c <= t ? n[u] : s, i || u === s || Ir(s) ? u : u + _n(s);
  } : Wm(n));
}, rb = function(n, e, t, i) {
  return Qr(wn(n) ? !e : t === !0 ? !!(t = 0) : !i, function() {
    return wn(n) ? n[~~(Math.random() * n.length)] : (t = t || 1e-5) && (i = t < 1 ? Math.pow(10, (t + "").length - 2) : 1) && Math.floor(Math.round((n - t / 2 + Math.random() * (e - n + 0.99 * t)) / t) * t * i) / i;
  });
}, Vy = function(n, e, t) {
  return Qr(t, function(i) {
    return n[~~e(i)];
  });
}, wh = function(n) {
  for (var e, t, i, r, s = 0, a = ""; ~(e = n.indexOf("random(", s)); )
    i = n.indexOf(")", e), r = n.charAt(e + 7) === "[", t = n.substr(e + 7, i - e - 7).match(r ? jM : zm), a += n.substr(s, e - s) + rb(r ? t : +t[0], r ? 0 : +t[1], +t[2] || 1e-5), s = i + 1;
  return a + n.substr(s, n.length - s);
}, Hy = function(n, e, t, i, r) {
  var s = e - n, a = i - t;
  return Qr(r, function(o) {
    return t + ((o - n) / s * a || 0);
  });
}, Gy = function(n, e, t) {
  var i, r, s, a = n.labels, o = Tr;
  for (i in a)
    (r = a[i] - e) < 0 == !!t && r && o > (r = Math.abs(r)) && (s = i, o = r);
  return s;
}, Jn = function(n, e, t) {
  var i, r, s, a = n.vars, o = a[e], l = Mt, h = n.Qi;
  if (o)
    return i = a[e + "Params"], r = a.callbackScope || n, t && hs.length && Qu(), h && (Mt = h), s = i ? o.apply(r, i) : o.call(r), Mt = l, s;
}, Ul = function(n) {
  return xs(n), n.scrollTrigger && n.scrollTrigger.kill(!!En), n.progress() < 1 && Jn(n, "onInterrupt"), n;
}, sb = [], ab = function(n) {
  if (n)
    if (n = !n.name && n.default || n, Jg() || n.headless) {
      var e = n.name, t = Lt(n), i = e && !t && n.init ? function() {
        this.ts = [];
      } : n, r = { init: Sh, render: Ym, add: t0, kill: UE, modifier: OE, rawVars: 0 }, s = { targetTest: 0, get: 0, getSetter: i0, aliases: {}, register: 0 };
      if (Yo(), n !== i) {
        if (Kn[e])
          return;
        bi(i, bi($u(n, r), s)), Ca(i.prototype, Ca(r, $u(n, s))), Kn[i.prop = e] = i, n.targetTest && (Nu.push(i), Qg[e] = 1), e = (e === "css" ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin";
      }
      XM(e, i), n.register && n.register(jn, i, Gn);
    } else
      sb.push(n);
}, dt = 255, Fl = { aqua: [0, dt, dt], lime: [0, dt, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, dt], navy: [0, 0, 128], white: [dt, dt, dt], olive: [128, 128, 0], yellow: [dt, dt, 0], orange: [dt, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [dt, 0, 0], pink: [dt, 192, 203], cyan: [0, dt, dt], transparent: [dt, dt, dt, 0] }, sf = function(n, e, t) {
  return (6 * (n += n < 0 ? 1 : n > 1 ? -1 : 0) < 1 ? e + (t - e) * n * 6 : n < 0.5 ? t : 3 * n < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e) * dt + 0.5 | 0;
}, ob = function(n, e, t) {
  var i, r, s, a, o, l, h, c, u, d, p = n ? Ir(n) ? [n >> 16, n >> 8 & dt, n & dt] : 0 : Fl.black;
  if (!p) {
    if (n.substr(-1) === "," && (n = n.substr(0, n.length - 1)), Fl[n])
      p = Fl[n];
    else if (n.charAt(0) === "#") {
      if (n.length < 6 && (i = n.charAt(1), r = n.charAt(2), s = n.charAt(3), n = "#" + i + i + r + r + s + s + (n.length === 5 ? n.charAt(4) + n.charAt(4) : "")), n.length === 9)
        return [(p = parseInt(n.substr(1, 6), 16)) >> 16, p >> 8 & dt, p & dt, parseInt(n.substr(7), 16) / 255];
      p = [(n = parseInt(n.substr(1), 16)) >> 16, n >> 8 & dt, n & dt];
    } else if (n.substr(0, 3) === "hsl")
      if (p = d = n.match(zm), e) {
        if (~n.indexOf("="))
          return p = n.match(HM), t && p.length < 4 && (p[3] = 1), p;
      } else
        a = +p[0] % 360 / 360, o = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= 0.5 ? l * (o + 1) : l + o - l * o), p.length > 3 && (p[3] *= 1), p[0] = sf(a + 1 / 3, i, r), p[1] = sf(a, i, r), p[2] = sf(a - 1 / 3, i, r);
    else
      p = n.match(zm) || Fl.transparent;
    p = p.map(Number);
  }
  return e && !d && (i = p[0] / dt, r = p[1] / dt, s = p[2] / dt, l = ((h = Math.max(i, r, s)) + (c = Math.min(i, r, s))) / 2, h === c ? a = o = 0 : (u = h - c, o = l > 0.5 ? u / (2 - h - c) : u / (h + c), a = h === i ? (r - s) / u + (r < s ? 6 : 0) : h === r ? (s - i) / u + 2 : (i - r) / u + 4, a *= 60), p[0] = ~~(a + 0.5), p[1] = ~~(100 * o + 0.5), p[2] = ~~(100 * l + 0.5)), t && p.length < 4 && (p[3] = 1), p;
}, lb = function(n) {
  var e = [], t = [], i = -1;
  return n.split(cs).forEach(function(r) {
    var s = r.match(uo) || [];
    e.push.apply(e, s), t.push(i += s.length + 1);
  }), e.c = t, e;
}, jy = function(n, e, t) {
  var i, r, s, a, o = "", l = (n + o).match(cs), h = e ? "hsla(" : "rgba(", c = 0;
  if (!l)
    return n;
  if (l = l.map(function(u) {
    return (u = ob(u, e, 1)) && h + (e ? u[0] + "," + u[1] + "%," + u[2] + "%," + u[3] : u.join(",")) + ")";
  }), t && (s = lb(n), (i = t.c).join(o) !== s.c.join(o)))
    for (a = (r = n.replace(cs, "1").split(uo)).length - 1; c < a; c++)
      o += r[c] + (~i.indexOf(c) ? l.shift() || h + "0,0,0,0)" : (s.length ? s : l.length ? l : t).shift());
  if (!r)
    for (a = (r = n.split(cs)).length - 1; c < a; c++)
      o += r[c] + l[c];
  return o + r[a];
}, cs = function() {
  var n, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
  for (n in Fl)
    e += "|" + n + "\\b";
  return new RegExp(e + ")", "gi");
}(), EE = /hsl[a]?\(/, hb = function(n) {
  var e, t = n.join(" ");
  if (cs.lastIndex = 0, cs.test(t))
    return e = EE.test(t), n[1] = jy(n[1], e), n[0] = jy(n[0], e, lb(n[1])), !0;
}, ti = function() {
  var n, e, t, i, r, s, a = Date.now, o = 500, l = 33, h = a(), c = h, u = 1e3 / 240, d = u, p = [], m = function g(f) {
    var v, y, x, M, b = a() - c, S = f === !0;
    if ((b > o || b < 0) && (h += b - l), ((v = (x = (c += b) - h) - d) > 0 || S) && (M = ++i.frame, r = x - 1e3 * i.time, i.time = x /= 1e3, d += v + (v >= u ? 4 : u - v), y = 1), S || (n = e(g)), y)
      for (s = 0; s < p.length; s++)
        p[s](x, r, M, f);
  };
  return i = { time: 0, frame: 0, tick: function() {
    m(!0);
  }, deltaRatio: function(g) {
    return r / (1e3 / (g || 60));
  }, wake: function() {
    BM && (!Bm && Jg() && (Zi = Bm = window, Zg = Zi.document || {}, ii.gsap = jn, (Zi.gsapVersions || (Zi.gsapVersions = [])).push(jn.version), WM(Ju || Zi.GreenSockGlobals || !Zi.gsap && Zi || {}), sb.forEach(ab)), t = typeof requestAnimationFrame != "undefined" && requestAnimationFrame, n && i.sleep(), e = t || function(g) {
      return setTimeout(g, d - 1e3 * i.time + 1 | 0);
    }, Mh = 1, m(2));
  }, sleep: function() {
    (t ? cancelAnimationFrame : clearTimeout)(n), Mh = 0, e = Sh;
  }, lagSmoothing: function(g, f) {
    o = g || 1 / 0, l = Math.min(f || 33, o);
  }, fps: function(g) {
    u = 1e3 / (g || 240), d = 1e3 * i.time + u;
  }, add: function(g, f, v) {
    var y = f ? function(x, M, b, S) {
      g(x, M, b, S), i.remove(y);
    } : g;
    return i.remove(g), p[v ? "unshift" : "push"](y), Yo(), y;
  }, remove: function(g, f) {
    ~(f = p.indexOf(g)) && p.splice(f, 1) && s >= f && s--;
  }, M: p }, i;
}(), Yo = function() {
  return !Mh && ti.wake();
}, et = {}, AE = /^[\d.\-M][\d.\-,\s]/, CE = /["']/g, PE = function(n) {
  for (var e, t, i, r = {}, s = n.substr(1, n.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++)
    t = s[o], e = o !== l - 1 ? t.lastIndexOf(",") : t.length, i = t.substr(0, e), r[a] = isNaN(i) ? i.replace(CE, "").trim() : +i, a = t.substr(e + 1).trim();
  return r;
}, cb = function(n) {
  return function(e) {
    return 1 - n(1 - e);
  };
}, ub = function n(e, t) {
  for (var i, r = e.rs; r; )
    r instanceof Dn ? n(r, t) : !r.vars.yoyoEase || r.os && r.Hi || r.os === t || (r.timeline ? n(r.timeline, t) : (i = r.hs, r.hs = r.cs, r.cs = i, r.os = t)), r = r.Ii;
}, ga = function(n, e) {
  return n && (Lt(n) ? n : et[n] || function(t) {
    var i, r, s, a, o = (t + "").split("("), l = et[o[0]];
    return l && o.length > 1 && l.config ? l.config.apply(null, ~t.indexOf("{") ? [PE(o[1])] : (i = t, r = i.indexOf("(") + 1, s = i.indexOf(")"), a = i.indexOf("(", r), i.substring(r, ~a && a < s ? i.indexOf(")", s + 1) : s)).split(",").map(ZM)) : et.ls && AE.test(t) ? et.ls("", t) : l;
  }(n)) || e;
}, Hs = function(n, e, t, i) {
  t === void 0 && (t = function(a) {
    return 1 - e(1 - a);
  }), i === void 0 && (i = function(a) {
    return a < 0.5 ? e(2 * a) / 2 : 1 - e(2 * (1 - a)) / 2;
  });
  var r, s = { easeIn: e, easeOut: t, easeInOut: i };
  return Vn(n, function(a) {
    for (var o in et[a] = ii[a] = s, et[r = a.toLowerCase()] = t, s)
      et[r + (o === "easeIn" ? ".in" : o === "easeOut" ? ".out" : ".inOut")] = et[a + "." + o] = s[o];
  }), s;
}, db = function(n) {
  return function(e) {
    return e < 0.5 ? (1 - n(1 - 2 * e)) / 2 : 0.5 + n(2 * (e - 0.5)) / 2;
  };
}, af = function n(e, t, i) {
  var r = t >= 1 ? t : 1, s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), a = s / km * (Math.asin(1 / r) || 0), o = function(h) {
    return h === 1 ? 1 : r * Math.pow(2, -10 * h) * vE((h - a) * s) + 1;
  }, l = e === "out" ? o : e === "in" ? function(h) {
    return 1 - o(1 - h);
  } : db(o);
  return s = km / s, l.config = function(h, c) {
    return n(e, h, c);
  }, l;
}, of = function n(e, t) {
  t === void 0 && (t = 1.70158);
  var i = function(s) {
    return s ? --s * s * ((t + 1) * s + t) + 1 : 0;
  }, r = e === "out" ? i : e === "in" ? function(s) {
    return 1 - i(1 - s);
  } : db(i);
  return r.config = function(s) {
    return n(e, s);
  }, r;
};
Vn("Linear,Quad,Cubic,Quart,Quint,Strong", function(n, e) {
  var t = e < 5 ? e + 1 : e;
  Hs(n + ",Power" + (t - 1), e ? function(i) {
    return Math.pow(i, t);
  } : function(i) {
    return i;
  }, function(i) {
    return 1 - Math.pow(1 - i, t);
  }, function(i) {
    return i < 0.5 ? Math.pow(2 * i, t) / 2 : 1 - Math.pow(2 * (1 - i), t) / 2;
  });
}), et.Linear.easeNone = et.none = et.Linear.easeIn, Hs("Elastic", af("in"), af("out"), af()), xl = 7.5625, Ny = 2 * (ef = 1 / ($c = 2.75)), Dy = 2.5 * ef, Hs("Bounce", function(n) {
  return 1 - Oy(1 - n);
}, Oy = function(n) {
  return n < ef ? xl * n * n : n < Ny ? xl * Math.pow(n - 1.5 / $c, 2) + 0.75 : n < Dy ? xl * (n -= 2.25 / $c) * n + 0.9375 : xl * Math.pow(n - 2.625 / $c, 2) + 0.984375;
}), Hs("Expo", function(n) {
  return n ? Math.pow(2, 10 * (n - 1)) : 0;
}), Hs("Circ", function(n) {
  return -(zM(1 - n * n) - 1);
}), Hs("Sine", function(n) {
  return n === 1 ? 1 : 1 - gE(n * fE);
}), Hs("Back", of("in"), of("out"), of()), et.SteppedEase = et.steps = ii.SteppedEase = { config: function(n, e) {
  n === void 0 && (n = 1);
  var t = 1 / n, i = n + (e ? 0 : 1), r = e ? 1 : 0;
  return function(s) {
    return ((i * Qh(0, 0.99999999, s) | 0) + r) * t;
  };
} }, Xo.ease = et["quad.out"], Vn("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(n) {
  return $g += n + "," + n + "Params,";
});
var pb = function(n, e) {
  this.id = mE++, n.Ci = this, this.target = n, this.harness = e, this.get = e ? e.get : qM, this.set = e ? e.getSetter : i0;
}, _h = function() {
  function n(t) {
    this.vars = t, this.qi = +t.delay || 0, (this.Hi = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this.Vi = t.repeatDelay || 0, this.os = !!t.yoyo || !!t.yoyoEase), this.Bi = 1, qo(this, +t.duration, 1, 1), this.data = t.data, Mt && (this.Qi = Mt, Mt.data.push(this)), Mh || ti.wake();
  }
  var e = n.prototype;
  return e.delay = function(t) {
    return t || t === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this.Fi + t - this.qi), this.qi = t, this) : this.qi;
  }, e.duration = function(t) {
    return arguments.length ? this.totalDuration(this.Hi > 0 ? t + (t + this.Vi) * this.Hi : t) : this.totalDuration() && this.ki;
  }, e.totalDuration = function(t) {
    return arguments.length ? (this.Gi = 0, qo(this, this.Hi < 0 ? t : (t - this.Hi * this.Vi) / (this.Hi + 1))) : this.Wi;
  }, e.totalTime = function(t, i) {
    if (Yo(), !arguments.length)
      return this.zi;
    var r = this.Ri;
    if (r && r.smoothChildTiming && this.Bi) {
      for (Kd(this, t), !r.Ri || r.parent || QM(r, this); r && r.parent; )
        r.parent.Xi !== r.Fi + (r.Bi >= 0 ? r.zi / r.Bi : (r.totalDuration() - r.zi) / -r.Bi) && r.totalTime(r.zi, !0), r = r.parent;
      !this.parent && this.Ri.autoRemoveChildren && (this.Bi > 0 && t < this.Wi || this.Bi < 0 && t > 0 || !this.Wi && !t) && Ji(this.Ri, this, this.Fi - this.qi);
    }
    return (this.zi !== t || !this.ki && !i || this.Li && Math.abs(this.Yi) === On || !t && !this.Li && (this.add || this.us)) && (this.Bi || (this.fs = t), YM(this, t, i)), this;
  }, e.time = function(t, i) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + By(this)) % (this.ki + this.Vi) || (t ? this.ki : 0), i) : this.Xi;
  }, e.totalProgress = function(t, i) {
    return arguments.length ? this.totalTime(this.totalDuration() * t, i) : this.totalDuration() ? Math.min(1, this.zi / this.Wi) : this.rawTime() > 0 ? 1 : 0;
  }, e.progress = function(t, i) {
    return arguments.length ? this.totalTime(this.duration() * (!this.os || 1 & this.iteration() ? t : 1 - t) + By(this), i) : this.duration() ? Math.min(1, this.Xi / this.ki) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(t, i) {
    var r = this.duration() + this.Vi;
    return arguments.length ? this.totalTime(this.Xi + (t - 1) * r, i) : this.Hi ? So(this.zi, r) + 1 : 1;
  }, e.timeScale = function(t, i) {
    if (!arguments.length)
      return this.ji === -1e-8 ? 0 : this.ji;
    if (this.ji === t)
      return this;
    var r = this.parent && this.Bi ? ed(this.parent.Xi, this) : this.zi;
    return this.ji = +t || 0, this.Bi = this.ds || t === -1e-8 ? 0 : this.ji, this.totalTime(Qh(-Math.abs(this.qi), this.Wi, r), i !== !1), Zd(this), function(s) {
      for (var a = s.parent; a && a.parent; )
        a.Gi = 1, a.totalDuration(), a = a.parent;
      return s;
    }(this);
  }, e.paused = function(t) {
    return arguments.length ? (this.ds !== t && (this.ds = t, t ? (this.fs = this.zi || Math.max(-this.qi, this.rawTime()), this.Bi = this.Ui = 0) : (Yo(), this.Bi = this.ji, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this.zi || this.fs, this.progress() === 1 && Math.abs(this.Yi) !== On && (this.zi -= On)))), this) : this.ds;
  }, e.startTime = function(t) {
    if (arguments.length) {
      this.Fi = t;
      var i = this.parent || this.Ri;
      return i && (i.Zi || !this.parent) && Ji(i, this, t - this.qi), this;
    }
    return this.Fi;
  }, e.endTime = function(t) {
    return this.Fi + (Hn(t) ? this.totalDuration() : this.duration()) / Math.abs(this.Bi || 1);
  }, e.rawTime = function(t) {
    var i = this.parent || this.Ri;
    return i ? t && (!this.Bi || this.Hi && this.Xi && this.totalProgress() < 1) ? this.zi % (this.ki + this.Vi) : this.Bi ? ed(i.rawTime(t), this) : this.zi : this.zi;
  }, e.revert = function(t) {
    t === void 0 && (t = ME);
    var i = En;
    return En = t, (this.Li || this.Ni) && (this.timeline && this.timeline.revert(t), this.totalTime(-0.01, t.suppressEvents)), this.data !== "nested" && t.kill !== !1 && this.kill(), En = i, this;
  }, e.globalTime = function(t) {
    for (var i = this, r = arguments.length ? t : i.rawTime(); i; )
      r = i.Fi + r / (Math.abs(i.Bi) || 1), i = i.Ri;
    return !this.parent && this.ps ? this.ps.globalTime(t) : r;
  }, e.repeat = function(t) {
    return arguments.length ? (this.Hi = t === 1 / 0 ? -2 : t, zy(this)) : this.Hi === -2 ? 1 / 0 : this.Hi;
  }, e.repeatDelay = function(t) {
    if (arguments.length) {
      var i = this.Xi;
      return this.Vi = t, zy(this), i ? this.time(i) : this;
    }
    return this.Vi;
  }, e.yoyo = function(t) {
    return arguments.length ? (this.os = t, this) : this.os;
  }, e.seek = function(t, i) {
    return this.totalTime(ui(this, t), Hn(i));
  }, e.restart = function(t, i) {
    return this.play().totalTime(t ? -this.qi : 0, Hn(i));
  }, e.play = function(t, i) {
    return t != null && this.seek(t, i), this.reversed(!1).paused(!1);
  }, e.reverse = function(t, i) {
    return t != null && this.seek(t || this.totalDuration(), i), this.reversed(!0).paused(!1);
  }, e.pause = function(t, i) {
    return t != null && this.seek(t, i), this.paused(!0);
  }, e.resume = function() {
    return this.paused(!1);
  }, e.reversed = function(t) {
    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this.ji || (t ? -1e-8 : 0)), this) : this.ji < 0;
  }, e.invalidate = function() {
    return this.Li = this.Ui = 0, this.Yi = -1e-8, this;
  }, e.isActive = function() {
    var t, i = this.parent || this.Ri, r = this.Fi;
    return !(i && !(this.Bi && this.Li && i.isActive() && (t = i.rawTime(!0)) >= r && t < this.endTime(!0) - On));
  }, e.eventCallback = function(t, i, r) {
    var s = this.vars;
    return arguments.length > 1 ? (i ? (s[t] = i, r && (s[t + "Params"] = r), t === "onUpdate" && (this.vs = i)) : delete s[t], this) : s[t];
  }, e.then = function(t) {
    var i = this;
    return new Promise(function(r) {
      var s = Lt(t) ? t : KM, a = function() {
        var o = i.then;
        i.then = null, Lt(s) && (s = s(i)) && (s.then || s === i) && (i.then = o), r(s), i.then = o;
      };
      i.Li && i.totalProgress() === 1 && i.Bi >= 0 || !i.zi && i.Bi < 0 ? a() : i.gs = a;
    });
  }, e.kill = function() {
    Ul(this);
  }, n;
}();
bi(_h.prototype, { Xi: 0, Fi: 0, Oi: 0, zi: 0, Wi: 0, Gi: 0, Hi: 0, os: !1, parent: null, Li: !1, Vi: 0, Bi: 1, Ri: 0, ratio: 0, Yi: -1e-8, gs: 0, ds: !1, ji: 1 });
var Dn = function(n) {
  function e(i, r) {
    var s;
    return i === void 0 && (i = {}), (s = n.call(this, i) || this).labels = {}, s.smoothChildTiming = !!i.smoothChildTiming, s.autoRemoveChildren = !!i.autoRemoveChildren, s.Zi = Hn(i.sortChildren), Tt && Ji(i.parent || Tt, gr(s), r), i.reversed && s.reverse(), i.paused && s.paused(!0), i.scrollTrigger && $M(gr(s), i.scrollTrigger), s;
  }
  FM(e, n);
  var t = e.prototype;
  return t.to = function(i, r, s) {
    return Kl(0, arguments, this), this;
  }, t.from = function(i, r, s) {
    return Kl(1, arguments, this), this;
  }, t.fromTo = function(i, r, s, a) {
    return Kl(2, arguments, this), this;
  }, t.set = function(i, r, s) {
    return r.duration = 0, r.parent = this, Zl(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new Zt(i, r, ui(this, s), 1), this;
  }, t.call = function(i, r, s) {
    return Ji(this, Zt.delayedCall(0, i, r), s);
  }, t.staggerTo = function(i, r, s, a, o, l, h) {
    return s.duration = r, s.stagger = s.stagger || a, s.onComplete = l, s.onCompleteParams = h, s.parent = this, new Zt(i, s, ui(this, o)), this;
  }, t.staggerFrom = function(i, r, s, a, o, l, h) {
    return s.runBackwards = 1, Zl(s).immediateRender = Hn(s.immediateRender), this.staggerTo(i, r, s, a, o, l, h);
  }, t.staggerFromTo = function(i, r, s, a, o, l, h, c) {
    return a.startAt = s, Zl(a).immediateRender = Hn(a.immediateRender), this.staggerTo(i, r, a, o, l, h, c);
  }, t.render = function(i, r, s) {
    var a, o, l, h, c, u, d, p, m, g, f, v, y = this.Xi, x = this.Gi ? this.totalDuration() : this.Wi, M = this.ki, b = i <= 0 ? 0 : cn(i), S = this.Yi < 0 != i < 0 && (this.Li || !M);
    if (this !== Tt && b > x && i >= 0 && (b = x), b !== this.zi || s || S) {
      if (y !== this.Xi && M && (b += this.Xi - y, i += this.Xi - y), a = b, m = this.Fi, u = !(p = this.Bi), S && (M || (y = this.Yi), (i || !r) && (this.Yi = i)), this.Hi) {
        if (f = this.os, c = M + this.Vi, this.Hi < -1 && i < 0)
          return this.totalTime(100 * c + i, r, s);
        if (a = cn(b % c), b === x ? (h = this.Hi, a = M) : ((h = ~~(b / c)) && h === b / c && (a = M, h--), a > M && (a = M)), g = So(this.zi, c), !y && this.zi && g !== h && this.zi - g * c - this.ki <= 0 && (g = h), f && 1 & h && (a = M - a, v = 1), h !== g && !this.$i) {
          var w = f && 1 & g, T = w === (f && 1 & h);
          if (h < g && (w = !w), y = w ? 0 : b % M ? M : b, this.$i = 1, this.render(y || (v ? 0 : cn(h * c)), r, !M).$i = 0, this.zi = b, !r && this.parent && Jn(this, "onRepeat"), this.vars.repeatRefresh && !v && (this.invalidate().$i = 1), y && y !== this.Xi || u !== !this.Bi || this.vars.onRepeat && !this.parent && !this.Ui)
            return this;
          if (M = this.ki, x = this.Wi, T && (this.$i = 2, y = w ? M : -1e-4, this.render(y, !0), this.vars.repeatRefresh && !v && this.invalidate()), this.$i = 0, !this.Bi && !u)
            return this;
          ub(this, v);
        }
      }
      if (this.ws && !this.Ms && this.$i < 2 && (d = function(I, A, L) {
        var D;
        if (L > A)
          for (D = I.rs; D && D.Fi <= L; ) {
            if (D.data === "isPause" && D.Fi > A)
              return D;
            D = D.Ii;
          }
        else
          for (D = I._s; D && D.Fi >= L; ) {
            if (D.data === "isPause" && D.Fi < A)
              return D;
            D = D.Di;
          }
      }(this, cn(y), cn(a)), d && (b -= a - (a = d.Fi))), this.zi = b, this.Xi = a, this.Ui = !p, this.Li || (this.vs = this.vars.onUpdate, this.Li = 1, this.Yi = i, y = 0), !y && a && !r && !h && (Jn(this, "onStart"), this.zi !== b))
        return this;
      if (a >= y && i >= 0)
        for (o = this.rs; o; ) {
          if (l = o.Ii, (o.Ui || a >= o.Fi) && o.Bi && d !== o) {
            if (o.parent !== this)
              return this.render(i, r, s);
            if (o.render(o.Bi > 0 ? (a - o.Fi) * o.Bi : (o.Gi ? o.totalDuration() : o.Wi) + (a - o.Fi) * o.Bi, r, s), a !== this.Xi || !this.Bi && !u) {
              d = 0, l && (b += this.Yi = -1e-8);
              break;
            }
          }
          o = l;
        }
      else {
        o = this._s;
        for (var C = i < 0 ? i : a; o; ) {
          if (l = o.Di, (o.Ui || C <= o.Oi) && o.Bi && d !== o) {
            if (o.parent !== this)
              return this.render(i, r, s);
            if (o.render(o.Bi > 0 ? (C - o.Fi) * o.Bi : (o.Gi ? o.totalDuration() : o.Wi) + (C - o.Fi) * o.Bi, r, s || En && (o.Li || o.Ni)), a !== this.Xi || !this.Bi && !u) {
              d = 0, l && (b += this.Yi = C ? -1e-8 : On);
              break;
            }
          }
          o = l;
        }
      }
      if (d && !r && (this.pause(), d.render(a >= y ? 0 : -1e-8).Yi = a >= y ? 1 : -1, this.Bi))
        return this.Fi = m, Zd(this), this.render(i, r, s);
      this.vs && !r && Jn(this, "onUpdate", !0), (b === x && this.zi >= this.totalDuration() || !b && y) && (m !== this.Fi && Math.abs(p) === Math.abs(this.Bi) || this.$i || ((i || !M) && (b === x && this.Bi > 0 || !b && this.Bi < 0) && xs(this, 1), r || i < 0 && !y || !b && !y && x || (Jn(this, b === x && i >= 0 ? "onComplete" : "onReverseComplete", !0), this.gs && !(b < x && this.timeScale() > 0) && this.gs())));
    }
    return this;
  }, t.add = function(i, r) {
    var s = this;
    if (Ir(r) || (r = ui(this, r, i)), !(i instanceof _h)) {
      if (wn(i))
        return i.forEach(function(a) {
          return s.add(a, r);
        }), this;
      if (un(i))
        return this.addLabel(i, r);
      if (!Lt(i))
        return this;
      i = Zt.delayedCall(0, i);
    }
    return this !== i ? Ji(this, i, r) : this;
  }, t.getChildren = function(i, r, s, a) {
    i === void 0 && (i = !0), r === void 0 && (r = !0), s === void 0 && (s = !0), a === void 0 && (a = -1e8);
    for (var o = [], l = this.rs; l; )
      l.Fi >= a && (l instanceof Zt ? r && o.push(l) : (s && o.push(l), i && o.push.apply(o, l.getChildren(!0, r, s)))), l = l.Ii;
    return o;
  }, t.getById = function(i) {
    for (var r = this.getChildren(1, 1, 1), s = r.length; s--; )
      if (r[s].vars.id === i)
        return r[s];
  }, t.remove = function(i) {
    return un(i) ? this.removeLabel(i) : Lt(i) ? this.killTweensOf(i) : (Yd(this, i), i === this.Ji && (this.Ji = this._s), ma(this));
  }, t.totalTime = function(i, r) {
    return arguments.length ? (this.Ms = 1, !this.Ri && this.Bi && (this.Fi = cn(ti.time - (this.Bi > 0 ? i / this.Bi : (this.totalDuration() - i) / -this.Bi))), n.prototype.totalTime.call(this, i, r), this.Ms = 0, this) : this.zi;
  }, t.addLabel = function(i, r) {
    return this.labels[i] = ui(this, r), this;
  }, t.removeLabel = function(i) {
    return delete this.labels[i], this;
  }, t.addPause = function(i, r, s) {
    var a = Zt.delayedCall(0, r || Sh, s);
    return a.data = "isPause", this.ws = 1, Ji(this, a, ui(this, i));
  }, t.removePause = function(i) {
    var r = this.rs;
    for (i = ui(this, i); r; )
      r.Fi === i && r.data === "isPause" && xs(r), r = r.Ii;
  }, t.killTweensOf = function(i, r, s) {
    for (var a = this.getTweensOf(i, s), o = a.length; o--; )
      $r !== a[o] && a[o].kill(i, r);
    return this;
  }, t.getTweensOf = function(i, r) {
    for (var s, a = [], o = vi(i), l = this.rs, h = Ir(r); l; )
      l instanceof Zt ? bE(l.xs, o) && (h ? (!$r || l.Li && l.Bi) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && a.push(l) : (s = l.getTweensOf(o, r)).length && a.push.apply(a, s), l = l.Ii;
    return a;
  }, t.tweenTo = function(i, r) {
    r = r || {};
    var s, a = this, o = ui(a, i), l = r, h = l.startAt, c = l.onStart, u = l.onStartParams, d = l.immediateRender, p = Zt.to(a, bi({ ease: r.ease || "none", lazy: !1, immediateRender: !1, time: o, overwrite: "auto", duration: r.duration || Math.abs((o - (h && "time" in h ? h.time : a.Xi)) / a.timeScale()) || On, onStart: function() {
      if (a.pause(), !s) {
        var m = r.duration || Math.abs((o - (h && "time" in h ? h.time : a.Xi)) / a.timeScale());
        p.ki !== m && qo(p, m, 0, 1).render(p.Xi, !0, !0), s = 1;
      }
      c && c.apply(p, u || []);
    } }, r));
    return d ? p.render(0) : p;
  }, t.tweenFromTo = function(i, r, s) {
    return this.tweenTo(r, bi({ startAt: { time: ui(this, i) } }, s));
  }, t.recent = function() {
    return this.Ji;
  }, t.nextLabel = function(i) {
    return i === void 0 && (i = this.Xi), Gy(this, ui(this, i));
  }, t.previousLabel = function(i) {
    return i === void 0 && (i = this.Xi), Gy(this, ui(this, i), 1);
  }, t.currentLabel = function(i) {
    return arguments.length ? this.seek(i, !0) : this.previousLabel(this.Xi + On);
  }, t.shiftChildren = function(i, r, s) {
    s === void 0 && (s = 0);
    for (var a, o = this.rs, l = this.labels; o; )
      o.Fi >= s && (o.Fi += i, o.Oi += i), o = o.Ii;
    if (r)
      for (a in l)
        l[a] >= s && (l[a] += i);
    return ma(this);
  }, t.invalidate = function(i) {
    var r = this.rs;
    for (this.$i = 0; r; )
      r.invalidate(i), r = r.Ii;
    return n.prototype.invalidate.call(this, i);
  }, t.clear = function(i) {
    i === void 0 && (i = !0);
    for (var r, s = this.rs; s; )
      r = s.Ii, this.remove(s), s = r;
    return this.Ri && (this.Xi = this.zi = this.fs = 0), i && (this.labels = {}), ma(this);
  }, t.totalDuration = function(i) {
    var r, s, a, o = 0, l = this, h = l._s, c = Tr;
    if (arguments.length)
      return l.timeScale((l.Hi < 0 ? l.duration() : l.totalDuration()) / (l.reversed() ? -i : i));
    if (l.Gi) {
      for (a = l.parent; h; )
        r = h.Di, h.Gi && h.totalDuration(), (s = h.Fi) > c && l.Zi && h.Bi && !l.$i ? (l.$i = 1, Ji(l, h, s - h.qi, 1).$i = 0) : c = s, s < 0 && h.Bi && (o -= s, (!a && !l.Ri || a && a.smoothChildTiming) && (l.Fi += s / l.Bi, l.Xi -= s, l.zi -= s), l.shiftChildren(-s, !1, -1 / 0), c = 0), h.Oi > o && h.Bi && (o = h.Oi), h = r;
      qo(l, l === Tt && l.Xi > o ? l.Xi : o, 1, 1), l.Gi = 0;
    }
    return l.Wi;
  }, e.updateRoot = function(i) {
    if (Tt.Bi && (YM(Tt, ed(i, Tt)), kM = ti.frame), ti.frame >= Uy) {
      Uy += si.autoSleep || 120;
      var r = Tt.rs;
      if ((!r || !r.Bi) && si.autoSleep && ti.M.length < 2) {
        for (; r && !r.Bi; )
          r = r.Ii;
        r || ti.sleep();
      }
    }
  }, e;
}(_h);
bi(Dn.prototype, { $i: 0, ws: 0, Ms: 0 });
var $r, Xm, RE = function(n, e, t, i, r, s, a) {
  var o, l, h, c, u, d, p, m, g = new Gn(this.Ki, n, e, 0, 1, xb, null, r), f = 0, v = 0;
  for (g.b = t, g.e = i, t += "", (p = ~(i += "").indexOf("random(")) && (i = wh(i)), s && (s(m = [t, i], n, e), t = m[0], i = m[1]), l = t.match(tf) || []; o = tf.exec(i); )
    c = o[0], u = i.substring(f, o.index), h ? h = (h + 1) % 5 : u.substr(-5) === "rgba(" && (h = 1), c !== l[v++] && (d = parseFloat(l[v - 1]) || 0, g.Ki = { Ii: g.Ki, p: u || v === 1 ? u : ",", s: d, c: c.charAt(1) === "=" ? bo(d, c) - d : parseFloat(c) - d, m: h && h < 4 ? Math.round : 0 }, f = tf.lastIndex);
  return g.c = f < i.length ? i.substring(f, i.length) : "", g.fp = a, (GM.test(i) || p) && (g.e = 0), this.Ki = g, g;
}, t0 = function(n, e, t, i, r, s, a, o, l, h) {
  Lt(i) && (i = i(r || 0, n, s));
  var c, u = n[e], d = t !== "get" ? t : Lt(u) ? l ? n[e.indexOf("set") || !Lt(n["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : n[e]() : u, p = Lt(u) ? l ? LE : vb : n0;
  if (un(i) && (~i.indexOf("random(") && (i = wh(i)), i.charAt(1) === "=" && ((c = bo(d, i) + (_n(d) || 0)) || c === 0) && (i = c)), !h || d !== i || Xm)
    return isNaN(d * i) || i === "" ? RE.call(this, n, e, d, i, p, o || si.stringFilter, l) : (c = new Gn(this.Ki, n, e, +d || 0, i - (d || 0), typeof u == "boolean" ? DE : yb, 0, p), l && (c.fp = l), a && c.modifier(a, this, n), this.Ki = c);
}, fb = function(n, e, t, i, r, s) {
  var a, o, l, h;
  if (Kn[n] && (a = new Kn[n]()).init(r, a.rawVars ? e[n] : function(c, u, d, p, m) {
    if (Lt(c) && (c = Jl(c, m, u, d, p)), !sr(c) || c.style && c.nodeType || wn(c) || VM(c))
      return un(c) ? Jl(c, m, u, d, p) : c;
    var g, f = {};
    for (g in c)
      f[g] = Jl(c[g], m, u, d, p);
    return f;
  }(e[n], i, r, s, t), t, i, s) !== !1 && (t.Ki = o = new Gn(t.Ki, r, n, 0, 1, a.render, a, 0, a.priority), t !== co))
    for (l = t.us[t.xs.indexOf(r)], h = a.ts.length; h--; )
      l[a.ts[h]] = o;
  return a;
}, qm = function n(e, t, i) {
  var r, s, a, o, l, h, c, u, d, p, m, g, f, v = e.vars, y = v.ease, x = v.startAt, M = v.immediateRender, b = v.lazy, S = v.onUpdate, w = v.runBackwards, T = v.yoyoEase, C = v.keyframes, I = v.autoRevert, A = e.ki, L = e.Ni, D = e.xs, U = e.parent, H = U && U.data === "nested" ? U.vars.targets : D, Z = e.ys === "auto" && !Yg, te = e.timeline;
  if (te && (!C || !y) && (y = "none"), e.hs = ga(y, Xo.ease), e.cs = T ? cb(ga(T === !0 ? y : T, Xo.ease)) : 0, T && e.os && !e.Hi && (T = e.cs, e.cs = e.hs, e.hs = T), e.Ss = !te && !!v.runBackwards, !te || C && !v.stagger) {
    if (g = (u = D[0] ? fa(D[0]).harness : 0) && v[u.prop], r = $u(v, Qg), L && (L.Yi < 0 && L.progress(1), t < 0 && w && M && !I ? L.render(-1, !0) : L.revert(w && A ? Lu : xE), L.Pi = 0), x) {
      if (xs(e.Ni = Zt.set(D, bi({ data: "isStart", overwrite: !1, parent: U, immediateRender: !0, lazy: !L && Hn(b), startAt: null, delay: 0, onUpdate: S && function() {
        return Jn(e, "onUpdate");
      }, stagger: 0 }, x))), e.Ni.Ri = 0, e.Ni.ps = e, t < 0 && (En || !M && !I) && e.Ni.revert(Lu), M && A && t <= 0 && i <= 0)
        return void (t && (e.Yi = t));
    } else if (w && A && !L)
      if (t && (M = !1), a = bi({ overwrite: !1, data: "isFromStart", lazy: M && !L && Hn(b), immediateRender: M, stagger: 0, parent: U }, r), g && (a[u.prop] = g), xs(e.Ni = Zt.set(D, a)), e.Ni.Ri = 0, e.Ni.ps = e, t < 0 && (En ? e.Ni.revert(Lu) : e.Ni.render(-1, !0)), e.Yi = t, M) {
        if (!t)
          return;
      } else
        n(e.Ni, On, On);
    for (e.Ki = e.bs = 0, b = A && Hn(b) || b && !A, s = 0; s < D.length; s++) {
      if (c = (l = D[s]).Ci || e0(D)[s].Ci, e.us[s] = p = {}, Vm[c.id] && hs.length && Qu(), m = H === D ? s : H.indexOf(l), u && (d = new u()).init(l, g || r, e, m, H) !== !1 && (e.Ki = o = new Gn(e.Ki, l, d.name, 0, 1, d.render, d, 0, d.priority), d.ts.forEach(function(ne) {
        p[ne] = o;
      }), d.priority && (h = 1)), !u || g)
        for (a in r)
          Kn[a] && (d = fb(a, r, e, m, l, H)) ? d.priority && (h = 1) : p[a] = o = t0.call(e, l, a, "get", r[a], m, H, 0, v.stringFilter);
      e.As && e.As[s] && e.kill(l, e.As[s]), Z && e.Ki && ($r = e, Tt.killTweensOf(l, p, e.globalTime(t)), f = !e.parent, $r = 0), e.Ki && b && (Vm[c.id] = 1);
    }
    h && Mb(e), e.Es && e.Es(e);
  }
  e.vs = S, e.Li = (!e.As || e.Ki) && !f, C && t <= 0 && te.render(Tr, !0, !0);
}, IE = function(n, e, t, i) {
  var r, s, a = e.ease || i || "power1.inOut";
  if (wn(e))
    s = t[n] || (t[n] = []), e.forEach(function(o, l) {
      return s.push({ t: l / (e.length - 1) * 100, v: o, e: a });
    });
  else
    for (r in e)
      s = t[r] || (t[r] = []), r === "ease" || s.push({ t: parseFloat(n), v: e[r], e: a });
}, Jl = function(n, e, t, i, r) {
  return Lt(n) ? n.call(e, t, i, r) : un(n) && ~n.indexOf("random(") ? wh(n) : n;
}, mb = $g + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", gb = {};
Vn(mb + ",id,stagger,delay,duration,paused,scrollTrigger", function(n) {
  return gb[n] = 1;
});
var Zt = function(n) {
  function e(i, r, s, a) {
    var o;
    typeof r == "number" && (s.duration = r, r = s, s = null);
    var l, h, c, u, d, p, m, g, f = (o = n.call(this, a ? r : Zl(r)) || this).vars, v = f.duration, y = f.delay, x = f.immediateRender, M = f.stagger, b = f.overwrite, S = f.keyframes, w = f.defaults, T = f.scrollTrigger, C = f.yoyoEase, I = r.parent || Tt, A = (wn(i) || VM(i) ? Ir(i[0]) : "length" in r) ? [i] : vi(i);
    if (o.xs = A.length ? e0(A) : bh(0, !si.nullTargetWarn) || [], o.us = [], o.ys = b, S || M || eu(v) || eu(y)) {
      if (r = o.vars, (l = o.timeline = new Dn({ data: "nested", defaults: w || {}, targets: I && I.data === "nested" ? I.vars.targets : A })).kill(), l.parent = l.Ri = gr(o), l.Fi = 0, M || eu(v) || eu(y)) {
        if (u = A.length, m = M && nb(M), sr(M))
          for (d in M)
            ~mb.indexOf(d) && (g || (g = {}), g[d] = M[d]);
        for (h = 0; h < u; h++)
          (c = $u(r, gb)).stagger = 0, C && (c.yoyoEase = C), g && Ca(c, g), p = A[h], c.duration = +Jl(v, gr(o), h, p, A), c.delay = (+Jl(y, gr(o), h, p, A) || 0) - o.qi, !M && u === 1 && c.delay && (o.qi = y = c.delay, o.Fi += y, c.delay = 0), l.to(p, c, m ? m(h, p, A) : 0), l.hs = et.none;
        l.duration() ? v = y = 0 : o.timeline = 0;
      } else if (S) {
        Zl(bi(l.vars.defaults, { ease: "none" })), l.hs = ga(S.ease || r.ease || "none");
        var L, D, U, H = 0;
        if (wn(S))
          S.forEach(function(Z) {
            return l.to(A, Z, ">");
          }), l.duration();
        else {
          for (d in c = {}, S)
            d === "ease" || d === "easeEach" || IE(d, S[d], c, S.easeEach);
          for (d in c)
            for (L = c[d].sort(function(Z, te) {
              return Z.t - te.t;
            }), H = 0, h = 0; h < L.length; h++)
              (U = { ease: (D = L[h]).e, duration: (D.t - (h ? L[h - 1].t : 0)) / 100 * v })[d] = D.v, l.to(A, U, H), H += U.duration;
          l.duration() < v && l.to({}, { duration: v - l.duration() });
        }
      }
      v || o.duration(v = l.duration());
    } else
      o.timeline = 0;
    return b !== !0 || Yg || ($r = gr(o), Tt.killTweensOf(A), $r = 0), Ji(I, gr(o), s), r.reversed && o.reverse(), r.paused && o.paused(!0), (x || !v && !S && o.Fi === cn(I.Xi) && Hn(x) && SE(gr(o)) && I.data !== "nested") && (o.zi = -1e-8, o.render(Math.max(0, -y) || 0)), T && $M(gr(o), T), o;
  }
  FM(e, n);
  var t = e.prototype;
  return t.render = function(i, r, s) {
    var a, o, l, h, c, u, d, p, m, g = this.Xi, f = this.Wi, v = this.ki, y = i < 0, x = i > f - On && !y ? f : i < On ? 0 : i;
    if (v) {
      if (x !== this.zi || !i || s || !this.Li && this.zi || this.Ni && this.Yi < 0 !== y) {
        if (a = x, p = this.timeline, this.Hi) {
          if (h = v + this.Vi, this.Hi < -1 && y)
            return this.totalTime(100 * h + i, r, s);
          if (a = cn(x % h), x === f ? (l = this.Hi, a = v) : ((l = ~~(x / h)) && l === cn(x / h) && (a = v, l--), a > v && (a = v)), (u = this.os && 1 & l) && (m = this.cs, a = v - a), c = So(this.zi, h), a === g && !s && this.Li && l === c)
            return this.zi = x, this;
          l !== c && (p && this.cs && ub(p, u), this.vars.repeatRefresh && !u && !this.$i && this.Xi !== h && this.Li && (this.$i = s = 1, this.render(cn(h * l), !0).invalidate().$i = 0));
        }
        if (!this.Li) {
          if (ky(this, y ? i : a, s, r, x))
            return this.zi = 0, this;
          if (!(g === this.Xi || s && this.vars.repeatRefresh && l !== c))
            return this;
          if (v !== this.ki)
            return this.render(i, r, s);
        }
        if (this.zi = x, this.Xi = a, !this.Ui && this.Bi && (this.Ui = 1, this.Pi = 0), this.ratio = d = (m || this.hs)(a / v), this.Ss && (this.ratio = d = 1 - d), a && !g && !r && !l && (Jn(this, "onStart"), this.zi !== x))
          return this;
        for (o = this.Ki; o; )
          o.r(d, o.d), o = o.Ii;
        p && p.render(i < 0 ? i : p.ki * p.hs(a / this.ki), r, s) || this.Ni && (this.Yi = i), this.vs && !r && (y && rf(this, i, 0, s), Jn(this, "onUpdate")), this.Hi && l !== c && this.vars.onRepeat && !r && this.parent && Jn(this, "onRepeat"), x !== this.Wi && x || this.zi !== x || (y && !this.vs && rf(this, i, 0, !0), (i || !v) && (x === this.Wi && this.Bi > 0 || !x && this.Bi < 0) && xs(this, 1), r || y && !g || !(x || g || u) || (Jn(this, x === f ? "onComplete" : "onReverseComplete", !0), this.gs && !(x < f && this.timeScale() > 0) && this.gs()));
      }
    } else
      (function(M, b, S, w) {
        var T, C, I, A = M.ratio, L = b < 0 || !b && (!M.Fi && wE(M) && (M.Li || !Hm(M)) || (M.Bi < 0 || M.Ri.Bi < 0) && !Hm(M)) ? 0 : 1, D = M.Vi, U = 0;
        if (D && M.Hi && (U = Qh(0, M.Wi, b), C = So(U, D), M.os && 1 & C && (L = 1 - L), C !== So(M.zi, D) && (A = 1 - L, M.vars.repeatRefresh && M.Li && M.invalidate())), L !== A || En || w || M.Yi === On || !b && M.Yi) {
          if (!M.Li && ky(M, b, w, S, U))
            return;
          for (I = M.Yi, M.Yi = b || (S ? On : 0), S || (S = b && !I), M.ratio = L, M.Ss && (L = 1 - L), M.Xi = 0, M.zi = U, T = M.Ki; T; )
            T.r(L, T.d), T = T.Ii;
          b < 0 && rf(M, b, 0, !0), M.vs && !S && Jn(M, "onUpdate"), U && M.Hi && !S && M.parent && Jn(M, "onRepeat"), (b >= M.Wi || b < 0) && M.ratio === L && (L && xs(M, 1), S || En || (Jn(M, L ? "onComplete" : "onReverseComplete", !0), M.gs && M.gs()));
        } else
          M.Yi || (M.Yi = b);
      })(this, i, r, s);
    return this;
  }, t.targets = function() {
    return this.xs;
  }, t.invalidate = function(i) {
    return (!i || !this.vars.runBackwards) && (this.Ni = 0), this.Ki = this.As = this.vs = this.Pi = this.ratio = 0, this.us = [], this.timeline && this.timeline.invalidate(i), n.prototype.invalidate.call(this, i);
  }, t.resetTo = function(i, r, s, a, o) {
    Mh || ti.wake(), this.Bi || this.play();
    var l = Math.min(this.ki, (this.Ri.Xi - this.Fi) * this.Bi);
    return this.Li || qm(this, l), function(h, c, u, d, p, m, g, f) {
      var v, y, x, M, b = (h.Ki && h.bs || (h.bs = {}))[c];
      if (!b)
        for (b = h.bs[c] = [], x = h.us, M = h.xs.length; M--; ) {
          if ((v = x[M][c]) && v.d && v.d.Ki)
            for (v = v.d.Ki; v && v.p !== c && v.fp !== c; )
              v = v.Ii;
          if (!v)
            return Xm = 1, h.vars[c] = "+=0", qm(h, g), Xm = 0, f ? bh() : 1;
          b.push(v);
        }
      for (M = b.length; M--; )
        (v = (y = b[M]).Ki || y).s = !d && d !== 0 || p ? v.s + (d || 0) + m * v.c : d, v.c = u - v.s, y.e && (y.e = zt(u) + _n(y.e)), y.b && (y.b = v.s + _n(y.b));
    }(this, i, r, s, a, this.hs(l / this.ki), l, o) ? this.resetTo(i, r, s, a, 1) : (Kd(this, 0), this.parent || JM(this.Ri, this, "_first", "_last", this.Ri.Zi ? "_start" : 0), this.render(0));
  }, t.kill = function(i, r) {
    if (r === void 0 && (r = "all"), !(i || r && r !== "all"))
      return this.Pi = this.Ki = 0, this.parent ? Ul(this) : this;
    if (this.timeline) {
      var s = this.timeline.totalDuration();
      return this.timeline.killTweensOf(i, r, $r && $r.vars.overwrite !== !0).rs || Ul(this), this.parent && s !== this.timeline.totalDuration() && qo(this, this.ki * this.timeline.Wi / s, 0, 1), this;
    }
    var a, o, l, h, c, u, d, p = this.xs, m = i ? vi(i) : p, g = this.us, f = this.Ki;
    if ((!r || r === "all") && function(v, y) {
      for (var x = v.length, M = x === y.length; M && x-- && v[x] === y[x]; )
        ;
      return x < 0;
    }(p, m))
      return r === "all" && (this.Ki = 0), Ul(this);
    for (a = this.As = this.As || [], r !== "all" && (un(r) && (c = {}, Vn(r, function(v) {
      return c[v] = 1;
    }), r = c), r = function(v, y) {
      var x, M, b, S, w = v[0] ? fa(v[0]).harness : 0, T = w && w.aliases;
      if (!T)
        return y;
      for (M in x = Ca({}, y), T)
        if (M in x)
          for (b = (S = T[M].split(",")).length; b--; )
            x[S[b]] = x[M];
      return x;
    }(p, r)), d = p.length; d--; )
      if (~m.indexOf(p[d]))
        for (c in o = g[d], r === "all" ? (a[d] = r, h = o, l = {}) : (l = a[d] = a[d] || {}, h = r), h)
          (u = o && o[c]) && ("kill" in u.d && u.d.kill(c) !== !0 || Yd(this, u, "_pt"), delete o[c]), l !== "all" && (l[c] = 1);
    return this.Li && !this.Ki && f && Ul(this), this;
  }, e.to = function(i, r) {
    return new e(i, r, arguments[2]);
  }, e.from = function(i, r) {
    return Kl(1, arguments);
  }, e.delayedCall = function(i, r, s, a) {
    return new e(r, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: i, onComplete: r, onReverseComplete: r, onCompleteParams: s, onReverseCompleteParams: s, callbackScope: a });
  }, e.fromTo = function(i, r, s) {
    return Kl(2, arguments);
  }, e.set = function(i, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(i, r);
  }, e.killTweensOf = function(i, r, s) {
    return Tt.killTweensOf(i, r, s);
  }, e;
}(_h);
bi(Zt.prototype, { xs: [], Pi: 0, Ni: 0, As: 0, Es: 0 }), Vn("staggerTo,staggerFrom,staggerFromTo", function(n) {
  Zt[n] = function() {
    var e = new Dn(), t = Gm.call(arguments, 0);
    return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t);
  };
});
var n0 = function(n, e, t) {
  return n[e] = t;
}, vb = function(n, e, t) {
  return n[e](t);
}, LE = function(n, e, t, i) {
  return n[e](i.fp, t);
}, NE = function(n, e, t) {
  return n.setAttribute(e, t);
}, i0 = function(n, e) {
  return Lt(n[e]) ? vb : Kg(n[e]) && n.setAttribute ? NE : n0;
}, yb = function(n, e) {
  return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * n)) / 1e6, e);
}, DE = function(n, e) {
  return e.set(e.t, e.p, !!(e.s + e.c * n), e);
}, xb = function(n, e) {
  var t = e.Ki, i = "";
  if (!n && e.b)
    i = e.b;
  else if (n === 1 && e.e)
    i = e.e;
  else {
    for (; t; )
      i = t.p + (t.m ? t.m(t.s + t.c * n) : Math.round(1e4 * (t.s + t.c * n)) / 1e4) + i, t = t.Ii;
    i += e.c;
  }
  e.set(e.t, e.p, i, e);
}, Ym = function(n, e) {
  for (var t = e.Ki; t; )
    t.r(n, t.d), t = t.Ii;
}, OE = function(n, e, t, i) {
  for (var r, s = this.Ki; s; )
    r = s.Ii, s.p === i && s.modifier(n, e, t), s = r;
}, UE = function(n) {
  for (var e, t, i = this.Ki; i; )
    t = i.Ii, i.p === n && !i.op || i.op === n ? Yd(this, i, "_pt") : i.dep || (e = 1), i = t;
  return !e;
}, FE = function(n, e, t, i) {
  i.mSet(n, e, i.m.call(i.tween, t, i.mt), i);
}, Mb = function(n) {
  for (var e, t, i, r, s = n.Ki; s; ) {
    for (e = s.Ii, t = i; t && t.pr > s.pr; )
      t = t.Ii;
    (s.Di = t ? t.Di : r) ? s.Di.Ii = s : i = s, (s.Ii = t) ? t.Di = s : r = s, s = e;
  }
  n.Ki = i;
}, Gn = function() {
  function n(e, t, i, r, s, a, o, l, h) {
    this.t = t, this.s = r, this.c = s, this.p = i, this.r = a || yb, this.d = o || this, this.set = l || n0, this.pr = h || 0, this.Ii = e, e && (e.Di = this);
  }
  return n.prototype.modifier = function(e, t, i) {
    this.mSet = this.mSet || this.set, this.set = FE, this.m = e, this.mt = i, this.tween = t;
  }, n;
}();
Vn($g + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(n) {
  return Qg[n] = 1;
}), ii.TweenMax = ii.TweenLite = Zt, ii.TimelineLite = ii.TimelineMax = Dn, Tt = new Dn({ sortChildren: !1, defaults: Xo, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), si.stringFilter = hb;
var va = [], Du = {}, BE = [], Wy = 0, kE = 0, lf = function(n) {
  return (Du[n] || BE).map(function(e) {
    return e();
  });
}, Zm = function() {
  var n = Date.now(), e = [];
  n - Wy > 2 && (lf("matchMediaInit"), va.forEach(function(t) {
    var i, r, s, a, o = t.queries, l = t.conditions;
    for (r in o)
      (i = Zi.matchMedia(o[r]).matches) && (s = 1), i !== l[r] && (l[r] = i, a = 1);
    a && (t.revert(), s && e.push(t));
  }), lf("matchMediaRevert"), e.forEach(function(t) {
    return t.onMatch(t, function(i) {
      return t.add(null, i);
    });
  }), Wy = n, lf("matchMedia"));
}, bb = function() {
  function n(t, i) {
    this.selector = i && jm(i), this.data = [], this.Ts = [], this.isReverted = !1, this.id = kE++, t && this.add(t);
  }
  var e = n.prototype;
  return e.add = function(t, i, r) {
    Lt(t) && (r = i, i = t, t = Lt);
    var s = this, a = function() {
      var o, l = Mt, h = s.selector;
      return l && l !== s && l.data.push(s), r && (s.selector = jm(r)), Mt = s, o = i.apply(s, arguments), Lt(o) && s.Ts.push(o), Mt = l, s.selector = h, s.isReverted = !1, o;
    };
    return s.last = a, t === Lt ? a(s, function(o) {
      return s.add(null, o);
    }) : t ? s[t] = a : a;
  }, e.ignore = function(t) {
    var i = Mt;
    Mt = null, t(this), Mt = i;
  }, e.getTweens = function() {
    var t = [];
    return this.data.forEach(function(i) {
      return i instanceof n ? t.push.apply(t, i.getTweens()) : i instanceof Zt && !(i.parent && i.parent.data === "nested") && t.push(i);
    }), t;
  }, e.clear = function() {
    this.Ts.length = this.data.length = 0;
  }, e.kill = function(t, i) {
    var r = this;
    if (t ? function() {
      for (var a, o = r.getTweens(), l = r.data.length; l--; )
        (a = r.data[l]).data === "isFlip" && (a.revert(), a.getChildren(!0, !0, !1).forEach(function(h) {
          return o.splice(o.indexOf(h), 1);
        }));
      for (o.map(function(h) {
        return { g: h.ki || h.qi || h.ps && !h.ps.vars.immediateRender ? h.globalTime(0) : -1 / 0, t: h };
      }).sort(function(h, c) {
        return c.g - h.g || -1 / 0;
      }).forEach(function(h) {
        return h.t.revert(t);
      }), l = r.data.length; l--; )
        (a = r.data[l]) instanceof Dn ? a.data !== "nested" && (a.scrollTrigger && a.scrollTrigger.revert(), a.kill()) : !(a instanceof Zt) && a.revert && a.revert(t);
      r.Ts.forEach(function(h) {
        return h(t, r);
      }), r.isReverted = !0;
    }() : this.data.forEach(function(a) {
      return a.kill && a.kill();
    }), this.clear(), i)
      for (var s = va.length; s--; )
        va[s].id === this.id && va.splice(s, 1);
  }, e.revert = function(t) {
    this.kill(t || {});
  }, n;
}(), zE = function() {
  function n(t) {
    this.contexts = [], this.scope = t, Mt && Mt.data.push(this);
  }
  var e = n.prototype;
  return e.add = function(t, i, r) {
    sr(t) || (t = { matches: t });
    var s, a, o, l = new bb(0, r || this.scope), h = l.conditions = {};
    for (a in Mt && !l.selector && (l.selector = Mt.selector), this.contexts.push(l), i = l.add("onMatch", i), l.queries = t, t)
      a === "all" ? o = 1 : (s = Zi.matchMedia(t[a])) && (va.indexOf(l) < 0 && va.push(l), (h[a] = s.matches) && (o = 1), s.addListener ? s.addListener(Zm) : s.addEventListener("change", Zm));
    return o && i(l, function(c) {
      return l.add(null, c);
    }), this;
  }, e.revert = function(t) {
    this.kill(t || {});
  }, e.kill = function(t) {
    this.contexts.forEach(function(i) {
      return i.kill(t, !0);
    });
  }, n;
}(), td = { registerPlugin: function() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  e.forEach(function(i) {
    return ab(i);
  });
}, timeline: function(n) {
  return new Dn(n);
}, getTweensOf: function(n, e) {
  return Tt.getTweensOf(n, e);
}, getProperty: function(n, e, t, i) {
  un(n) && (n = vi(n)[0]);
  var r = fa(n || {}).get, s = t ? KM : ZM;
  return t === "native" && (t = ""), n && (e ? s((Kn[e] && Kn[e].get || r)(n, e, t, i)) : function(a, o, l) {
    return s((Kn[a] && Kn[a].get || r)(n, a, o, l));
  });
}, quickSetter: function(n, e, t) {
  if ((n = vi(n)).length > 1) {
    var i = n.map(function(h) {
      return jn.quickSetter(h, e, t);
    }), r = i.length;
    return function(h) {
      for (var c = r; c--; )
        i[c](h);
    };
  }
  n = n[0] || {};
  var s = Kn[e], a = fa(n), o = a.harness && (a.harness.aliases || {})[e] || e, l = s ? function(h) {
    var c = new s();
    co.Ki = 0, c.init(n, t ? h + t : h, co, 0, [n]), c.render(1, c), co.Ki && Ym(1, co);
  } : a.set(n, o);
  return s ? l : function(h) {
    return l(n, o, t ? h + t : h, a, 1);
  };
}, quickTo: function(n, e, t) {
  var i, r = jn.to(n, Ca(((i = {})[e] = "+=0.1", i.paused = !0, i), t || {})), s = function(a, o, l) {
    return r.resetTo(e, a, o, l);
  };
  return s.tween = r, s;
}, isTweening: function(n) {
  return Tt.getTweensOf(n, !0).length > 0;
}, defaults: function(n) {
  return n && n.ease && (n.ease = ga(n.ease, Xo.ease)), Fy(Xo, n || {});
}, config: function(n) {
  return Fy(si, n || {});
}, registerEffect: function(n) {
  var e = n.name, t = n.effect, i = n.plugins, r = n.defaults, s = n.extendTimeline;
  (i || "").split(",").forEach(function(a) {
    return a && !Kn[a] && !ii[a] && bh();
  }), nf[e] = function(a, o, l) {
    return t(vi(a), bi(o || {}, r), l);
  }, s && (Dn.prototype[e] = function(a, o, l) {
    return this.add(nf[e](a, sr(o) ? o : (l = o) && {}, this), l);
  });
}, registerEase: function(n, e) {
  et[n] = ga(e);
}, parseEase: function(n, e) {
  return arguments.length ? ga(n, e) : et;
}, getById: function(n) {
  return Tt.getById(n);
}, exportRoot: function(n, e) {
  n === void 0 && (n = {});
  var t, i, r = new Dn(n);
  for (r.smoothChildTiming = Hn(n.smoothChildTiming), Tt.remove(r), r.Ri = 0, r.Xi = r.zi = Tt.Xi, t = Tt.rs; t; )
    i = t.Ii, !e && !t.ki && t instanceof Zt && t.vars.onComplete === t.xs[0] || Ji(r, t, t.Fi - t.qi), t = i;
  return Ji(Tt, r, 0), r;
}, context: function(n, e) {
  return n ? new bb(n, e) : Mt;
}, matchMedia: function(n) {
  return new zE(n);
}, matchMediaRefresh: function() {
  return va.forEach(function(n) {
    var e, t, i = n.conditions;
    for (t in i)
      i[t] && (i[t] = !1, e = 1);
    e && n.revert();
  }) || Zm();
}, addEventListener: function(n, e) {
  var t = Du[n] || (Du[n] = []);
  ~t.indexOf(e) || t.push(e);
}, removeEventListener: function(n, e) {
  var t = Du[n], i = t && t.indexOf(e);
  i >= 0 && t.splice(i, 1);
}, utils: { wrap: function n(e, t, i) {
  var r = t - e;
  return wn(e) ? Vy(e, n(0, e.length), t) : Qr(i, function(s) {
    return (r + (s - e) % r) % r + e;
  });
}, wrapYoyo: function n(e, t, i) {
  var r = t - e, s = 2 * r;
  return wn(e) ? Vy(e, n(0, e.length - 1), t) : Qr(i, function(a) {
    return e + ((a = (s + (a - e) % s) % s || 0) > r ? s - a : a);
  });
}, distribute: nb, random: rb, snap: ib, normalize: function(n, e, t) {
  return Hy(n, e, 0, 1, t);
}, getUnit: _n, clamp: function(n, e, t) {
  return Qr(t, function(i) {
    return Qh(n, e, i);
  });
}, splitColor: ob, toArray: vi, selector: jm, mapRange: Hy, pipe: function() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return function(i) {
    return e.reduce(function(r, s) {
      return s(r);
    }, i);
  };
}, unitize: function(n, e) {
  return function(t) {
    return n(parseFloat(t)) + (e || _n(t));
  };
}, interpolate: function n(e, t, i, r) {
  var s = isNaN(e + t) ? 0 : function(p) {
    return (1 - p) * e + p * t;
  };
  if (!s) {
    var a, o, l, h, c, u = un(e), d = {};
    if (i === !0 && (r = 1) && (i = null), u)
      e = { p: e }, t = { p: t };
    else if (wn(e) && !wn(t)) {
      for (l = [], h = e.length, c = h - 2, o = 1; o < h; o++)
        l.push(n(e[o - 1], e[o]));
      h--, s = function(p) {
        p *= h;
        var m = Math.min(c, ~~p);
        return l[m](p - m);
      }, i = t;
    } else
      r || (e = Ca(wn(e) ? [] : {}, e));
    if (!l) {
      for (a in t)
        t0.call(d, e, a, "get", t[a]);
      s = function(p) {
        return Ym(p, d) || (u ? e.p : e);
      };
    }
  }
  return Qr(i, s);
}, shuffle: tb }, install: WM, effects: nf, ticker: ti, updateRoot: Dn.updateRoot, plugins: Kn, globalTimeline: Tt, core: { PropTween: Gn, globals: XM, Tween: Zt, Timeline: Dn, Animation: _h, getCache: fa, Cs: Yd, reverting: function() {
  return En;
}, context: function(n) {
  return n && Mt && (Mt.data.push(n), n.Qi = Mt), Mt;
}, suppressOverwrites: function(n) {
  return Yg = n;
} } };
Vn("to,from,fromTo,delayedCall,set,killTweensOf", function(n) {
  return td[n] = Zt[n];
}), ti.add(Dn.updateRoot), co = td.to({}, { duration: 0 });
var VE = function(n, e) {
  for (var t = n.Ki; t && t.p !== e && t.op !== e && t.fp !== e; )
    t = t.Ii;
  return t;
}, hf = function(n, e) {
  return { name: n, rawVars: 1, init: function(t, i, r) {
    r.Es = function(s) {
      var a, o;
      if (un(i) && (a = {}, Vn(i, function(l) {
        return a[l] = 1;
      }), i = a), e) {
        for (o in a = {}, i)
          a[o] = e(i[o]);
        i = a;
      }
      (function(l, h) {
        var c, u, d, p = l.xs;
        for (c in h)
          for (u = p.length; u--; )
            (d = l.us[u][c]) && (d = d.d) && (d.Ki && (d = VE(d, c)), d && d.modifier && d.modifier(h[c], l, p[u], c));
      })(s, i);
    };
  } };
}, jn = td.registerPlugin({ name: "attr", init: function(n, e, t, i, r) {
  var s, a, o;
  for (s in this.tween = t, e)
    o = n.getAttribute(s) || "", (a = this.add(n, "setAttribute", (o || 0) + "", e[s], i, r, 0, 0, s)).op = s, a.b = o, this.ts.push(s);
}, render: function(n, e) {
  for (var t = e.Ki; t; )
    En ? t.set(t.t, t.p, t.b, t) : t.r(n, t.d), t = t.Ii;
} }, { name: "endArray", init: function(n, e) {
  for (var t = e.length; t--; )
    this.add(n, t, n[t] || 0, e[t], 0, 0, 0, 0, 0, 1);
} }, hf("roundProps", Wm), hf("modifiers"), hf("snap", ib)) || td;
Zt.version = Dn.version = jn.version = "3.12.5", BM = 1, Jg() && Yo(), et.Power0, et.Power1, et.Power2, et.Power3, et.Power4, et.Linear, et.Quad, et.Cubic, et.Quart, et.Quint, et.Strong, et.Elastic, et.Back, et.SteppedEase, et.Bounce, et.Sine, et.Expo, et.Circ;
var Xy, es, wo, r0, ha, qy, s0, Sb, Lr = {}, Qs = 180 / Math.PI, _o = Math.PI / 180, to = Math.atan2, a0 = /([A-Z])/g, HE = /(left|right|width|margin|padding|x)/i, GE = /[\s,\(]\S/, Qi = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, Km = function(n, e) {
  return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * n)) / 1e4 + e.u, e);
}, jE = function(n, e) {
  return e.set(e.t, e.p, n === 1 ? e.e : Math.round(1e4 * (e.s + e.c * n)) / 1e4 + e.u, e);
}, WE = function(n, e) {
  return e.set(e.t, e.p, n ? Math.round(1e4 * (e.s + e.c * n)) / 1e4 + e.u : e.b, e);
}, XE = function(n, e) {
  var t = e.s + e.c * n;
  e.set(e.t, e.p, ~~(t + (t < 0 ? -0.5 : 0.5)) + e.u, e);
}, wb = function(n, e) {
  return e.set(e.t, e.p, n ? e.e : e.b, e);
}, _b = function(n, e) {
  return e.set(e.t, e.p, n !== 1 ? e.b : e.e, e);
}, qE = function(n, e, t) {
  return n.style[e] = t;
}, YE = function(n, e, t) {
  return n.style.setProperty(e, t);
}, ZE = function(n, e, t) {
  return n.Ci[e] = t;
}, KE = function(n, e, t) {
  return n.Ci.scaleX = n.Ci.scaleY = t;
}, JE = function(n, e, t, i, r) {
  var s = n.Ci;
  s.scaleX = s.scaleY = t, s.renderTransform(r, s);
}, QE = function(n, e, t, i, r) {
  var s = n.Ci;
  s[e] = t, s.renderTransform(r, s);
}, At = "transform", Wn = At + "Origin", $E = function n(e, t) {
  var i = this, r = this.target, s = r.style, a = r.Ci;
  if (e in Lr && s) {
    if (this.tfm = this.tfm || {}, e === "transform")
      return Qi.transform.split(",").forEach(function(o) {
        return n.call(i, o, t);
      });
    if (~(e = Qi[e] || e).indexOf(",") ? e.split(",").forEach(function(o) {
      return i.tfm[o] = yr(r, o);
    }) : this.tfm[e] = a.x ? a[e] : yr(r, e), e === Wn && (this.tfm.zOrigin = a.zOrigin), this.props.indexOf(At) >= 0)
      return;
    a.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(Wn, t, "")), e = At;
  }
  (s || t) && this.props.push(e, t, s[e]);
}, Tb = function(n) {
  n.translate && (n.removeProperty("translate"), n.removeProperty("scale"), n.removeProperty("rotate"));
}, eA = function() {
  var n, e, t = this.props, i = this.target, r = i.style, s = i.Ci;
  for (n = 0; n < t.length; n += 3)
    t[n + 1] ? i[t[n]] = t[n + 2] : t[n + 2] ? r[t[n]] = t[n + 2] : r.removeProperty(t[n].substr(0, 2) === "--" ? t[n] : t[n].replace(a0, "-$1").toLowerCase());
  if (this.tfm) {
    for (e in this.tfm)
      s[e] = this.tfm[e];
    s.svg && (s.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), (n = s0()) && n.isStart || r[At] || (Tb(r), s.zOrigin && r[Wn] && (r[Wn] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1);
  }
}, Eb = function(n, e) {
  var t = { target: n, props: [], revert: eA, save: $E };
  return n.Ci || jn.core.getCache(n), e && e.split(",").forEach(function(i) {
    return t.save(i);
  }), t;
}, Jm = function(n, e) {
  var t = es.createElementNS ? es.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), n) : es.createElement(n);
  return t && t.style ? t : es.createElement(n);
}, nr = function n(e, t, i) {
  var r = getComputedStyle(e);
  return r[t] || r.getPropertyValue(t.replace(a0, "-$1").toLowerCase()) || r.getPropertyValue(t) || !i && n(e, Zo(t) || t, 1) || "";
}, Yy = "O,Moz,ms,Ms,Webkit".split(","), Zo = function(n, e, t) {
  var i = (e || ha).style, r = 5;
  if (n in i && !t)
    return n;
  for (n = n.charAt(0).toUpperCase() + n.substr(1); r-- && !(Yy[r] + n in i); )
    ;
  return r < 0 ? null : (r === 3 ? "ms" : r >= 0 ? Yy[r] : "") + n;
}, Qm = function() {
  typeof window != "undefined" && window.document && (Xy = window, es = Xy.document, wo = es.documentElement, ha = Jm("div") || { style: {} }, Jm("div"), At = Zo(At), Wn = At + "Origin", ha.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Sb = !!Zo("perspective"), s0 = jn.core.reverting, r0 = 1);
}, cf = function n(e) {
  var t, i = Jm("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, a = this.style.cssText;
  if (wo.appendChild(i), i.appendChild(this), this.style.display = "block", e)
    try {
      t = this.getBBox(), this.Ps = this.getBBox, this.getBBox = n;
    } catch (o) {
    }
  else
    this.Ps && (t = this.Ps());
  return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), wo.removeChild(i), this.style.cssText = a, t;
}, Zy = function(n, e) {
  for (var t = e.length; t--; )
    if (n.hasAttribute(e[t]))
      return n.getAttribute(e[t]);
}, Ab = function(n) {
  var e;
  try {
    e = n.getBBox();
  } catch (t) {
    e = cf.call(n, !0);
  }
  return e && (e.width || e.height) || n.getBBox === cf || (e = cf.call(n, !0)), !e || e.width || e.x || e.y ? e : { x: +Zy(n, ["x", "cx", "x1"]) || 0, y: +Zy(n, ["y", "cy", "y1"]) || 0, width: 0, height: 0 };
}, Cb = function(n) {
  return !(!n.getCTM || n.parentNode && !n.ownerSVGElement || !Ab(n));
}, Pa = function(n, e) {
  if (e) {
    var t, i = n.style;
    e in Lr && e !== Wn && (e = At), i.removeProperty ? ((t = e.substr(0, 2)) !== "ms" && e.substr(0, 6) !== "webkit" || (e = "-" + e), i.removeProperty(t === "--" ? e : e.replace(a0, "-$1").toLowerCase())) : i.removeAttribute(e);
  }
}, ts = function(n, e, t, i, r, s) {
  var a = new Gn(n.Ki, e, t, 0, 1, s ? _b : wb);
  return n.Ki = a, a.b = i, a.e = r, n.ts.push(t), a;
}, Ky = { deg: 1, rad: 1, turn: 1 }, tA = { grid: 1, flex: 1 }, Ms = function n(e, t, i, r) {
  var s, a, o, l, h = parseFloat(i) || 0, c = (i + "").trim().substr((h + "").length) || "px", u = ha.style, d = HE.test(t), p = e.tagName.toLowerCase() === "svg", m = (p ? "client" : "offset") + (d ? "Width" : "Height"), g = 100, f = r === "px", v = r === "%";
  if (r === c || !h || Ky[r] || Ky[c])
    return h;
  if (c !== "px" && !f && (h = n(e, t, i, "px")), l = e.getCTM && Cb(e), (v || c === "%") && (Lr[t] || ~t.indexOf("adius")))
    return s = l ? e.getBBox()[d ? "width" : "height"] : e[m], zt(v ? h / s * g : h / 100 * s);
  if (u[d ? "width" : "height"] = g + (f ? c : r), a = ~t.indexOf("adius") || r === "em" && e.appendChild && !p ? e : e.parentNode, l && (a = (e.ownerSVGElement || {}).parentNode), a && a !== es && a.appendChild || (a = es.body), (o = a.Ci) && v && o.width && d && o.time === ti.time && !o.uncache)
    return zt(h / o.width * g);
  if (!v || t !== "height" && t !== "width")
    (v || c === "%") && !tA[nr(a, "display")] && (u.position = nr(e, "position")), a === e && (u.position = "static"), a.appendChild(ha), s = ha[m], a.removeChild(ha), u.position = "absolute";
  else {
    var y = e.style[t];
    e.style[t] = g + r, s = e[m], y ? e.style[t] = y : Pa(e, t);
  }
  return d && v && ((o = fa(a)).time = ti.time, o.width = a[m]), zt(f ? s * h / g : s && h ? g / s * h : 0);
}, yr = function(n, e, t, i) {
  var r;
  return r0 || Qm(), e in Qi && e !== "transform" && ~(e = Qi[e]).indexOf(",") && (e = e.split(",")[0]), Lr[e] && e !== "transform" ? (r = Eh(n, i), r = e !== "transformOrigin" ? r[e] : r.svg ? r.origin : id(nr(n, Wn)) + " " + r.zOrigin + "px") : (!(r = n.style[e]) || r === "auto" || i || ~(r + "").indexOf("calc(")) && (r = nd[e] && nd[e](n, e, t) || nr(n, e) || qM(n, e) || (e === "opacity" ? 1 : 0)), t && !~(r + "").trim().indexOf(" ") ? Ms(n, e, r, t) + t : r;
}, nA = function(n, e, t, i) {
  if (!t || t === "none") {
    var r = Zo(e, n, 1), s = r && nr(n, r, 1);
    s && s !== t ? (e = r, t = s) : e === "borderColor" && (t = nr(n, "borderTopColor"));
  }
  var a, o, l, h, c, u, d, p, m, g, f, v = new Gn(this.Ki, n.style, e, 0, 1, xb), y = 0, x = 0;
  if (v.b = t, v.e = i, t += "", (i += "") == "auto" && (u = n.style[e], n.style[e] = i, i = nr(n, e) || i, u ? n.style[e] = u : Pa(n, e)), hb(a = [t, i]), i = a[1], l = (t = a[0]).match(uo) || [], (i.match(uo) || []).length) {
    for (; o = uo.exec(i); )
      d = o[0], m = i.substring(y, o.index), c ? c = (c + 1) % 5 : m.substr(-5) !== "rgba(" && m.substr(-5) !== "hsla(" || (c = 1), d !== (u = l[x++] || "") && (h = parseFloat(u) || 0, f = u.substr((h + "").length), d.charAt(1) === "=" && (d = bo(h, d) + f), p = parseFloat(d), g = d.substr((p + "").length), y = uo.lastIndex - g.length, g || (g = g || si.units[e] || f, y === i.length && (i += g, v.e += g)), f !== g && (h = Ms(n, e, u, g) || 0), v.Ki = { Ii: v.Ki, p: m || x === 1 ? m : ",", s: h, c: p - h, m: c && c < 4 || e === "zIndex" ? Math.round : 0 });
    v.c = y < i.length ? i.substring(y, i.length) : "";
  } else
    v.r = e === "display" && i === "none" ? _b : wb;
  return GM.test(i) && (v.e = 0), this.Ki = v, v;
}, Jy = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, iA = function(n) {
  var e = n.split(" "), t = e[0], i = e[1] || "50%";
  return t !== "top" && t !== "bottom" && i !== "left" && i !== "right" || (n = t, t = i, i = n), e[0] = Jy[t] || t, e[1] = Jy[i] || i, e.join(" ");
}, rA = function(n, e) {
  if (e.tween && e.tween.Xi === e.tween.ki) {
    var t, i, r, s = e.t, a = s.style, o = e.u, l = s.Ci;
    if (o === "all" || o === !0)
      a.cssText = "", i = 1;
    else
      for (r = (o = o.split(",")).length; --r > -1; )
        t = o[r], Lr[t] && (i = 1, t = t === "transformOrigin" ? Wn : At), Pa(s, t);
    i && (Pa(s, At), l && (l.svg && s.removeAttribute("transform"), Eh(s, 1), l.uncache = 1, Tb(a)));
  }
}, nd = { clearProps: function(n, e, t, i, r) {
  if (r.data !== "isFromStart") {
    var s = n.Ki = new Gn(n.Ki, e, t, 0, 0, rA);
    return s.u = i, s.pr = -10, s.tween = r, n.ts.push(t), 1;
  }
} }, Th = [1, 0, 0, 1, 0, 0], Pb = {}, Rb = function(n) {
  return n === "matrix(1, 0, 0, 1, 0, 0)" || n === "none" || !n;
}, Qy = function(n) {
  var e = nr(n, At);
  return Rb(e) ? Th : e.substr(7).match(HM).map(zt);
}, o0 = function(n, e) {
  var t, i, r, s, a = n.Ci || fa(n), o = n.style, l = Qy(n);
  return a.svg && n.getAttribute("transform") ? (l = [(r = n.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") === "1,0,0,1,0,0" ? Th : l : (l !== Th || n.offsetParent || n === wo || a.svg || (r = o.display, o.display = "block", (t = n.parentNode) && n.offsetParent || (s = 1, i = n.nextElementSibling, wo.appendChild(n)), l = Qy(n), r ? o.display = r : Pa(n, "display"), s && (i ? t.insertBefore(n, i) : t ? t.appendChild(n) : wo.removeChild(n))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
}, $m = function(n, e, t, i, r, s) {
  var a, o, l, h = n.Ci, c = r || o0(n, !0), u = h.xOrigin || 0, d = h.yOrigin || 0, p = h.xOffset || 0, m = h.yOffset || 0, g = c[0], f = c[1], v = c[2], y = c[3], x = c[4], M = c[5], b = e.split(" "), S = parseFloat(b[0]) || 0, w = parseFloat(b[1]) || 0;
  t ? c !== Th && (o = g * y - f * v) && (l = S * (-f / o) + w * (g / o) - (g * M - f * x) / o, S = S * (y / o) + w * (-v / o) + (v * M - y * x) / o, w = l) : (S = (a = Ab(n)).x + (~b[0].indexOf("%") ? S / 100 * a.width : S), w = a.y + (~(b[1] || b[0]).indexOf("%") ? w / 100 * a.height : w)), i || i !== !1 && h.smooth ? (x = S - u, M = w - d, h.xOffset = p + (x * g + M * v) - x, h.yOffset = m + (x * f + M * y) - M) : h.xOffset = h.yOffset = 0, h.xOrigin = S, h.yOrigin = w, h.smooth = !!i, h.origin = e, h.originIsAbsolute = !!t, n.style[Wn] = "0px 0px", s && (ts(s, h, "xOrigin", u, S), ts(s, h, "yOrigin", d, w), ts(s, h, "xOffset", p, h.xOffset), ts(s, h, "yOffset", m, h.yOffset)), n.setAttribute("data-svg-origin", S + " " + w);
}, Eh = function(n, e) {
  var t = n.Ci || new pb(n);
  if ("x" in t && !e && !t.uncache)
    return t;
  var i, r, s, a, o, l, h, c, u, d, p, m, g, f, v, y, x, M, b, S, w, T, C, I, A, L, D, U, H, Z, te, ne, ve = n.style, Se = t.scaleX < 0, Q = "px", ae = "deg", de = getComputedStyle(n), ie = nr(n, Wn) || "0";
  return i = r = s = l = h = c = u = d = p = 0, a = o = 1, t.svg = !(!n.getCTM || !Cb(n)), de.translate && (de.translate === "none" && de.scale === "none" && de.rotate === "none" || (ve[At] = (de.translate !== "none" ? "translate3d(" + (de.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (de.rotate !== "none" ? "rotate(" + de.rotate + ") " : "") + (de.scale !== "none" ? "scale(" + de.scale.split(" ").join(",") + ") " : "") + (de[At] !== "none" ? de[At] : "")), ve.scale = ve.rotate = ve.translate = "none"), f = o0(n, t.svg), t.svg && (t.uncache ? (A = n.getBBox(), ie = t.xOrigin - A.x + "px " + (t.yOrigin - A.y) + "px", I = "") : I = !e && n.getAttribute("data-svg-origin"), $m(n, I || ie, !!I || t.originIsAbsolute, t.smooth !== !1, f)), m = t.xOrigin || 0, g = t.yOrigin || 0, f !== Th && (M = f[0], b = f[1], S = f[2], w = f[3], i = T = f[4], r = C = f[5], f.length === 6 ? (a = Math.sqrt(M * M + b * b), o = Math.sqrt(w * w + S * S), l = M || b ? to(b, M) * Qs : 0, (u = S || w ? to(S, w) * Qs + l : 0) && (o *= Math.abs(Math.cos(u * _o))), t.svg && (i -= m - (m * M + g * S), r -= g - (m * b + g * w))) : (ne = f[6], Z = f[7], D = f[8], U = f[9], H = f[10], te = f[11], i = f[12], r = f[13], s = f[14], h = (v = to(ne, H)) * Qs, v && (I = T * (y = Math.cos(-v)) + D * (x = Math.sin(-v)), A = C * y + U * x, L = ne * y + H * x, D = T * -x + D * y, U = C * -x + U * y, H = ne * -x + H * y, te = Z * -x + te * y, T = I, C = A, ne = L), c = (v = to(-S, H)) * Qs, v && (y = Math.cos(-v), te = w * (x = Math.sin(-v)) + te * y, M = I = M * y - D * x, b = A = b * y - U * x, S = L = S * y - H * x), l = (v = to(b, M)) * Qs, v && (I = M * (y = Math.cos(v)) + b * (x = Math.sin(v)), A = T * y + C * x, b = b * y - M * x, C = C * y - T * x, M = I, T = A), h && Math.abs(h) + Math.abs(l) > 359.9 && (h = l = 0, c = 180 - c), a = zt(Math.sqrt(M * M + b * b + S * S)), o = zt(Math.sqrt(C * C + ne * ne)), v = to(T, C), u = Math.abs(v) > 2e-4 ? v * Qs : 0, p = te ? 1 / (te < 0 ? -te : te) : 0), t.svg && (I = n.getAttribute("transform"), t.forceCSS = n.setAttribute("transform", "") || !Rb(nr(n, At)), I && n.setAttribute("transform", I))), Math.abs(u) > 90 && Math.abs(u) < 270 && (Se ? (a *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, u += u <= 0 ? 180 : -180)), e = e || t.uncache, t.x = i - ((t.xPercent = i && (!e && t.xPercent || (Math.round(n.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? n.offsetWidth * t.xPercent / 100 : 0) + Q, t.y = r - ((t.yPercent = r && (!e && t.yPercent || (Math.round(n.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? n.offsetHeight * t.yPercent / 100 : 0) + Q, t.z = s + Q, t.scaleX = zt(a), t.scaleY = zt(o), t.rotation = zt(l) + ae, t.rotationX = zt(h) + ae, t.rotationY = zt(c) + ae, t.skewX = u + ae, t.skewY = d + ae, t.transformPerspective = p + Q, (t.zOrigin = parseFloat(ie.split(" ")[2]) || !e && t.zOrigin || 0) && (ve[Wn] = id(ie)), t.xOffset = t.yOffset = 0, t.force3D = si.force3D, t.renderTransform = t.svg ? aA : Sb ? Ib : sA, t.uncache = 0, t;
}, id = function(n) {
  return (n = n.split(" "))[0] + " " + n[1];
}, uf = function(n, e, t) {
  var i = _n(e);
  return zt(parseFloat(e) + parseFloat(Ms(n, "x", t + "px", i))) + i;
}, sA = function(n, e) {
  e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, Ib(n, e);
}, Gs = "0deg", Ml = "0px", js = ") ", Ib = function(n, e) {
  var t = e || this, i = t.xPercent, r = t.yPercent, s = t.x, a = t.y, o = t.z, l = t.rotation, h = t.rotationY, c = t.rotationX, u = t.skewX, d = t.skewY, p = t.scaleX, m = t.scaleY, g = t.transformPerspective, f = t.force3D, v = t.target, y = t.zOrigin, x = "", M = f === "auto" && n && n !== 1 || f === !0;
  if (y && (c !== Gs || h !== Gs)) {
    var b, S = parseFloat(h) * _o, w = Math.sin(S), T = Math.cos(S);
    S = parseFloat(c) * _o, b = Math.cos(S), s = uf(v, s, w * b * -y), a = uf(v, a, -Math.sin(S) * -y), o = uf(v, o, T * b * -y + y);
  }
  g !== Ml && (x += "perspective(" + g + js), (i || r) && (x += "translate(" + i + "%, " + r + "%) "), (M || s !== Ml || a !== Ml || o !== Ml) && (x += o !== Ml || M ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + js), l !== Gs && (x += "rotate(" + l + js), h !== Gs && (x += "rotateY(" + h + js), c !== Gs && (x += "rotateX(" + c + js), u === Gs && d === Gs || (x += "skew(" + u + ", " + d + js), p === 1 && m === 1 || (x += "scale(" + p + ", " + m + js), v.style[At] = x || "translate(0, 0)";
}, aA = function(n, e) {
  var t, i, r, s, a, o = e || this, l = o.xPercent, h = o.yPercent, c = o.x, u = o.y, d = o.rotation, p = o.skewX, m = o.skewY, g = o.scaleX, f = o.scaleY, v = o.target, y = o.xOrigin, x = o.yOrigin, M = o.xOffset, b = o.yOffset, S = o.forceCSS, w = parseFloat(c), T = parseFloat(u);
  d = parseFloat(d), p = parseFloat(p), (m = parseFloat(m)) && (p += m = parseFloat(m), d += m), d || p ? (d *= _o, p *= _o, t = Math.cos(d) * g, i = Math.sin(d) * g, r = Math.sin(d - p) * -f, s = Math.cos(d - p) * f, p && (m *= _o, a = Math.tan(p - m), r *= a = Math.sqrt(1 + a * a), s *= a, m && (a = Math.tan(m), t *= a = Math.sqrt(1 + a * a), i *= a)), t = zt(t), i = zt(i), r = zt(r), s = zt(s)) : (t = g, s = f, i = r = 0), (w && !~(c + "").indexOf("px") || T && !~(u + "").indexOf("px")) && (w = Ms(v, "x", c, "px"), T = Ms(v, "y", u, "px")), (y || x || M || b) && (w = zt(w + y - (y * t + x * r) + M), T = zt(T + x - (y * i + x * s) + b)), (l || h) && (a = v.getBBox(), w = zt(w + l / 100 * a.width), T = zt(T + h / 100 * a.height)), a = "matrix(" + t + "," + i + "," + r + "," + s + "," + w + "," + T + ")", v.setAttribute("transform", a), S && (v.style[At] = a);
}, oA = function(n, e, t, i, r) {
  var s, a, o = 360, l = un(r), h = parseFloat(r) * (l && ~r.indexOf("rad") ? Qs : 1) - i, c = i + h + "deg";
  return l && ((s = r.split("_")[1]) === "short" && (h %= o) !== h % 180 && (h += h < 0 ? o : -360), s === "cw" && h < 0 ? h = (h + 36e9) % o - ~~(h / o) * o : s === "ccw" && h > 0 && (h = (h - 36e9) % o - ~~(h / o) * o)), n.Ki = a = new Gn(n.Ki, e, t, i, h, jE), a.e = c, a.u = "deg", n.ts.push(t), a;
}, $y = function(n, e) {
  for (var t in e)
    n[t] = e[t];
  return n;
}, lA = function(n, e, t) {
  var i, r, s, a, o, l, h, c = $y({}, t.Ci), u = t.style;
  for (r in c.svg ? (s = t.getAttribute("transform"), t.setAttribute("transform", ""), u[At] = e, i = Eh(t, 1), Pa(t, At), t.setAttribute("transform", s)) : (s = getComputedStyle(t)[At], u[At] = e, i = Eh(t, 1), u[At] = s), Lr)
    (s = c[r]) !== (a = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = _n(s) !== (h = _n(a)) ? Ms(t, r, s, h) : parseFloat(s), l = parseFloat(a), n.Ki = new Gn(n.Ki, i, r, o, l - o, Km), n.Ki.u = h || 0, n.ts.push(r));
  $y(i, c);
};
Vn("padding,margin,Width,Radius", function(n, e) {
  var t = "Top", i = "Right", r = "Bottom", s = "Left", a = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function(o) {
    return e < 2 ? n + o : "border" + o + n;
  });
  nd[e > 1 ? "border" + n : n] = function(o, l, h, c, u) {
    var d, p;
    if (arguments.length < 4)
      return d = a.map(function(m) {
        return yr(o, m, h);
      }), (p = d.join(" ")).split(d[0]).length === 5 ? d[0] : p;
    d = (c + "").split(" "), p = {}, a.forEach(function(m, g) {
      return p[m] = d[g] = d[g] || d[(g - 1) / 2 | 0];
    }), o.init(l, p, u);
  };
});
var ex, df, pf, Lb = { name: "css", register: Qm, targetTest: function(n) {
  return n.style && n.nodeType;
}, init: function(n, e, t, i, r) {
  var s, a, o, l, h, c, u, d, p, m, g, f, v, y, x, M, b = this.ts, S = n.style, w = t.vars.startAt;
  for (u in r0 || Qm(), this.styles = this.styles || Eb(n), M = this.styles.props, this.tween = t, e)
    if (u !== "autoRound" && (a = e[u], !Kn[u] || !fb(u, e, t, i, n, r))) {
      if (h = typeof a, c = nd[u], h === "function" && (h = typeof (a = a.call(t, i, n, r))), h === "string" && ~a.indexOf("random(") && (a = wh(a)), c)
        c(this, n, u, a, t) && (x = 1);
      else if (u.substr(0, 2) === "--")
        s = (getComputedStyle(n).getPropertyValue(u) + "").trim(), a += "", cs.lastIndex = 0, cs.test(s) || (d = _n(s), p = _n(a)), p ? d !== p && (s = Ms(n, u, s, p) + p) : d && (a += d), this.add(S, "setProperty", s, a, i, r, 0, 0, u), b.push(u), M.push(u, 0, S[u]);
      else if (h !== "undefined") {
        if (w && u in w ? (s = typeof w[u] == "function" ? w[u].call(t, i, n, r) : w[u], un(s) && ~s.indexOf("random(") && (s = wh(s)), _n(s + "") || s === "auto" || (s += si.units[u] || _n(yr(n, u)) || ""), (s + "").charAt(1) === "=" && (s = yr(n, u))) : s = yr(n, u), l = parseFloat(s), (m = h === "string" && a.charAt(1) === "=" && a.substr(0, 2)) && (a = a.substr(2)), o = parseFloat(a), u in Qi && (u === "autoAlpha" && (l === 1 && yr(n, "visibility") === "hidden" && o && (l = 0), M.push("visibility", 0, S.visibility), ts(this, S, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), u !== "scale" && u !== "transform" && ~(u = Qi[u]).indexOf(",") && (u = u.split(",")[0])), g = u in Lr)
          if (this.styles.save(u), f || ((v = n.Ci).renderTransform && !e.parseTransform || Eh(n, e.parseTransform), y = e.smoothOrigin !== !1 && v.smooth, (f = this.Ki = new Gn(this.Ki, S, At, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), u === "scale")
            this.Ki = new Gn(this.Ki, v, "scaleY", v.scaleY, (m ? bo(v.scaleY, m + o) : o) - v.scaleY || 0, Km), this.Ki.u = 0, b.push("scaleY", u), u += "X";
          else {
            if (u === "transformOrigin") {
              M.push(Wn, 0, S[Wn]), a = iA(a), v.svg ? $m(n, a, 0, y, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== v.zOrigin && ts(this, v, "zOrigin", v.zOrigin, p), ts(this, S, u, id(s), id(a)));
              continue;
            }
            if (u === "svgOrigin") {
              $m(n, a, 1, y, 0, this);
              continue;
            }
            if (u in Pb) {
              oA(this, v, u, l, m ? bo(l, m + a) : a);
              continue;
            }
            if (u === "smoothOrigin") {
              ts(this, v, "smooth", v.smooth, a);
              continue;
            }
            if (u === "force3D") {
              v[u] = a;
              continue;
            }
            if (u === "transform") {
              lA(this, a, n);
              continue;
            }
          }
        else
          u in S || (u = Zo(u) || u);
        if (g || (o || o === 0) && (l || l === 0) && !GE.test(a) && u in S)
          o || (o = 0), (d = (s + "").substr((l + "").length)) !== (p = _n(a) || (u in si.units ? si.units[u] : d)) && (l = Ms(n, u, s, p)), this.Ki = new Gn(this.Ki, g ? v : S, u, l, (m ? bo(l, m + o) : o) - l, g || p !== "px" && u !== "zIndex" || e.autoRound === !1 ? Km : XE), this.Ki.u = p || 0, d !== p && p !== "%" && (this.Ki.b = s, this.Ki.r = WE);
        else if (u in S)
          nA.call(this, n, u, s, m ? m + a : a);
        else if (u in n)
          this.add(n, u, s || n[u], m ? m + a : a, i, r);
        else if (u !== "parseTransform")
          continue;
        g || (u in S ? M.push(u, 0, S[u]) : M.push(u, 1, s || n[u])), b.push(u);
      }
    }
  x && Mb(this);
}, render: function(n, e) {
  if (e.tween.Xi || !s0())
    for (var t = e.Ki; t; )
      t.r(n, t.d), t = t.Ii;
  else
    e.styles.revert();
}, get: yr, aliases: Qi, getSetter: function(n, e, t) {
  var i = Qi[e];
  return i && i.indexOf(",") < 0 && (e = i), e in Lr && e !== Wn && (n.Ci.x || yr(n, "x")) ? t && qy === t ? e === "scale" ? KE : ZE : (qy = t || {}) && (e === "scale" ? JE : QE) : n.style && !Kg(n.style[e]) ? qE : ~e.indexOf("-") ? YE : i0(n, e);
}, core: { Ls: Pa, Ns: o0 } };
jn.utils.checkPrefix = Zo, jn.core.getStyleSaver = Eb, pf = Vn((ex = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (df = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function(n) {
  Lr[n] = 1;
}), Vn(df, function(n) {
  si.units[n] = "deg", Pb[n] = 1;
}), Qi[pf[13]] = ex + "," + df, Vn("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function(n) {
  var e = n.split(":");
  Qi[e[1]] = pf[e[0]];
}), Vn("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(n) {
  si.units[n] = "px";
}), jn.registerPlugin(Lb);
var l0 = jn.registerPlugin(Lb) || jn;
function po(n, e) {
  var t = n.Rs.conversionName.toString(), i = Math.round(n.r), r = Math.round(n.g), s = Math.round(n.b), a = n.a, o = Math.round(n.h), l = n.s.toFixed(1), h = n.v.toFixed(1);
  if (e || t === "THREE_CHAR_HEX" || t === "SIX_CHAR_HEX") {
    for (var c = n.hex.toString(16); c.length < 6; )
      c = "0" + c;
    return "#" + c;
  }
  return t === "CSS_RGB" ? "rgb(" + i + "," + r + "," + s + ")" : t === "CSS_RGBA" ? "rgba(" + i + "," + r + "," + s + "," + a + ")" : t === "HEX" ? "0x" + n.hex.toString(16) : t === "RGB_ARRAY" ? "[" + i + "," + r + "," + s + "]" : t === "RGBA_ARRAY" ? "[" + i + "," + r + "," + s + "," + a + "]" : t === "RGB_OBJ" ? "{r:" + i + ",g:" + r + ",b:" + s + "}" : t === "RGBA_OBJ" ? "{r:" + i + ",g:" + r + ",b:" + s + ",a:" + a + "}" : t === "HSV_OBJ" ? "{h:" + o + ",s:" + l + ",v:" + h + "}" : t === "HSVA_OBJ" ? "{h:" + o + ",s:" + l + ",v:" + h + ",a:" + a + "}" : "unknown format";
}
l0.core.Tween;
var tx = Array.prototype.forEach, bl = Array.prototype.slice, he = { BREAK: {}, extend: function(n) {
  return this.each(bl.call(arguments, 1), function(e) {
    (this.isObject(e) ? Object.keys(e) : []).forEach(function(t) {
      this.isUndefined(e[t]) || (n[t] = e[t]);
    }.bind(this));
  }, this), n;
}, defaults: function(n) {
  return this.each(bl.call(arguments, 1), function(e) {
    (this.isObject(e) ? Object.keys(e) : []).forEach(function(t) {
      this.isUndefined(n[t]) && (n[t] = e[t]);
    }.bind(this));
  }, this), n;
}, compose: function() {
  var n = bl.call(arguments);
  return function() {
    for (var e = bl.call(arguments), t = n.length - 1; t >= 0; t--)
      e = [n[t].apply(this, e)];
    return e[0];
  };
}, each: function(n, e, t) {
  if (n) {
    if (tx && n.forEach && n.forEach === tx)
      n.forEach(e, t);
    else if (n.length === n.length + 0) {
      var i, r = void 0;
      for (r = 0, i = n.length; r < i; r++)
        if (r in n && e.call(t, n[r], r) === this.BREAK)
          return;
    } else
      for (var s in n)
        if (e.call(t, n[s], s) === this.BREAK)
          return;
  }
}, defer: function(n) {
  setTimeout(n, 0);
}, debounce: function(n, e, t) {
  var i = void 0;
  return function() {
    var r = this, s = arguments, a = t || !i;
    clearTimeout(i), i = setTimeout(function() {
      i = null, t || n.apply(r, s);
    }, e), a && n.apply(r, s);
  };
}, toArray: function(n) {
  return n.toArray ? n.toArray() : bl.call(n);
}, isUndefined: function(n) {
  return n === void 0;
}, isNull: function(n) {
  return n === null;
}, isNaN: function(n) {
  function e(t) {
    return n.apply(this, arguments);
  }
  return e.toString = function() {
    return n.toString();
  }, e;
}(function(n) {
  return isNaN(n);
}), isArray: Array.isArray || function(n) {
  return n.constructor === Array;
}, isObject: function(n) {
  return n === Object(n);
}, isNumber: function(n) {
  return n === n + 0;
}, isString: function(n) {
  return n === n + "";
}, isBoolean: function(n) {
  return n === !1 || n === !0;
}, isFunction: function(n) {
  return n instanceof Function;
} }, hA = [{ litmus: he.isString, conversions: { THREE_CHAR_HEX: { read: function(n) {
  var e = n.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
  return e !== null && { space: "HEX", hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0) };
}, write: po }, SIX_CHAR_HEX: { read: function(n) {
  var e = n.match(/^#([A-F0-9]{6})$/i);
  return e !== null && { space: "HEX", hex: parseInt("0x" + e[1].toString(), 0) };
}, write: po }, CSS_RGB: { read: function(n) {
  var e = n.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
  return e !== null && { space: "RGB", r: parseFloat(e[1]), g: parseFloat(e[2]), b: parseFloat(e[3]) };
}, write: po }, CSS_RGBA: { read: function(n) {
  var e = n.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
  return e !== null && { space: "RGB", r: parseFloat(e[1]), g: parseFloat(e[2]), b: parseFloat(e[3]), a: parseFloat(e[4]) };
}, write: po } } }, { litmus: he.isNumber, conversions: { HEX: { read: function(n) {
  return { space: "HEX", hex: n, conversionName: "HEX" };
}, write: function(n) {
  return n.hex;
} } } }, { litmus: he.isArray, conversions: { RGB_ARRAY: { read: function(n) {
  return n.length === 3 && { space: "RGB", r: n[0], g: n[1], b: n[2] };
}, write: function(n) {
  return [n.r, n.g, n.b];
} }, RGBA_ARRAY: { read: function(n) {
  return n.length === 4 && { space: "RGB", r: n[0], g: n[1], b: n[2], a: n[3] };
}, write: function(n) {
  return [n.r, n.g, n.b, n.a];
} } } }, { litmus: he.isObject, conversions: { RGBA_OBJ: { read: function(n) {
  return !!(he.isNumber(n.r) && he.isNumber(n.g) && he.isNumber(n.b) && he.isNumber(n.a)) && { space: "RGB", r: n.r, g: n.g, b: n.b, a: n.a };
}, write: function(n) {
  return { r: n.r, g: n.g, b: n.b, a: n.a };
} }, RGB_OBJ: { read: function(n) {
  return !!(he.isNumber(n.r) && he.isNumber(n.g) && he.isNumber(n.b)) && { space: "RGB", r: n.r, g: n.g, b: n.b };
}, write: function(n) {
  return { r: n.r, g: n.g, b: n.b };
} }, HSVA_OBJ: { read: function(n) {
  return !!(he.isNumber(n.h) && he.isNumber(n.s) && he.isNumber(n.v) && he.isNumber(n.a)) && { space: "HSV", h: n.h, s: n.s, v: n.v, a: n.a };
}, write: function(n) {
  return { h: n.h, s: n.s, v: n.v, a: n.a };
} }, HSV_OBJ: { read: function(n) {
  return !!(he.isNumber(n.h) && he.isNumber(n.s) && he.isNumber(n.v)) && { space: "HSV", h: n.h, s: n.s, v: n.v };
}, write: function(n) {
  return { h: n.h, s: n.s, v: n.v };
} } } }], Sl = void 0, tu = void 0, rd = function() {
  tu = !1;
  var n = arguments.length > 1 ? he.toArray(arguments) : arguments[0];
  return he.each(hA, function(e) {
    if (e.litmus(n))
      return he.each(e.conversions, function(t, i) {
        if (Sl = t.read(n), tu === !1 && Sl !== !1)
          return tu = Sl, Sl.conversionName = i, Sl.conversion = t, he.BREAK;
      }), he.BREAK;
  }), tu;
}, nx = void 0, Bl = { hsv_to_rgb: function(n, e, t) {
  var i = Math.floor(n / 60) % 6, r = n / 60 - Math.floor(n / 60), s = t * (1 - e), a = t * (1 - r * e), o = t * (1 - (1 - r) * e), l = [[t, o, s], [a, t, s], [s, t, o], [s, a, t], [o, s, t], [t, s, a]][i];
  return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] };
}, rgb_to_hsv: function(n, e, t) {
  var i = Math.min(n, e, t), r = Math.max(n, e, t), s = r - i, a = void 0;
  return r === 0 ? { h: NaN, s: 0, v: 0 } : (a = n === r ? (e - t) / s : e === r ? 2 + (t - n) / s : 4 + (n - e) / s, (a /= 6) < 0 && (a += 1), { h: 360 * a, s: s / r, v: r / 255 });
}, rgb_to_hex: function(n, e, t) {
  var i = this.hex_with_component(0, 2, n);
  return i = this.hex_with_component(i, 1, e), i = this.hex_with_component(i, 0, t);
}, component_from_hex: function(n, e) {
  return n >> 8 * e & 255;
}, hex_with_component: function(n, e, t) {
  return t << (nx = 8 * e) | n & ~(255 << nx);
} }, cA = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
  return typeof n;
} : function(n) {
  return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n;
}, Fi = function(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}, Bi = /* @__PURE__ */ function() {
  function n(e, t) {
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
    }
  }
  return function(e, t, i) {
    return t && n(e.prototype, t), i && n(e, i), e;
  };
}(), bs = function n(e, t, i) {
  e === null && (e = Function.prototype);
  var r = Object.getOwnPropertyDescriptor(e, t);
  if (r === void 0) {
    var s = Object.getPrototypeOf(e);
    return s === null ? void 0 : n(s, t, i);
  }
  if ("value" in r)
    return r.value;
  var a = r.get;
  return a === void 0 ? void 0 : a.call(i);
}, _s = function(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  n.prototype = Object.create(e && e.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e);
}, Ts = function(n, e) {
  if (!n)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return !e || typeof e != "object" && typeof e != "function" ? n : e;
}, tn = function() {
  function n() {
    if (Fi(this, n), this.Rs = rd.apply(this, arguments), this.Rs === !1)
      throw new Error("Failed to interpret color arguments");
    this.Rs.a = this.Rs.a || 1;
  }
  return Bi(n, [{ key: "toString", value: function() {
    return po(this);
  } }, { key: "toHexString", value: function() {
    return po(this, !0);
  } }, { key: "toOriginal", value: function() {
    return this.Rs.conversion.write(this);
  } }]), n;
}();
function ff(n, e, t) {
  Object.defineProperty(n, e, { get: function() {
    return this.Rs.space === "RGB" || tn.recalculateRGB(this, e, t), this.Rs[e];
  }, set: function(i) {
    this.Rs.space !== "RGB" && (tn.recalculateRGB(this, e, t), this.Rs.space = "RGB"), this.Rs[e] = i;
  } });
}
function mf(n, e) {
  Object.defineProperty(n, e, { get: function() {
    return this.Rs.space === "HSV" || tn.recalculateHSV(this), this.Rs[e];
  }, set: function(t) {
    this.Rs.space !== "HSV" && (tn.recalculateHSV(this), this.Rs.space = "HSV"), this.Rs[e] = t;
  } });
}
tn.recalculateRGB = function(n, e, t) {
  if (n.Rs.space === "HEX")
    n.Rs[e] = Bl.component_from_hex(n.Rs.hex, t);
  else {
    if (n.Rs.space !== "HSV")
      throw new Error("Corrupted color state");
    he.extend(n.Rs, Bl.hsv_to_rgb(n.Rs.h, n.Rs.s, n.Rs.v));
  }
}, tn.recalculateHSV = function(n) {
  var e = Bl.rgb_to_hsv(n.r, n.g, n.b);
  he.extend(n.Rs, { s: e.s, v: e.v }), he.isNaN(e.h) ? he.isUndefined(n.Rs.h) && (n.Rs.h = 0) : n.Rs.h = e.h;
}, tn.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], ff(tn.prototype, "r", 2), ff(tn.prototype, "g", 1), ff(tn.prototype, "b", 0), mf(tn.prototype, "h"), mf(tn.prototype, "s"), mf(tn.prototype, "v"), Object.defineProperty(tn.prototype, "a", { get: function() {
  return this.Rs.a;
}, set: function(n) {
  this.Rs.a = n;
} }), Object.defineProperty(tn.prototype, "hex", { get: function() {
  return this.Rs.space !== "HEX" && (this.Rs.hex = Bl.rgb_to_hex(this.r, this.g, this.b), this.Rs.space = "HEX"), this.Rs.hex;
}, set: function(n) {
  this.Rs.space = "HEX", this.Rs.hex = n;
} });
var Es = function() {
  function n(e, t) {
    Fi(this, n), this.initialValue = e[t], this.domElement = document.createElement("div"), this.object = e, this.property = t, this.Ds = void 0, this.Is = void 0;
  }
  return Bi(n, [{ key: "onChange", value: function(e) {
    return this.Ds = e, this;
  } }, { key: "onFinishChange", value: function(e) {
    return this.Is = e, this;
  } }, { key: "setValue", value: function(e) {
    return this.object[this.property] = e, this.Ds && this.Ds.call(this, e), this.updateDisplay(), this;
  } }, { key: "getValue", value: function() {
    return this.object[this.property];
  } }, { key: "updateDisplay", value: function() {
    return this;
  } }, { key: "isModified", value: function() {
    return this.initialValue !== this.getValue();
  } }]), n;
}(), Nb = {};
he.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, function(n, e) {
  he.each(n, function(t) {
    Nb[t] = e;
  });
});
var uA = /(\d+(\.\d+)?)px/;
function zi(n) {
  if (n === "0" || he.isUndefined(n))
    return 0;
  var e = n.match(uA);
  return he.isNull(e) ? 0 : parseFloat(e[1]);
}
var Y = { makeSelectable: function(n, e) {
  n !== void 0 && n.style !== void 0 && (n.onselectstart = e ? function() {
    return !1;
  } : function() {
  }, n.style.MozUserSelect = e ? "auto" : "none", n.style.KhtmlUserSelect = e ? "auto" : "none", n.unselectable = e ? "on" : "off");
}, makeFullscreen: function(n, e, t) {
  var i = t, r = e;
  he.isUndefined(r) && (r = !0), he.isUndefined(i) && (i = !0), n.style.position = "absolute", r && (n.style.left = 0, n.style.right = 0), i && (n.style.top = 0, n.style.bottom = 0);
}, fakeEvent: function(n, e, t, i) {
  var r = t || {}, s = Nb[e];
  if (!s)
    throw new Error("Event type " + e + " not supported.");
  var a = document.createEvent(s);
  switch (s) {
    case "MouseEvents":
      var o = r.x || r.clientX || 0, l = r.y || r.clientY || 0;
      a.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, o, l, !1, !1, !1, !1, 0, null);
      break;
    case "KeyboardEvents":
      var h = a.initKeyboardEvent || a.initKeyEvent;
      he.defaults(r, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), h(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
      break;
    default:
      a.initEvent(e, r.bubbles || !1, r.cancelable || !0);
  }
  he.defaults(a, i), n.dispatchEvent(a);
}, bind: function(n, e, t, i) {
  var r = i || !1;
  return n.addEventListener ? n.addEventListener(e, t, r) : n.attachEvent && n.attachEvent("on" + e, t), Y;
}, unbind: function(n, e, t, i) {
  var r = i || !1;
  return n.removeEventListener ? n.removeEventListener(e, t, r) : n.detachEvent && n.detachEvent("on" + e, t), Y;
}, addClass: function(n, e) {
  if (n.className === void 0)
    n.className = e;
  else if (n.className !== e) {
    var t = n.className.split(/ +/);
    t.indexOf(e) === -1 && (t.push(e), n.className = t.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
  }
  return Y;
}, removeClass: function(n, e) {
  if (e)
    if (n.className === e)
      n.removeAttribute("class");
    else {
      var t = n.className.split(/ +/), i = t.indexOf(e);
      i !== -1 && (t.splice(i, 1), n.className = t.join(" "));
    }
  else
    n.className = void 0;
  return Y;
}, hasClass: function(n, e) {
  return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(n.className) || !1;
}, getWidth: function(n) {
  var e = getComputedStyle(n);
  return zi(e["border-left-width"]) + zi(e["border-right-width"]) + zi(e["padding-left"]) + zi(e["padding-right"]) + zi(e.width);
}, getHeight: function(n) {
  var e = getComputedStyle(n);
  return zi(e["border-top-width"]) + zi(e["border-bottom-width"]) + zi(e["padding-top"]) + zi(e["padding-bottom"]) + zi(e.height);
}, getOffset: function(n) {
  var e = n, t = { left: 0, top: 0 };
  if (e.offsetParent)
    do
      t.left += e.offsetLeft, t.top += e.offsetTop, e = e.offsetParent;
    while (e);
  return t;
}, isActive: function(n) {
  return n === document.activeElement && (n.type || n.href);
} }, h0 = function(n) {
  function e(t, i) {
    Fi(this, e);
    var r = Ts(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)), s = r;
    return r.Us = r.getValue(), r.Os = document.createElement("input"), r.Os.setAttribute("type", "checkbox"), Y.bind(r.Os, "change", function() {
      s.setValue(!s.Us);
    }, !1), r.domElement.appendChild(r.Os), r.updateDisplay(), r;
  }
  return _s(e, Es), Bi(e, [{ key: "setValue", value: function(t) {
    var i = bs(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
    return this.Is && this.Is.call(this, this.getValue()), this.Us = this.getValue(), i;
  } }, { key: "updateDisplay", value: function() {
    return this.getValue() === !0 ? (this.Os.setAttribute("checked", "checked"), this.Os.checked = !0, this.Us = !0) : (this.Os.checked = !1, this.Us = !1), bs(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
  } }]), e;
}(), Db = function(n) {
  function e(t, i, r) {
    Fi(this, e);
    var s = Ts(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)), a = r, o = s;
    if (s.ks = document.createElement("select"), he.isArray(a)) {
      var l = {};
      he.each(a, function(h) {
        l[h] = h;
      }), a = l;
    }
    return he.each(a, function(h, c) {
      var u = document.createElement("option");
      u.innerHTML = c, u.setAttribute("value", h), o.ks.appendChild(u);
    }), s.updateDisplay(), Y.bind(s.ks, "change", function() {
      var h = this.options[this.selectedIndex].value;
      o.setValue(h);
    }), s.domElement.appendChild(s.ks), s;
  }
  return _s(e, Es), Bi(e, [{ key: "setValue", value: function(t) {
    var i = bs(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
    return this.Is && this.Is.call(this, this.getValue()), i;
  } }, { key: "updateDisplay", value: function() {
    return Y.isActive(this.ks) ? this : (this.ks.value = this.getValue(), bs(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this));
  } }]), e;
}(), Ob = function(n) {
  function e(t, i) {
    Fi(this, e);
    var r = Ts(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)), s = r;
    function a() {
      s.setValue(s.Fs.value);
    }
    return r.Fs = document.createElement("input"), r.Fs.setAttribute("type", "text"), Y.bind(r.Fs, "keyup", a), Y.bind(r.Fs, "change", a), Y.bind(r.Fs, "blur", function() {
      s.Is && s.Is.call(s, s.getValue());
    }), Y.bind(r.Fs, "keydown", function(o) {
      o.keyCode === 13 && this.blur();
    }), r.updateDisplay(), r.domElement.appendChild(r.Fs), r;
  }
  return _s(e, Es), Bi(e, [{ key: "updateDisplay", value: function() {
    return Y.isActive(this.Fs) || (this.Fs.value = this.getValue()), bs(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
  } }]), e;
}();
function ix(n) {
  var e = n.toString();
  return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0;
}
var c0 = function(n) {
  function e(t, i, r) {
    Fi(this, e);
    var s = Ts(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)), a = r || {};
    return s.Gs = a.min, s.Bs = a.max, s.Hs = a.step, he.isUndefined(s.Hs) ? s.initialValue === 0 ? s.zs = 1 : s.zs = Math.pow(10, Math.floor(Math.log(Math.abs(s.initialValue)) / Math.LN10)) / 10 : s.zs = s.Hs, s.Vs = ix(s.zs), s;
  }
  return _s(e, Es), Bi(e, [{ key: "setValue", value: function(t) {
    var i = t;
    return this.Gs !== void 0 && i < this.Gs ? i = this.Gs : this.Bs !== void 0 && i > this.Bs && (i = this.Bs), this.Hs !== void 0 && i % this.Hs != 0 && (i = Math.round(i / this.Hs) * this.Hs), bs(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, i);
  } }, { key: "min", value: function(t) {
    return this.Gs = t, this;
  } }, { key: "max", value: function(t) {
    return this.Bs = t, this;
  } }, { key: "step", value: function(t) {
    return this.Hs = t, this.zs = t, this.Vs = ix(t), this;
  } }]), e;
}(), Ah = function(n) {
  function e(t, i, r) {
    Fi(this, e);
    var s = Ts(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, r));
    s.Ws = !1;
    var a = s, o = void 0;
    function l() {
      a.Is && a.Is.call(a, a.getValue());
    }
    function h(u) {
      var d = o - u.clientY;
      a.setValue(a.getValue() + d * a.zs), o = u.clientY;
    }
    function c() {
      Y.unbind(window, "mousemove", h), Y.unbind(window, "mouseup", c), l();
    }
    return s.Fs = document.createElement("input"), s.Fs.setAttribute("type", "text"), Y.bind(s.Fs, "change", function() {
      var u = parseFloat(a.Fs.value);
      he.isNaN(u) || a.setValue(u);
    }), Y.bind(s.Fs, "blur", function() {
      l();
    }), Y.bind(s.Fs, "mousedown", function(u) {
      Y.bind(window, "mousemove", h), Y.bind(window, "mouseup", c), o = u.clientY;
    }), Y.bind(s.Fs, "keydown", function(u) {
      u.keyCode === 13 && (a.Ws = !0, this.blur(), a.Ws = !1, l());
    }), s.updateDisplay(), s.domElement.appendChild(s.Fs), s;
  }
  return _s(e, c0), Bi(e, [{ key: "updateDisplay", value: function() {
    var t, i, r;
    return this.Fs.value = this.Ws ? this.getValue() : (t = this.getValue(), i = this.Vs, r = Math.pow(10, i), Math.round(t * r) / r), bs(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
  } }]), e;
}();
function rx(n, e, t, i, r) {
  return i + (n - e) / (t - e) * (r - i);
}
var sd = function(n) {
  function e(t, i, r, s, a) {
    Fi(this, e);
    var o = Ts(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, { min: r, max: s, step: a })), l = o;
    function h(p) {
      p.preventDefault();
      var m = l.js.getBoundingClientRect();
      return l.setValue(rx(p.clientX, m.left, m.right, l.Gs, l.Bs)), !1;
    }
    function c() {
      Y.unbind(window, "mousemove", h), Y.unbind(window, "mouseup", c), l.Is && l.Is.call(l, l.getValue());
    }
    function u(p) {
      var m = p.touches[0].clientX, g = l.js.getBoundingClientRect();
      l.setValue(rx(m, g.left, g.right, l.Gs, l.Bs));
    }
    function d() {
      Y.unbind(window, "touchmove", u), Y.unbind(window, "touchend", d), l.Is && l.Is.call(l, l.getValue());
    }
    return o.js = document.createElement("div"), o.Xs = document.createElement("div"), Y.bind(o.js, "mousedown", function(p) {
      document.activeElement.blur(), Y.bind(window, "mousemove", h), Y.bind(window, "mouseup", c), h(p);
    }), Y.bind(o.js, "touchstart", function(p) {
      p.touches.length === 1 && (Y.bind(window, "touchmove", u), Y.bind(window, "touchend", d), u(p));
    }), Y.addClass(o.js, "slider"), Y.addClass(o.Xs, "slider-fg"), o.updateDisplay(), o.js.appendChild(o.Xs), o.domElement.appendChild(o.js), o;
  }
  return _s(e, c0), Bi(e, [{ key: "updateDisplay", value: function() {
    var t = (this.getValue() - this.Gs) / (this.Bs - this.Gs);
    return this.Xs.style.width = 100 * t + "%", bs(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
  } }]), e;
}(), u0 = function(n) {
  function e(t, i, r) {
    Fi(this, e);
    var s = Ts(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)), a = s;
    return s.Ys = document.createElement("div"), s.Ys.innerHTML = r === void 0 ? "Fire" : r, Y.bind(s.Ys, "click", function(o) {
      return o.preventDefault(), a.fire(), !1;
    }), Y.addClass(s.Ys, "button"), s.domElement.appendChild(s.Ys), s;
  }
  return _s(e, Es), Bi(e, [{ key: "fire", value: function() {
    this.Ds && this.Ds.call(this), this.getValue().call(this.object), this.Is && this.Is.call(this, this.getValue());
  } }]), e;
}(), Ou = function(n) {
  function e(t, i) {
    Fi(this, e);
    var r = Ts(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
    r.qs = new tn(r.getValue()), r.Zs = new tn(0);
    var s = r;
    r.domElement = document.createElement("div"), Y.makeSelectable(r.domElement, !1), r.Js = document.createElement("div"), r.Js.className = "selector", r.Ks = document.createElement("div"), r.Ks.className = "saturation-field", r.$s = document.createElement("div"), r.$s.className = "field-knob", r.Qs = "2px solid ", r.tr = document.createElement("div"), r.tr.className = "hue-knob", r.er = document.createElement("div"), r.er.className = "hue-field", r.Fs = document.createElement("input"), r.Fs.type = "text", r.nr = "0 1px 1px ", Y.bind(r.Fs, "keydown", function(f) {
      f.keyCode === 13 && d.call(this);
    }), Y.bind(r.Fs, "blur", d), Y.bind(r.Js, "mousedown", function() {
      Y.addClass(this, "drag").bind(window, "mouseup", function() {
        Y.removeClass(s.Js, "drag");
      });
    }), Y.bind(r.Js, "touchstart", function() {
      Y.addClass(this, "drag").bind(window, "touchend", function() {
        Y.removeClass(s.Js, "drag");
      });
    });
    var a, o = document.createElement("div");
    function l(f) {
      m(f), Y.bind(window, "mousemove", m), Y.bind(window, "touchmove", m), Y.bind(window, "mouseup", c), Y.bind(window, "touchend", c);
    }
    function h(f) {
      g(f), Y.bind(window, "mousemove", g), Y.bind(window, "touchmove", g), Y.bind(window, "mouseup", u), Y.bind(window, "touchend", u);
    }
    function c() {
      Y.unbind(window, "mousemove", m), Y.unbind(window, "touchmove", m), Y.unbind(window, "mouseup", c), Y.unbind(window, "touchend", c), p();
    }
    function u() {
      Y.unbind(window, "mousemove", g), Y.unbind(window, "touchmove", g), Y.unbind(window, "mouseup", u), Y.unbind(window, "touchend", u), p();
    }
    function d() {
      var f = rd(this.value);
      f !== !1 ? (s.qs.Rs = f, s.setValue(s.qs.toOriginal())) : this.value = s.qs.toString();
    }
    function p() {
      s.Is && s.Is.call(s, s.qs.toOriginal());
    }
    function m(f) {
      f.type.indexOf("touch") === -1 && f.preventDefault();
      var v = s.Ks.getBoundingClientRect(), y = f.touches && f.touches[0] || f, x = y.clientX, M = y.clientY, b = (x - v.left) / (v.right - v.left), S = 1 - (M - v.top) / (v.bottom - v.top);
      return S > 1 ? S = 1 : S < 0 && (S = 0), b > 1 ? b = 1 : b < 0 && (b = 0), s.qs.v = S, s.qs.s = b, s.setValue(s.qs.toOriginal()), !1;
    }
    function g(f) {
      f.type.indexOf("touch") === -1 && f.preventDefault();
      var v = s.er.getBoundingClientRect(), y = 1 - ((f.touches && f.touches[0] || f).clientY - v.top) / (v.bottom - v.top);
      return y > 1 ? y = 1 : y < 0 && (y = 0), s.qs.h = 360 * y, s.setValue(s.qs.toOriginal()), !1;
    }
    return he.extend(r.Js.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), he.extend(r.$s.style, { position: "absolute", width: "12px", height: "12px", border: r.Qs + (r.qs.v < 0.5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), he.extend(r.tr.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), he.extend(r.Ks.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), he.extend(o.style, { width: "100%", height: "100%", background: "none" }), sx(o, "top", "rgba(0,0,0,0)", "#000"), he.extend(r.er.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), (a = r.er).style.background = "", a.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", a.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", he.extend(r.Fs.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: r.nr + "rgba(0,0,0,0.7)" }), Y.bind(r.Ks, "mousedown", l), Y.bind(r.Ks, "touchstart", l), Y.bind(r.$s, "mousedown", l), Y.bind(r.$s, "touchstart", l), Y.bind(r.er, "mousedown", h), Y.bind(r.er, "touchstart", h), r.Ks.appendChild(o), r.Js.appendChild(r.$s), r.Js.appendChild(r.Ks), r.Js.appendChild(r.er), r.er.appendChild(r.tr), r.domElement.appendChild(r.Fs), r.domElement.appendChild(r.Js), r.updateDisplay(), r;
  }
  return _s(e, Es), Bi(e, [{ key: "updateDisplay", value: function() {
    var t = rd(this.getValue());
    if (t !== !1) {
      var i = !1;
      he.each(tn.COMPONENTS, function(a) {
        if (!he.isUndefined(t[a]) && !he.isUndefined(this.qs.Rs[a]) && t[a] !== this.qs.Rs[a])
          return i = !0, {};
      }, this), i && he.extend(this.qs.Rs, t);
    }
    he.extend(this.Zs.Rs, this.qs.Rs), this.Zs.a = 1;
    var r = this.qs.v < 0.5 || this.qs.s > 0.5 ? 255 : 0, s = 255 - r;
    he.extend(this.$s.style, { marginLeft: 100 * this.qs.s - 7 + "px", marginTop: 100 * (1 - this.qs.v) - 7 + "px", backgroundColor: this.Zs.toHexString(), border: this.Qs + "rgb(" + r + "," + r + "," + r + ")" }), this.tr.style.marginTop = 100 * (1 - this.qs.h / 360) + "px", this.Zs.s = 1, this.Zs.v = 1, sx(this.Ks, "left", "#fff", this.Zs.toHexString()), this.Fs.value = this.qs.toString(), he.extend(this.Fs.style, { backgroundColor: this.qs.toHexString(), color: "rgb(" + r + "," + r + "," + r + ")", textShadow: this.nr + "rgba(" + s + "," + s + "," + s + ",.7)" });
  } }]), e;
}(), dA = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
function sx(n, e, t, i) {
  n.style.background = "", he.each(dA, function(r) {
    n.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + t + " 0%, " + i + " 100%); ";
  });
}
var pA = function(n, e) {
  var t = e || document, i = document.createElement("style");
  i.type = "text/css", i.innerHTML = n;
  var r = t.getElementsByTagName("head")[0];
  try {
    r.appendChild(i);
  } catch (s) {
  }
}, fA = function(n, e) {
  var t = n[e];
  return he.isArray(arguments[2]) || he.isObject(arguments[2]) ? new Db(n, e, arguments[2]) : he.isNumber(t) ? he.isNumber(arguments[2]) && he.isNumber(arguments[3]) ? he.isNumber(arguments[4]) ? new sd(n, e, arguments[2], arguments[3], arguments[4]) : new sd(n, e, arguments[2], arguments[3]) : he.isNumber(arguments[4]) ? new Ah(n, e, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new Ah(n, e, { min: arguments[2], max: arguments[3] }) : he.isString(t) ? new Ob(n, e) : he.isFunction(t) ? new u0(n, e, "") : he.isBoolean(t) ? new h0(n, e) : null;
}, mA = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(n) {
  setTimeout(n, 1e3 / 60);
}, gA = function() {
  function n() {
    Fi(this, n), this.backgroundElement = document.createElement("div"), he.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), Y.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), he.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
    var e = this;
    Y.bind(this.backgroundElement, "click", function() {
      e.hide();
    });
  }
  return Bi(n, [{ key: "show", value: function() {
    var e = this;
    this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), he.defer(function() {
      e.backgroundElement.style.opacity = 1, e.domElement.style.opacity = 1, e.domElement.style.webkitTransform = "scale(1)";
    });
  } }, { key: "hide", value: function() {
    var e = this, t = function i() {
      e.domElement.style.display = "none", e.backgroundElement.style.display = "none", Y.unbind(e.domElement, "webkitTransitionEnd", i), Y.unbind(e.domElement, "transitionend", i), Y.unbind(e.domElement, "oTransitionEnd", i);
    };
    Y.bind(this.domElement, "webkitTransitionEnd", t), Y.bind(this.domElement, "transitionend", t), Y.bind(this.domElement, "oTransitionEnd", t), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
  } }, { key: "layout", value: function() {
    this.domElement.style.left = window.innerWidth / 2 - Y.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - Y.getHeight(this.domElement) / 2 + "px";
  } }]), n;
}(), vA = function(n) {
  if (typeof window != "undefined") {
    var e = document.createElement("style");
    return e.setAttribute("type", "text/css"), e.innerHTML = n, document.head.appendChild(e), n;
  }
}(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);
pA(vA);
var Ch = "Default", kl = function() {
  try {
    return !!window.localStorage;
  } catch (n) {
    return !1;
  }
}(), nu = void 0, ax = !0, ao = void 0, gf = !1, Ub = [], ct = function n(e) {
  var t = this, i = e || {};
  this.domElement = document.createElement("div"), this.ir = document.createElement("ul"), this.domElement.appendChild(this.ir), Y.addClass(this.domElement, "dg"), this.rr = {}, this.ar = [], this.hr = [], this.cr = [], this.lr = [], i = he.defaults(i, { closeOnTop: !1, autoPlace: !0, width: n.DEFAULT_WIDTH }), i = he.defaults(i, { resizable: i.autoPlace, hideable: i.autoPlace }), he.isUndefined(i.load) ? i.load = { preset: Ch } : i.preset && (i.load.preset = i.preset), he.isUndefined(i.parent) && i.hideable && Ub.push(this), i.resizable = he.isUndefined(i.parent) && i.resizable, i.autoPlace && he.isUndefined(i.scrollable) && (i.scrollable = !0);
  var r, s = kl && localStorage.getItem(oo(this, "isLocal")) === "true", a = void 0, o = void 0;
  if (Object.defineProperties(this, { parent: { get: function() {
    return i.parent;
  } }, scrollable: { get: function() {
    return i.scrollable;
  } }, autoPlace: { get: function() {
    return i.autoPlace;
  } }, closeOnTop: { get: function() {
    return i.closeOnTop;
  } }, preset: { get: function() {
    return t.parent ? t.getRoot().preset : i.load.preset;
  }, set: function(c) {
    t.parent ? t.getRoot().preset = c : i.load.preset = c, function(u) {
      for (var d = 0; d < u.ur.length; d++)
        u.ur[d].value === u.preset && (u.ur.selectedIndex = d);
    }(this), t.revert();
  } }, width: { get: function() {
    return i.width;
  }, set: function(c) {
    i.width = c, tg(t, c);
  } }, name: { get: function() {
    return i.name;
  }, set: function(c) {
    i.name = c, o && (o.innerHTML = i.name);
  } }, closed: { get: function() {
    return i.closed;
  }, set: function(c) {
    i.closed = c, i.closed ? Y.addClass(t.ir, n.CLASS_CLOSED) : Y.removeClass(t.ir, n.CLASS_CLOSED), this.onResize(), t.dr && (t.dr.innerHTML = c ? n.TEXT_OPEN : n.TEXT_CLOSED);
  } }, load: { get: function() {
    return i.load;
  } }, useLocalStorage: { get: function() {
    return s;
  }, set: function(c) {
    kl && (s = c, c ? Y.bind(window, "unload", a) : Y.unbind(window, "unload", a), localStorage.setItem(oo(t, "isLocal"), c));
  } } }), he.isUndefined(i.parent)) {
    if (this.closed = i.closed || !1, Y.addClass(this.domElement, n.CLASS_MAIN), Y.makeSelectable(this.domElement, !1), kl && s) {
      t.useLocalStorage = !0;
      var l = localStorage.getItem(oo(this, "gui"));
      l && (i.load = JSON.parse(l));
    }
    this.dr = document.createElement("div"), this.dr.innerHTML = n.TEXT_CLOSED, Y.addClass(this.dr, n.CLASS_CLOSE_BUTTON), i.closeOnTop ? (Y.addClass(this.dr, n.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.dr, this.domElement.childNodes[0])) : (Y.addClass(this.dr, n.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.dr)), Y.bind(this.dr, "click", function() {
      t.closed = !t.closed;
    });
  } else {
    i.closed === void 0 && (i.closed = !0);
    var h = document.createTextNode(i.name);
    Y.addClass(h, "controller-name"), o = d0(t, h), Y.addClass(this.ir, n.CLASS_CLOSED), Y.addClass(o, "title"), Y.bind(o, "click", function(c) {
      return c.preventDefault(), t.closed = !t.closed, !1;
    }), i.closed || (this.closed = !1);
  }
  i.autoPlace && (he.isUndefined(i.parent) && (ax && (ao = document.createElement("div"), Y.addClass(ao, "dg"), Y.addClass(ao, n.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(ao), ax = !1), ao.appendChild(this.domElement), Y.addClass(this.domElement, n.CLASS_AUTO_PLACE)), this.parent || tg(t, i.width)), this.mr = function() {
    t.onResizeDebounced();
  }, Y.bind(window, "resize", this.mr), Y.bind(this.ir, "webkitTransitionEnd", this.mr), Y.bind(this.ir, "transitionend", this.mr), Y.bind(this.ir, "oTransitionEnd", this.mr), this.onResize(), i.resizable && yA(this), a = function() {
    kl && localStorage.getItem(oo(t, "isLocal")) === "true" && localStorage.setItem(oo(t, "gui"), JSON.stringify(t.getSaveObject()));
  }, this.saveToLocalStorageIfPossible = a, i.parent || ((r = t.getRoot()).width += 1, he.defer(function() {
    r.width -= 1;
  }));
};
function d0(n, e, t) {
  var i = document.createElement("li");
  return e && i.appendChild(e), t ? n.ir.insertBefore(i, t) : n.ir.appendChild(i), n.onResize(), i;
}
function ox(n) {
  Y.unbind(window, "resize", n.mr), n.saveToLocalStorageIfPossible && Y.unbind(window, "unload", n.saveToLocalStorageIfPossible);
}
function eg(n, e) {
  var t = n.ur[n.ur.selectedIndex];
  t.innerHTML = e ? t.value + "*" : t.value;
}
function Fb(n, e) {
  var t = n.getRoot(), i = t.hr.indexOf(e.object);
  if (i !== -1) {
    var r = t.cr[i];
    if (r === void 0 && (r = {}, t.cr[i] = r), r[e.property] = e, t.load && t.load.remembered) {
      var s = t.load.remembered, a = void 0;
      if (s[n.preset])
        a = s[n.preset];
      else {
        if (!s[Ch])
          return;
        a = s[Ch];
      }
      if (a[i] && a[i][e.property] !== void 0) {
        var o = a[i][e.property];
        e.initialValue = o, e.setValue(o);
      }
    }
  }
}
function Ql(n, e, t, i) {
  if (e[t] === void 0)
    throw new Error('Object "' + e + '" has no property "' + t + '"');
  var r = void 0;
  if (i.color)
    r = new Ou(e, t);
  else {
    var s = [e, t].concat(i.factoryArgs);
    r = fA.apply(n, s);
  }
  i.before instanceof Es && (i.before = i.before.vr), Fb(n, r), Y.addClass(r.domElement, "c");
  var a = document.createElement("span");
  Y.addClass(a, "property-name"), a.innerHTML = r.property;
  var o = document.createElement("div");
  o.appendChild(a), o.appendChild(r.domElement);
  var l = d0(n, o, i.before);
  return Y.addClass(l, ct.CLASS_CONTROLLER_ROW), r instanceof Ou ? Y.addClass(l, "color") : Y.addClass(l, cA(r.getValue())), function(h, c, u) {
    if (u.vr = c, u.gr = h, he.extend(u, { options: function(m) {
      if (arguments.length > 1) {
        var g = u.vr.nextElementSibling;
        return u.remove(), Ql(h, u.object, u.property, { before: g, factoryArgs: [he.toArray(arguments)] });
      }
      if (he.isArray(m) || he.isObject(m)) {
        var f = u.vr.nextElementSibling;
        return u.remove(), Ql(h, u.object, u.property, { before: f, factoryArgs: [m] });
      }
    }, name: function(m) {
      return u.vr.firstElementChild.firstElementChild.innerHTML = m, u;
    }, listen: function() {
      return u.gr.listen(u), u;
    }, remove: function() {
      return u.gr.remove(u), u;
    } }), u instanceof sd) {
      var d = new Ah(u.object, u.property, { min: u.Gs, max: u.Bs, step: u.Hs });
      he.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(m) {
        var g = u[m], f = d[m];
        u[m] = d[m] = function() {
          var v = Array.prototype.slice.call(arguments);
          return f.apply(d, v), g.apply(u, v);
        };
      }), Y.addClass(c, "has-slider"), u.domElement.insertBefore(d.domElement, u.domElement.firstElementChild);
    } else if (u instanceof Ah) {
      var p = function(m) {
        if (he.isNumber(u.Gs) && he.isNumber(u.Bs)) {
          var g = u.vr.firstElementChild.firstElementChild.innerHTML, f = u.gr.lr.indexOf(u) > -1;
          u.remove();
          var v = Ql(h, u.object, u.property, { before: u.vr.nextElementSibling, factoryArgs: [u.Gs, u.Bs, u.Hs] });
          return v.name(g), f && v.listen(), v;
        }
        return m;
      };
      u.min = he.compose(p, u.min), u.max = he.compose(p, u.max);
    } else
      u instanceof h0 ? (Y.bind(c, "click", function() {
        Y.fakeEvent(u.Os, "click");
      }), Y.bind(u.Os, "click", function(m) {
        m.stopPropagation();
      })) : u instanceof u0 ? (Y.bind(c, "click", function() {
        Y.fakeEvent(u.Ys, "click");
      }), Y.bind(c, "mouseover", function() {
        Y.addClass(u.Ys, "hover");
      }), Y.bind(c, "mouseout", function() {
        Y.removeClass(u.Ys, "hover");
      })) : u instanceof Ou && (Y.addClass(c, "color"), u.updateDisplay = he.compose(function(m) {
        return c.style.borderLeftColor = u.qs.toString(), m;
      }, u.updateDisplay), u.updateDisplay());
    u.setValue = he.compose(function(m) {
      return h.getRoot().ur && u.isModified() && eg(h.getRoot(), !0), m;
    }, u.setValue);
  }(n, l, r), n.ar.push(r), r;
}
function oo(n, e) {
  return document.location.href + "." + e;
}
function vf(n, e, t) {
  var i = document.createElement("option");
  i.innerHTML = e, i.value = e, n.ur.appendChild(i), t && (n.ur.selectedIndex = n.ur.length - 1);
}
function lx(n, e) {
  e.style.display = n.useLocalStorage ? "block" : "none";
}
function yA(n) {
  var e = void 0;
  function t(s) {
    return s.preventDefault(), n.width += e - s.clientX, n.onResize(), e = s.clientX, !1;
  }
  function i() {
    Y.removeClass(n.dr, ct.CLASS_DRAG), Y.unbind(window, "mousemove", t), Y.unbind(window, "mouseup", i);
  }
  function r(s) {
    return s.preventDefault(), e = s.clientX, Y.addClass(n.dr, ct.CLASS_DRAG), Y.bind(window, "mousemove", t), Y.bind(window, "mouseup", i), !1;
  }
  n.wr = document.createElement("div"), he.extend(n.wr.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), Y.bind(n.wr, "mousedown", r), Y.bind(n.dr, "mousedown", r), n.domElement.insertBefore(n.wr, n.domElement.firstElementChild);
}
function tg(n, e) {
  n.domElement.style.width = e + "px", n.Mr && n.autoPlace && (n.Mr.style.width = e + "px"), n.dr && (n.dr.style.width = e + "px");
}
function iu(n, e) {
  var t = {};
  return he.each(n.hr, function(i, r) {
    var s = {}, a = n.cr[r];
    he.each(a, function(o, l) {
      s[l] = e ? o.initialValue : o.getValue();
    }), t[r] = s;
  }), t;
}
function Bb(n) {
  n.length !== 0 && mA.call(window, function() {
    Bb(n);
  }), he.each(n, function(e) {
    e.updateDisplay();
  });
}
ct.toggleHide = function() {
  gf = !gf, he.each(Ub, function(n) {
    n.domElement.style.display = gf ? "none" : "";
  });
}, ct.CLASS_AUTO_PLACE = "a", ct.CLASS_AUTO_PLACE_CONTAINER = "ac", ct.CLASS_MAIN = "main", ct.CLASS_CONTROLLER_ROW = "cr", ct.CLASS_TOO_TALL = "taller-than-window", ct.CLASS_CLOSED = "closed", ct.CLASS_CLOSE_BUTTON = "close-button", ct.CLASS_CLOSE_TOP = "close-top", ct.CLASS_CLOSE_BOTTOM = "close-bottom", ct.CLASS_DRAG = "drag", ct.DEFAULT_WIDTH = 245, ct.TEXT_CLOSED = "Close Controls", ct.TEXT_OPEN = "Open Controls", ct._r = function(n) {
  document.activeElement.type === "text" || n.which !== 72 && n.keyCode !== 72 || ct.toggleHide();
}, Y.bind(window, "keydown", ct._r, !1), he.extend(ct.prototype, { add: function(n, e) {
  return Ql(this, n, e, { factoryArgs: Array.prototype.slice.call(arguments, 2) });
}, addColor: function(n, e) {
  return Ql(this, n, e, { color: !0 });
}, remove: function(n) {
  this.ir.removeChild(n.vr), this.ar.splice(this.ar.indexOf(n), 1);
  var e = this;
  he.defer(function() {
    e.onResize();
  });
}, destroy: function() {
  if (this.parent)
    throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
  this.autoPlace && ao.removeChild(this.domElement);
  var n = this;
  he.each(this.rr, function(e) {
    n.removeFolder(e);
  }), Y.unbind(window, "keydown", ct._r, !1), ox(this);
}, addFolder: function(n) {
  if (this.rr[n] !== void 0)
    throw new Error('You already have a folder in this GUI by the name "' + n + '"');
  var e = { name: n, parent: this };
  e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[n] && (e.closed = this.load.folders[n].closed, e.load = this.load.folders[n]);
  var t = new ct(e);
  this.rr[n] = t;
  var i = d0(this, t.domElement);
  return Y.addClass(i, "folder"), t;
}, removeFolder: function(n) {
  this.ir.removeChild(n.domElement.parentElement), delete this.rr[n.name], this.load && this.load.folders && this.load.folders[n.name] && delete this.load.folders[n.name], ox(n);
  var e = this;
  he.each(n.rr, function(t) {
    n.removeFolder(t);
  }), he.defer(function() {
    e.onResize();
  });
}, open: function() {
  this.closed = !1;
}, close: function() {
  this.closed = !0;
}, hide: function() {
  this.domElement.style.display = "none";
}, show: function() {
  this.domElement.style.display = "";
}, onResize: function() {
  var n = this.getRoot();
  if (n.scrollable) {
    var e = Y.getOffset(n.ir).top, t = 0;
    he.each(n.ir.childNodes, function(i) {
      n.autoPlace && i === n.Mr || (t += Y.getHeight(i));
    }), window.innerHeight - e - 20 < t ? (Y.addClass(n.domElement, ct.CLASS_TOO_TALL), n.ir.style.height = window.innerHeight - e - 20 + "px") : (Y.removeClass(n.domElement, ct.CLASS_TOO_TALL), n.ir.style.height = "auto");
  }
  n.wr && he.defer(function() {
    n.wr.style.height = n.ir.offsetHeight + "px";
  }), n.dr && (n.dr.style.width = n.width + "px");
}, onResizeDebounced: he.debounce(function() {
  this.onResize();
}, 50), remember: function() {
  if (he.isUndefined(nu) && ((nu = new gA()).domElement.innerHTML = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`), this.parent)
    throw new Error("You can only call remember on a top level GUI.");
  var n = this;
  he.each(Array.prototype.slice.call(arguments), function(e) {
    n.hr.length === 0 && function(t) {
      var i = t.Mr = document.createElement("li");
      Y.addClass(t.domElement, "has-save"), t.ir.insertBefore(i, t.ir.firstChild), Y.addClass(i, "save-row");
      var r = document.createElement("span");
      r.innerHTML = "&nbsp;", Y.addClass(r, "button gears");
      var s = document.createElement("span");
      s.innerHTML = "Save", Y.addClass(s, "button"), Y.addClass(s, "save");
      var a = document.createElement("span");
      a.innerHTML = "New", Y.addClass(a, "button"), Y.addClass(a, "save-as");
      var o = document.createElement("span");
      o.innerHTML = "Revert", Y.addClass(o, "button"), Y.addClass(o, "revert");
      var l = t.ur = document.createElement("select");
      if (t.load && t.load.remembered ? he.each(t.load.remembered, function(d, p) {
        vf(t, p, p === t.preset);
      }) : vf(t, Ch, !1), Y.bind(l, "change", function() {
        for (var d = 0; d < t.ur.length; d++)
          t.ur[d].innerHTML = t.ur[d].value;
        t.preset = this.value;
      }), i.appendChild(l), i.appendChild(r), i.appendChild(s), i.appendChild(a), i.appendChild(o), kl) {
        var h = document.getElementById("dg-local-explain"), c = document.getElementById("dg-local-storage");
        document.getElementById("dg-save-locally").style.display = "block", localStorage.getItem(oo(t, "isLocal")) === "true" && c.setAttribute("checked", "checked"), lx(t, h), Y.bind(c, "change", function() {
          t.useLocalStorage = !t.useLocalStorage, lx(t, h);
        });
      }
      var u = document.getElementById("dg-new-constructor");
      Y.bind(u, "keydown", function(d) {
        !d.metaKey || d.which !== 67 && d.keyCode !== 67 || nu.hide();
      }), Y.bind(r, "click", function() {
        u.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), nu.show(), u.focus(), u.select();
      }), Y.bind(s, "click", function() {
        t.save();
      }), Y.bind(a, "click", function() {
        var d = prompt("Enter a new preset name.");
        d && t.saveAs(d);
      }), Y.bind(o, "click", function() {
        t.revert();
      });
    }(n), n.hr.indexOf(e) === -1 && n.hr.push(e);
  }), this.autoPlace && tg(this, this.width);
}, getRoot: function() {
  for (var n = this; n.parent; )
    n = n.parent;
  return n;
}, getSaveObject: function() {
  var n = this.load;
  return n.closed = this.closed, this.hr.length > 0 && (n.preset = this.preset, n.remembered || (n.remembered = {}), n.remembered[this.preset] = iu(this)), n.folders = {}, he.each(this.rr, function(e, t) {
    n.folders[t] = e.getSaveObject();
  }), n;
}, save: function() {
  this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = iu(this), eg(this, !1), this.saveToLocalStorageIfPossible();
}, saveAs: function(n) {
  this.load.remembered || (this.load.remembered = {}, this.load.remembered[Ch] = iu(this, !0)), this.load.remembered[n] = iu(this), this.preset = n, vf(this, n, !0), this.saveToLocalStorageIfPossible();
}, revert: function(n) {
  he.each(this.ar, function(e) {
    this.getRoot().load.remembered ? Fb(n || this.getRoot(), e) : e.setValue(e.initialValue), e.Is && e.Is.call(e, e.getValue());
  }, this), he.each(this.rr, function(e) {
    e.revert(e);
  }), n || eg(this.getRoot(), !1);
}, listen: function(n) {
  var e = this.lr.length === 0;
  this.lr.push(n), e && Bb(this.lr);
}, updateDisplay: function() {
  he.each(this.ar, function(n) {
    n.updateDisplay();
  }), he.each(this.rr, function(n) {
    n.updateDisplay();
  });
} });
var kb = { Color: tn, math: Bl, interpret: rd }, zb = { Controller: Es, BooleanController: h0, OptionController: Db, StringController: Ob, NumberController: c0, NumberControllerBox: Ah, NumberControllerSlider: sd, FunctionController: u0, ColorController: Ou }, Vb = { dom: Y }, Hb = { GUI: ct }, Yi = ct, xA = { color: kb, controllers: zb, dom: Vb, gui: Hb, GUI: Yi };
const P3 = Object.freeze(Object.defineProperty({ __proto__: null, GUI: Yi, color: kb, controllers: zb, default: xA, dom: Vb, gui: Hb }, Symbol.toStringTag, { value: "Module" }));
var ya = 1, xa = 2, To = 3, MA = 4, ng = 5, hx = 6378137, bA = 6356752314e-3, cx = 0.0066943799901413165, $l = 484813681109536e-20, pe = Math.PI / 2, SA = 0.16666666666666666, wA = 0.04722222222222222, _A = 0.022156084656084655, be = 1e-10, mn = 0.017453292519943295, ns = 57.29577951308232, lt = Math.PI / 4, Ph = 2 * Math.PI, Ft = 3.14159265359, TA = { greenwich: 0, lisbon: -9.131906111111, paris: 2.337229166667, bogota: -74.080916666667, madrid: -3.687938888889, rome: 12.452333333333, bern: 7.439583333333, jakarta: 106.807719444444, ferro: -17.666666666667, brussels: 4.367975, stockholm: 18.058277777778, athens: 23.7163375, oslo: 10.722916666667 };
const EA = { ft: { to_meter: 0.3048 }, "us-ft": { to_meter: 1200 / 3937 } };
var ux = /[\s_\-\/\(\)]/g;
function is(n, e) {
  if (n[e])
    return n[e];
  for (var t, i = Object.keys(n), r = e.toLowerCase().replace(ux, ""), s = -1; ++s < i.length; )
    if ((t = i[s]).toLowerCase().replace(ux, "") === r)
      return n[t];
}
function ig(n) {
  var e, t, i, r = {}, s = n.split("+").map(function(o) {
    return o.trim();
  }).filter(function(o) {
    return o;
  }).reduce(function(o, l) {
    var h = l.split("=");
    return h.push(!0), o[h[0].toLowerCase()] = h[1], o;
  }, {}), a = { proj: "projName", datum: "datumCode", rf: function(o) {
    r.rf = parseFloat(o);
  }, lat_0: function(o) {
    r.lat0 = o * mn;
  }, lat_1: function(o) {
    r.lat1 = o * mn;
  }, lat_2: function(o) {
    r.lat2 = o * mn;
  }, lat_ts: function(o) {
    r.lat_ts = o * mn;
  }, lon_0: function(o) {
    r.long0 = o * mn;
  }, lon_1: function(o) {
    r.long1 = o * mn;
  }, lon_2: function(o) {
    r.long2 = o * mn;
  }, alpha: function(o) {
    r.alpha = parseFloat(o) * mn;
  }, gamma: function(o) {
    r.rectified_grid_angle = parseFloat(o);
  }, lonc: function(o) {
    r.longc = o * mn;
  }, x_0: function(o) {
    r.x0 = parseFloat(o);
  }, y_0: function(o) {
    r.y0 = parseFloat(o);
  }, k_0: function(o) {
    r.k0 = parseFloat(o);
  }, k: function(o) {
    r.k0 = parseFloat(o);
  }, a: function(o) {
    r.a = parseFloat(o);
  }, b: function(o) {
    r.b = parseFloat(o);
  }, r: function(o) {
    r.a = r.b = parseFloat(o);
  }, r_a: function() {
    r.R_A = !0;
  }, zone: function(o) {
    r.zone = parseInt(o, 10);
  }, south: function() {
    r.utmSouth = !0;
  }, towgs84: function(o) {
    r.datum_params = o.split(",").map(function(l) {
      return parseFloat(l);
    });
  }, to_meter: function(o) {
    r.to_meter = parseFloat(o);
  }, units: function(o) {
    r.units = o;
    var l = is(EA, o);
    l && (r.to_meter = l.to_meter);
  }, from_greenwich: function(o) {
    r.from_greenwich = o * mn;
  }, pm: function(o) {
    var l = is(TA, o);
    r.from_greenwich = (l || parseFloat(o)) * mn;
  }, nadgrids: function(o) {
    o === "@null" ? r.datumCode = "none" : r.nadgrids = o;
  }, axis: function(o) {
    var l = "ewnsud";
    o.length === 3 && l.indexOf(o.substr(0, 1)) !== -1 && l.indexOf(o.substr(1, 1)) !== -1 && l.indexOf(o.substr(2, 1)) !== -1 && (r.axis = o);
  }, approx: function() {
    r.approx = !0;
  } };
  for (e in s)
    t = s[e], e in a ? typeof (i = a[e]) == "function" ? i(t) : r[i] = t : r[e] = t;
  return typeof r.datumCode == "string" && r.datumCode !== "WGS84" && (r.datumCode = r.datumCode.toLowerCase()), r;
}
var zl = 1, AA = /\s/, CA = /[A-Za-z]/, PA = /[A-Za-z84_]/, ru = /[,\]]/, dx = /[\d\.E\-\+]/;
function mr(n) {
  if (typeof n != "string")
    throw new Error("not a string");
  this.text = n.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = zl;
}
function px(n, e, t) {
  Array.isArray(e) && (t.unshift(e), e = null);
  var i = e ? {} : n, r = t.reduce(function(s, a) {
    return fo(a, s), s;
  }, i);
  e && (n[e] = r);
}
function fo(n, e) {
  if (Array.isArray(n)) {
    var t = n.shift();
    if (t === "PARAMETER" && (t = n.shift()), n.length === 1)
      return Array.isArray(n[0]) ? (e[t] = {}, void fo(n[0], e[t])) : void (e[t] = n[0]);
    if (n.length)
      if (t !== "TOWGS84") {
        if (t === "AXIS")
          return t in e || (e[t] = []), void e[t].push(n);
        var i;
        switch (Array.isArray(t) || (e[t] = {}), t) {
          case "UNIT":
          case "PRIMEM":
          case "VERT_DATUM":
            return e[t] = { name: n[0].toLowerCase(), convert: n[1] }, void (n.length === 3 && fo(n[2], e[t]));
          case "SPHEROID":
          case "ELLIPSOID":
            return e[t] = { name: n[0], a: n[1], rf: n[2] }, void (n.length === 4 && fo(n[3], e[t]));
          case "PROJECTEDCRS":
          case "PROJCRS":
          case "GEOGCS":
          case "GEOCCS":
          case "PROJCS":
          case "LOCAL_CS":
          case "GEODCRS":
          case "GEODETICCRS":
          case "GEODETICDATUM":
          case "EDATUM":
          case "ENGINEERINGDATUM":
          case "VERT_CS":
          case "VERTCRS":
          case "VERTICALCRS":
          case "COMPD_CS":
          case "COMPOUNDCRS":
          case "ENGINEERINGCRS":
          case "ENGCRS":
          case "FITTED_CS":
          case "LOCAL_DATUM":
          case "DATUM":
            return n[0] = ["name", n[0]], void px(e, t, n);
          default:
            for (i = -1; ++i < n.length; )
              if (!Array.isArray(n[i]))
                return fo(n, e[t]);
            return px(e, t, n);
        }
      } else
        e[t] = n;
    else
      e[t] = !0;
  } else
    e[n] = !0;
}
mr.prototype.readCharicter = function() {
  var n = this.text[this.place++];
  if (this.state !== 4)
    for (; AA.test(n); ) {
      if (this.place >= this.text.length)
        return;
      n = this.text[this.place++];
    }
  switch (this.state) {
    case zl:
      return this.neutral(n);
    case 2:
      return this.keyword(n);
    case 4:
      return this.quoted(n);
    case 5:
      return this.afterquote(n);
    case 3:
      return this.number(n);
    case -1:
      return;
  }
}, mr.prototype.afterquote = function(n) {
  if (n === '"')
    return this.word += '"', void (this.state = 4);
  if (ru.test(n))
    return this.word = this.word.trim(), void this.afterItem(n);
  throw new Error(`havn't handled "` + n + '" in afterquote yet, index ' + this.place);
}, mr.prototype.afterItem = function(n) {
  return n === "," ? (this.word !== null && this.currentObject.push(this.word), this.word = null, void (this.state = zl)) : n === "]" ? (this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = zl, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = -1))) : void 0;
}, mr.prototype.number = function(n) {
  if (!dx.test(n)) {
    if (ru.test(n))
      return this.word = parseFloat(this.word), void this.afterItem(n);
    throw new Error(`havn't handled "` + n + '" in number yet, index ' + this.place);
  }
  this.word += n;
}, mr.prototype.quoted = function(n) {
  n !== '"' ? this.word += n : this.state = 5;
}, mr.prototype.keyword = function(n) {
  if (PA.test(n))
    this.word += n;
  else {
    if (n === "[") {
      var e = [];
      return e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, void (this.state = zl);
    }
    if (!ru.test(n))
      throw new Error(`havn't handled "` + n + '" in keyword yet, index ' + this.place);
    this.afterItem(n);
  }
}, mr.prototype.neutral = function(n) {
  if (CA.test(n))
    return this.word = n, void (this.state = 2);
  if (n === '"')
    return this.word = "", void (this.state = 4);
  if (dx.test(n))
    return this.word = n, void (this.state = 3);
  if (!ru.test(n))
    throw new Error(`havn't handled "` + n + '" in neutral yet, index ' + this.place);
  this.afterItem(n);
}, mr.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === -1)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
var RA = 0.017453292519943295;
function Vi(n) {
  return n * RA;
}
function Gb(n) {
  var e = new mr(n).output(), t = e.shift(), i = e.shift();
  e.unshift(["name", i]), e.unshift(["type", t]);
  var r = {};
  return fo(e, r), function(s) {
    if (s.type === "GEOGCS" ? s.projName = "longlat" : s.type === "LOCAL_CS" ? (s.projName = "identity", s.local = !0) : typeof s.PROJECTION == "object" ? s.projName = Object.keys(s.PROJECTION)[0] : s.projName = s.PROJECTION, s.AXIS) {
      for (var a = "", o = 0, l = s.AXIS.length; o < l; ++o) {
        var h = [s.AXIS[o][0].toLowerCase(), s.AXIS[o][1].toLowerCase()];
        h[0].indexOf("north") !== -1 || (h[0] === "y" || h[0] === "lat") && h[1] === "north" ? a += "n" : h[0].indexOf("south") !== -1 || (h[0] === "y" || h[0] === "lat") && h[1] === "south" ? a += "s" : h[0].indexOf("east") !== -1 || (h[0] === "x" || h[0] === "lon") && h[1] === "east" ? a += "e" : h[0].indexOf("west") === -1 && (h[0] !== "x" && h[0] !== "lon" || h[1] !== "west") || (a += "w");
      }
      a.length === 2 && (a += "u"), a.length === 3 && (s.axis = a);
    }
    s.UNIT && (s.units = s.UNIT.name.toLowerCase(), s.units === "metre" && (s.units = "meter"), s.UNIT.convert && (s.type === "GEOGCS" ? s.DATUM && s.DATUM.SPHEROID && (s.to_meter = s.UNIT.convert * s.DATUM.SPHEROID.a) : s.to_meter = s.UNIT.convert));
    var c = s.GEOGCS;
    function u(d) {
      return d * (s.to_meter || 1);
    }
    s.type === "GEOGCS" && (c = s), c && (c.DATUM ? s.datumCode = c.DATUM.name.toLowerCase() : s.datumCode = c.name.toLowerCase(), s.datumCode.slice(0, 2) === "d_" && (s.datumCode = s.datumCode.slice(2)), s.datumCode !== "new_zealand_geodetic_datum_1949" && s.datumCode !== "new_zealand_1949" || (s.datumCode = "nzgd49"), s.datumCode !== "wgs_1984" && s.datumCode !== "world_geodetic_system_1984" || (s.PROJECTION === "Mercator_Auxiliary_Sphere" && (s.sphere = !0), s.datumCode = "wgs84"), s.datumCode.slice(-6) === "_ferro" && (s.datumCode = s.datumCode.slice(0, -6)), s.datumCode.slice(-8) === "_jakarta" && (s.datumCode = s.datumCode.slice(0, -8)), ~s.datumCode.indexOf("belge") && (s.datumCode = "rnb72"), c.DATUM && c.DATUM.SPHEROID && (s.ellps = c.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), s.ellps.toLowerCase().slice(0, 13) === "international" && (s.ellps = "intl"), s.a = c.DATUM.SPHEROID.a, s.rf = parseFloat(c.DATUM.SPHEROID.rf, 10)), c.DATUM && c.DATUM.TOWGS84 && (s.datum_params = c.DATUM.TOWGS84), ~s.datumCode.indexOf("osgb_1936") && (s.datumCode = "osgb36"), ~s.datumCode.indexOf("osni_1952") && (s.datumCode = "osni52"), (~s.datumCode.indexOf("tm65") || ~s.datumCode.indexOf("geodetic_datum_of_1965")) && (s.datumCode = "ire65"), s.datumCode === "ch1903+" && (s.datumCode = "ch1903"), ~s.datumCode.indexOf("israel") && (s.datumCode = "isr93")), s.b && !isFinite(s.b) && (s.b = s.a), [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_1", "Latitude of 1st standard parallel"], ["standard_parallel_2", "Standard_Parallel_2"], ["standard_parallel_2", "Latitude of 2nd standard parallel"], ["false_easting", "False_Easting"], ["false_easting", "False easting"], ["false-easting", "Easting at false origin"], ["false_northing", "False_Northing"], ["false_northing", "False northing"], ["false_northing", "Northing at false origin"], ["central_meridian", "Central_Meridian"], ["central_meridian", "Longitude of natural origin"], ["central_meridian", "Longitude of false origin"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["latitude_of_origin", "Latitude of natural origin"], ["latitude_of_origin", "Latitude of false origin"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", Vi], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", Vi], ["x0", "false_easting", u], ["y0", "false_northing", u], ["long0", "central_meridian", Vi], ["lat0", "latitude_of_origin", Vi], ["lat0", "standard_parallel_1", Vi], ["lat1", "standard_parallel_1", Vi], ["lat2", "standard_parallel_2", Vi], ["azimuth", "Azimuth"], ["alpha", "azimuth", Vi], ["srsCode", "name"]].forEach(function(d) {
      return function(p, m) {
        var g = m[0], f = m[1];
        !(g in p) && f in p && (p[g] = p[f], m.length === 3 && (p[g] = m[2](p[g])));
      }(s, d);
    }), s.long0 || !s.longc || s.projName !== "Albers_Conic_Equal_Area" && s.projName !== "Lambert_Azimuthal_Equal_Area" || (s.long0 = s.longc), s.lat_ts || !s.lat1 || s.projName !== "Stereographic_South_Pole" && s.projName !== "Polar Stereographic (variant B)" ? !s.lat_ts && s.lat0 && s.projName === "Polar_Stereographic" && (s.lat_ts = s.lat0, s.lat0 = Vi(s.lat0 > 0 ? 90 : -90)) : (s.lat0 = Vi(s.lat1 > 0 ? 90 : -90), s.lat_ts = s.lat1);
  }(r), r;
}
function Rn(n) {
  var e = this;
  if (arguments.length === 2) {
    var t = arguments[1];
    typeof t == "string" ? t.charAt(0) === "+" ? Rn[n] = ig(arguments[1]) : Rn[n] = Gb(arguments[1]) : Rn[n] = t;
  } else if (arguments.length === 1) {
    if (Array.isArray(n))
      return n.map(function(i) {
        Array.isArray(i) ? Rn.apply(e, i) : Rn(i);
      });
    if (typeof n == "string") {
      if (n in Rn)
        return Rn[n];
    } else
      "EPSG" in n ? Rn["EPSG:" + n.EPSG] = n : "ESRI" in n ? Rn["ESRI:" + n.ESRI] = n : "IAU2000" in n && (Rn["IAU2000:" + n.IAU2000] = n);
    return;
  }
}
(function(n) {
  n("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), n("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), n("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), n.WGS84 = n["EPSG:4326"], n["EPSG:3785"] = n["EPSG:3857"], n.GOOGLE = n["EPSG:3857"], n["EPSG:900913"] = n["EPSG:3857"], n["EPSG:102113"] = n["EPSG:3857"];
})(Rn);
var IA = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"], LA = ["3857", "900913", "3785", "102113"];
function NA(n) {
  if (!/* @__PURE__ */ function(i) {
    return typeof i == "string";
  }(n))
    return n;
  if (function(i) {
    return i in Rn;
  }(n))
    return Rn[n];
  if (function(i) {
    return IA.some(function(r) {
      return i.indexOf(r) > -1;
    });
  }(n)) {
    var e = Gb(n);
    if (function(i) {
      var r = is(i, "authority");
      if (r) {
        var s = is(r, "epsg");
        return s && LA.indexOf(s) > -1;
      }
    }(e))
      return Rn["EPSG:3857"];
    var t = function(i) {
      var r = is(i, "extension");
      if (r)
        return is(r, "proj4");
    }(e);
    return t ? ig(t) : e;
  }
  return function(i) {
    return i[0] === "+";
  }(n) ? ig(n) : void 0;
}
function fx(n, e) {
  var t, i;
  if (n = n || {}, !e)
    return n;
  for (i in e)
    (t = e[i]) !== void 0 && (n[i] = t);
  return n;
}
function ar(n, e, t) {
  var i = n * e;
  return t / Math.sqrt(1 - i * i);
}
function $h(n) {
  return n < 0 ? -1 : 1;
}
function we(n) {
  return Math.abs(n) <= Ft ? n : n - $h(n) * Ph;
}
function Ni(n, e, t) {
  var i = n * t, r = 0.5 * n;
  return i = Math.pow((1 - i) / (1 + i), r), Math.tan(0.5 * (pe - e)) / i;
}
function Rh(n, e) {
  for (var t, i, r = 0.5 * n, s = pe - 2 * Math.atan(e), a = 0; a <= 15; a++)
    if (t = n * Math.sin(s), s += i = pe - 2 * Math.atan(e * Math.pow((1 - t) / (1 + t), r)) - s, Math.abs(i) <= 1e-10)
      return s;
  return -9999;
}
const DA = { init: function() {
  var n = this.b / this.a;
  this.es = 1 - n * n, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = ar(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}, forward: function(n) {
  var e, t, i = n.x, r = n.y;
  if (r * ns > 90 && r * ns < -90 && i * ns > 180 && i * ns < -180 || Math.abs(Math.abs(r) - pe) <= be)
    return null;
  if (this.sphere)
    e = this.x0 + this.a * this.k0 * we(i - this.long0), t = this.y0 + this.a * this.k0 * Math.log(Math.tan(lt + 0.5 * r));
  else {
    var s = Math.sin(r), a = Ni(this.e, r, s);
    e = this.x0 + this.a * this.k0 * we(i - this.long0), t = this.y0 - this.a * this.k0 * Math.log(a);
  }
  return n.x = e, n.y = t, n;
}, inverse: function(n) {
  var e, t, i = n.x - this.x0, r = n.y - this.y0;
  if (this.sphere)
    t = pe - 2 * Math.atan(Math.exp(-r / (this.a * this.k0)));
  else {
    var s = Math.exp(-r / (this.a * this.k0));
    if ((t = Rh(this.e, s)) === -9999)
      return null;
  }
  return e = we(this.long0 + i / (this.a * this.k0)), n.x = e, n.y = t, n;
}, names: ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"] };
function mx(n) {
  return n;
}
var OA = [DA, { init: function() {
}, forward: mx, inverse: mx, names: ["longlat", "identity"] }], Uu = {}, ad = [];
function gx(n, e) {
  var t = ad.length;
  return !n.names || (ad[t] = n, n.names.forEach(function(i) {
    Uu[i.toLowerCase()] = t;
  }), this);
}
const UA = { start: function() {
  OA.forEach(gx);
}, add: gx, get: function(n) {
  if (!n)
    return !1;
  var e = n.toLowerCase();
  return typeof Uu[e] != "undefined" && ad[Uu[e]] ? ad[Uu[e]] : void 0;
} };
var p0 = { MERIT: { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, SGS85: { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, GRS80: { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, IAU76: { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, airy: { a: 6377563396e-3, b: 635625691e-2, ellipseName: "Airy 1830" }, APL4: { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, NWL9D: { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, mod_airy: { a: 6377340189e-3, b: 6356034446e-3, ellipseName: "Modified Airy" }, andrae: { a: 637710443e-2, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, aust_SA: { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, GRS67: { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, bessel: { a: 6377397155e-3, rf: 299.1528128, ellipseName: "Bessel 1841" }, bess_nam: { a: 6377483865e-3, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, clrk66: { a: 63782064e-1, b: 63565838e-1, ellipseName: "Clarke 1866" }, clrk80: { a: 6378249145e-3, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, clrk80ign: { a: 63782492e-1, b: 6356515, rf: 293.4660213, ellipseName: "Clarke 1880 (IGN)" }, clrk58: { a: 6378293645208759e-9, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, CPM: { a: 63757387e-1, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, delmbr: { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, engelis: { a: 637813605e-2, rf: 298.2566, ellipseName: "Engelis 1985" }, evrst30: { a: 6377276345e-3, rf: 300.8017, ellipseName: "Everest 1830" }, evrst48: { a: 6377304063e-3, rf: 300.8017, ellipseName: "Everest 1948" }, evrst56: { a: 6377301243e-3, rf: 300.8017, ellipseName: "Everest 1956" }, evrst69: { a: 6377295664e-3, rf: 300.8017, ellipseName: "Everest 1969" }, evrstSS: { a: 6377298556e-3, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, fschr60: { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, fschr60m: { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, fschr68: { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, helmert: { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, hough: { a: 6378270, rf: 297, ellipseName: "Hough" }, intl: { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, kaula: { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, lerch: { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, mprts: { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, new_intl: { a: 63781575e-1, b: 63567722e-1, ellipseName: "New International 1967" }, plessis: { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, krass: { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, SEasia: { a: 6378155, b: 63567733205e-4, ellipseName: "Southeast Asia" }, walbeck: { a: 6376896, b: 63558348467e-4, ellipseName: "Walbeck" }, WGS60: { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, WGS66: { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, WGS7: { a: 6378135, rf: 298.26, ellipseName: "WGS 72" } }, FA = p0.WGS84 = { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" };
p0.sphere = { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" };
var en = {};
en.wgs84 = { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, en.ch1903 = { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, en.ggrs87 = { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, en.nad83 = { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, en.nad27 = { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, en.potsdam = { towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, en.carthage = { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, en.hermannskogel = { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Hermannskogel" }, en.militargeographische_institut = { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Militar-Geographische Institut" }, en.osni52 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "airy", datumName: "Irish National" }, en.ire65 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, en.rassadiran = { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, en.nzgd49 = { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, en.osgb36 = { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Airy 1830" }, en.s_jtsk = { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, en.beduaram = { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, en.gunung_segara = { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, en.rnb72 = { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" };
var jb = {};
function BA(n) {
  if (n.length === 0)
    return null;
  var e = n[0] === "@";
  return e && (n = n.slice(1)), n === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : { name: n, mandatory: !e, grid: jb[n] || null, isNull: !1 };
}
function mo(n) {
  return n / 3600 * Math.PI / 180;
}
function rg(n, e, t) {
  return String.fromCharCode.apply(null, new Uint8Array(n.buffer.slice(e, t)));
}
function kA(n) {
  return n.map(function(e) {
    return [mo(e.longitudeShift), mo(e.latitudeShift)];
  });
}
function zA(n, e, t) {
  return { name: rg(n, e + 8, e + 16).trim(), parent: rg(n, e + 24, e + 24 + 8).trim(), lowerLatitude: n.getFloat64(e + 72, t), upperLatitude: n.getFloat64(e + 88, t), lowerLongitude: n.getFloat64(e + 104, t), upperLongitude: n.getFloat64(e + 120, t), latitudeInterval: n.getFloat64(e + 136, t), longitudeInterval: n.getFloat64(e + 152, t), gridNodeCount: n.getInt32(e + 168, t) };
}
function VA(n, e, t, i) {
  for (var r = e + 176, s = [], a = 0; a < t.gridNodeCount; a++) {
    var o = { latitudeShift: n.getFloat32(r + 16 * a, i), longitudeShift: n.getFloat32(r + 16 * a + 4, i), latitudeAccuracy: n.getFloat32(r + 16 * a + 8, i), longitudeAccuracy: n.getFloat32(r + 16 * a + 12, i) };
    s.push(o);
  }
  return s;
}
function ir(n, e) {
  if (!(this instanceof ir))
    return new ir(n);
  e = e || function(h) {
    if (h)
      throw h;
  };
  var t = NA(n);
  if (typeof t == "object") {
    var i = ir.projections.get(t.projName);
    if (i) {
      if (t.datumCode && t.datumCode !== "none") {
        var r = is(en, t.datumCode);
        r && (t.datum_params = t.datum_params || (r.towgs84 ? r.towgs84.split(",") : null), t.ellps = r.ellipse, t.datumName = r.datumName ? r.datumName : t.datumCode);
      }
      t.k0 = t.k0 || 1, t.axis = t.axis || "enu", t.ellps = t.ellps || "wgs84", t.lat1 = t.lat1 || t.lat0;
      var s = function(h, c, u, d, p) {
        if (!h) {
          var m = is(p0, d);
          m || (m = FA), h = m.a, c = m.b, u = m.rf;
        }
        return u && !c && (c = (1 - 1 / u) * h), (u === 0 || Math.abs(h - c) < be) && (p = !0, c = h), { a: h, b: c, rf: u, sphere: p };
      }(t.a, t.b, t.rf, t.ellps, t.sphere), a = function(h, c, u, d) {
        var p = h * h, m = c * c, g = (p - m) / p, f = 0;
        return d ? (p = (h *= 1 - g * (SA + g * (wA + g * _A))) * h, g = 0) : f = Math.sqrt(g), { es: g, e: f, ep2: (p - m) / m };
      }(s.a, s.b, s.rf, t.R_A), o = function(h) {
        return h === void 0 ? null : h.split(",").map(BA);
      }(t.nadgrids), l = t.datum || function(h, c, u, d, p, m, g) {
        var f = {};
        return h === void 0 || h === "none" ? f.datum_type = ng : f.datum_type = MA, c && (f.datum_params = c.map(parseFloat), f.datum_params[0] === 0 && f.datum_params[1] === 0 && f.datum_params[2] === 0 || (f.datum_type = ya), f.datum_params.length > 3 && (f.datum_params[3] === 0 && f.datum_params[4] === 0 && f.datum_params[5] === 0 && f.datum_params[6] === 0 || (f.datum_type = xa, f.datum_params[3] *= $l, f.datum_params[4] *= $l, f.datum_params[5] *= $l, f.datum_params[6] = f.datum_params[6] / 1e6 + 1))), g && (f.datum_type = To, f.grids = g), f.a = u, f.b = d, f.es = p, f.ep2 = m, f;
      }(t.datumCode, t.datum_params, s.a, s.b, a.es, a.ep2, o);
      fx(this, t), fx(this, i), this.a = s.a, this.b = s.b, this.rf = s.rf, this.sphere = s.sphere, this.es = a.es, this.e = a.e, this.ep2 = a.ep2, this.datum = l, this.init(), e(null, this);
    } else
      e(n);
  } else
    e(n);
}
function Wb(n, e, t) {
  var i, r, s, a, o = n.x, l = n.y, h = n.z ? n.z : 0;
  if (l < -pe && l > -1.001 * pe)
    l = -pe;
  else if (l > pe && l < 1.001 * pe)
    l = pe;
  else {
    if (l < -pe)
      return { x: -1 / 0, y: -1 / 0, z: n.z };
    if (l > pe)
      return { x: 1 / 0, y: 1 / 0, z: n.z };
  }
  return o > Math.PI && (o -= 2 * Math.PI), r = Math.sin(l), a = Math.cos(l), s = r * r, { x: ((i = t / Math.sqrt(1 - e * s)) + h) * a * Math.cos(o), y: (i + h) * a * Math.sin(o), z: (i * (1 - e) + h) * r };
}
function Xb(n, e, t, i) {
  var r, s, a, o, l, h, c, u, d, p, m, g, f, v, y, x = 1e-12, M = n.x, b = n.y, S = n.z ? n.z : 0;
  if (r = Math.sqrt(M * M + b * b), s = Math.sqrt(M * M + b * b + S * S), r / t < x) {
    if (v = 0, s / t < x)
      return y = -i, { x: n.x, y: n.y, z: n.z };
  } else
    v = Math.atan2(b, M);
  a = S / s, u = (o = r / s) * (1 - e) * (l = 1 / Math.sqrt(1 - e * (2 - e) * o * o)), d = a * l, f = 0;
  do
    f++, h = e * (c = t / Math.sqrt(1 - e * d * d)) / (c + (y = r * u + S * d - c * (1 - e * d * d))), g = (m = a * (l = 1 / Math.sqrt(1 - h * (2 - h) * o * o))) * u - (p = o * (1 - h) * l) * d, u = p, d = m;
  while (g * g > 1e-24 && f < 30);
  return { x: v, y: Math.atan(m / Math.abs(p)), z: y };
}
function su(n) {
  return n === ya || n === xa;
}
function HA(n, e, t) {
  if (function(l, h) {
    return l.datum_type === h.datum_type && !(l.a !== h.a || Math.abs(l.es - h.es) > 5e-11) && (l.datum_type === ya ? l.datum_params[0] === h.datum_params[0] && l.datum_params[1] === h.datum_params[1] && l.datum_params[2] === h.datum_params[2] : l.datum_type !== xa || l.datum_params[0] === h.datum_params[0] && l.datum_params[1] === h.datum_params[1] && l.datum_params[2] === h.datum_params[2] && l.datum_params[3] === h.datum_params[3] && l.datum_params[4] === h.datum_params[4] && l.datum_params[5] === h.datum_params[5] && l.datum_params[6] === h.datum_params[6]);
  }(n, e) || n.datum_type === ng || e.datum_type === ng)
    return t;
  var i = n.a, r = n.es;
  if (n.datum_type === To) {
    if (vx(n, !1, t) !== 0)
      return;
    i = hx, r = cx;
  }
  var s = e.a, a = e.b, o = e.es;
  if (e.datum_type === To && (s = hx, a = bA, o = cx), r === o && i === s && !su(n.datum_type) && !su(e.datum_type))
    return t;
  if (t = Wb(t, r, i), su(n.datum_type) && (t = function(l, h, c) {
    if (h === ya)
      return { x: l.x + c[0], y: l.y + c[1], z: l.z + c[2] };
    if (h === xa) {
      var u = c[0], d = c[1], p = c[2], m = c[3], g = c[4], f = c[5], v = c[6];
      return { x: v * (l.x - f * l.y + g * l.z) + u, y: v * (f * l.x + l.y - m * l.z) + d, z: v * (-g * l.x + m * l.y + l.z) + p };
    }
  }(t, n.datum_type, n.datum_params)), su(e.datum_type) && (t = function(l, h, c) {
    if (h === ya)
      return { x: l.x - c[0], y: l.y - c[1], z: l.z - c[2] };
    if (h === xa) {
      var u = c[0], d = c[1], p = c[2], m = c[3], g = c[4], f = c[5], v = c[6], y = (l.x - u) / v, x = (l.y - d) / v, M = (l.z - p) / v;
      return { x: y + f * x - g * M, y: -f * y + x + m * M, z: g * y - m * x + M };
    }
  }(t, e.datum_type, e.datum_params)), t = Xb(t, o, s, a), !(e.datum_type === To && vx(e, !0, t) !== 0))
    return t;
}
function vx(n, e, t) {
  if (n.grids === null || n.grids.length === 0)
    return -1;
  var i = { x: -t.x, y: t.y }, r = { x: Number.NaN, y: Number.NaN }, s = [];
  e:
    for (var a = 0; a < n.grids.length; a++) {
      var o = n.grids[a];
      if (s.push(o.name), o.isNull) {
        r = i;
        break;
      }
      if (o.mandatory, o.grid !== null)
        for (var l = o.grid.subgrids, h = 0, c = l.length; h < c; h++) {
          var u = l[h], d = (Math.abs(u.del[1]) + Math.abs(u.del[0])) / 1e4, p = u.ll[0] - d, m = u.ll[1] - d, g = u.ll[0] + (u.lim[0] - 1) * u.del[0] + d, f = u.ll[1] + (u.lim[1] - 1) * u.del[1] + d;
          if (!(m > i.y || p > i.x || f < i.y || g < i.x) && (r = GA(i, e, u), !isNaN(r.x)))
            break e;
        }
      else if (o.mandatory)
        return -1;
    }
  return isNaN(r.x) ? -1 : (t.x = -r.x, t.y = r.y, 0);
}
function GA(n, e, t) {
  var i = { x: Number.NaN, y: Number.NaN };
  if (isNaN(n.x))
    return i;
  var r = { x: n.x, y: n.y };
  r.x -= t.ll[0], r.y -= t.ll[1], r.x = we(r.x - Math.PI) + Math.PI;
  var s = yx(r, t);
  if (e) {
    if (isNaN(s.x))
      return i;
    s.x = r.x - s.x, s.y = r.y - s.y;
    var a, o, l = 9;
    do {
      if (o = yx(s, t), isNaN(o.x))
        break;
      a = { x: r.x - (o.x + s.x), y: r.y - (o.y + s.y) }, s.x += a.x, s.y += a.y;
    } while (l-- && Math.abs(a.x) > 1e-12 && Math.abs(a.y) > 1e-12);
    if (l < 0)
      return i;
    i.x = we(s.x + t.ll[0]), i.y = s.y + t.ll[1];
  } else
    isNaN(s.x) || (i.x = n.x + s.x, i.y = n.y + s.y);
  return i;
}
function yx(n, e) {
  var t, i = { x: n.x / e.del[0], y: n.y / e.del[1] }, r = Math.floor(i.x), s = Math.floor(i.y), a = i.x - 1 * r, o = i.y - 1 * s, l = { x: Number.NaN, y: Number.NaN };
  if (r < 0 || r >= e.lim[0] || s < 0 || s >= e.lim[1])
    return l;
  t = s * e.lim[0] + r;
  var h = e.cvs[t][0], c = e.cvs[t][1];
  t++;
  var u = e.cvs[t][0], d = e.cvs[t][1];
  t += e.lim[0];
  var p = e.cvs[t][0], m = e.cvs[t][1];
  t--;
  var g = e.cvs[t][0], f = e.cvs[t][1], v = a * o, y = a * (1 - o), x = (1 - a) * (1 - o), M = (1 - a) * o;
  return l.x = x * h + y * u + M * g + v * p, l.y = x * c + y * d + M * f + v * m, l;
}
function xx(n, e, t) {
  var i, r, s, a = t.x, o = t.y, l = t.z || 0, h = {};
  for (s = 0; s < 3; s++)
    if (!e || s !== 2 || t.z !== void 0)
      switch (s === 0 ? (i = a, r = "ew".indexOf(n.axis[s]) !== -1 ? "x" : "y") : s === 1 ? (i = o, r = "ns".indexOf(n.axis[s]) !== -1 ? "y" : "x") : (i = l, r = "z"), n.axis[s]) {
        case "e":
        case "n":
          h[r] = i;
          break;
        case "w":
        case "s":
          h[r] = -i;
          break;
        case "u":
          t[r] !== void 0 && (h.z = i);
          break;
        case "d":
          t[r] !== void 0 && (h.z = -i);
          break;
        default:
          return null;
      }
  return h;
}
function qb(n) {
  var e = { x: n[0], y: n[1] };
  return n.length > 2 && (e.z = n[2]), n.length > 3 && (e.m = n[3]), e;
}
function Mx(n) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(n))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof n != "number" || n != n || !isFinite(n))
    throw new TypeError("coordinates must be finite numbers");
}
function od(n, e, t, i) {
  var r, s = (t = Array.isArray(t) ? qb(t) : { x: t.x, y: t.y, z: t.z, m: t.m }).z !== void 0;
  if (function(a) {
    Mx(a.x), Mx(a.y);
  }(t), n.datum && e.datum && function(a, o) {
    return (a.datum.datum_type === ya || a.datum.datum_type === xa || a.datum.datum_type === To) && o.datumCode !== "WGS84" || (o.datum.datum_type === ya || o.datum.datum_type === xa || o.datum.datum_type === To) && a.datumCode !== "WGS84";
  }(n, e) && (t = od(n, r = new ir("WGS84"), t, i), n = r), i && n.axis !== "enu" && (t = xx(n, !1, t)), n.projName === "longlat")
    t = { x: t.x * mn, y: t.y * mn, z: t.z || 0 };
  else if (n.to_meter && (t = { x: t.x * n.to_meter, y: t.y * n.to_meter, z: t.z || 0 }), !(t = n.inverse(t)))
    return;
  if (n.from_greenwich && (t.x += n.from_greenwich), t = HA(n.datum, e.datum, t))
    return e.from_greenwich && (t = { x: t.x - e.from_greenwich, y: t.y, z: t.z || 0 }), e.projName === "longlat" ? t = { x: t.x * ns, y: t.y * ns, z: t.z || 0 } : (t = e.forward(t), e.to_meter && (t = { x: t.x / e.to_meter, y: t.y / e.to_meter, z: t.z || 0 })), i && e.axis !== "enu" ? xx(e, !0, t) : (t && !s && delete t.z, t);
}
ir.projections = UA, ir.projections.start();
var bx = ir("WGS84");
function yf(n, e, t, i) {
  var r, s, a;
  return Array.isArray(t) ? (r = od(n, e, t, i) || { x: NaN, y: NaN }, t.length > 2 ? typeof n.name != "undefined" && n.name === "geocent" || typeof e.name != "undefined" && e.name === "geocent" ? typeof r.z == "number" ? [r.x, r.y, r.z].concat(t.splice(3)) : [r.x, r.y, t[2]].concat(t.splice(3)) : [r.x, r.y].concat(t.splice(2)) : [r.x, r.y]) : (s = od(n, e, t, i), (a = Object.keys(t)).length === 2 || a.forEach(function(o) {
    if (typeof n.name != "undefined" && n.name === "geocent" || typeof e.name != "undefined" && e.name === "geocent") {
      if (o === "x" || o === "y" || o === "z")
        return;
    } else if (o === "x" || o === "y")
      return;
    s[o] = t[o];
  }), s);
}
function Sx(n) {
  return n instanceof ir ? n : n.oProj ? n.oProj : ir(n);
}
function Bn(n, e, t) {
  n = Sx(n);
  var i, r = !1;
  return e === void 0 ? (e = n, n = bx, r = !0) : (typeof e.x != "undefined" || Array.isArray(e)) && (t = e, e = n, n = bx, r = !0), e = Sx(e), t ? yf(n, e, t) : (i = { forward: function(s, a) {
    return yf(n, e, s, a);
  }, inverse: function(s, a) {
    return yf(e, n, s, a);
  } }, r && (i.oProj = e), i);
}
var wx = 6, Yb = "AJSAJS", Zb = "AFAFAF", go = 65, kn = 73, di = 79, Vl = 86, Hl = 90;
const jA = { forward: Kb, inverse: function(n) {
  var e = f0($b(n.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}, toPoint: Jb };
function Kb(n, e) {
  return e = e || 5, function(t, i) {
    var r = "00000" + t.easting, s = "00000" + t.northing;
    return t.zoneNumber + t.zoneLetter + (a = t.easting, o = t.northing, l = t.zoneNumber, h = Qb(l), c = Math.floor(a / 1e5), u = Math.floor(o / 1e5) % 20, function(d, p, m) {
      var g = m - 1, f = Yb.charCodeAt(g), v = Zb.charCodeAt(g), y = f + d - 1, x = v + p, M = !1;
      return y > Hl && (y = y - Hl + go - 1, M = !0), (y === kn || f < kn && y > kn || (y > kn || f < kn) && M) && y++, (y === di || f < di && y > di || (y > di || f < di) && M) && ++y === kn && y++, y > Hl && (y = y - Hl + go - 1), x > Vl ? (x = x - Vl + go - 1, M = !0) : M = !1, (x === kn || v < kn && x > kn || (x > kn || v < kn) && M) && x++, (x === di || v < di && x > di || (x > di || v < di) && M) && ++x === kn && x++, x > Vl && (x = x - Vl + go - 1), String.fromCharCode(y) + String.fromCharCode(x);
    }(c, u, h)) + r.substr(r.length - 5, i) + s.substr(s.length - 5, i);
    var a, o, l, h, c, u;
  }(function(t) {
    var i, r, s, a, o, l, h, c, u = t.lat, d = t.lon, p = 6378137, m = 669438e-8, g = 0.9996, f = xf(u), v = xf(d);
    c = Math.floor((d + 180) / 6) + 1, d === 180 && (c = 60), u >= 56 && u < 64 && d >= 3 && d < 12 && (c = 32), u >= 72 && u < 84 && (d >= 0 && d < 9 ? c = 31 : d >= 9 && d < 21 ? c = 33 : d >= 21 && d < 33 ? c = 35 : d >= 33 && d < 42 && (c = 37)), h = xf(6 * (c - 1) - 180 + 3), i = m / (1 - m), r = p / Math.sqrt(1 - m * Math.sin(f) * Math.sin(f)), s = Math.tan(f) * Math.tan(f), a = i * Math.cos(f) * Math.cos(f), o = Math.cos(f) * (v - h), l = p * ((1 - m / 4 - 3 * m * m / 64 - 5 * m * m * m / 256) * f - (3 * m / 8 + 3 * m * m / 32 + 45 * m * m * m / 1024) * Math.sin(2 * f) + (15 * m * m / 256 + 45 * m * m * m / 1024) * Math.sin(4 * f) - 35 * m * m * m / 3072 * Math.sin(6 * f));
    var y = g * r * (o + (1 - s + a) * o * o * o / 6 + (5 - 18 * s + s * s + 72 * a - 58 * i) * o * o * o * o * o / 120) + 5e5, x = g * (l + r * Math.tan(f) * (o * o / 2 + (5 - s + 9 * a + 4 * a * a) * o * o * o * o / 24 + (61 - 58 * s + s * s + 600 * a - 330 * i) * o * o * o * o * o * o / 720));
    return u < 0 && (x += 1e7), { northing: Math.round(x), easting: Math.round(y), zoneNumber: c, zoneLetter: WA(u) };
  }({ lat: n[1], lon: n[0] }), e);
}
function Jb(n) {
  var e = f0($b(n.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function xf(n) {
  return n * (Math.PI / 180);
}
function _x(n) {
  return n / Math.PI * 180;
}
function f0(n) {
  var e = n.northing, t = n.easting, i = n.zoneLetter, r = n.zoneNumber;
  if (r < 0 || r > 60)
    return null;
  var s, a, o, l, h, c, u, d, p, m = 0.9996, g = 6378137, f = 669438e-8, v = (1 - Math.sqrt(0.99330562)) / (1 + Math.sqrt(0.99330562)), y = t - 5e5, x = e;
  i < "N" && (x -= 1e7), u = 6 * (r - 1) - 180 + 3, s = 0.006739496752268451, p = (d = x / m / 6367449145945056e-9) + (3 * v / 2 - 27 * v * v * v / 32) * Math.sin(2 * d) + (21 * v * v / 16 - 55 * v * v * v * v / 32) * Math.sin(4 * d) + 151 * v * v * v / 96 * Math.sin(6 * d), a = g / Math.sqrt(1 - f * Math.sin(p) * Math.sin(p)), o = Math.tan(p) * Math.tan(p), l = s * Math.cos(p) * Math.cos(p), h = 0.99330562 * g / Math.pow(1 - f * Math.sin(p) * Math.sin(p), 1.5), c = y / (a * m);
  var M = p - a * Math.tan(p) / h * (c * c / 2 - (5 + 3 * o + 10 * l - 4 * l * l - 9 * s) * c * c * c * c / 24 + (61 + 90 * o + 298 * l + 45 * o * o - 1.6983531815716497 - 3 * l * l) * c * c * c * c * c * c / 720);
  M = _x(M);
  var b, S = (c - (1 + 2 * o + l) * c * c * c / 6 + (5 - 2 * l + 28 * o - 3 * l * l + 8 * s + 24 * o * o) * c * c * c * c * c / 120) / Math.cos(p);
  if (S = u + _x(S), n.accuracy) {
    var w = f0({ northing: n.northing + n.accuracy, easting: n.easting + n.accuracy, zoneLetter: n.zoneLetter, zoneNumber: n.zoneNumber });
    b = { top: w.lat, right: w.lon, bottom: M, left: S };
  } else
    b = { lat: M, lon: S };
  return b;
}
function WA(n) {
  var e = "Z";
  return 84 >= n && n >= 72 ? e = "X" : 72 > n && n >= 64 ? e = "W" : 64 > n && n >= 56 ? e = "V" : 56 > n && n >= 48 ? e = "U" : 48 > n && n >= 40 ? e = "T" : 40 > n && n >= 32 ? e = "S" : 32 > n && n >= 24 ? e = "R" : 24 > n && n >= 16 ? e = "Q" : 16 > n && n >= 8 ? e = "P" : 8 > n && n >= 0 ? e = "N" : 0 > n && n >= -8 ? e = "M" : -8 > n && n >= -16 ? e = "L" : -16 > n && n >= -24 ? e = "K" : -24 > n && n >= -32 ? e = "J" : -32 > n && n >= -40 ? e = "H" : -40 > n && n >= -48 ? e = "G" : -48 > n && n >= -56 ? e = "F" : -56 > n && n >= -64 ? e = "E" : -64 > n && n >= -72 ? e = "D" : -72 > n && n >= -80 && (e = "C"), e;
}
function Qb(n) {
  var e = n % wx;
  return e === 0 && (e = wx), e;
}
function $b(n) {
  if (n && n.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e, t = n.length, i = null, r = "", s = 0; !/[A-Z]/.test(e = n.charAt(s)); ) {
    if (s >= 2)
      throw "MGRSPoint bad conversion from: " + n;
    r += e, s++;
  }
  var a = parseInt(r, 10);
  if (s === 0 || s + 3 > t)
    throw "MGRSPoint bad conversion from: " + n;
  var o = n.charAt(s++);
  if (o <= "A" || o === "B" || o === "Y" || o >= "Z" || o === "I" || o === "O")
    throw "MGRSPoint zone letter " + o + " not handled: " + n;
  i = n.substring(s, s += 2);
  for (var l = Qb(a), h = function(y, x) {
    for (var M = Yb.charCodeAt(x - 1), b = 1e5, S = !1; M !== y.charCodeAt(0); ) {
      if (++M === kn && M++, M === di && M++, M > Hl) {
        if (S)
          throw "Bad character: " + y;
        M = go, S = !0;
      }
      b += 1e5;
    }
    return b;
  }(i.charAt(0), l), c = function(y, x) {
    if (y > "V")
      throw "MGRSPoint given invalid Northing " + y;
    for (var M = Zb.charCodeAt(x - 1), b = 0, S = !1; M !== y.charCodeAt(0); ) {
      if (++M === kn && M++, M === di && M++, M > Vl) {
        if (S)
          throw "Bad character: " + y;
        M = go, S = !0;
      }
      b += 1e5;
    }
    return b;
  }(i.charAt(1), l); c < XA(o); )
    c += 2e6;
  var u = t - s;
  if (u % 2 != 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + n;
  var d, p, m, g = u / 2, f = 0, v = 0;
  return g > 0 && (d = 1e5 / Math.pow(10, g), p = n.substring(s, s + g), f = parseFloat(p) * d, m = n.substring(s + g), v = parseFloat(m) * d), { easting: f + h, northing: v + c, zoneLetter: o, zoneNumber: a, accuracy: d };
}
function XA(n) {
  var e;
  switch (n) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + n;
}
function Eo(n, e, t) {
  if (!(this instanceof Eo))
    return new Eo(n, e, t);
  if (Array.isArray(n))
    this.x = n[0], this.y = n[1], this.z = n[2] || 0;
  else if (typeof n == "object")
    this.x = n.x, this.y = n.y, this.z = n.z || 0;
  else if (typeof n == "string" && e === void 0) {
    var i = n.split(",");
    this.x = parseFloat(i[0], 10), this.y = parseFloat(i[1], 10), this.z = parseFloat(i[2], 10) || 0;
  } else
    this.x = n, this.y = e, this.z = t || 0;
}
Eo.fromMGRS = function(n) {
  return new Eo(Jb(n));
}, Eo.prototype.toMGRS = function(n) {
  return Kb([this.x, this.y], n);
};
var qA = 1, YA = 0.25, Tx = 0.046875, Ex = 0.01953125, Ax = 0.01068115234375, ZA = 0.75, KA = 0.46875, JA = 0.013020833333333334, QA = 0.007120768229166667, $A = 0.3645833333333333, e2 = 0.005696614583333333, t2 = 0.3076171875;
function eS(n) {
  var e = [];
  e[0] = qA - n * (YA + n * (Tx + n * (Ex + n * Ax))), e[1] = n * (ZA - n * (Tx + n * (Ex + n * Ax)));
  var t = n * n;
  return e[2] = t * (KA - n * (JA + n * QA)), t *= n, e[3] = t * ($A - n * e2), e[4] = t * n * t2, e;
}
function ld(n, e, t, i) {
  return t *= e, e *= e, i[0] * n - t * (i[1] + e * (i[2] + e * (i[3] + e * i[4])));
}
var n2 = 20;
function tS(n, e, t) {
  for (var i = 1 / (1 - e), r = n, s = n2; s; --s) {
    var a = Math.sin(r), o = 1 - e * a * a;
    if (r -= o = (ld(r, a, Math.cos(r), t) - n) * (o * Math.sqrt(o)) * i, Math.abs(o) < be)
      return r;
  }
  return r;
}
const Fu = { init: function() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = eS(this.es), this.ml0 = ld(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}, forward: function(n) {
  var e, t, i, r = n.x, s = n.y, a = we(r - this.long0), o = Math.sin(s), l = Math.cos(s);
  if (this.es) {
    var h = l * a, c = Math.pow(h, 2), u = this.ep2 * Math.pow(l, 2), d = Math.pow(u, 2), p = Math.abs(l) > be ? Math.tan(s) : 0, m = Math.pow(p, 2), g = Math.pow(m, 2);
    e = 1 - this.es * Math.pow(o, 2), h /= Math.sqrt(e);
    var f = ld(s, o, l, this.en);
    t = this.a * (this.k0 * h * (1 + c / 6 * (1 - m + u + c / 20 * (5 - 18 * m + g + 14 * u - 58 * m * u + c / 42 * (61 + 179 * g - g * m - 479 * m))))) + this.x0, i = this.a * (this.k0 * (f - this.ml0 + o * a * h / 2 * (1 + c / 12 * (5 - m + 9 * u + 4 * d + c / 30 * (61 + g - 58 * m + 270 * u - 330 * m * u + c / 56 * (1385 + 543 * g - g * m - 3111 * m)))))) + this.y0;
  } else {
    var v = l * Math.sin(a);
    if (Math.abs(Math.abs(v) - 1) < be)
      return 93;
    if (t = 0.5 * this.a * this.k0 * Math.log((1 + v) / (1 - v)) + this.x0, i = l * Math.cos(a) / Math.sqrt(1 - Math.pow(v, 2)), (v = Math.abs(i)) >= 1) {
      if (v - 1 > be)
        return 93;
      i = 0;
    } else
      i = Math.acos(i);
    s < 0 && (i = -i), i = this.a * this.k0 * (i - this.lat0) + this.y0;
  }
  return n.x = t, n.y = i, n;
}, inverse: function(n) {
  var e, t, i, r, s = (n.x - this.x0) * (1 / this.a), a = (n.y - this.y0) * (1 / this.a);
  if (this.es)
    if (t = tS(e = this.ml0 + a / this.k0, this.es, this.en), Math.abs(t) < pe) {
      var o = Math.sin(t), l = Math.cos(t), h = Math.abs(l) > be ? Math.tan(t) : 0, c = this.ep2 * Math.pow(l, 2), u = Math.pow(c, 2), d = Math.pow(h, 2), p = Math.pow(d, 2);
      e = 1 - this.es * Math.pow(o, 2);
      var m = s * Math.sqrt(e) / this.k0, g = Math.pow(m, 2);
      i = t - (e *= h) * g / (1 - this.es) * 0.5 * (1 - g / 12 * (5 + 3 * d - 9 * c * d + c - 4 * u - g / 30 * (61 + 90 * d - 252 * c * d + 45 * p + 46 * c - g / 56 * (1385 + 3633 * d + 4095 * p + 1574 * p * d)))), r = we(this.long0 + m * (1 - g / 6 * (1 + 2 * d + c - g / 20 * (5 + 28 * d + 24 * p + 8 * c * d + 6 * c - g / 42 * (61 + 662 * d + 1320 * p + 720 * p * d)))) / l);
    } else
      i = pe * $h(a), r = 0;
  else {
    var f = Math.exp(s / this.k0), v = 0.5 * (f - 1 / f), y = this.lat0 + a / this.k0, x = Math.cos(y);
    e = Math.sqrt((1 - Math.pow(x, 2)) / (1 + Math.pow(v, 2))), i = Math.asin(e), a < 0 && (i = -i), r = v === 0 && x === 0 ? 0 : we(Math.atan2(v, x) + this.long0);
  }
  return n.x = r, n.y = i, n;
}, names: ["Fast_Transverse_Mercator", "Fast Transverse Mercator"] };
function nS(n) {
  var e = Math.exp(n);
  return e = (e - 1 / e) / 2;
}
function mi(n, e) {
  n = Math.abs(n), e = Math.abs(e);
  var t = Math.max(n, e), i = Math.min(n, e) / (t || 1);
  return t * Math.sqrt(1 + Math.pow(i, 2));
}
function i2(n) {
  var e = Math.abs(n);
  return e = function(t) {
    var i = 1 + t, r = i - 1;
    return r === 0 ? t : t * Math.log(i) / r;
  }(e * (1 + e / (mi(1, e) + 1))), n < 0 ? -e : e;
}
function Mf(n, e) {
  for (var t, i = 2 * Math.cos(2 * e), r = n.length - 1, s = n[r], a = 0; --r >= 0; )
    t = i * s - a + n[r], a = s, s = t;
  return e + t * Math.sin(2 * e);
}
function Cx(n, e, t) {
  for (var i, r, s = Math.sin(e), a = Math.cos(e), o = nS(t), l = function(f) {
    var v = Math.exp(f);
    return (v + 1 / v) / 2;
  }(t), h = 2 * a * l, c = -2 * s * o, u = n.length - 1, d = n[u], p = 0, m = 0, g = 0; --u >= 0; )
    i = m, r = p, d = h * (m = d) - i - c * (p = g) + n[u], g = c * m - r + h * p;
  return [(h = s * l) * d - (c = a * o) * g, h * g + c * d];
}
const Bu = { init: function() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (Fu.init.apply(this), this.forward = Fu.forward, this.inverse = Fu.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var n = this.es / (1 + Math.sqrt(1 - this.es)), e = n / (2 - n), t = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675))) - 2))), this.cbg[0] = e * (e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725))))) - 2), t *= e, this.cgb[1] = t * (7 / 3 + e * (e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))) - 1.6)), this.cbg[1] = t * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), t *= e, this.cgb[2] = t * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = t * (-26 / 15 + e * (34 / 21 + e * (1.6 + e * (-12686 / 2835)))), t *= e, this.cgb[3] = t * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = t * (1237 / 630 + e * (e * (-24832 / 14175) - 2.4)), t *= e, this.cgb[4] = t * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = t * (-734 / 315 + e * (109598 / 31185)), t *= e, this.cgb[5] = t * (601676 / 22275), this.cbg[5] = t * (444337 / 155925), t = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + t * (1 / 4 + t * (1 / 64 + t / 256))), this.utg[0] = e * (e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800))))) - 0.5), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = t * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = t * (13 / 48 + e * (e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))) - 0.6)), t *= e, this.utg[2] = t * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = t * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), t *= e, this.utg[3] = t * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = t * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), t *= e, this.utg[4] = t * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = t * (34729 / 80640 + e * (-3418889 / 1995840)), t *= e, this.utg[5] = t * (-20648693 / 638668800), this.gtu[5] = 0.6650675310896665 * t;
  var i = Mf(this.cbg, this.lat0);
  this.Zb = -this.Qn * (i + function(r, s) {
    for (var a, o = 2 * Math.cos(s), l = r.length - 1, h = r[l], c = 0; --l >= 0; )
      a = o * h - c + r[l], c = h, h = a;
    return Math.sin(s) * a;
  }(this.gtu, 2 * i));
}, forward: function(n) {
  var e = we(n.x - this.long0), t = n.y;
  t = Mf(this.cbg, t);
  var i = Math.sin(t), r = Math.cos(t), s = Math.sin(e), a = Math.cos(e);
  t = Math.atan2(i, a * r), e = Math.atan2(s * r, mi(i, r * a)), e = i2(Math.tan(e));
  var o, l, h = Cx(this.gtu, 2 * t, 2 * e);
  return t += h[0], e += h[1], Math.abs(e) <= 2.623395162778 ? (o = this.a * (this.Qn * e) + this.x0, l = this.a * (this.Qn * t + this.Zb) + this.y0) : (o = 1 / 0, l = 1 / 0), n.x = o, n.y = l, n;
}, inverse: function(n) {
  var e, t, i = (n.x - this.x0) * (1 / this.a), r = (n.y - this.y0) * (1 / this.a);
  if (r = (r - this.Zb) / this.Qn, i /= this.Qn, Math.abs(i) <= 2.623395162778) {
    var s = Cx(this.utg, 2 * r, 2 * i);
    r += s[0], i += s[1], i = Math.atan(nS(i));
    var a = Math.sin(r), o = Math.cos(r), l = Math.sin(i), h = Math.cos(i);
    r = Math.atan2(a * h, mi(l, h * o)), e = we((i = Math.atan2(l, h * o)) + this.long0), t = Mf(this.cgb, r);
  } else
    e = 1 / 0, t = 1 / 0;
  return n.x = e, n.y = t, n;
}, names: ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"] }, r2 = { init: function() {
  var n = function(e, t) {
    if (e === void 0) {
      if ((e = Math.floor(30 * (we(t) + Math.PI) / Math.PI) + 1) < 0)
        return 0;
      if (e > 60)
        return 60;
    }
    return e;
  }(this.zone, this.long0);
  if (n === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(n) - 183) * mn, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, Bu.init.apply(this), this.forward = Bu.forward, this.inverse = Bu.inverse;
}, names: ["Universal Transverse Mercator System", "utm"], dependsOn: "etmerc" };
function bf(n, e) {
  return Math.pow((1 - n) / (1 + n), e);
}
const Sf = { init: function() {
  var n = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * n * n), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(n / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + lt) / (Math.pow(Math.tan(0.5 * this.lat0 + lt), this.C) * bf(this.e * n, this.ratexp));
}, forward: function(n) {
  var e = n.x, t = n.y;
  return n.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * t + lt), this.C) * bf(this.e * Math.sin(t), this.ratexp)) - pe, n.x = this.C * e, n;
}, inverse: function(n) {
  for (var e = n.x / this.C, t = n.y, i = Math.pow(Math.tan(0.5 * t + lt) / this.K, 1 / this.C), r = 20; r > 0 && (t = 2 * Math.atan(i * bf(this.e * Math.sin(n.y), -0.5 * this.e)) - pe, !(Math.abs(t - n.y) < 1e-14)); --r)
    n.y = t;
  return r ? (n.x = e, n.y = t, n) : null;
}, names: ["gauss"] }, s2 = { init: function() {
  Sf.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}, forward: function(n) {
  var e, t, i, r;
  return n.x = we(n.x - this.long0), Sf.forward.apply(this, [n]), e = Math.sin(n.y), t = Math.cos(n.y), i = Math.cos(n.x), r = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * t * i), n.x = r * t * Math.sin(n.x), n.y = r * (this.cosc0 * e - this.sinc0 * t * i), n.x = this.a * n.x + this.x0, n.y = this.a * n.y + this.y0, n;
}, inverse: function(n) {
  var e, t, i, r, s;
  if (n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a, n.x /= this.k0, n.y /= this.k0, s = mi(n.x, n.y)) {
    var a = 2 * Math.atan2(s, this.R2);
    e = Math.sin(a), t = Math.cos(a), r = Math.asin(t * this.sinc0 + n.y * e * this.cosc0 / s), i = Math.atan2(n.x * e, s * this.cosc0 * t - n.y * this.sinc0 * e);
  } else
    r = this.phic0, i = 0;
  return n.x = i, n.y = r, Sf.inverse.apply(this, [n]), n.x = we(n.x + this.long0), n;
}, names: ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"] }, a2 = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= be && (this.k0 = 0.5 * (1 + $h(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= be && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= be && Math.abs(Math.cos(this.lat_ts)) > be && (this.k0 = 0.5 * this.cons * ar(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Ni(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = ar(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - pe, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}, forward: function(n) {
  var e, t, i, r, s, a, o = n.x, l = n.y, h = Math.sin(l), c = Math.cos(l), u = we(o - this.long0);
  return Math.abs(Math.abs(o - this.long0) - Math.PI) <= be && Math.abs(l + this.lat0) <= be ? (n.x = NaN, n.y = NaN, n) : this.sphere ? (e = 2 * this.k0 / (1 + this.sinlat0 * h + this.coslat0 * c * Math.cos(u)), n.x = this.a * e * c * Math.sin(u) + this.x0, n.y = this.a * e * (this.coslat0 * h - this.sinlat0 * c * Math.cos(u)) + this.y0, n) : (t = 2 * Math.atan(this.ssfn_(l, h, this.e)) - pe, r = Math.cos(t), i = Math.sin(t), Math.abs(this.coslat0) <= be ? (s = Ni(this.e, l * this.con, this.con * h), a = 2 * this.a * this.k0 * s / this.cons, n.x = this.x0 + a * Math.sin(o - this.long0), n.y = this.y0 - this.con * a * Math.cos(o - this.long0), n) : (Math.abs(this.sinlat0) < be ? (e = 2 * this.a * this.k0 / (1 + r * Math.cos(u)), n.y = e * i) : (e = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * i + this.cosX0 * r * Math.cos(u))), n.y = e * (this.cosX0 * i - this.sinX0 * r * Math.cos(u)) + this.y0), n.x = e * r * Math.sin(u) + this.x0, n));
}, inverse: function(n) {
  var e, t, i, r, s;
  n.x -= this.x0, n.y -= this.y0;
  var a = Math.sqrt(n.x * n.x + n.y * n.y);
  if (this.sphere) {
    var o = 2 * Math.atan(a / (2 * this.a * this.k0));
    return e = this.long0, t = this.lat0, a <= be ? (n.x = e, n.y = t, n) : (t = Math.asin(Math.cos(o) * this.sinlat0 + n.y * Math.sin(o) * this.coslat0 / a), e = Math.abs(this.coslat0) < be ? this.lat0 > 0 ? we(this.long0 + Math.atan2(n.x, -1 * n.y)) : we(this.long0 + Math.atan2(n.x, n.y)) : we(this.long0 + Math.atan2(n.x * Math.sin(o), a * this.coslat0 * Math.cos(o) - n.y * this.sinlat0 * Math.sin(o))), n.x = e, n.y = t, n);
  }
  if (Math.abs(this.coslat0) <= be) {
    if (a <= be)
      return t = this.lat0, e = this.long0, n.x = e, n.y = t, n;
    n.x *= this.con, n.y *= this.con, i = a * this.cons / (2 * this.a * this.k0), t = this.con * Rh(this.e, i), e = this.con * we(this.con * this.long0 + Math.atan2(n.x, -1 * n.y));
  } else
    r = 2 * Math.atan(a * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, a <= be ? s = this.X0 : (s = Math.asin(Math.cos(r) * this.sinX0 + n.y * Math.sin(r) * this.cosX0 / a), e = we(this.long0 + Math.atan2(n.x * Math.sin(r), a * this.cosX0 * Math.cos(r) - n.y * this.sinX0 * Math.sin(r)))), t = -1 * Rh(this.e, Math.tan(0.5 * (pe + s)));
  return n.x = e, n.y = t, n;
}, names: ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"], ssfn_: function(n, e, t) {
  return e *= t, Math.tan(0.5 * (pe + n)) * Math.pow((1 - e) / (1 + e), 0.5 * t);
} }, o2 = { init: function() {
  var n = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(n), t = this.a, i = 1 / this.rf, r = 2 * i - Math.pow(i, 2), s = this.e = Math.sqrt(r);
  this.R = this.k0 * t * Math.sqrt(1 - r) / (1 - r * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + r / (1 - r) * Math.pow(Math.cos(n), 4)), this.b0 = Math.asin(e / this.alpha);
  var a = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), o = Math.log(Math.tan(Math.PI / 4 + n / 2)), l = Math.log((1 + s * e) / (1 - s * e));
  this.K = a - this.alpha * o + this.alpha * s / 2 * l;
}, forward: function(n) {
  var e = Math.log(Math.tan(Math.PI / 4 - n.y / 2)), t = this.e / 2 * Math.log((1 + this.e * Math.sin(n.y)) / (1 - this.e * Math.sin(n.y))), i = -this.alpha * (e + t) + this.K, r = 2 * (Math.atan(Math.exp(i)) - Math.PI / 4), s = this.alpha * (n.x - this.lambda0), a = Math.atan(Math.sin(s) / (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(s))), o = Math.asin(Math.cos(this.b0) * Math.sin(r) - Math.sin(this.b0) * Math.cos(r) * Math.cos(s));
  return n.y = this.R / 2 * Math.log((1 + Math.sin(o)) / (1 - Math.sin(o))) + this.y0, n.x = this.R * a + this.x0, n;
}, inverse: function(n) {
  for (var e = n.x - this.x0, t = n.y - this.y0, i = e / this.R, r = 2 * (Math.atan(Math.exp(t / this.R)) - Math.PI / 4), s = Math.asin(Math.cos(this.b0) * Math.sin(r) + Math.sin(this.b0) * Math.cos(r) * Math.cos(i)), a = Math.atan(Math.sin(i) / (Math.cos(this.b0) * Math.cos(i) - Math.sin(this.b0) * Math.tan(r))), o = this.lambda0 + a / this.alpha, l = 0, h = s, c = -1e3, u = 0; Math.abs(h - c) > 1e-7; ) {
    if (++u > 20)
      return;
    l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + s / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(h)) / 2)), c = h, h = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
  }
  return n.x = o, n.y = h, n;
}, names: ["somerc"] };
var no = 1e-7;
const l2 = { init: function() {
  var n, e, t, i, r, s, a, o, l, h, c, u, d, p = 0, m = 0, g = 0, f = 0, v = 0, y = 0, x = 0;
  this.no_off = (d = typeof (u = this).PROJECTION == "object" ? Object.keys(u.PROJECTION)[0] : u.PROJECTION, "no_uoff" in u || "no_off" in u || ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"].indexOf(d) !== -1), this.no_rot = "no_rot" in this;
  var M = !1;
  "alpha" in this && (M = !0);
  var b = !1;
  if ("rectified_grid_angle" in this && (b = !0), M && (x = this.alpha), b && (p = this.rectified_grid_angle * mn), M || b)
    m = this.longc;
  else if (g = this.long1, v = this.lat1, f = this.long2, y = this.lat2, Math.abs(v - y) <= no || (n = Math.abs(v)) <= no || Math.abs(n - pe) <= no || Math.abs(Math.abs(this.lat0) - pe) <= no || Math.abs(Math.abs(y) - pe) <= no)
    throw new Error();
  var S = 1 - this.es;
  e = Math.sqrt(S), Math.abs(this.lat0) > be ? (o = Math.sin(this.lat0), t = Math.cos(this.lat0), n = 1 - this.es * o * o, this.B = t * t, this.B = Math.sqrt(1 + this.es * this.B * this.B / S), this.A = this.B * this.k0 * e / n, (r = (i = this.B * e / (t * Math.sqrt(n))) * i - 1) <= 0 ? r = 0 : (r = Math.sqrt(r), this.lat0 < 0 && (r = -r)), this.E = r += i, this.E *= Math.pow(Ni(this.e, this.lat0, o), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = i = r = 1), M || b ? (M ? (c = Math.asin(Math.sin(x) / i), b || (p = x)) : (c = p, x = Math.asin(i * Math.sin(c))), this.lam0 = m - Math.asin(0.5 * (r - 1 / r) * Math.tan(c)) / this.B) : (s = Math.pow(Ni(this.e, v, Math.sin(v)), this.B), a = Math.pow(Ni(this.e, y, Math.sin(y)), this.B), r = this.E / s, l = (a - s) / (a + s), h = ((h = this.E * this.E) - a * s) / (h + a * s), (n = g - f) < -Math.pi ? f -= Ph : n > Math.pi && (f += Ph), this.lam0 = we(0.5 * (g + f) - Math.atan(h * Math.tan(0.5 * this.B * (g - f)) / l) / this.B), c = Math.atan(2 * Math.sin(this.B * we(g - this.lam0)) / (r - 1 / r)), p = x = Math.asin(i * Math.sin(c))), this.singam = Math.sin(c), this.cosgam = Math.cos(c), this.sinrot = Math.sin(p), this.cosrot = Math.cos(p), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A, this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(i * i - 1) / Math.cos(x))), this.lat0 < 0 && (this.u_0 = -this.u_0)), r = 0.5 * c, this.v_pole_n = this.ArB * Math.log(Math.tan(lt - r)), this.v_pole_s = this.ArB * Math.log(Math.tan(lt + r));
}, forward: function(n) {
  var e, t, i, r, s, a, o, l, h = {};
  if (n.x = n.x - this.lam0, Math.abs(Math.abs(n.y) - pe) > be) {
    if (e = 0.5 * ((s = this.E / Math.pow(Ni(this.e, n.y, Math.sin(n.y)), this.B)) - (a = 1 / s)), t = 0.5 * (s + a), r = Math.sin(this.B * n.x), i = (e * this.singam - r * this.cosgam) / t, Math.abs(Math.abs(i) - 1) < be)
      throw new Error();
    l = 0.5 * this.ArB * Math.log((1 - i) / (1 + i)), a = Math.cos(this.B * n.x), o = Math.abs(a) < no ? this.A * n.x : this.ArB * Math.atan2(e * this.cosgam + r * this.singam, a);
  } else
    l = n.y > 0 ? this.v_pole_n : this.v_pole_s, o = this.ArB * n.y;
  return this.no_rot ? (h.x = o, h.y = l) : (o -= this.u_0, h.x = l * this.cosrot + o * this.sinrot, h.y = o * this.cosrot - l * this.sinrot), h.x = this.a * h.x + this.x0, h.y = this.a * h.y + this.y0, h;
}, inverse: function(n) {
  var e, t, i, r, s, a, o, l = {};
  if (n.x = (n.x - this.x0) * (1 / this.a), n.y = (n.y - this.y0) * (1 / this.a), this.no_rot ? (t = n.y, e = n.x) : (t = n.x * this.cosrot - n.y * this.sinrot, e = n.y * this.cosrot + n.x * this.sinrot + this.u_0), r = 0.5 * ((i = Math.exp(-this.BrA * t)) - 1 / i), s = 0.5 * (i + 1 / i), o = ((a = Math.sin(this.BrA * e)) * this.cosgam + r * this.singam) / s, Math.abs(Math.abs(o) - 1) < be)
    l.x = 0, l.y = o < 0 ? -pe : pe;
  else {
    if (l.y = this.E / Math.sqrt((1 + o) / (1 - o)), l.y = Rh(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0)
      throw new Error();
    l.x = -this.rB * Math.atan2(r * this.cosgam - a * this.singam, Math.cos(this.BrA * e));
  }
  return l.x += this.lam0, l;
}, names: ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"] }, h2 = { init: function() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < be)) {
    var n = this.b / this.a;
    this.e = Math.sqrt(1 - n * n);
    var e = Math.sin(this.lat1), t = Math.cos(this.lat1), i = ar(this.e, e, t), r = Ni(this.e, this.lat1, e), s = Math.sin(this.lat2), a = Math.cos(this.lat2), o = ar(this.e, s, a), l = Ni(this.e, this.lat2, s), h = Ni(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > be ? this.ns = Math.log(i / o) / Math.log(r / l) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = i / (this.ns * Math.pow(r, this.ns)), this.rh = this.a * this.f0 * Math.pow(h, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}, forward: function(n) {
  var e = n.x, t = n.y;
  Math.abs(2 * Math.abs(t) - Math.PI) <= be && (t = $h(t) * (pe - 2 * be));
  var i, r, s = Math.abs(Math.abs(t) - pe);
  if (s > be)
    i = Ni(this.e, t, Math.sin(t)), r = this.a * this.f0 * Math.pow(i, this.ns);
  else {
    if ((s = t * this.ns) <= 0)
      return null;
    r = 0;
  }
  var a = this.ns * we(e - this.long0);
  return n.x = this.k0 * (r * Math.sin(a)) + this.x0, n.y = this.k0 * (this.rh - r * Math.cos(a)) + this.y0, n;
}, inverse: function(n) {
  var e, t, i, r, s, a = (n.x - this.x0) / this.k0, o = this.rh - (n.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(a * a + o * o), t = 1) : (e = -Math.sqrt(a * a + o * o), t = -1);
  var l = 0;
  if (e !== 0 && (l = Math.atan2(t * a, t * o)), e !== 0 || this.ns > 0) {
    if (t = 1 / this.ns, i = Math.pow(e / (this.a * this.f0), t), (r = Rh(this.e, i)) === -9999)
      return null;
  } else
    r = -pe;
  return s = we(l / this.ns + this.long0), n.x = s, n.y = r, n;
}, names: ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"] }, c2 = { init: function() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.4334234309119251), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}, forward: function(n) {
  var e, t, i, r, s, a, o, l = n.x, h = n.y, c = we(l - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(h)) / (1 - this.e * Math.sin(h)), this.alfa * this.e / 2), t = 2 * (Math.atan(this.k * Math.pow(Math.tan(h / 2 + this.s45), this.alfa) / e) - this.s45), i = -c * this.alfa, r = Math.asin(Math.cos(this.ad) * Math.sin(t) + Math.sin(this.ad) * Math.cos(t) * Math.cos(i)), s = Math.asin(Math.cos(t) * Math.sin(i) / Math.cos(r)), a = this.n * s, o = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(r / 2 + this.s45), this.n), n.y = o * Math.cos(a) / 1, n.x = o * Math.sin(a) / 1, this.czech || (n.y *= -1, n.x *= -1), n;
}, inverse: function(n) {
  var e, t, i, r, s, a, o, l = n.x;
  n.x = n.y, n.y = l, this.czech || (n.y *= -1, n.x *= -1), s = Math.sqrt(n.x * n.x + n.y * n.y), r = Math.atan2(n.y, n.x) / Math.sin(this.s0), i = 2 * (Math.atan(Math.pow(this.ro0 / s, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(i) - Math.sin(this.ad) * Math.cos(i) * Math.cos(r)), t = Math.asin(Math.cos(i) * Math.sin(r) / Math.cos(e)), n.x = this.long0 - t / this.alfa, a = e, o = 0;
  var h = 0;
  do
    n.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(a)) / (1 - this.e * Math.sin(a)), this.e / 2)) - this.s45), Math.abs(a - n.y) < 1e-10 && (o = 1), a = n.y, h += 1;
  while (o === 0 && h < 15);
  return h >= 15 ? null : n;
}, names: ["Krovak", "krovak"] };
function Ln(n, e, t, i, r) {
  return n * r - e * Math.sin(2 * r) + t * Math.sin(4 * r) - i * Math.sin(6 * r);
}
function Ih(n) {
  return 1 - 0.25 * n * (1 + n / 16 * (3 + 1.25 * n));
}
function Lh(n) {
  return 0.375 * n * (1 + 0.25 * n * (1 + 0.46875 * n));
}
function Nh(n) {
  return 0.05859375 * n * n * (1 + 0.75 * n);
}
function Dh(n) {
  return n * n * n * (35 / 3072);
}
function Ao(n, e, t) {
  var i = e * t;
  return n / Math.sqrt(1 - i * i);
}
function Ko(n) {
  return Math.abs(n) < pe ? n : n - $h(n) * Math.PI;
}
function hd(n, e, t, i, r) {
  var s, a;
  s = n / e;
  for (var o = 0; o < 15; o++)
    if (s += a = (n - (e * s - t * Math.sin(2 * s) + i * Math.sin(4 * s) - r * Math.sin(6 * s))) / (e - 2 * t * Math.cos(2 * s) + 4 * i * Math.cos(4 * s) - 6 * r * Math.cos(6 * s)), Math.abs(a) <= 1e-10)
      return s;
  return NaN;
}
const u2 = { init: function() {
  this.sphere || (this.e0 = Ih(this.es), this.e1 = Lh(this.es), this.e2 = Nh(this.es), this.e3 = Dh(this.es), this.ml0 = this.a * Ln(this.e0, this.e1, this.e2, this.e3, this.lat0));
}, forward: function(n) {
  var e, t, i = n.x, r = n.y;
  if (i = we(i - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(r) * Math.sin(i)), t = this.a * (Math.atan2(Math.tan(r), Math.cos(i)) - this.lat0);
  else {
    var s = Math.sin(r), a = Math.cos(r), o = Ao(this.a, this.e, s), l = Math.tan(r) * Math.tan(r), h = i * Math.cos(r), c = h * h, u = this.es * a * a / (1 - this.es);
    e = o * h * (1 - c * l * (1 / 6 - (8 - l + 8 * u) * c / 120)), t = this.a * Ln(this.e0, this.e1, this.e2, this.e3, r) - this.ml0 + o * s / a * c * (0.5 + (5 - l + 6 * u) * c / 24);
  }
  return n.x = e + this.x0, n.y = t + this.y0, n;
}, inverse: function(n) {
  n.x -= this.x0, n.y -= this.y0;
  var e, t, i = n.x / this.a, r = n.y / this.a;
  if (this.sphere) {
    var s = r + this.lat0;
    e = Math.asin(Math.sin(s) * Math.cos(i)), t = Math.atan2(Math.tan(i), Math.cos(s));
  } else {
    var a = hd(this.ml0 / this.a + r, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(a) - pe) <= be)
      return n.x = this.long0, n.y = pe, r < 0 && (n.y *= -1), n;
    var o = Ao(this.a, this.e, Math.sin(a)), l = o * o * o / this.a / this.a * (1 - this.es), h = Math.pow(Math.tan(a), 2), c = i * this.a / o, u = c * c;
    e = a - o * Math.tan(a) / l * c * c * (0.5 - (1 + 3 * h) * c * c / 24), t = c * (1 - u * (h / 3 + (1 + 3 * h) * h * u / 15)) / Math.cos(a);
  }
  return n.x = we(t + this.long0), n.y = Ko(e), n;
}, names: ["Cassini", "Cassini_Soldner", "cass"] };
function rs(n, e) {
  var t;
  return n > 1e-7 ? (1 - n * n) * (e / (1 - (t = n * e) * t) - 0.5 / n * Math.log((1 - t) / (1 + t))) : 2 * e;
}
var d2 = 0.3333333333333333, p2 = 0.17222222222222222, f2 = 0.10257936507936508, m2 = 0.06388888888888888, g2 = 0.0664021164021164, v2 = 0.016415012942191543;
const y2 = { init: function() {
  var n, e = Math.abs(this.lat0);
  if (Math.abs(e - pe) < be ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(e) < be ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0)
    switch (this.qp = rs(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = function(t) {
      var i, r = [];
      return r[0] = t * d2, i = t * t, r[0] += i * p2, r[1] = i * m2, i *= t, r[0] += i * f2, r[1] += i * g2, r[2] = i * v2, r;
    }(this.es), this.mode) {
      case this.N_POLE:
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), n = Math.sin(this.lat0), this.sinb1 = rs(this.e, n) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * n * n) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
    }
  else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}, forward: function(n) {
  var e, t, i, r, s, a, o, l, h, c, u = n.x, d = n.y;
  if (u = we(u - this.long0), this.sphere) {
    if (s = Math.sin(d), c = Math.cos(d), i = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if ((t = this.mode === this.EQUIT ? 1 + c * i : 1 + this.sinph0 * s + this.cosph0 * c * i) <= be)
        return null;
      e = (t = Math.sqrt(2 / t)) * c * Math.sin(u), t *= this.mode === this.EQUIT ? s : this.cosph0 * s - this.sinph0 * c * i;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (i = -i), Math.abs(d + this.lat0) < be)
        return null;
      t = lt - 0.5 * d, e = (t = 2 * (this.mode === this.S_POLE ? Math.cos(t) : Math.sin(t))) * Math.sin(u), t *= i;
    }
  } else {
    switch (o = 0, l = 0, h = 0, i = Math.cos(u), r = Math.sin(u), s = Math.sin(d), a = rs(this.e, s), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (o = a / this.qp, l = Math.sqrt(1 - o * o)), this.mode) {
      case this.OBLIQ:
        h = 1 + this.sinb1 * o + this.cosb1 * l * i;
        break;
      case this.EQUIT:
        h = 1 + l * i;
        break;
      case this.N_POLE:
        h = pe + d, a = this.qp - a;
        break;
      case this.S_POLE:
        h = d - pe, a = this.qp + a;
    }
    if (Math.abs(h) < be)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        h = Math.sqrt(2 / h), t = this.mode === this.OBLIQ ? this.ymf * h * (this.cosb1 * o - this.sinb1 * l * i) : (h = Math.sqrt(2 / (1 + l * i))) * o * this.ymf, e = this.xmf * h * l * r;
        break;
      case this.N_POLE:
      case this.S_POLE:
        a >= 0 ? (e = (h = Math.sqrt(a)) * r, t = i * (this.mode === this.S_POLE ? h : -h)) : e = t = 0;
    }
  }
  return n.x = this.a * e + this.x0, n.y = this.a * t + this.y0, n;
}, inverse: function(n) {
  n.x -= this.x0, n.y -= this.y0;
  var e, t, i, r, s, a, o, l, h, c, u = n.x / this.a, d = n.y / this.a;
  if (this.sphere) {
    var p, m = 0, g = 0;
    if ((t = 0.5 * (p = Math.sqrt(u * u + d * d))) > 1)
      return null;
    switch (t = 2 * Math.asin(t), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (g = Math.sin(t), m = Math.cos(t)), this.mode) {
      case this.EQUIT:
        t = Math.abs(p) <= be ? 0 : Math.asin(d * g / p), u *= g, d = m * p;
        break;
      case this.OBLIQ:
        t = Math.abs(p) <= be ? this.lat0 : Math.asin(m * this.sinph0 + d * g * this.cosph0 / p), u *= g * this.cosph0, d = (m - Math.sin(t) * this.sinph0) * p;
        break;
      case this.N_POLE:
        d = -d, t = pe - t;
        break;
      case this.S_POLE:
        t -= pe;
    }
    e = d !== 0 || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(u, d) : 0;
  } else {
    if (o = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (u /= this.dd, d *= this.dd, (a = Math.sqrt(u * u + d * d)) < be)
        return n.x = this.long0, n.y = this.lat0, n;
      r = 2 * Math.asin(0.5 * a / this.rq), i = Math.cos(r), u *= r = Math.sin(r), this.mode === this.OBLIQ ? (o = i * this.sinb1 + d * r * this.cosb1 / a, s = this.qp * o, d = a * this.cosb1 * i - d * this.sinb1 * r) : (o = d * r / a, s = this.qp * o, d = a * i);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (d = -d), !(s = u * u + d * d))
        return n.x = this.long0, n.y = this.lat0, n;
      o = 1 - s / this.qp, this.mode === this.S_POLE && (o = -o);
    }
    e = Math.atan2(u, d), l = Math.asin(o), h = this.apa, c = l + l, t = l + h[0] * Math.sin(c) + h[1] * Math.sin(c + c) + h[2] * Math.sin(c + c + c);
  }
  return n.x = we(this.long0 + e), n.y = t, n;
}, names: ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"], S_POLE: 1, N_POLE: 2, EQUIT: 3, OBLIQ: 4 };
function Ss(n) {
  return Math.abs(n) > 1 && (n = n > 1 ? 1 : -1), Math.asin(n);
}
const x2 = { init: function() {
  Math.abs(this.lat1 + this.lat2) < be || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = ar(this.e3, this.sin_po, this.cos_po), this.qs1 = rs(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = ar(this.e3, this.sin_po, this.cos_po), this.qs2 = rs(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = rs(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > be ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}, forward: function(n) {
  var e = n.x, t = n.y;
  this.sin_phi = Math.sin(t), this.cos_phi = Math.cos(t);
  var i = rs(this.e3, this.sin_phi), r = this.a * Math.sqrt(this.c - this.ns0 * i) / this.ns0, s = this.ns0 * we(e - this.long0), a = r * Math.sin(s) + this.x0, o = this.rh - r * Math.cos(s) + this.y0;
  return n.x = a, n.y = o, n;
}, inverse: function(n) {
  var e, t, i, r, s, a;
  return n.x -= this.x0, n.y = this.rh - n.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(n.x * n.x + n.y * n.y), i = 1) : (e = -Math.sqrt(n.x * n.x + n.y * n.y), i = -1), r = 0, e !== 0 && (r = Math.atan2(i * n.x, i * n.y)), i = e * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - i * i) / (2 * this.ns0)) : (t = (this.c - i * i) / this.ns0, a = this.phi1z(this.e3, t)), s = we(r / this.ns0 + this.long0), n.x = s, n.y = a, n;
}, names: ["Albers_Conic_Equal_Area", "Albers", "aea"], phi1z: function(n, e) {
  var t, i, r, s, a = Ss(0.5 * e);
  if (n < be)
    return a;
  for (var o = n * n, l = 1; l <= 25; l++)
    if (a += s = 0.5 * (r = 1 - (i = n * (t = Math.sin(a))) * i) * r / Math.cos(a) * (e / (1 - o) - t / r + 0.5 / n * Math.log((1 - i) / (1 + i))), Math.abs(s) <= 1e-7)
      return a;
  return null;
} }, M2 = { init: function() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}, forward: function(n) {
  var e, t, i, r, s, a, o, l = n.x, h = n.y;
  return i = we(l - this.long0), e = Math.sin(h), t = Math.cos(h), r = Math.cos(i), (s = this.sin_p14 * e + this.cos_p14 * t * r) > 0 || Math.abs(s) <= be ? (a = this.x0 + 1 * this.a * t * Math.sin(i) / s, o = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * t * r) / s) : (a = this.x0 + this.infinity_dist * t * Math.sin(i), o = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * t * r)), n.x = a, n.y = o, n;
}, inverse: function(n) {
  var e, t, i, r, s, a;
  return n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a, n.x /= this.k0, n.y /= this.k0, (e = Math.sqrt(n.x * n.x + n.y * n.y)) ? (r = Math.atan2(e, this.rc), t = Math.sin(r), a = Ss((i = Math.cos(r)) * this.sin_p14 + n.y * t * this.cos_p14 / e), s = Math.atan2(n.x * t, e * this.cos_p14 * i - n.y * this.sin_p14 * t), s = we(this.long0 + s)) : (a = this.phic0, s = 0), n.x = s, n.y = a, n;
}, names: ["gnom"] }, b2 = { init: function() {
  this.sphere || (this.k0 = ar(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}, forward: function(n) {
  var e, t, i = n.x, r = n.y, s = we(i - this.long0);
  if (this.sphere)
    e = this.x0 + this.a * s * Math.cos(this.lat_ts), t = this.y0 + this.a * Math.sin(r) / Math.cos(this.lat_ts);
  else {
    var a = rs(this.e, Math.sin(r));
    e = this.x0 + this.a * this.k0 * s, t = this.y0 + this.a * a * 0.5 / this.k0;
  }
  return n.x = e, n.y = t, n;
}, inverse: function(n) {
  var e, t;
  return n.x -= this.x0, n.y -= this.y0, this.sphere ? (e = we(this.long0 + n.x / this.a / Math.cos(this.lat_ts)), t = Math.asin(n.y / this.a * Math.cos(this.lat_ts))) : (t = function(i, r) {
    var s = 1 - (1 - i * i) / (2 * i) * Math.log((1 - i) / (1 + i));
    if (Math.abs(Math.abs(r) - s) < 1e-6)
      return r < 0 ? -1 * pe : pe;
    for (var a, o, l, h, c = Math.asin(0.5 * r), u = 0; u < 30; u++)
      if (o = Math.sin(c), l = Math.cos(c), h = i * o, c += a = Math.pow(1 - h * h, 2) / (2 * l) * (r / (1 - i * i) - o / (1 - h * h) + 0.5 / i * Math.log((1 - h) / (1 + h))), Math.abs(a) <= 1e-10)
        return c;
    return NaN;
  }(this.e, 2 * n.y * this.k0 / this.a), e = we(this.long0 + n.x / (this.a * this.k0))), n.x = e, n.y = t, n;
}, names: ["cea"] }, S2 = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}, forward: function(n) {
  var e = n.x, t = n.y, i = we(e - this.long0), r = Ko(t - this.lat0);
  return n.x = this.x0 + this.a * i * this.rc, n.y = this.y0 + this.a * r, n;
}, inverse: function(n) {
  var e = n.x, t = n.y;
  return n.x = we(this.long0 + (e - this.x0) / (this.a * this.rc)), n.y = Ko(this.lat0 + (t - this.y0) / this.a), n;
}, names: ["Equirectangular", "Equidistant_Cylindrical", "eqc"] }, w2 = { init: function() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Ih(this.es), this.e1 = Lh(this.es), this.e2 = Nh(this.es), this.e3 = Dh(this.es), this.ml0 = this.a * Ln(this.e0, this.e1, this.e2, this.e3, this.lat0);
}, forward: function(n) {
  var e, t, i, r = n.x, s = n.y, a = we(r - this.long0);
  if (i = a * Math.sin(s), this.sphere)
    Math.abs(s) <= be ? (e = this.a * a, t = -1 * this.a * this.lat0) : (e = this.a * Math.sin(i) / Math.tan(s), t = this.a * (Ko(s - this.lat0) + (1 - Math.cos(i)) / Math.tan(s)));
  else if (Math.abs(s) <= be)
    e = this.a * a, t = -1 * this.ml0;
  else {
    var o = Ao(this.a, this.e, Math.sin(s)) / Math.tan(s);
    e = o * Math.sin(i), t = this.a * Ln(this.e0, this.e1, this.e2, this.e3, s) - this.ml0 + o * (1 - Math.cos(i));
  }
  return n.x = e + this.x0, n.y = t + this.y0, n;
}, inverse: function(n) {
  var e, t, i, r, s, a, o, l, h;
  if (i = n.x - this.x0, r = n.y - this.y0, this.sphere)
    if (Math.abs(r + this.a * this.lat0) <= be)
      e = we(i / this.a + this.long0), t = 0;
    else {
      var c;
      for (a = this.lat0 + r / this.a, o = i * i / this.a / this.a + a * a, l = a, s = 20; s; --s)
        if (l += h = -1 * (a * (l * (c = Math.tan(l)) + 1) - l - 0.5 * (l * l + o) * c) / ((l - a) / c - 1), Math.abs(h) <= be) {
          t = l;
          break;
        }
      e = we(this.long0 + Math.asin(i * Math.tan(l) / this.a) / Math.sin(t));
    }
  else if (Math.abs(r + this.ml0) <= be)
    t = 0, e = we(this.long0 + i / this.a);
  else {
    var u, d, p, m, g;
    for (a = (this.ml0 + r) / this.a, o = i * i / this.a / this.a + a * a, l = a, s = 20; s; --s)
      if (g = this.e * Math.sin(l), u = Math.sqrt(1 - g * g) * Math.tan(l), d = this.a * Ln(this.e0, this.e1, this.e2, this.e3, l), p = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), l -= h = (a * (u * (m = d / this.a) + 1) - m - 0.5 * u * (m * m + o)) / (this.es * Math.sin(2 * l) * (m * m + o - 2 * a * m) / (4 * u) + (a - m) * (u * p - 2 / Math.sin(2 * l)) - p), Math.abs(h) <= be) {
        t = l;
        break;
      }
    u = Math.sqrt(1 - this.es * Math.pow(Math.sin(t), 2)) * Math.tan(t), e = we(this.long0 + Math.asin(i * u / this.a) / Math.sin(t));
  }
  return n.x = e, n.y = t, n;
}, names: ["Polyconic", "poly"] }, _2 = { init: function() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}, forward: function(n) {
  var e, t = n.x, i = n.y - this.lat0, r = t - this.long0, s = i / $l * 1e-5, a = r, o = 1, l = 0;
  for (e = 1; e <= 10; e++)
    o *= s, l += this.A[e] * o;
  var h, c = l, u = a, d = 1, p = 0, m = 0, g = 0;
  for (e = 1; e <= 6; e++)
    h = p * c + d * u, d = d * c - p * u, p = h, m = m + this.B_re[e] * d - this.B_im[e] * p, g = g + this.B_im[e] * d + this.B_re[e] * p;
  return n.x = g * this.a + this.x0, n.y = m * this.a + this.y0, n;
}, inverse: function(n) {
  var e, t, i = n.x, r = n.y, s = i - this.x0, a = (r - this.y0) / this.a, o = s / this.a, l = 1, h = 0, c = 0, u = 0;
  for (e = 1; e <= 6; e++)
    t = h * a + l * o, l = l * a - h * o, h = t, c = c + this.C_re[e] * l - this.C_im[e] * h, u = u + this.C_im[e] * l + this.C_re[e] * h;
  for (var d = 0; d < this.iterations; d++) {
    var p, m = c, g = u, f = a, v = o;
    for (e = 2; e <= 6; e++)
      p = g * c + m * u, m = m * c - g * u, g = p, f += (e - 1) * (this.B_re[e] * m - this.B_im[e] * g), v += (e - 1) * (this.B_im[e] * m + this.B_re[e] * g);
    m = 1, g = 0;
    var y = this.B_re[1], x = this.B_im[1];
    for (e = 2; e <= 6; e++)
      p = g * c + m * u, m = m * c - g * u, g = p, y += e * (this.B_re[e] * m - this.B_im[e] * g), x += e * (this.B_im[e] * m + this.B_re[e] * g);
    var M = y * y + x * x;
    c = (f * y + v * x) / M, u = (v * y - f * x) / M;
  }
  var b = c, S = u, w = 1, T = 0;
  for (e = 1; e <= 9; e++)
    w *= b, T += this.D[e] * w;
  var C = this.lat0 + T * $l * 1e5, I = this.long0 + S;
  return n.x = I, n.y = C, n;
}, names: ["New_Zealand_Map_Grid", "nzmg"] }, T2 = { init: function() {
}, forward: function(n) {
  var e = n.x, t = n.y, i = we(e - this.long0), r = this.x0 + this.a * i, s = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + t / 2.5)) * 1.25;
  return n.x = r, n.y = s, n;
}, inverse: function(n) {
  n.x -= this.x0, n.y -= this.y0;
  var e = we(this.long0 + n.x / this.a), t = 2.5 * (Math.atan(Math.exp(0.8 * n.y / this.a)) - Math.PI / 4);
  return n.x = e, n.y = t, n;
}, names: ["Miller_Cylindrical", "mill"] }, E2 = { init: function() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = eS(this.es);
}, forward: function(n) {
  var e, t, i = n.x, r = n.y;
  if (i = we(i - this.long0), this.sphere) {
    if (this.m)
      for (var s = this.n * Math.sin(r), a = 20; a; --a) {
        var o = (this.m * r + Math.sin(r) - s) / (this.m + Math.cos(r));
        if (r -= o, Math.abs(o) < be)
          break;
      }
    else
      r = this.n !== 1 ? Math.asin(this.n * Math.sin(r)) : r;
    e = this.a * this.C_x * i * (this.m + Math.cos(r)), t = this.a * this.C_y * r;
  } else {
    var l = Math.sin(r), h = Math.cos(r);
    t = this.a * ld(r, l, h, this.en), e = this.a * i * h / Math.sqrt(1 - this.es * l * l);
  }
  return n.x = e, n.y = t, n;
}, inverse: function(n) {
  var e, t, i;
  return n.x -= this.x0, t = n.x / this.a, n.y -= this.y0, e = n.y / this.a, this.sphere ? (e /= this.C_y, t /= this.C_x * (this.m + Math.cos(e)), this.m ? e = Ss((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = Ss(Math.sin(e) / this.n)), t = we(t + this.long0), e = Ko(e)) : (e = tS(n.y / this.a, this.es, this.en), (i = Math.abs(e)) < pe ? (i = Math.sin(e), t = we(this.long0 + n.x * Math.sqrt(1 - this.es * i * i) / (this.a * Math.cos(e)))) : i - be < pe && (t = this.long0)), n.x = t, n.y = e, n;
}, names: ["Sinusoidal", "sinu"] }, A2 = { init: function() {
}, forward: function(n) {
  for (var e = n.x, t = n.y, i = we(e - this.long0), r = t, s = Math.PI * Math.sin(t); ; ) {
    var a = -(r + Math.sin(r) - s) / (1 + Math.cos(r));
    if (r += a, Math.abs(a) < be)
      break;
  }
  r /= 2, Math.PI / 2 - Math.abs(t) < be && (i = 0);
  var o = 0.900316316158 * this.a * i * Math.cos(r) + this.x0, l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
  return n.x = o, n.y = l, n;
}, inverse: function(n) {
  var e, t;
  n.x -= this.x0, n.y -= this.y0, t = n.y / (1.4142135623731 * this.a), Math.abs(t) > 0.999999999999 && (t = 0.999999999999), e = Math.asin(t);
  var i = we(this.long0 + n.x / (0.900316316158 * this.a * Math.cos(e)));
  i < -Math.PI && (i = -Math.PI), i > Math.PI && (i = Math.PI), t = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(t) > 1 && (t = 1);
  var r = Math.asin(t);
  return n.x = i, n.y = r, n;
}, names: ["Mollweide", "moll"] }, C2 = { init: function() {
  Math.abs(this.lat1 + this.lat2) < be || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Ih(this.es), this.e1 = Lh(this.es), this.e2 = Nh(this.es), this.e3 = Dh(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = ar(this.e, this.sinphi, this.cosphi), this.ml1 = Ln(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < be ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = ar(this.e, this.sinphi, this.cosphi), this.ml2 = Ln(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Ln(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}, forward: function(n) {
  var e, t = n.x, i = n.y;
  if (this.sphere)
    e = this.a * (this.g - i);
  else {
    var r = Ln(this.e0, this.e1, this.e2, this.e3, i);
    e = this.a * (this.g - r);
  }
  var s = this.ns * we(t - this.long0), a = this.x0 + e * Math.sin(s), o = this.y0 + this.rh - e * Math.cos(s);
  return n.x = a, n.y = o, n;
}, inverse: function(n) {
  var e, t, i, r;
  n.x -= this.x0, n.y = this.rh - n.y + this.y0, this.ns >= 0 ? (t = Math.sqrt(n.x * n.x + n.y * n.y), e = 1) : (t = -Math.sqrt(n.x * n.x + n.y * n.y), e = -1);
  var s = 0;
  return t !== 0 && (s = Math.atan2(e * n.x, e * n.y)), this.sphere ? (r = we(this.long0 + s / this.ns), i = Ko(this.g - t / this.a), n.x = r, n.y = i, n) : (i = hd(this.g - t / this.a, this.e0, this.e1, this.e2, this.e3), r = we(this.long0 + s / this.ns), n.x = r, n.y = i, n);
}, names: ["Equidistant_Conic", "eqdc"] }, P2 = { init: function() {
  this.R = this.a;
}, forward: function(n) {
  var e, t, i = n.x, r = n.y, s = we(i - this.long0);
  Math.abs(r) <= be && (e = this.x0 + this.R * s, t = this.y0);
  var a = Ss(2 * Math.abs(r / Math.PI));
  (Math.abs(s) <= be || Math.abs(Math.abs(r) - pe) <= be) && (e = this.x0, t = r >= 0 ? this.y0 + Math.PI * this.R * Math.tan(0.5 * a) : this.y0 + Math.PI * this.R * -Math.tan(0.5 * a));
  var o = 0.5 * Math.abs(Math.PI / s - s / Math.PI), l = o * o, h = Math.sin(a), c = Math.cos(a), u = c / (h + c - 1), d = u * u, p = u * (2 / h - 1), m = p * p, g = Math.PI * this.R * (o * (u - m) + Math.sqrt(l * (u - m) * (u - m) - (m + l) * (d - m))) / (m + l);
  s < 0 && (g = -g), e = this.x0 + g;
  var f = l + u;
  return g = Math.PI * this.R * (p * f - o * Math.sqrt((m + l) * (l + 1) - f * f)) / (m + l), t = r >= 0 ? this.y0 + g : this.y0 - g, n.x = e, n.y = t, n;
}, inverse: function(n) {
  var e, t, i, r, s, a, o, l, h, c, u, d;
  return n.x -= this.x0, n.y -= this.y0, u = Math.PI * this.R, s = (i = n.x / u) * i + (r = n.y / u) * r, u = 3 * (r * r / (l = -2 * (a = -Math.abs(r) * (1 + s)) + 1 + 2 * r * r + s * s) + (2 * (o = a - 2 * r * r + i * i) * o * o / l / l / l - 9 * a * o / l / l) / 27) / (h = (a - o * o / 3 / l) / l) / (c = 2 * Math.sqrt(-h / 3)), Math.abs(u) > 1 && (u = u >= 0 ? 1 : -1), d = Math.acos(u) / 3, t = n.y >= 0 ? (-c * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI : -(-c * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI, e = Math.abs(i) < be ? this.long0 : we(this.long0 + Math.PI * (s - 1 + Math.sqrt(1 + 2 * (i * i - r * r) + s * s)) / 2 / i), n.x = e, n.y = t, n;
}, names: ["Van_der_Grinten_I", "VanDerGrinten", "vandg"] }, R2 = { init: function() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}, forward: function(n) {
  var e, t, i, r, s, a, o, l, h, c, u, d, p, m, g, f, v, y, x, M, b, S, w = n.x, T = n.y, C = Math.sin(n.y), I = Math.cos(n.y), A = we(w - this.long0);
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= be ? (n.x = this.x0 + this.a * (pe - T) * Math.sin(A), n.y = this.y0 - this.a * (pe - T) * Math.cos(A), n) : Math.abs(this.sin_p12 + 1) <= be ? (n.x = this.x0 + this.a * (pe + T) * Math.sin(A), n.y = this.y0 + this.a * (pe + T) * Math.cos(A), n) : (y = this.sin_p12 * C + this.cos_p12 * I * Math.cos(A), v = (f = Math.acos(y)) ? f / Math.sin(f) : 1, n.x = this.x0 + this.a * v * I * Math.sin(A), n.y = this.y0 + this.a * v * (this.cos_p12 * C - this.sin_p12 * I * Math.cos(A)), n) : (e = Ih(this.es), t = Lh(this.es), i = Nh(this.es), r = Dh(this.es), Math.abs(this.sin_p12 - 1) <= be ? (s = this.a * Ln(e, t, i, r, pe), a = this.a * Ln(e, t, i, r, T), n.x = this.x0 + (s - a) * Math.sin(A), n.y = this.y0 - (s - a) * Math.cos(A), n) : Math.abs(this.sin_p12 + 1) <= be ? (s = this.a * Ln(e, t, i, r, pe), a = this.a * Ln(e, t, i, r, T), n.x = this.x0 + (s + a) * Math.sin(A), n.y = this.y0 + (s + a) * Math.cos(A), n) : (o = C / I, l = Ao(this.a, this.e, this.sin_p12), h = Ao(this.a, this.e, C), c = Math.atan((1 - this.es) * o + this.es * l * this.sin_p12 / (h * I)), x = (u = Math.atan2(Math.sin(A), this.cos_p12 * Math.tan(c) - this.sin_p12 * Math.cos(A))) === 0 ? Math.asin(this.cos_p12 * Math.sin(c) - this.sin_p12 * Math.cos(c)) : Math.abs(Math.abs(u) - Math.PI) <= be ? -Math.asin(this.cos_p12 * Math.sin(c) - this.sin_p12 * Math.cos(c)) : Math.asin(Math.sin(A) * Math.cos(c) / Math.sin(u)), d = this.e * this.sin_p12 / Math.sqrt(1 - this.es), f = l * x * (1 - (M = x * x) * (g = (p = this.e * this.cos_p12 * Math.cos(u) / Math.sqrt(1 - this.es)) * p) * (1 - g) / 6 + (b = M * x) / 8 * (m = d * p) * (1 - 2 * g) + (S = b * x) / 120 * (g * (4 - 7 * g) - 3 * d * d * (1 - 7 * g)) - S * x / 48 * m), n.x = this.x0 + f * Math.sin(u), n.y = this.y0 + f * Math.cos(u), n));
}, inverse: function(n) {
  var e, t, i, r, s, a, o, l, h, c, u, d, p, m, g, f, v, y, x, M, b, S, w;
  return n.x -= this.x0, n.y -= this.y0, this.sphere ? (e = Math.sqrt(n.x * n.x + n.y * n.y)) > 2 * pe * this.a ? void 0 : (t = e / this.a, i = Math.sin(t), r = Math.cos(t), s = this.long0, Math.abs(e) <= be ? a = this.lat0 : (a = Ss(r * this.sin_p12 + n.y * i * this.cos_p12 / e), o = Math.abs(this.lat0) - pe, s = Math.abs(o) <= be ? this.lat0 >= 0 ? we(this.long0 + Math.atan2(n.x, -n.y)) : we(this.long0 - Math.atan2(-n.x, n.y)) : we(this.long0 + Math.atan2(n.x * i, e * this.cos_p12 * r - n.y * this.sin_p12 * i))), n.x = s, n.y = a, n) : (l = Ih(this.es), h = Lh(this.es), c = Nh(this.es), u = Dh(this.es), Math.abs(this.sin_p12 - 1) <= be ? (a = hd(((d = this.a * Ln(l, h, c, u, pe)) - (e = Math.sqrt(n.x * n.x + n.y * n.y))) / this.a, l, h, c, u), s = we(this.long0 + Math.atan2(n.x, -1 * n.y)), n.x = s, n.y = a, n) : Math.abs(this.sin_p12 + 1) <= be ? (d = this.a * Ln(l, h, c, u, pe), a = hd(((e = Math.sqrt(n.x * n.x + n.y * n.y)) - d) / this.a, l, h, c, u), s = we(this.long0 + Math.atan2(n.x, n.y)), n.x = s, n.y = a, n) : (e = Math.sqrt(n.x * n.x + n.y * n.y), g = Math.atan2(n.x, n.y), p = Ao(this.a, this.e, this.sin_p12), f = Math.cos(g), y = -(v = this.e * this.cos_p12 * f) * v / (1 - this.es), x = 3 * this.es * (1 - y) * this.sin_p12 * this.cos_p12 * f / (1 - this.es), S = 1 - y * (b = (M = e / p) - y * (1 + y) * Math.pow(M, 3) / 6 - x * (1 + 3 * y) * Math.pow(M, 4) / 24) * b / 2 - M * b * b * b / 6, m = Math.asin(this.sin_p12 * Math.cos(b) + this.cos_p12 * Math.sin(b) * f), s = we(this.long0 + Math.asin(Math.sin(g) * Math.sin(b) / Math.cos(m))), w = Math.sin(m), a = Math.atan2((w - this.es * S * this.sin_p12) * Math.tan(m), w * (1 - this.es)), n.x = s, n.y = a, n));
}, names: ["Azimuthal_Equidistant", "aeqd"] }, I2 = { init: function() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}, forward: function(n) {
  var e, t, i, r, s, a, o, l = n.x, h = n.y;
  return i = we(l - this.long0), e = Math.sin(h), t = Math.cos(h), r = Math.cos(i), ((s = this.sin_p14 * e + this.cos_p14 * t * r) > 0 || Math.abs(s) <= be) && (a = 1 * this.a * t * Math.sin(i), o = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * t * r)), n.x = a, n.y = o, n;
}, inverse: function(n) {
  var e, t, i, r, s, a, o;
  return n.x -= this.x0, n.y -= this.y0, t = Ss((e = Math.sqrt(n.x * n.x + n.y * n.y)) / this.a), i = Math.sin(t), r = Math.cos(t), a = this.long0, Math.abs(e) <= be ? (o = this.lat0, n.x = a, n.y = o, n) : (o = Ss(r * this.sin_p14 + n.y * i * this.cos_p14 / e), s = Math.abs(this.lat0) - pe, Math.abs(s) <= be ? (a = this.lat0 >= 0 ? we(this.long0 + Math.atan2(n.x, -n.y)) : we(this.long0 - Math.atan2(-n.x, n.y)), n.x = a, n.y = o, n) : (a = we(this.long0 + Math.atan2(n.x * i, e * this.cos_p14 * r - n.y * this.sin_p14 * i)), n.x = a, n.y = o, n));
}, names: ["ortho"] };
var Px = 1, wl = 2, _l = 3, Tl = 4, wf = 5, _f = 6, ot = { AREA_0: 1, AREA_1: 2, AREA_2: 3, AREA_3: 4 };
function au(n, e, t, i) {
  var r;
  return n < be ? (i.value = ot.AREA_0, r = 0) : (r = Math.atan2(e, t), Math.abs(r) <= lt ? i.value = ot.AREA_0 : r > lt && r <= pe + lt ? (i.value = ot.AREA_1, r -= pe) : r > pe + lt || r <= -(pe + lt) ? (i.value = ot.AREA_2, r = r >= 0 ? r - Ft : r + Ft) : (i.value = ot.AREA_3, r += pe)), r;
}
function io(n, e) {
  var t = n + e;
  return t < -Ft ? t += Ph : t > +Ft && (t -= Ph), t;
}
const L2 = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= pe - lt / 2 ? this.face = wf : this.lat0 <= -(pe - lt / 2) ? this.face = _f : Math.abs(this.long0) <= lt ? this.face = Px : Math.abs(this.long0) <= pe + lt ? this.face = this.long0 > 0 ? wl : Tl : this.face = _l, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}, forward: function(n) {
  var e, t, i, r, s, a, o = { x: 0, y: 0 }, l = { value: 0 };
  if (n.x -= this.long0, e = this.es !== 0 ? Math.atan(this.one_minus_f_squared * Math.tan(n.y)) : n.y, t = n.x, this.face === wf)
    r = pe - e, t >= lt && t <= pe + lt ? (l.value = ot.AREA_0, i = t - pe) : t > pe + lt || t <= -(pe + lt) ? (l.value = ot.AREA_1, i = t > 0 ? t - Ft : t + Ft) : t > -(pe + lt) && t <= -lt ? (l.value = ot.AREA_2, i = t + pe) : (l.value = ot.AREA_3, i = t);
  else if (this.face === _f)
    r = pe + e, t >= lt && t <= pe + lt ? (l.value = ot.AREA_0, i = -t + pe) : t < lt && t >= -lt ? (l.value = ot.AREA_1, i = -t) : t < -lt && t >= -(pe + lt) ? (l.value = ot.AREA_2, i = -t - pe) : (l.value = ot.AREA_3, i = t > 0 ? -t + Ft : -t - Ft);
  else {
    var h, c, u, d, p, m;
    this.face === wl ? t = io(t, +pe) : this.face === _l ? t = io(t, +Ft) : this.face === Tl && (t = io(t, -pe)), d = Math.sin(e), p = Math.cos(e), m = Math.sin(t), h = p * Math.cos(t), c = p * m, u = d, this.face === Px ? i = au(r = Math.acos(h), u, c, l) : this.face === wl ? i = au(r = Math.acos(c), u, -h, l) : this.face === _l ? i = au(r = Math.acos(-h), u, -c, l) : this.face === Tl ? i = au(r = Math.acos(-c), u, h, l) : (r = i = 0, l.value = ot.AREA_0);
  }
  return a = Math.atan(12 / Ft * (i + Math.acos(Math.sin(i) * Math.cos(lt)) - pe)), s = Math.sqrt((1 - Math.cos(r)) / (Math.cos(a) * Math.cos(a)) / (1 - Math.cos(Math.atan(1 / Math.cos(i))))), l.value === ot.AREA_1 ? a += pe : l.value === ot.AREA_2 ? a += Ft : l.value === ot.AREA_3 && (a += 1.5 * Ft), o.x = s * Math.cos(a), o.y = s * Math.sin(a), o.x = o.x * this.a + this.x0, o.y = o.y * this.a + this.y0, n.x = o.x, n.y = o.y, n;
}, inverse: function(n) {
  var e, t, i, r, s, a, o, l, h, c, u, d, p = { lam: 0, phi: 0 }, m = { value: 0 };
  if (n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a, t = Math.atan(Math.sqrt(n.x * n.x + n.y * n.y)), e = Math.atan2(n.y, n.x), n.x >= 0 && n.x >= Math.abs(n.y) ? m.value = ot.AREA_0 : n.y >= 0 && n.y >= Math.abs(n.x) ? (m.value = ot.AREA_1, e -= pe) : n.x < 0 && -n.x >= Math.abs(n.y) ? (m.value = ot.AREA_2, e = e < 0 ? e + Ft : e - Ft) : (m.value = ot.AREA_3, e += pe), h = Ft / 12 * Math.tan(e), s = Math.sin(h) / (Math.cos(h) - 1 / Math.sqrt(2)), a = Math.atan(s), (o = 1 - (i = Math.cos(e)) * i * (r = Math.tan(t)) * r * (1 - Math.cos(Math.atan(1 / Math.cos(a))))) < -1 ? o = -1 : o > 1 && (o = 1), this.face === wf)
    l = Math.acos(o), p.phi = pe - l, m.value === ot.AREA_0 ? p.lam = a + pe : m.value === ot.AREA_1 ? p.lam = a < 0 ? a + Ft : a - Ft : m.value === ot.AREA_2 ? p.lam = a - pe : p.lam = a;
  else if (this.face === _f)
    l = Math.acos(o), p.phi = l - pe, m.value === ot.AREA_0 ? p.lam = -a + pe : m.value === ot.AREA_1 ? p.lam = -a : m.value === ot.AREA_2 ? p.lam = -a - pe : p.lam = a < 0 ? -a - Ft : -a + Ft;
  else {
    var g, f, v;
    h = (g = o) * g, f = (h += (v = h >= 1 ? 0 : Math.sqrt(1 - h) * Math.sin(a)) * v) >= 1 ? 0 : Math.sqrt(1 - h), m.value === ot.AREA_1 ? (h = f, f = -v, v = h) : m.value === ot.AREA_2 ? (f = -f, v = -v) : m.value === ot.AREA_3 && (h = f, f = v, v = -h), this.face === wl ? (h = g, g = -f, f = h) : this.face === _l ? (g = -g, f = -f) : this.face === Tl && (h = g, g = f, f = -h), p.phi = Math.acos(-v) - pe, p.lam = Math.atan2(f, g), this.face === wl ? p.lam = io(p.lam, -pe) : this.face === _l ? p.lam = io(p.lam, -Ft) : this.face === Tl && (p.lam = io(p.lam, +pe));
  }
  return this.es !== 0 && (c = p.phi < 0 ? 1 : 0, u = Math.tan(p.phi), d = this.b / Math.sqrt(u * u + this.one_minus_f_squared), p.phi = Math.atan(Math.sqrt(this.a * this.a - d * d) / (this.one_minus_f * d)), c && (p.phi = -p.phi)), p.lam += this.long0, n.x = p.lam, n.y = p.phi, n;
}, names: ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"] };
var Tf = [[1, 22199e-21, -715515e-10, 31103e-10], [0.9986, -482243e-9, -24897e-9, -13309e-10], [0.9954, -83103e-8, -448605e-10, -986701e-12], [0.99, -135364e-8, -59661e-9, 36777e-10], [0.9822, -167442e-8, -449547e-11, -572411e-11], [0.973, -214868e-8, -903571e-10, 18736e-12], [0.96, -305085e-8, -900761e-10, 164917e-11], [0.9427, -382792e-8, -653386e-10, -26154e-10], [0.9216, -467746e-8, -10457e-8, 481243e-11], [0.8962, -536223e-8, -323831e-10, -543432e-11], [0.8679, -609363e-8, -113898e-9, 332484e-11], [0.835, -698325e-8, -640253e-10, 934959e-12], [0.7986, -755338e-8, -500009e-10, 935324e-12], [0.7597, -798324e-8, -35971e-9, -227626e-11], [0.7186, -851367e-8, -701149e-10, -86303e-10], [0.6732, -986209e-8, -199569e-9, 191974e-10], [0.6213, -0.010418, 883923e-10, 624051e-11], [0.5722, -906601e-8, 182e-6, 624051e-11], [0.5322, -677797e-8, 275608e-9, 624051e-11]], El = [[-520417e-23, 0.0124, 121431e-23, -845284e-16], [0.062, 0.0124, -126793e-14, 422642e-15], [0.124, 0.0124, 507171e-14, -160604e-14], [0.186, 0.0123999, -190189e-13, 600152e-14], [0.248, 0.0124002, 710039e-13, -224e-10], [0.31, 0.0123992, -264997e-12, 835986e-13], [0.372, 0.0124029, 988983e-12, -311994e-12], [0.434, 0.0123893, -369093e-11, -435621e-12], [0.4958, 0.0123198, -102252e-10, -345523e-12], [0.5571, 0.0121916, -154081e-10, -582288e-12], [0.6176, 0.0119938, -241424e-10, -525327e-12], [0.6769, 0.011713, -320223e-10, -516405e-12], [0.7346, 0.0113541, -397684e-10, -609052e-12], [0.7903, 0.0109107, -489042e-10, -104739e-11], [0.8435, 0.0103431, -64615e-9, -140374e-14], [0.8936, 969686e-8, -64636e-9, -8547e-9], [0.9394, 840947e-8, -192841e-9, -42106e-10], [0.9761, 616527e-8, -256e-6, -42106e-10], [1, 328947e-8, -319159e-9, -42106e-10]], Rx = 0.8487, Ix = 1.3523, iS = ns / 5, N2 = 1 / iS, Ef = 18, ou = function(n, e) {
  return n[0] + e * (n[1] + e * (n[2] + e * n[3]));
};
const D2 = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}, forward: function(n) {
  var e = we(n.x - this.long0), t = Math.abs(n.y), i = Math.floor(t * iS);
  i < 0 ? i = 0 : i >= Ef && (i = 17);
  var r = { x: ou(Tf[i], t = ns * (t - N2 * i)) * e, y: ou(El[i], t) };
  return n.y < 0 && (r.y = -r.y), r.x = r.x * this.a * Rx + this.x0, r.y = r.y * this.a * Ix + this.y0, r;
}, inverse: function(n) {
  var e = { x: (n.x - this.x0) / (this.a * Rx), y: Math.abs(n.y - this.y0) / (this.a * Ix) };
  if (e.y >= 1)
    e.x /= Tf[18][0], e.y = n.y < 0 ? -pe : pe;
  else {
    var t = Math.floor(e.y * Ef);
    for (t < 0 ? t = 0 : t >= Ef && (t = 17); ; )
      if (El[t][0] > e.y)
        --t;
      else {
        if (!(El[t + 1][0] <= e.y))
          break;
        ++t;
      }
    var i = El[t], r = 5 * (e.y - i[0]) / (El[t + 1][0] - i[0]);
    r = function(s, a, o, l) {
      for (var h = a; l; --l) {
        var c = s(h);
        if (h -= c, Math.abs(c) < o)
          break;
      }
      return h;
    }(function(s) {
      return (ou(i, s) - e.y) / function(a, o) {
        return a[1] + o * (2 * a[2] + 3 * o * a[3]);
      }(i, s);
    }, r, be, 100), e.x /= ou(Tf[t], r), e.y = (5 * t + r) * mn, n.y < 0 && (e.y = -e.y);
  }
  return e.x = we(e.x + this.long0), e;
}, names: ["Robinson", "robin"] }, O2 = { init: function() {
  this.name = "geocent";
}, forward: function(n) {
  return Wb(n, this.es, this.a);
}, inverse: function(n) {
  return Xb(n, this.es, this.a, this.b);
}, names: ["Geocentric", "geocentric", "geocent", "Geocent"] };
var lu = 0, hu = 1, cu = 2, uu = 3, Al = { h: { def: 1e5, num: !0 }, azi: { def: 0, num: !0, degrees: !0 }, tilt: { def: 0, num: !0, degrees: !0 }, long0: { def: 0, num: !0 }, lat0: { def: 0, num: !0 } };
const U2 = { init: function() {
  if (Object.keys(Al).forEach(function(t) {
    if (typeof this[t] == "undefined")
      this[t] = Al[t].def;
    else {
      if (Al[t].num && isNaN(this[t]))
        throw new Error("Invalid parameter value, must be numeric " + t + " = " + this[t]);
      Al[t].num && (this[t] = parseFloat(this[t]));
    }
    Al[t].degrees && (this[t] = this[t] * mn);
  }.bind(this)), Math.abs(Math.abs(this.lat0) - pe) < be ? this.mode = this.lat0 < 0 ? hu : lu : Math.abs(this.lat0) < be ? this.mode = cu : (this.mode = uu, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var n = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(n), this.sw = Math.sin(n);
}, forward: function(n) {
  n.x -= this.long0;
  var e, t, i, r, s = Math.sin(n.y), a = Math.cos(n.y), o = Math.cos(n.x);
  switch (this.mode) {
    case uu:
      t = this.sinph0 * s + this.cosph0 * a * o;
      break;
    case cu:
      t = a * o;
      break;
    case hu:
      t = -s;
      break;
    case lu:
      t = s;
  }
  switch (e = (t = this.pn1 / (this.p - t)) * a * Math.sin(n.x), this.mode) {
    case uu:
      t *= this.cosph0 * s - this.sinph0 * a * o;
      break;
    case cu:
      t *= s;
      break;
    case lu:
      t *= -a * o;
      break;
    case hu:
      t *= a * o;
  }
  return r = 1 / ((i = t * this.cg + e * this.sg) * this.sw * this.h1 + this.cw), e = (e * this.cg - t * this.sg) * this.cw * r, t = i * r, n.x = e * this.a, n.y = t * this.a, n;
}, inverse: function(n) {
  n.x /= this.a, n.y /= this.a;
  var e, t, i, r = { x: n.x, y: n.y };
  i = 1 / (this.pn1 - n.y * this.sw), e = this.pn1 * n.x * i, t = this.pn1 * n.y * this.cw * i, n.x = e * this.cg + t * this.sg, n.y = t * this.cg - e * this.sg;
  var s = mi(n.x, n.y);
  if (Math.abs(s) < be)
    r.x = 0, r.y = n.y;
  else {
    var a, o;
    switch (o = 1 - s * s * this.pfact, o = (this.p - Math.sqrt(o)) / (this.pn1 / s + s / this.pn1), a = Math.sqrt(1 - o * o), this.mode) {
      case uu:
        r.y = Math.asin(a * this.sinph0 + n.y * o * this.cosph0 / s), n.y = (a - this.sinph0 * Math.sin(r.y)) * s, n.x *= o * this.cosph0;
        break;
      case cu:
        r.y = Math.asin(n.y * o / s), n.y = a * s, n.x *= o;
        break;
      case lu:
        r.y = Math.asin(a), n.y = -n.y;
        break;
      case hu:
        r.y = -Math.asin(a);
    }
    r.x = Math.atan2(n.x, n.y);
  }
  return n.x = r.x + this.long0, n.y = r.y, n;
}, names: ["Tilted_Perspective", "tpers"] }, F2 = { init: function() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var n = 1 - this.es, e = 1 / n;
    this.radius_p = Math.sqrt(n), this.radius_p2 = n, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}, forward: function(n) {
  var e, t, i, r, s = n.x, a = n.y;
  if (s -= this.long0, this.shape === "ellipse") {
    a = Math.atan(this.radius_p2 * Math.tan(a));
    var o = this.radius_p / mi(this.radius_p * Math.cos(a), Math.sin(a));
    if (t = o * Math.cos(s) * Math.cos(a), i = o * Math.sin(s) * Math.cos(a), r = o * Math.sin(a), (this.radius_g - t) * t - i * i - r * r * this.radius_p_inv2 < 0)
      return n.x = Number.NaN, n.y = Number.NaN, n;
    e = this.radius_g - t, this.flip_axis ? (n.x = this.radius_g_1 * Math.atan(i / mi(r, e)), n.y = this.radius_g_1 * Math.atan(r / e)) : (n.x = this.radius_g_1 * Math.atan(i / e), n.y = this.radius_g_1 * Math.atan(r / mi(i, e)));
  } else
    this.shape === "sphere" && (e = Math.cos(a), t = Math.cos(s) * e, i = Math.sin(s) * e, r = Math.sin(a), e = this.radius_g - t, this.flip_axis ? (n.x = this.radius_g_1 * Math.atan(i / mi(r, e)), n.y = this.radius_g_1 * Math.atan(r / e)) : (n.x = this.radius_g_1 * Math.atan(i / e), n.y = this.radius_g_1 * Math.atan(r / mi(i, e))));
  return n.x = n.x * this.a, n.y = n.y * this.a, n;
}, inverse: function(n) {
  var e, t, i, r, s = -1, a = 0, o = 0;
  if (n.x = n.x / this.a, n.y = n.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (o = Math.tan(n.y / this.radius_g_1), a = Math.tan(n.x / this.radius_g_1) * mi(1, o)) : (a = Math.tan(n.x / this.radius_g_1), o = Math.tan(n.y / this.radius_g_1) * mi(1, a));
    var l = o / this.radius_p;
    if (e = a * a + l * l + s * s, (i = (t = 2 * this.radius_g * s) * t - 4 * e * this.C) < 0)
      return n.x = Number.NaN, n.y = Number.NaN, n;
    r = (-t - Math.sqrt(i)) / (2 * e), s = this.radius_g + r * s, a *= r, o *= r, n.x = Math.atan2(a, s), n.y = Math.atan(o * Math.cos(n.x) / s), n.y = Math.atan(this.radius_p_inv2 * Math.tan(n.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (o = Math.tan(n.y / this.radius_g_1), a = Math.tan(n.x / this.radius_g_1) * Math.sqrt(1 + o * o)) : (a = Math.tan(n.x / this.radius_g_1), o = Math.tan(n.y / this.radius_g_1) * Math.sqrt(1 + a * a)), e = a * a + o * o + s * s, (i = (t = 2 * this.radius_g * s) * t - 4 * e * this.C) < 0)
      return n.x = Number.NaN, n.y = Number.NaN, n;
    r = (-t - Math.sqrt(i)) / (2 * e), s = this.radius_g + r * s, a *= r, o *= r, n.x = Math.atan2(a, s), n.y = Math.atan(o * Math.cos(n.x) / s);
  }
  return n.x = n.x + this.long0, n;
}, names: ["Geostationary Satellite View", "Geostationary_Satellite", "geos"] };
var Cl = 1.340264, Pl = -0.081106, Rl = 893e-6, Il = 3796e-6, du = Math.sqrt(3) / 2;
const B2 = { init: function() {
  this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}, forward: function(n) {
  var e = we(n.x - this.long0), t = n.y, i = Math.asin(du * Math.sin(t)), r = i * i, s = r * r * r;
  return n.x = e * Math.cos(i) / (du * (Cl + 3 * Pl * r + s * (7 * Rl + 9 * Il * r))), n.y = i * (Cl + Pl * r + s * (Rl + Il * r)), n.x = this.a * n.x + this.x0, n.y = this.a * n.y + this.y0, n;
}, inverse: function(n) {
  n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a;
  var e, t, i, r, s = n.y;
  for (r = 0; r < 12 && (s -= i = (s * (Cl + Pl * (e = s * s) + (t = e * e * e) * (Rl + Il * e)) - n.y) / (Cl + 3 * Pl * e + t * (7 * Rl + 9 * Il * e)), !(Math.abs(i) < 1e-9)); ++r)
    ;
  return t = (e = s * s) * e * e, n.x = du * n.x * (Cl + 3 * Pl * e + t * (7 * Rl + 9 * Il * e)) / Math.cos(s), n.y = Math.asin(Math.sin(s) / du), n.x = we(n.x + this.long0), n;
}, names: ["eqearth", "Equal Earth", "Equal_Earth"] };
Bn.defaultDatum = "WGS84", Bn.Proj = ir, Bn.WGS84 = new Bn.Proj("WGS84"), Bn.Point = Eo, Bn.toPoint = qb, Bn.defs = Rn, Bn.nadgrid = function(n, e) {
  var t = new DataView(e), i = function(o) {
    var l = o.getInt32(8, !1);
    return l === 11 ? !1 : (l = o.getInt32(8, !0), !0);
  }(t), r = function(o, l) {
    return { nFields: o.getInt32(8, l), nSubgridFields: o.getInt32(24, l), nSubgrids: o.getInt32(40, l), shiftType: rg(o, 56, 64).trim(), fromSemiMajorAxis: o.getFloat64(120, l), fromSemiMinorAxis: o.getFloat64(136, l), toSemiMajorAxis: o.getFloat64(152, l), toSemiMinorAxis: o.getFloat64(168, l) };
  }(t, i), s = function(o, l, h) {
    for (var c = 176, u = [], d = 0; d < l.nSubgrids; d++) {
      var p = zA(o, c, h), m = VA(o, c, p, h), g = Math.round(1 + (p.upperLongitude - p.lowerLongitude) / p.longitudeInterval), f = Math.round(1 + (p.upperLatitude - p.lowerLatitude) / p.latitudeInterval);
      u.push({ ll: [mo(p.lowerLongitude), mo(p.lowerLatitude)], del: [mo(p.longitudeInterval), mo(p.latitudeInterval)], lim: [g, f], count: p.gridNodeCount, cvs: kA(m) }), c += 176 + 16 * p.gridNodeCount;
    }
    return u;
  }(t, r, i), a = { header: r, subgrids: s };
  return jb[n] = a, a;
}, Bn.transform = od, Bn.mgrs = jA, Bn.version = "__VERSION__", function(n) {
  n.Proj.projections.add(Fu), n.Proj.projections.add(Bu), n.Proj.projections.add(r2), n.Proj.projections.add(s2), n.Proj.projections.add(a2), n.Proj.projections.add(o2), n.Proj.projections.add(l2), n.Proj.projections.add(h2), n.Proj.projections.add(c2), n.Proj.projections.add(u2), n.Proj.projections.add(y2), n.Proj.projections.add(x2), n.Proj.projections.add(M2), n.Proj.projections.add(b2), n.Proj.projections.add(S2), n.Proj.projections.add(w2), n.Proj.projections.add(_2), n.Proj.projections.add(T2), n.Proj.projections.add(E2), n.Proj.projections.add(A2), n.Proj.projections.add(C2), n.Proj.projections.add(P2), n.Proj.projections.add(R2), n.Proj.projections.add(I2), n.Proj.projections.add(L2), n.Proj.projections.add(D2), n.Proj.projections.add(O2), n.Proj.projections.add(U2), n.Proj.projections.add(F2), n.Proj.projections.add(B2);
}(Bn);
class rS extends Ue {
  constructor(e = document.createElement("div")) {
    super(), this.isCSS2DObject = !0, this.element = e, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.center = new X(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(t) {
        t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element);
      });
    });
  }
  copy(e, t) {
    return super.copy(e, t), this.element = e.element.cloneNode(!0), this.center = e.center, this;
  }
}
const ro = new _(), Lx = new fe(), Nx = new fe(), Dx = new _(), Ox = new _();
class k2 {
  constructor(e = {}) {
    const t = this;
    let i, r, s, a;
    const o = { objects: /* @__PURE__ */ new WeakMap() }, l = e.element !== void 0 ? e.element : document.createElement("div");
    function h(d) {
      d.isCSS2DObject && (d.element.style.display = "none");
      for (let p = 0, m = d.children.length; p < m; p++)
        h(d.children[p]);
    }
    function c(d, p, m) {
      if (d.visible !== !1) {
        if (d.isCSS2DObject) {
          ro.setFromMatrixPosition(d.matrixWorld), ro.applyMatrix4(Nx);
          const g = ro.z >= -1 && ro.z <= 1 && d.layers.test(m.layers) === !0, f = d.element;
          f.style.display = g === !0 ? "" : "none", g === !0 && (d.onBeforeRender(t, p, m), f.style.transform = "translate(" + -100 * d.center.x + "%," + -100 * d.center.y + "%)translate(" + (ro.x * s + s) + "px," + (-ro.y * a + a) + "px)", f.parentNode !== l && l.appendChild(f), d.onAfterRender(t, p, m));
          const v = { distanceToCameraSquared: u(m, d) };
          o.objects.set(d, v);
        }
        for (let g = 0, f = d.children.length; g < f; g++)
          c(d.children[g], p, m);
      } else
        h(d);
    }
    function u(d, p) {
      return Dx.setFromMatrixPosition(d.matrixWorld), Ox.setFromMatrixPosition(p.matrixWorld), Dx.distanceToSquared(Ox);
    }
    l.style.overflow = "hidden", this.domElement = l, this.getSize = function() {
      return { width: i, height: r };
    }, this.render = function(d, p) {
      d.matrixWorldAutoUpdate === !0 && d.updateMatrixWorld(), p.parent === null && p.matrixWorldAutoUpdate === !0 && p.updateMatrixWorld(), Lx.copy(p.matrixWorldInverse), Nx.multiplyMatrices(p.projectionMatrix, Lx), c(d, d, p), function(m) {
        const g = function(v) {
          const y = [];
          return v.traverseVisible(function(x) {
            x.isCSS2DObject && y.push(x);
          }), y;
        }(m).sort(function(v, y) {
          return v.renderOrder !== y.renderOrder ? y.renderOrder - v.renderOrder : o.objects.get(v).distanceToCameraSquared - o.objects.get(y).distanceToCameraSquared;
        }), f = g.length;
        for (let v = 0, y = g.length; v < y; v++)
          g[v].element.style.zIndex = f - v;
      }(d);
    }, this.setSize = function(d, p) {
      i = d, r = p, s = i / 2, a = r / 2, l.style.width = d + "px", l.style.height = p + "px";
    };
  }
}
const Ux = new _(), z2 = new Ye(), Fx = new _();
class sS extends Ue {
  constructor(e = document.createElement("div")) {
    super(), this.isCSS3DObject = !0, this.element = e, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.addEventListener("removed", function() {
      this.traverse(function(t) {
        t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element);
      });
    });
  }
  copy(e, t) {
    return super.copy(e, t), this.element = e.element.cloneNode(!0), this;
  }
}
const Hi = new fe(), V2 = new fe();
class H2 {
  constructor(e = {}) {
    const t = this;
    let i, r, s, a;
    const o = { camera: { style: "" }, objects: /* @__PURE__ */ new WeakMap() }, l = e.element !== void 0 ? e.element : document.createElement("div");
    l.style.overflow = "hidden", this.domElement = l;
    const h = document.createElement("div");
    h.style.transformOrigin = "0 0", h.style.pointerEvents = "none", l.appendChild(h);
    const c = document.createElement("div");
    function u(f) {
      return Math.abs(f) < 1e-10 ? 0 : f;
    }
    function d(f) {
      const v = f.elements;
      return "matrix3d(" + u(v[0]) + "," + u(-v[1]) + "," + u(v[2]) + "," + u(v[3]) + "," + u(v[4]) + "," + u(-v[5]) + "," + u(v[6]) + "," + u(v[7]) + "," + u(v[8]) + "," + u(-v[9]) + "," + u(v[10]) + "," + u(v[11]) + "," + u(v[12]) + "," + u(-v[13]) + "," + u(v[14]) + "," + u(v[15]) + ")";
    }
    function p(f) {
      const v = f.elements;
      return "translate(-50%,-50%)" + ("matrix3d(" + u(v[0]) + "," + u(v[1]) + "," + u(v[2]) + "," + u(v[3]) + "," + u(-v[4]) + "," + u(-v[5]) + "," + u(-v[6]) + "," + u(-v[7]) + "," + u(v[8]) + "," + u(v[9]) + "," + u(v[10]) + "," + u(v[11]) + "," + u(v[12]) + "," + u(v[13]) + "," + u(v[14]) + "," + u(v[15]) + ")");
    }
    function m(f) {
      f.isCSS3DObject && (f.element.style.display = "none");
      for (let v = 0, y = f.children.length; v < y; v++)
        m(f.children[v]);
    }
    function g(f, v, y, x) {
      if (f.visible !== !1) {
        if (f.isCSS3DObject) {
          const M = f.layers.test(y.layers) === !0, b = f.element;
          if (b.style.display = M === !0 ? "" : "none", M === !0) {
            let S;
            f.onBeforeRender(t, v, y), f.isCSS3DSprite ? (Hi.copy(y.matrixWorldInverse), Hi.transpose(), f.rotation2D !== 0 && Hi.multiply(V2.makeRotationZ(f.rotation2D)), f.matrixWorld.decompose(Ux, z2, Fx), Hi.setPosition(Ux), Hi.scale(Fx), Hi.elements[3] = 0, Hi.elements[7] = 0, Hi.elements[11] = 0, Hi.elements[15] = 1, S = p(Hi)) : S = p(f.matrixWorld);
            const w = o.objects.get(f);
            if (w === void 0 || w.style !== S) {
              b.style.transform = S;
              const T = { style: S };
              o.objects.set(f, T);
            }
            b.parentNode !== c && c.appendChild(b), f.onAfterRender(t, v, y);
          }
        }
        for (let M = 0, b = f.children.length; M < b; M++)
          g(f.children[M], v, y);
      } else
        m(f);
    }
    c.style.transformStyle = "preserve-3d", h.appendChild(c), this.getSize = function() {
      return { width: i, height: r };
    }, this.render = function(f, v) {
      const y = v.projectionMatrix.elements[5] * a;
      let x, M;
      v.view && v.view.enabled ? (h.style.transform = `translate( ${-v.view.offsetX * (i / v.view.width)}px, ${-v.view.offsetY * (r / v.view.height)}px )`, h.style.transform += `scale( ${v.view.fullWidth / v.view.width}, ${v.view.fullHeight / v.view.height} )`) : h.style.transform = "", f.matrixWorldAutoUpdate === !0 && f.updateMatrixWorld(), v.parent === null && v.matrixWorldAutoUpdate === !0 && v.updateMatrixWorld(), v.isOrthographicCamera && (x = -(v.right + v.left) / 2, M = (v.top + v.bottom) / 2);
      const b = v.view && v.view.enabled ? v.view.height / v.view.fullHeight : 1, S = v.isOrthographicCamera ? `scale( ${b} )scale(` + y + ")translate(" + u(x) + "px," + u(M) + "px)" + d(v.matrixWorldInverse) : `scale( ${b} )translateZ(` + y + "px)" + d(v.matrixWorldInverse), w = (v.isPerspectiveCamera ? "perspective(" + y + "px) " : "") + S + "translate(" + s + "px," + a + "px)";
      o.camera.style !== w && (c.style.transform = w, o.camera.style = w), g(f, f, v);
    }, this.setSize = function(f, v) {
      i = f, r = v, s = i / 2, a = r / 2, l.style.width = f + "px", l.style.height = v + "px", h.style.width = f + "px", h.style.height = v + "px", c.style.width = f + "px", c.style.height = v + "px";
    };
  }
}
function R3(n, e, t = 0.9) {
  const i = n.distanceTo(e);
  return new _().subVectors(e, n).normalize().multiplyScalar(i * t).add(n);
}
function I3(n, e) {
  return n.multiply(e.scale), n.applyEuler(e.rotation), n.add(e.position), n;
}
function L3(n, e) {
  const t = new _();
  t.subVectors(e, n).normalize();
  const i = new Ye();
  i.setFromUnitVectors(new _(0, 1, 0), t);
  const r = new gt();
  return r.setFromQuaternion(i), { quaternion: i, euler: r };
}
function Bx(n) {
  for (; n != null && n.parent && n.parent.type !== "Scene"; )
    n = n.parent;
  return n;
}
function Jo(n) {
  if (n)
    return n.type === "Scene" ? n : Jo(n.parent);
}
function G2(n) {
  const e = new yt().setFromObject(n), { max: t, min: i } = e, r = new _();
  return e.getCenter(r), { box: e, max: t, min: i, center: r, radius: new _().subVectors(t, i).length() / 2 };
}
function j2(n, e = 50) {
  const { center: t, radius: i, max: r } = G2(n), s = n.getWorldDirection(new _()), a = i / Math.tan(Math.PI * e / 360), o = s.multiplyScalar(a), l = o.clone().add(t), h = o.clone().applyAxisAngle(new _(0, 1, 0), -Math.PI / 2).add(t), c = o.clone().applyAxisAngle(new _(0, 1, 0), Math.PI / 2).add(t), u = o.clone().applyAxisAngle(new _(1, 0, 0), -Math.PI / 2).add(t), d = o.clone().applyAxisAngle(new _(1, 0, 0), Math.PI / 2).add(t), p = o.clone().applyAxisAngle(new _(0, 1, 0), Math.PI).add(t), m = function(g, f, v) {
    return new _().subVectors(f, g).normalize().multiplyScalar(v).add(g);
  }(t, r, t.distanceTo(r) / Math.tan(Math.PI * e / 360));
  return { frontView: l, leftView: h, rightView: c, topView: u, bottomView: d, backView: p, maxView: m, target: t };
}
const W2 = ["立方体", "球体", "平面", "胶囊", "圆锥", "圆面", "圆柱", "圆环", "环面"];
function Jd(n, e = {}) {
  let t = null;
  switch (n) {
    case "立方体":
    default:
      t = X2(e);
      break;
    case "球体":
      t = function(i = {}) {
        return new Ea(i.radius || 5, i.widthSegments || 32, i.heightSegments || 32);
      }(e);
      break;
    case "平面":
      t = function(i = {}) {
        return new or(i.width || 5, i.height || 5, i.widthSegments || 32, i.heightSegments || 32);
      }(e);
      break;
    case "胶囊":
      t = function(i = {}) {
        return new Yh(i.radius || 5, i.length || 5, i.capSegments || 32, i.radialSegments || 32);
      }(e);
      break;
    case "圆锥":
      t = function(i = {}) {
        return new Kh(i.radius || 5, i.height || 5, i.radialSegments || 32);
      }(e);
      break;
    case "圆面":
      t = function(i = {}) {
        return new Zh(i.radius || 5, i.segments || 32, i.thetaStart || 0, i.thetaLength || 2 * Math.PI);
      }(e);
      break;
    case "圆柱":
      t = function(i = {}) {
        return new Pt(i.radiusTop || 5, i.radiusBottom || 5, i.height || 5, i.radialSegments || 32);
      }(e);
      break;
    case "圆环":
      t = function(i = {}) {
        return new Ki(i.radius || 10, i.tube || 3, i.radialSegments || 32, i.tubularSegments || 32, i.arc || 2 * Math.PI);
      }(e);
      break;
    case "环面":
      t = function(i = {}) {
        return new Jh(i.innerRadius || 5, i.outerRadius || 10, i.thetaSegments || 32, i.phiSegments || 32, i.thetaStart || 0, i.thetaLength || 2 * Math.PI);
      }(e);
  }
  return t.geometryType = n, t;
}
function X2(n = {}) {
  return new _t(n.width || 5, n.height || 5, n.depth || 5, n.widthSegments || 1, n.heightSegments || 1, n.depthSegments || 1);
}
const Co = ["基础材质", "标准材质", "镜面高光材质", "Lambert材质", "物理材质", "卡通材质"];
function xi(n, e = null) {
  let t = null;
  switch (n) {
    case "基础材质":
    case "MeshBasicMaterial":
    default:
      t = q2(e);
      break;
    case "标准材质":
    case "MeshStandardMaterial":
      t = function(i) {
        return new jo(Te({ color: 16777215, side: bt }, i));
      }(e);
      break;
    case "镜面高光材质":
    case "MeshPhongMaterial":
      t = function(i) {
        return new Aa(Te({ color: 16777215, side: bt }, i));
      }(e);
      break;
    case "Lambert材质":
    case "MeshLambertMaterial":
      t = function(i) {
        return new Xd(Te({ color: 16777215, side: bt }, i));
      }(e);
      break;
    case "物理材质":
    case "MeshPhysicalMaterial":
      t = function(i) {
        return new ai(Te({ color: 16777215, side: bt }, i));
      }(e);
      break;
    case "卡通材质":
    case "MeshToonMaterial":
      t = function(i) {
        return new kg(Te({ color: 16777215, side: bt }, i));
      }(e);
  }
  return t.materialType = n || "基础材质", t.transparent = !0, t;
}
function q2(n) {
  return new Wt(Te({ color: 16777215, side: bt }, n));
}
function aS(n) {
  const e = document.createElement("video");
  return e.crossOrigin = "anonymous", e.src = n, e.muted = !0, e.loop = !0, e.play(), new lM(e);
}
function Y2(n) {
  const { mapType: e, mapUrl: t, map: i } = n;
  if (t && i)
    return { mapType: e, mapUrl: t, map: { wrapS: i.wrapS, wrapT: i.wrapT, rotation: i.rotation, center: i.center, repeat: i.repeat, offset: i.offset, textureAnimation: i.textureAnimation } };
}
function oS(n, e, t) {
  var i;
  if (!e.mapUrl)
    return e.map = null;
  e.mapType == "视频" ? e.map = aS(e.mapUrl) : e.map = new Ui().load(e.mapUrl), t && (e.map.wrapS = t.wrapS, e.map.wrapT = t.wrapT, e.map.repeat.set(t.repeat.x, t.repeat.y), e.map.offset.set(t.offset.x, t.offset.y), e.map.center.set(t.center.x, t.center.y), e.map.rotation = t.rotation, (i = t.textureAnimation) != null && i.isTextureAnimation && (e.map.textureAnimation = t.textureAnimation, e.map.commonAnimateRender = function() {
    e.map.offset.x += t.textureAnimation.offset.x, e.map.offset.y += t.textureAnimation.offset.y, e.map.rotation += t.textureAnimation.rotation;
  }, n.push(e.map))), e.map.center.set(0.5, 0.5), e.isCustomTexture = !0, e.needsUpdate = !0;
}
const m0 = { 无混合: 0, 正常混合: 1, 叠加混合: Ar, 减去混合: 3, 乘法混合: 4, 自定义混合: Ro }, Z2 = { 加法: $n, 减法: 101, 反向减法: 102, 最小值: 103, 最大值: 104 }, K2 = { 零: Io, 一: kh, 源颜色: xd, "1-源颜色": Md, 源透明度: us, "1-源透明度": ds, 目标透明度: zh, "1-目标透明度": bd, 目标颜色: Vh, "1-目标颜色": Sd, 源透明饱和: 210 }, J2 = { 零: Io, 一: kh, 源颜色: xd, "1-源颜色": Md, 源透明度: us, "1-源透明度": ds, 目标透明度: zh, "1-目标透明度": bd, 目标颜色: Vh, "1-目标颜色": Sd }, Q2 = { 正面: Mi, 背面: Tn, 双面: bt };
function $2(n) {
  const { visible: e, color: t, wireframe: i, transparent: r, opacity: s, alphaTest: a, blending: o, side: l } = n;
  return Te({ visible: e, color: t, wireframe: i, transparent: r, opacity: s, alphaTest: a, blending: o, side: l }, Y2(n));
}
function eC(n, e, t) {
  t.add(e, "visible").name("显示"), t.addHexColor(e.color).name("颜色"), t.add(e, "wireframe").name("线框模式"), t.add(e, "side", Q2).name("面类型").onFinishChange((i) => (e.side = Number(i), e.needsUpdate = !0)), t.add(e, "transparent").name("透明"), t.add(e, "opacity", 0, 1).name("透明度"), t.add(e, "alphaTest", 0, 1).name("剔除阈值"), t.add(e, "blending", m0).name("混合模式").onChange((i) => (e.blending = Number(i), e.needsUpdate = !0)), function(i, r, s) {
    !Reflect.has(r, "mapUrl") && (r.mapUrl = ""), s.add(r, "mapUrl").name("贴图"), !Reflect.has(r, "mapType") && (r.mapType = "图片"), s.add(r, "mapType", ["图片", "视频"]).name("贴图类型"), s.add({ updateMap: () => oS(i, r) }, "updateMap").name("更新贴图");
  }(n, e, t.addFolder("贴图"));
}
function tC(n) {
  switch (n.type) {
    case "MeshBasicMaterial":
      return { envMap: !!n.envMap, reflectivity: n.reflectivity };
    case "MeshStandardMaterial":
      return { emissive: n.emissive.getHex(), emissiveIntensity: n.emissiveIntensity, metalness: n.metalness, roughness: n.roughness, envMap: !!n.envMap, envMapIntensity: n.envMapIntensity };
    case "MeshLambertMaterial":
      return { emissive: n.emissive.getHex(), emissiveIntensity: n.emissiveIntensity, envMap: !!n.envMap, reflectivity: n.reflectivity };
    case "MeshPhongMaterial":
      return { shininess: n.shininess, specular: n.specular.getHex(), emissive: n.emissive.getHex(), emissiveIntensity: n.emissiveIntensity, envMap: !!n.envMap, reflectivity: n.reflectivity };
    case "MeshToonMaterial":
      return { emissive: n.emissive.getHex(), emissiveIntensity: n.emissiveIntensity };
    case "MeshPhysicalMaterial":
      return { metalness: n.metalness, roughness: n.roughness, clearcoat: n.clearcoat, clearcoatRoughness: n.clearcoatRoughness, sheen: n.sheen, sheenRoughness: n.sheenRoughness, sheenColor: n.sheenColor.getHex(), specularColor: n.specularColor.getHex(), specularIntensity: n.specularIntensity, transmission: n.transmission, emissive: n.emissive.getHex(), emissiveIntensity: n.emissiveIntensity, envMap: !!n.envMap, envMapIntensity: n.envMapIntensity, reflectivity: n.reflectivity };
  }
}
function Qd(n) {
  return Te(Te({ materialType: n.materialType }, $2(n)), tC(n));
}
function $d(n, e, t) {
  t && (function(i, r, s) {
    const { visible: a, color: o, wireframe: l, side: h, transparent: c, opacity: u, alphaTest: d, blending: p, map: m, mapUrl: g, mapType: f } = s;
    r.visible = a, r.color.setHex(o), r.wireframe = l, r.transparent = c, r.opacity = u, r.alphaTest = d, r.blending = p, r.side = h != null ? h : bt, g && (r.mapUrl = g, r.mapType = f, oS(i, r, m));
  }(n.commonFrames, e, t), function(i, r, s) {
    switch (r.type) {
      case "MeshBasicMaterial":
        s.envMap && (r.envMap = i.envBackground, i.envMapChangeUseList.push(() => r.envMap = i.envBackground)), r.reflectivity = s.reflectivity;
        break;
      case "MeshStandardMaterial":
        r.emissive.setHex(s.emissive), r.emissiveIntensity = s.emissiveIntensity, s.envMap && (r.envMap = i.envBackground, i.envMapChangeUseList.push(() => r.envMap = i.envBackground)), r.envMapIntensity = s.envMapIntensity, r.metalness = s.metalness, r.roughness = s.roughness;
        break;
      case "MeshLambertMaterial":
        r.emissive.setHex(s.emissive), r.emissiveIntensity = s.emissiveIntensity, s.envMap && (r.envMap = i.envBackground, i.envMapChangeUseList.push(() => r.envMap = i.envBackground)), r.reflectivity = s.reflectivity;
        break;
      case "MeshPhongMaterial":
        r.shininess = s.shininess, r.specular.setHex(s.specular), r.emissive.setHex(s.emissive), r.emissiveIntensity = s.emissiveIntensity, s.envMap && (r.envMap = i.envBackground, i.envMapChangeUseList.push(() => r.envMap = i.envBackground)), r.reflectivity = s.reflectivity;
        break;
      case "MeshToonMaterial":
        r.emissive.setHex(s.emissive), r.emissiveIntensity = s.emissiveIntensity;
        break;
      case "MeshPhysicalMaterial":
        r.metalness = s.metalness, r.roughness = s.roughness, r.clearcoat = s.clearcoat, r.clearcoatRoughness = s.clearcoatRoughness, r.sheen = s.sheen, r.sheenRoughness = s.sheenRoughness, r.sheenColor.setHex(s.sheenColor), r.specularColor.setHex(s.specularColor), r.specularIntensity = s.specularIntensity, r.transmission = s.transmission, r.emissive.setHex(s.emissive), r.emissiveIntensity = s.emissiveIntensity, s.envMap && (r.envMap = i.envBackground, i.envMapChangeUseList.push(() => r.envMap = i.envBackground)), r.envMapIntensity = s.envMapIntensity, r.reflectivity = s.reflectivity;
    }
  }(n, e, t));
}
function ep(n, e, t) {
  eC(n.commonFrames, e, t), function(i, r, s) {
    switch (r.type) {
      case "MeshBasicMaterial":
        s.add({ isEnvMap: !!r.envMap }, "isEnvMap").name("环境贴图").onChange((a) => r.envMap = a ? i.envBackground : null), s.add(r, "reflectivity", 0, 1).name("反射率");
        break;
      case "MeshStandardMaterial":
        s.addHexColor(r.emissive).name("自发光颜色"), s.add(r, "emissiveIntensity", 0).name("自发光强度"), s.add(r, "metalness", 0, 1).name("金属度"), s.add(r, "roughness", 0, 1).name("粗糙度"), s.add({ isEnvMap: !!r.envMap }, "isEnvMap").name("环境贴图").onChange((a) => r.envMap = a ? i.envBackground : null), s.add(r, "envMapIntensity", 0).name("环境贴图强度");
        break;
      case "MeshLambertMaterial":
        s.addHexColor(r.emissive).name("自发光颜色"), s.add(r, "emissiveIntensity", 0).name("自发光强度"), s.add({ isEnvMap: !!r.envMap }, "isEnvMap").name("环境贴图").onChange((a) => r.envMap = a ? i.envBackground : null), s.add(r, "reflectivity", 0, 1).name("反射率");
        break;
      case "MeshPhongMaterial":
        s.add(r, "shininess", 0, 100).name("高光亮度").onChange((a) => r.needsUpdate = !0), s.addHexColor(r.specular).name("高光颜色"), s.addHexColor(r.emissive).name("自发光颜色"), s.add(r, "emissiveIntensity", 0).name("自发光强度"), s.add({ isEnvMap: !!r.envMap }, "isEnvMap").name("环境贴图").onChange((a) => r.envMap = a ? i.envBackground : null), s.add(r, "reflectivity", 0, 1).name("反射率");
        break;
      case "MeshToonMaterial":
        s.addHexColor(r.emissive).name("自发光颜色"), s.add(r, "emissiveIntensity", 0).name("自发光强度");
        break;
      case "MeshPhysicalMaterial":
        s.add(r, "metalness", 0, 1).name("金属度"), s.add(r, "roughness", 0, 1).name("粗糙度"), s.add(r, "clearcoat", 0, 1).name("清漆层"), s.add(r, "clearcoatRoughness", 0, 1).name("清漆层粗糙度"), s.add(r, "sheen", 0, 1).name("光泽度"), s.add(r, "sheenRoughness", 0, 1).name("光泽粗糙度"), s.addHexColor(r.sheenColor).name("光泽颜色"), s.addHexColor(r.specularColor).name("高光颜色"), s.add(r, "specularIntensity", 0, 1).name("高光强度"), s.add(r, "transmission", 0, 1).name("透射率"), s.addHexColor(r.emissive).name("自发光颜色"), s.add(r, "emissiveIntensity", 0).name("自发光强度"), s.add({ isEnvMap: !!r.envMap }, "isEnvMap").name("环境贴图").onChange((a) => r.envMap = a ? i.envBackground : null), s.add(r, "envMapIntensity", 0).name("环境贴图强度"), s.add(r, "reflectivity", 0, 1).name("反射率");
    }
  }(n, e, t.addFolder(e.materialType + "配置"));
}
const lS = { material: "vUv = uv;", position: "vUv = position.xy/ position.z;", modelMatrix: "vUv = (modelMatrix * vec4(position, 1.0)).xy;", modelViewMatrix: "vUv = (modelViewMatrix * vec4(position, 1.0)).xy;", projectionMatrix: "vUv = (projectionMatrix * vec4(position, 1.0)).xy;", viewMatrix: "vUv = (viewMatrix * vec4(position, 1.0)).xy;", custom_uv1: `
    
        vec4 projectedPosition = projectionMatrix * modelMatrix  * vec4(position, 1.0);

        vec3 ndcPosition = projectedPosition.xyz / projectedPosition.w;

        vUv = ndcPosition.xy / ndcPosition.z;
    ` }, nC = Object.keys(lS), hS = [{ name: "彩虹光", commonUniforms: !0, vertex: "vUv-material", fragment: `
            vec3 c;
            float l,z=iTime;
            for(int i=0;i<3;i++) {
                vec2 uv,p=gl_FragCoord.xy/iResolution/2.0;
                uv=p;
                p-=.3;
                <UV_PLACEHOLDER>
                z+=.07;
                l=length(p);
                uv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z-z));
                c[i]=.01/length(mod(uv,1.)-.5);
            }
        `, commonFinish: !0, key: "c", isParticle: !0, render: "iTime+speed" }, { name: "水波纹", commonUniforms: !0, customUniforms: ["TAU-number-float-6.28318530718", "MAX_ITER-number-int-5"], vertex: "vUv-material", fragment: `
            float time = iTime * .5+23.0;
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            <UV_PLACEHOLDER>
            #ifdef SHOW_TILING
                vec2 p = mod(uv*TAU*2.0, TAU)-250.0;
            #else
                vec2 p = mod(uv*TAU, TAU)-250.0;
            #endif
            vec2 i = vec2(p);
            float c = 1.0;
            float inten = .005;
            for (int n = 0; n < MAX_ITER; n++) 
            {
                float t = time * (1.0 - (3.5 / float(n+1)));
                i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
                c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));
            }
            c /= float(MAX_ITER);
            c = 1.17-pow(c, 1.4);
            vec3 colour = vec3(pow(abs(c), 8.0));
            colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);
            #ifdef SHOW_TILING
            // Flash tile borders...
            vec2 pixel = 2.0 / iResolution.xy;
            uv *= 2.0;
            float f = floor(mod(iTime*.5, 2.0)); 	// Flash value.
            vec2 first = step(pixel, uv) * f;		   	// Rule out first screen pixels and flash.
            uv  = step(fract(uv), pixel);				// Add one line of pixels per tile.
            colour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line
            #endif
        `, commonFinish: !0, key: "colour", isParticle: !0, render: "iTime+speed" }, { name: "光圈扫射", commonUniforms: !1, customUniforms: ["innerCircleWidth-number-float-1", "circleWidth-number-float-2", "circleMax-number-float-2", "opacityScale-number-float-1", "reverseOpacity-bool-bool-true", "circleSpeed-number-float-0.01", "diff-color-vec3-0.0,0.0,1.0", "color3-color-vec3-0.0,0.0,1.0", "center-position-vec3-0,0,0", "intensity-number-float-1", "isDisCard-bool-bool-false"], vertex: "vUv-material,vPosition", fragment: `
            float dis = length(vPosition - center);
            vec4 diffuseColor;
            if(dis < (innerCircleWidth + circleWidth) && dis > innerCircleWidth) {
                float r = (dis - innerCircleWidth) / circleWidth;
                float cOpacity = reverseOpacity ? (innerCircleWidth / circleMax) : 1. - ( innerCircleWidth / circleMax );
                #ifdef USE_MAP
                    vec3 textureColor = texture2D(map, vUv).rgb;
                    if(isDisCard && textureColor.r < 0.1 && textureColor.g < 0.1  && textureColor.b < 0.1 ) discard;
                #endif
                diffuseColor = vec4( mix(diff, color3, r) * vec3(intensity, intensity, intensity)  , opacity * cOpacity * opacityScale);
            }
            else {
                if(isDisCard)  discard ;
                else diffuseColor = vec4( diffuse, opacity );
            }
        `, commonFinish: !1, render: "this.innerCircleWidth.value < this.circleMax.value ? this.innerCircleWidth.value += this.circleSpeed.value : this.innerCircleWidth.value = 0" }, { name: "晶片着色", commonUniforms: !0, vertex: "vUv-material", key: "col", fragment: `
            float gTime = 0.;
            const float REPEAT = 5.0;
            mat2 rot(float a) {
                float c = cos(a), s = sin(a);
                return mat2(c,s,-s,c);
            }
            float sdBox( vec3 p, vec3 b )
            {
                vec3 q = abs(p) - b;
                return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
            }
            float box(vec3 pos, float scale) {
                pos *= scale;
                float base = sdBox(pos, vec3(.4,.4,.1)) /1.5;
                pos.xy *= 5.;
                pos.y -= 3.5;
                pos.xy *= rot(.75);
                float result = -base;
                return result;
            }
            float box_set(vec3 pos, float iTime) {
                vec3 pos_origin = pos;
                pos = pos_origin;
                pos .y += sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);
                pos = pos_origin;
                pos .y -=sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);
                pos = pos_origin;
                pos .x +=sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);	
                pos = pos_origin;
                pos .x -=sin(gTime * 0.4) * 2.5;
                pos.xy *=   rot(.8);
                float box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);	
                pos = pos_origin;
                pos.xy *=   rot(.8);
                float box5 = box(pos,.5) * 6.;	
                pos = pos_origin;
                float box6 = box(pos,.5) * 6.;	
                float result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);
                return result;
            }
            float mapf(vec3 pos, float iTime) {
                vec3 pos_origin = pos;
                float box_set1 = box_set(pos, iTime);

                return box_set1;
            }
            <SPLIT_PLACEHOLDER>
            vec2 p = gl_FragCoord.xy / iResolution.xy;
            p.x -=.5;
            p.y -=.5;
            p.x *= iResolution.x / iResolution.y;
            vec2 uv = p;
            <UV_PLACEHOLDER>
            p = uv;
            vec3 ro = vec3(0., -0.2 ,iTime * 4.);
            vec3 ray = normalize(vec3(p, 1.5));
            ray.xy = ray.xy * rot(sin(iTime * .03) * 5.);
            ray.yz = ray.yz * rot(sin(iTime * .05) * .2);
            float t = 0.1;
            vec3 col = vec3(0.);
            float ac = 0.0;
            for (int i = 0; i < 99; i++){
                vec3 pos = ro + ray * t;
                pos = mod(pos-2., 4.) -2.;
                gTime = iTime -float(i) * 0.01;
                
                float d = mapf(pos, iTime);

                d = max(abs(d), 0.01);
                ac += exp(-d*23.);

                t += d* 0.55;
            }
            col = vec3(ac * 0.02);
            col +=vec3(0.,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);  
        `, commonFinish: !0, isParticle: !0, render: "iTime+speed" }, { name: "流光围栏", commonUniforms: !1, customUniforms: ["iTime-number-float-0.0", "speed-number-float-0.05", "intensity-number-float-2", "density-number-float-5", "mixColor-color-vec3-1.0,1.0,1.0", "high-number-float-0.5", "medium-number-float-0.4"], vertex: "vUv-material", fragment: `
            vec4 fragColor = vec4(0.);
            float sin = sin((vUv.y - iTime * speed) * 10. * density);
            if (sin > high) {
            fragColor = vec4( mixColor, (1. - sin) / (1. - high));
            } else if(sin > medium) {
            fragColor = vec4(mixColor, mix(1., 0., 1.-(sin - medium) / (high - medium)));
            } else {
            fragColor = vec4(mixColor, 0.);
            }
            fragColor = mix(fragColor, vec4(mix(mixColor, vec3(0., 0., 0.), vUv.y), 1.), 0.);
            vec4 diffuseColor = vec4(fragColor.rgb * vec3(intensity, intensity, intensity), fragColor.a * opacity * (1. - vUv.y));
        `, commonFinish: !1, render: "iTime+speed" }, { name: "雪片着色", commonUniforms: !0, customUniforms: !1, vertex: "precision-lowp,vUv-material", fragment: `
            mat2 rot(float a) {
                float c = cos(a), s = sin(a);
                return mat2(c,s,-s,c);
            }
            const float pi = acos(-1.0);
            const float pi2 = pi*2.0;
            vec2 pmod(vec2 p, float r) {
                float a = atan(p.x, p.y) + pi/r;
                float n = pi2 / r;
                a = floor(a/n)*n;
                return p*rot(-a);
            }
            float box( vec3 p, vec3 b ) {
                vec3 d = abs(p) - b;
                return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
            }
            float ifsBox(vec3 p) {
                for (int i=0; i<5; i++) {
                    p = abs(p) - 1.0;
                    p.xy *= rot(iTime*0.3);
                    p.xz *= rot(iTime*0.1);
                }
                p.xz *= rot(iTime);
                return box(p, vec3(0.4,0.8,0.3));
            }
            float mapSnow(vec3 p, vec3 cPos) {
                vec3 p1 = p;
                p1.x = mod(p1.x-5., 10.) - 5.;
                p1.y = mod(p1.y-5., 10.) - 5.;
                p1.z = mod(p1.z, 16.)-8.;
                p1.xy = pmod(p1.xy, 5.0);
                return ifsBox(p1);
            }  
            <SPLIT_PLACEHOLDER>
            vec2 p = (gl_FragCoord.xy * 2.0  - iResolution.xy) / min(iResolution.x, iResolution.y);
            vec2 uv = p;
            <UV_PLACEHOLDER>
            p = uv;
            vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);
            vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));
            vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);
            vec3 cSide = cross(cDir, cUp);
            vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);
            float acc = 0.0;
            float acc2 = 0.0;
            float t = 0.0;
            for (int i = 0; i < 99; i++) {
                vec3 pos = cPos + ray * t;
                float dist = mapSnow(pos, cPos);
                dist = max(abs(dist), 0.02);
                float a = exp(-dist*3.0);
                if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {
                    a *= 2.0;
                    acc2 += a;
                }
                acc += a;
                t += dist * 0.5;
            }
            vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.002, acc * 0.012+ acc2*0.005);
        `, commonFinish: !0, key: "col", isParticle: !0, render: "iTime+speed" }, { name: "光线叠加", commonUniforms: !0, customUniforms: !1, vertex: "vUv-material", fragment: `
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            vec3 wave_color = vec3(0.0);
            float wave_width = 0.0;
            uv  = -3.0 + 2.0 * uv;
            uv.y += 0.0;
            <UV_PLACEHOLDER>
            for(float i = 0.0; i <= 28.0; i++) {
                uv.y += (0.2+(0.9*sin(iTime*0.4) * sin(uv.x + i/3.0 + 3.0 *iTime )));
                uv.x += 1.7* sin(iTime*0.4);
                wave_width = abs(1.0 / (200.0*abs(cos(iTime)) * uv.y));
                wave_color += vec3(wave_width *( 0.4+((i+1.0)/18.0)), wave_width * (i / 9.0), wave_width * ((i+1.0)/ 8.0) * 1.9);
        }`, commonFinish: !0, key: "wave_color", isParticle: !0, render: "iTime+speed" }, { name: "绚烂线条", commonUniforms: !0, customUniforms: !1, vertex: "vUv-material", fragment: `
            vec3 hsv2rgb( vec3 c ){
                vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                        6.0)-3.0)-1.0,
                                0.0,
                                1.0 );
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * mix(vec3(1.0), rgb, c.y);
            }
            float rands(vec2 v){
                v = fract(v * vec2(70.26593, 1.6682));
                v += dot(v, v+23.45);
                return fract(v.x*v.y);
            }
            vec2 rand_2(vec2 v){
                float n = rands(v);
                return vec2(n, rands(v + n));
            }
            float dist_line(vec2 which, vec2 p1, vec2 p2){
                float r = clamp(dot(which - p1, p2 - p1) / dot(p2 - p1, p2 - p1), .0, 1.);
                return length((which - p1)-(p2 - p1)*r);
            }
            float drawline(vec2 which, vec2 p1, vec2 p2, float w){
                float dis = dist_line(which, p1, p2);
                return smoothstep(.015*w, .005*w, dis)*smoothstep(.8, .0, distance(p1, p2)-.25);
            }
            vec2 Getpos(vec2 v){
                vec2 p = rand_2(v);
                return vec2(.5)+.4*vec2(cos(p.x*(iTime+5.)), sin(p.y*(iTime+5.)));
            }
            vec3 layer(vec2 uv, float w){
                float m=.0;
                vec2 fl_uv = floor(uv);
                vec2 fr_uv = fract(uv);
                vec2 id = Getpos(fl_uv);
                m = smoothstep(.08*w, .01*w, distance(fr_uv, id))*abs(sin((iTime+id.x)*4.));
                vec2 p[9];
                int num = 0;
                for(float i=-1.; i<=1.; i++){
                    for(float j=-1.; j<=1.; j++){
                        p[num++] = vec2(i,j)+Getpos(fl_uv + vec2(i,j));
                    }
                }
                for(int i=0; i<9; i++){
                m += drawline(fr_uv, p[4], p[i], w);
                }
                m += drawline(fr_uv, p[1], p[3], w);
                m += drawline(fr_uv, p[1], p[5], w);
                m += drawline(fr_uv, p[3], p[7], w);
                m += drawline(fr_uv, p[5], p[7], w);
                return vec3(m);
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            <UV_PLACEHOLDER>
            float yy = uv.y;
            uv -= .5;
            uv.x *= iResolution.x / iResolution.y;
            uv *= .5;
            float t = iTime*.1;
            float rs = sin(2.*t);
            float rc = cos(2.*t);
            uv *= mat2(rc, -rs, rs, rc);
            float m = .0;
            vec3 v3 = vec3(1.);
            vec2 fl_uv = floor(uv);
            vec2 fr_uv = fract(uv);
            
            vec2 id = Getpos(fl_uv);
            vec3 col = vec3(.0);
            
            for(float i=.0; i<1.; i+=1./8.){
                float z = fract(i+t);
                float size = mix(10., .5, z);
                float al = smoothstep(.0, .8, z) * smoothstep(1., .8, z);
                v3 = 0.5 + 0.5*cos(-1.2*z+iTime+uv.xyx+vec3(0,2,4));
            col += layer(uv*size + i*27.385, 1.)*al*v3;
            col += layer(uv*size + i*27.385, .4)*pow(al, 2.);
            }
            //col *= smoothstep(1., .7, yy)*smoothstep(.0, .3, yy);
            v3 = 0.5 + 0.5*cos(iTime-1.2+uv.xyx+vec3(0,2,4));
            col += vec3(.8*yy)*.3*v3;
            col += vec3(.2*(1.-yy))*.3*v3;
        `, commonFinish: !0, key: "col", isParticle: !0, render: "iTime+speed" }], cS = [{ name: "流光闪电", commonUniforms: !0, vertex: "vUv-material", fragment: `
            float hash11(float p)
            {
                p = fract(p * .1031);
                p *= p + 33.33;
                p *= p + p;
                return fract(p);
            }
            float hash12(vec2 p)
            {
                vec3 p3 = fract(vec3(p.xyx) * .1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.x + p3.y) * p3.z);
            }
            mat2 rotate2d(float theta)
            {
                float c = cos(theta);
                float s = sin(theta);
                return mat2(
                    c, -s,
                    s, c
                );
            }
            float noise(vec2 p)
            {
                vec2 ip = floor(p);
                vec2 fp = fract(p);
                float a = hash12(ip);
                float b = hash12(ip + vec2(1, 0));
                float c = hash12(ip + vec2(0, 1));
                float d = hash12(ip + vec2(1, 1));
                
                vec2 t = smoothstep(0.0, 1.0, fp);
                return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);
            }
            float fbm(vec2 p)
            {
                float value = 0.0;
                float amplitude = 0.5;
                for (int i = 0; i < 8; ++i)
                {
                    value += amplitude * noise(p);
                    p *= rotate2d(0.45);
                    p *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = gl_FragCoord.xy / iResolution.xy; 
            <UV_PLACEHOLDER>
            uv = 2.0 * uv - 1.0;
            uv.x *= iResolution.x / iResolution.y;
            uv += 2.0 * fbm(uv+0.8*iTime) - 1.0;
            float dist = abs(uv.x);
            vec3 col = vec3(0.2, 0.3, 0.8) * pow(mix(0.0, 0.07, hash11(iTime)) / dist, 1.0);
            col = pow(col, vec3(1.0));  
        `, commonFinish: !0, key: "col", isParticle: !0, render: "iTime+speed" }, { name: "火焰燃烧", commonUniforms: !0, customUniforms: ["isDiscard-bool-bool-false"], vertex: "vUv-material", fragment: `
            const vec3 c = vec3(1, 0, -1);
            const mat2 m = .4 * mat2(4, 3, -3, 4);
            float hash12(vec2 p)
            {
                vec3 p3  = fract(vec3(p.xyx) * .1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract(dot(p3.xy, p3.zz));
            }
            float lfnoise(vec2 t)
            {
                vec2 i = floor(t);
                t = c.xx * smoothstep(0., 1., fract(t));
                vec2 v1 = 2. * mix(vec2(hash12(i), hash12(i + c.xy)), vec2(hash12(i + c.yx), hash12(i + c.xx)), t.y) - 1.;
                return mix(v1.x, v1.y, t.x);
            }
            float fbm(vec2 uv)
            {
                vec2 uv0 = uv;
                uv = uv * vec2(5., 2.) - vec2(-2., -.25) - 3.1 * iTime * c.yx;
                float f = 1.,
                    a = .5,
                    c = 2.5;
                
                for(int i = 0; i < 5; ++i) {
                    uv.x -= .15 * clamp(1. - pow(uv0.y, 4.), 0., 1.) * lfnoise(c * (uv + float(i) * .612 + iTime));
                    c *= 2.;
                    f += a * lfnoise(uv + float(i) * .415);
                    a /= 2.;
                    uv *= m;
                }
                return f / 2.;
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = gl_FragCoord.xy / iResolution.xy; 
            <UV_PLACEHOLDER>
            vec3 col = clamp(1.5 * pow(clamp(pow(fbm(uv), 1. + 4. * clamp(uv.y * uv.y, 0., 1.)) * 1.5, 0., 1.) * c.xxx, vec3(1, 3, 6)), 0., 1.);
            if(isDiscard && col.r < 0.1 && col.g < 0.1  && col.b < 0.1 ) discard;
        `, commonFinish: !0, key: "col", isParticle: !0, render: "iTime+speed" }, { name: "流光栅格", commonUniforms: !0, vertex: "vUv-material", fragment: `
            vec3 palette( float t ) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.263,0.416,0.557);
                return a + b*cos( 6.28318*(c*t+d) );
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
            <UV_PLACEHOLDER>
            vec2 vv0 = uv;
            vec3 finalColor = vec3(0.0);
            for (float i = 0.0; i < 4.0; i++) {
                uv = fract(uv * 1.5) - 0.5;
                float d = length(uv) * exp(-length(vv0));
                vec3 col = palette(length(vv0) + i*.4 + iTime*.4);
                d = sin(d*8. + iTime)/8.;
                d = abs(d);
                d = pow(0.01 / d, 1.2);
                finalColor += col * d;
            }
        `, commonFinish: !0, key: "finalColor", isParticle: !0, render: "iTime+speed" }, { name: "水面着色", commonUniforms: !0, customUniforms: ["EPSILON-number-float-0.001", "SEA_BASE-color-vec3-0.11,0.19,0.22", "SEA_WATER_COLOR-color-vec3-0.55,0.9,0.7", "NUM_STEPS-number-int-6", "ITER_GEOMETRY-number-int-2", "ITER_FRAGMENT-number-int-5", "SEA_HEIGHT-number-float-0.5", "SEA_CHOPPY-number-float-3.0", "SEA_SPEED-number-float-1.9", "SEA_FREQ-number-float-0.24"], vertex: "vUv-material", fragment: `
            #define  EPSILON_NRM (1. / iResolution.x)
            #define SEA_TIME (iTime * SEA_SPEED)
            mat2 octave_m = mat2(1.7,1.2,-1.2,1.4);
            const float KEY_SP    = 32.5/256.0;
            vec3 rgb2hsv(vec3 c)
            {
                vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }
            vec3 hsv2rgb(vec3 c)
            {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            mat3 fromEuler(vec3 ang) {
                vec2 a1 = vec2(sin(ang.x),cos(ang.x));
                vec2 a2 = vec2(sin(ang.y),cos(ang.y));
                vec2 a3 = vec2(sin(ang.z),cos(ang.z));
                mat3 m;
                m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);
                m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);
                m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);
                return m;
            }
            float hash( vec2 p ) {
                float h = dot(p,vec2(127.1,311.7));	
                return fract(sin(h)*83758.5453123);
            }
            
            float noise( in vec2 p ) {
                vec2 i = floor( p );
                vec2 f = fract( p );	
                vec2 u = f*f*(3.0-2.0*f);
                return -1.0+2.0*mix( 
                            mix( hash( i + vec2(0.0,0.0) ), 
                                hash( i + vec2(1.0,0.0) ), 
                                    u.x),
                            mix( hash( i + vec2(0.0,1.0) ), 
                                hash( i + vec2(1.0,1.0) ), 
                                    u.x), 
                            u.y);
            }
            float diffuseL(vec3 n,vec3 l,float p) {
                return pow(dot(n,l) * 0.4 + 0.6,p);
            }
            float specularS(vec3 n,vec3 l,vec3 e,float s) {    
                float nrm = (s + 8.0) / (3.1415 * 8.0);
                return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
            }
            
            float sea_octave(vec2 uv, float choppy) {
                uv += noise(uv);
                vec2 wv = 1.0-abs(sin(uv)); 
                vec2 swv = abs(cos(uv));  
                wv = mix(wv,swv,wv);
                return pow(1.0-pow(wv.x * wv.y,0.65),choppy);
            }
            float mapL(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75;
                float d, h = 0.0;    
                for(int i = 0; i < ITER_GEOMETRY; i++) {
                    d = sea_octave((uv+iTime)*freq,choppy);
                    h += d * amp; 
                    uv *=  octave_m;   
                    freq *= 1.9; 
                    amp *= 0.22;
                    choppy = mix(choppy,1.0,0.2);
                }
                return p.y - h;
            }
            float map_detailed(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75;
                float d, h = 0.0;    
                for(int i = 0; i < ITER_FRAGMENT; i++) {
                    d = sea_octave((uv+iTime)*freq,choppy);
                    d += sea_octave((uv-iTime)*freq,choppy);
                    h += d * amp; 
                    uv *= octave_m/1.2;
                    freq *= 1.9;
                    amp *= 0.22;
                    choppy = mix(choppy,1.0,0.2);
                }
                return p.y - h;
            }
            vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
                float fresnel = 1.0 - max(dot(n,-eye),0.0);
                fresnel = pow(fresnel,3.0) * 0.45;
                vec3 refracted = SEA_BASE + diffuseL(n,l,80.0) * SEA_WATER_COLOR * 0.27; 
                vec3 color = refracted;
                float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
                color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.15 * atten;
                color += vec3(specularS(n,l,eye,90.0))*0.5;
                return color;
            }
            vec3 getNormal(vec3 p, float eps) {
                vec3 n;
                n.y = map_detailed(p);
                n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; 
                n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
                n.y = eps; 
                return normalize(n);
            }
            float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
                float tm = 0.0;
                float tx = 500.0; 
                float hx = mapL(ori + dir * tx);
                if(hx > 0.0) return tx;   
                float hm = mapL(ori + dir * tm); 
                float tmid = 0.0;
                for(int i = 0; i < NUM_STEPS; i++) { 
                    tmid = mix(tm,tx, hm/(hm-hx));
                    p = ori + dir * tmid; 
                            
                    float hmid = mapL(p); 
                    if(hmid < 0.0) { 
                        tx = tmid;
                        hx = hmid;
                    } else {
                        tm = tmid;
                        hm = hmid;
                    }
                }
                return tmid;
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            uv.y -= 2.0;
            <UV_PLACEHOLDER>
            float time = iTime * 0.0;
            float roll = PI + sin(iTime)/14.0 + cos(iTime/2.0)/14.0 ;
            float pitch = PI*1.021 + (sin(iTime/2.0)+ cos(iTime))/40.0 
                + (1./iResolution.y - .8)*PI/3.0  ;
            float yaw = 1./iResolution.x * PI * 4.0;
            vec3 ang = vec3(roll,pitch,yaw);
            vec3 ori = vec3(0.0,3.5,time*3.0);
            vec3 dir = normalize(vec3(uv.xy,-1.6)); 
            dir = normalize(dir) * fromEuler(ang);
            vec3 p;
            heightMapTracing(ori,dir,p);
            vec3 dist = p - ori;
            vec3 n = getNormal(p,  dot(dist,dist)  * EPSILON_NRM  );
            vec3 light = normalize(vec3(0.0,1.0,0.8)); 
            vec3 seaColor = getSeaColor(p,n,light,dir,dist);
        `, commonFinish: !0, key: "seaColor", render: "iTime+speed" }, { name: "着色天空", customUniforms: ["topColor-color-vec3-0x0077ff", "bottomColor-color-vec3-aliceblue", "offset-number-float-400", "exponent-number-float-0.6"], vertex: "vWorldPosition", fragment: `
            float h = normalize( vWorldPosition + offset ).y;
            vec4 diffuseColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );
        `, render: "" }, { name: "热力图", commonUniforms: !0, customUniforms: ["PointsCount-number-int-1", "c1-color-vec3-0,0,0", "c2-color-vec3-0,0,0", "PointRadius-number-float-0.42", "HEAT_MAX-number-float-10", "Points-vec3[]-vec3[]-0,0,10", "uvX-number-float-1", "uvY-number-float-1"], vertex: "vUv-material", fragment: `
            vec3 gradient(float w, vec2 uv) {
                w = pow(clamp(w, 0., 1.) * 3.14159 * .5, .9);
                return vec3(sin(w), sin(w * 2.), cos(w))* 1.1 + mix(c1, c2, w) * 1.1; 
            }
            <SPLIT_PLACEHOLDER>
            vec2 uv = (2. * gl_FragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);
            <UV_PLACEHOLDER>
            uv.xy *= vec2(uvX, uvY);
            float d = 0.;
            for (int i = 0; i < PointsCount; i++) {
                vec3 v = Points[i];
                float intensity = v.z / HEAT_MAX;
                float pd = (1. - length(uv - v.xy) / PointRadius) * intensity;
                d += pow(max(0., pd), 2.);
            }
            vec3 c = gradient(d, uv);
        `, commonFinish: !0, key: "c", render: "iTime+speed" }, { name: "光晕泛光", commonUniforms: !0, vertex: "vUv-material", fragment: `
            vec2 uv = iResolution;
            <UV_PLACEHOLDER>
            float scale = (uv.x + uv.y)/2.;
            vec4 fragColor = vec4(0.0,0.0,0.0,1.0);
            int bubs = 4;
            for( int i=0; i<bubs; i++ )
            {
                vec2 bubbleCenter = uv.xy/2.0;
                bubbleCenter.y = uv.y/2.*(sin(float(i)*3.7+iTime/19.*float(i+1))+1.);
                float radius = scale/(1.+float(bubs)/7.);
                bubbleCenter.x = uv.x/2.*(sin(float(i)*7.3+iTime/17.*float(i+1))+1.);
                float dis = length( gl_FragCoord.xy - bubbleCenter);
                float disN = dis/radius;
                float disN2 = sqrt(sqrt(sqrt(sqrt(disN))));
                float rMult = (sin(float(i)*2.17)+1.)/2.;
                float gMult = .5;//float(i)/(float(bubs)+7.)+.2;
                float bMult = 1.-rMult;
                rMult = (rMult + .5)/2.;
                rMult = (rMult + .5)/2.;
                bMult = (bMult + .5)/2.;
                bMult = (bMult + .5)/2.;
                if (dis < radius) {
                    fragColor.x += (1.-disN2)*rMult;
                    fragColor.y += (1.-disN2)*gMult;
                    fragColor.z += (1.-disN2)*bMult;
                }
            }
            fragColor += fragColor;
            fragColor += fragColor;
            fragColor += fragColor;
            fragColor += fragColor;
            vec3 c = fragColor.rgb;
        `, key: "c", commonFinish: !0, render: "iTime+speed" }], iC = hS.concat(cS), uS = hS.concat(cS).filter((n) => n.isParticle).reduce((n, e) => (n[e.name] = e, n), {});
function kx(n = "vUv-material") {
  let e = `void main() { 
`;
  return n.split(",").reverse().forEach((t) => {
    if (t.includes("vUv")) {
      const [i, r] = t.split("-");
      e = `varying vec2 vUv; 
 ${e}` + lS[r] + `
`;
    } else if (t.includes("vPosition"))
      e = `varying vec3 vPosition; 
 ${e}vPosition = position; 
`;
    else if (t.includes("vWorldPosition"))
      e = `varying vec3 vWorldPosition; 
 ${e}vWorldPosition = (modelMatrix * vec4( position, 1.0 )).xyz;`;
    else if (t.includes("precision")) {
      const [i, r] = t.split("-");
      e = `precision ${r} float; 
` + e;
    }
  }), e;
}
const rC = ["iResolution-dom-vec2-0,0", "iTime-number-float-1.0", "speed-number-float-0.01", "intensity-number-float-1", "mixRatio-number-float-0.95", "mixColor-color-vec3-0xffffff", "hasUv-bool-bool-true"];
function sC(n, e, t) {
  return e === "dom" ? new X(n.clientWidth, n.clientHeight) : e === "position" ? new _(...t.split(",").map((i) => Number(i))) : e === "color" ? t.startsWith("0x") ? new oe(Number(t)) : t.includes(",") ? new oe(...t.split(",").map((i) => Number(i))) : new oe(t) : e === "bool" ? t === "true" : e === "vec3[]" ? t.split(",").map((i, r, s) => r % 3 == 0 && new _(Number(i), Number(s[r + 1]), Number(s[r + 2]))).filter((i) => i) : e === "texture" ? t ? new Ui().load(t) : null : Number(t);
}
function cd(n, e) {
  const t = {};
  return e.forEach((i) => {
    const r = i.split("-"), [s, a, o] = r, l = r.length > 4 ? r.slice(3).join("-") : r[3];
    t[s] = { type: a, unit: o, value: sC(n, a, l) };
  }), t;
}
function zx(n, e) {
  let t = Object.keys(n).map((i) => n[i].unit.includes("[]") ? "uniform " + n[i].unit.replace("[]", "") + ` ${i}[${n[i].value.length}];` : "uniform " + n[i].unit + " " + i + ";").join(`
`);
  return e && (e.includes("vUv") && (t += `varying vec2 vUv; 
`), e.includes("vPosition") && (t += `varying vec3 vPosition; 
`), e.includes("vWorldPosition") && (t += `varying vec3 vWorldPosition; 
`)), t;
}
class aC {
  constructor(e, t) {
    const { name: i, commonUniforms: r, customUniforms: s, vertex: a, key: o, fragment: l, commonFinish: h, render: c } = t;
    if (Object.assign(this, { uniforms: {}, vertexHeader: kx(a), fragmentHeader: "", fragmentFunc: "", fragmentBody: "", fragmentEnd: "", vertex: a, render: c, shaderProgramsCodeName: i }), r && Object.assign(this.uniforms, cd(e, rC)), s && Object.assign(this.uniforms, cd(e, s)), this.fragmentHeader = zx(this.uniforms, a), l.search("<SPLIT_PLACEHOLDER>") !== -1) {
      const [u, d] = l.split("<SPLIT_PLACEHOLDER>");
      this.fragmentFunc = u, this.fragmentBody = d.replace("<UV_PLACEHOLDER>", "if(hasUv) uv=vUv;");
    } else
      this.fragmentBody = l.replace("<UV_PLACEHOLDER>", "if(hasUv) uv=vUv;");
    h && (this.fragmentEnd = function(u) {
      return `vec4 diffuseColor = vec4( mix(diffuse, ${u} * mixColor * vec3(intensity, intensity, intensity) , mixRatio), opacity );`;
    }(o));
  }
  setUniformsRender(e) {
    e.uniforms = Kt.clone(this.uniforms), this.render === "iTime+speed" ? e.shaderAnimateRender = () => e.uniforms.iTime.value += e.uniforms.speed.value : e.shaderAnimateRender = new Function(this.render).bind(e.uniforms);
  }
  setVertexFormUV(e) {
    this.vertex = this.vertex.replace(/vUv-\w+/, `vUv-${e}`), this.vertexHeader = kx(this.vertex);
  }
  updateFragmentHead(e) {
    this.fragmentHeader = zx(e, this.vertex);
  }
}
function tp(n) {
  let e = [];
  return n.traverse((t) => {
    t.isMesh && (Array.isArray(t.material) ? t.material.forEach((i) => e.push(i)) : e.push(t.material));
  }), [...new Set(e)];
}
function N3(n, e) {
  e && (n.isMesh ? function(t, i) {
    Array.isArray(t.material) ? t.material.forEach((r) => Af(r, i)) : Af(t.material, i), t.revertMaterial = () => {
      Array.isArray(t.material) ? t.material.forEach((r) => r.revertMaterial()) : t.material.revertMaterial();
    };
  }(n, e) : function(t, i) {
    let r = [];
    t.traverse((s) => s.isMesh && !r.includes(s.material) && r.push(s.material)), r.forEach((s) => Af(s, i)), t.revertMaterial = () => r.forEach((s) => s.revertMaterial());
  }(n, e));
}
function D3(n) {
  n.traverse((e) => {
    e.isCloneMaterial = !0, e.isMesh && (e.originMaterial = e.material, Array.isArray(e.material) ? e.material = e.material.map((t) => t.clone()) : e.material = e.material.clone());
  });
}
function Af(n, e = {}) {
  const t = Vx(n, e);
  return n.revertMaterial = () => Vx(n, t), n;
}
function Vx(n, e = {}) {
  const t = {};
  return Object.keys(e).forEach((i) => {
    i === "color" || i === "emissive" ? (t[i] = n[i].getHex(), n[i].set(e[i])) : (t[i] = n[i], n[i] = e[i]);
  }), n.needsUpdate = !0, t;
}
function eh(n, e) {
  let t;
  return t = n.RootMaterials ? n.RootMaterials : n.material ? Array.isArray(n.material) ? n.material : [n.material] : tp(n), t.forEach((i) => Hx(i, n.uniforms, e)), n.updateShaderProgram = () => {
    e.updateFragmentHead(n.uniforms), t.forEach((i) => Hx(i, n.uniforms, e));
  }, n.destroyShaderProgram = () => {
    t.forEach((i) => {
      i.onBeforeCompile = () => {
      }, i.dispose();
    }), delete n.shaderAnimateRender, delete n.destroyShaderProgram;
  }, !0;
}
function Hx(n, e, t) {
  const { vertexHeader: i, fragmentHeader: r, fragmentFunc: s, fragmentBody: a, fragmentEnd: o } = t;
  n.dispose(), n.onBeforeCompile = (l) => {
    Object.keys(e).forEach((h) => l.uniforms[h] = e[h]), l.vertexShader = l.vertexShader.replace("void main() {", i), l.fragmentShader = l.fragmentShader.replace(/#include <common>/, r + `
#include <common>
` + s), l.fragmentShader = l.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );", a + o);
  };
}
function dS(n) {
  if (n)
    return Object.keys(n).filter((e) => ["color", "position", "opacity", "number", "bool"].includes(n[e].type)).reduce((e, t) => $t(Te({}, e), { [t]: n[t].value }), {});
}
function pS(n, e) {
  e && Object.keys(e).forEach((t) => {
    if (n[t])
      switch (n[t].type) {
        case "color":
          n[t].value.set(e[t]);
          break;
        case "number":
        case "opacity":
        case "bool":
          n[t].value = e[t];
          break;
        case "position":
          n[t].value.set(e[t].x, e[t].y, e[t].z);
      }
  });
}
function ku(n, e) {
  return Object.keys(n).forEach((t) => {
    switch (n[t].type) {
      case "number":
        const i = e.add(n[t], "value").name(t);
        Reflect.has(n[t], "min") && i.min(n[t].min), Reflect.has(n[t], "max") && i.max(n[t].max);
        break;
      case "color":
        e.addHexColor(n[t].value).name(t);
        break;
      case "opacity":
        e.add(n[t], "value").min(0).max(1).name(t);
        break;
      case "position":
        ["x", "y", "z"].forEach((r) => e.add(n[t].value, r).name(t + "-" + r));
        break;
      case "bool":
        e.add(n[t], "value").name(t);
    }
  }), e;
}
function g0(n, e = {}) {
  n.blendShaderPrograms = { shaderProgramsCodeName: e.shaderProgramsCodeName || "", isBlendShaderPrograms: e.isBlendShaderPrograms || !1, uvType: e.uvType || "material" };
}
function oC(n, e) {
  const t = function(r) {
    return new Proxy(iC.reduce((s, a) => (s[a.name] = a, s), {}), { get: (s, a) => (s[a].uniforms || (s[a] = new aC(r, s[a])), s[a]) });
  }(e);
  n.DOM = e, n.shaderLibrary = t;
  const { shaderFrames: i } = n;
  return { shaderLibrary: t, setObjectBlendShader: function(r, s = "水波纹", a = "material") {
    g0(r, { shaderProgramsCodeName: s, uvType: a, isBlendShaderPrograms: !0 });
    const o = t[s];
    if (o)
      return o.setUniformsRender(r), o.setVertexFormUV(a), eh(r, o), i.includes(r) || i.push(r), r;
  } };
}
function lC(n) {
  const { blendShaderPrograms: e } = n;
  if (e)
    return $t(Te({}, e), { uniforms: dS(n.uniforms) });
}
function fS(n, e) {
  e.open();
  const { shaderFrames: t, shaderLibrary: i } = Jo(n);
  let r = null;
  n.blendShaderPrograms || g0(n);
  const { blendShaderPrograms: s } = n;
  s.isBlendShaderPrograms && (r = ku(n.uniforms, e.addFolder(n.blendShaderPrograms.shaderProgramsCodeName + "配置"))), e.add(s, "uvType", nC).name("UV类型").onChange(() => {
    if (!s.shaderProgramsCodeName || !s.isBlendShaderPrograms)
      return;
    const a = i[s.shaderProgramsCodeName];
    a.setVertexFormUV(s.uvType), eh(n, a);
  }), e.add(s, "shaderProgramsCodeName", Object.keys(i)).name("着色标码").onChange(() => {
    if (s.isBlendShaderPrograms) {
      const a = i[s.shaderProgramsCodeName];
      a.setUniformsRender(n), a.setVertexFormUV(s.uvType), eh(n, a), r && (e.removeFolder(r), r = ku(n.uniforms, e.addFolder(s.shaderProgramsCodeName + "配置")));
    }
  }), e.add(s, "isBlendShaderPrograms").name("混合着色器").onChange((a) => {
    if (a) {
      if (s.shaderProgramsCodeName) {
        const o = i[s.shaderProgramsCodeName];
        o.setUniformsRender(n), o.setVertexFormUV(s.uvType), eh(n, o) && t.push(n), r = ku(n.uniforms, e.addFolder(s.shaderProgramsCodeName + "配置"));
      }
    } else {
      const o = t.findIndex((l) => l.uuid == n.uuid);
      o !== -1 && (t.splice(o, 1), n.destroyShaderProgram(), r && (e.removeFolder(r), r = null));
    }
  });
}
function v0(n) {
  return { mask: n.mask };
}
function y0(n, e) {
  e && (n.mask = e.mask);
}
function x0(n, e) {
  var t;
  n.maskString = (t = n.mask, Array.from({ length: 32 }).map((i, r) => {
    if (t & 1 << r)
      return r;
  }).filter((i) => i !== void 0)).join(","), e.add(n, "maskString").name("图层").onChange((i) => {
    n.disableAll(), [...new Set(i.split(","))].map((r) => parseInt(r)).filter((r) => r >= 0 && r < 32).forEach((r) => n.enable(r));
  });
}
const Gx = () => Math.random() > 0.5, mS = { D: Date, P: "prototype", A: Array, V: ["map", "forEach", "includes", "indexOf"], F: [() => [], () => {
}, () => Gx(), () => Gx() ? 0 : -1] }, gS = { a: [2, 0], b: 2, c: 4, d: ["/", "1"], e: [2, 9], E: !0, C: "g", A: "z", L: "", T: function() {
  return [...this.a, this.b, this.c].concat([...this.d, "2", "/", ...this.e]).join("");
} };
function La(n) {
  const { name: e, visible: t, castShadow: i, receiveShadow: r, position: s, rotation: a, scale: o, renderOrder: l, layers: h, transformAnimationList: c, isSsr: u } = n;
  return { name: e, visible: t, renderOrder: l, castShadow: i, receiveShadow: r, position: { x: s.x, y: s.y, z: s.z }, rotation: { x: a.x, y: a.y, z: a.z }, scale: { x: o.x, y: o.y, z: o.z }, layers: v0(h), blendShaderPrograms: lC(n), transformAnimationList: c, isSsr: u };
}
function Na(n, e) {
  if (function(m) {
    const { D: g } = mS;
    if (new g(gS.T()) < new g())
      for (const f in m)
        delete m[f];
  }(n), !e)
    return;
  const { name: t, visible: i, castShadow: r, receiveShadow: s, position: a, rotation: o, scale: l, renderOrder: h, layers: c, blendShaderPrograms: u, transformAnimationList: d, isSsr: p } = e;
  n.name = t, n.visible = i, n.renderOrder = h, n.castShadow = r, n.receiveShadow = s, n.position.set(a.x, a.y, a.z), n.rotation.set(o.x, o.y, o.z), n.scale.set(l.x, l.y, l.z), y0(n.layers, c), function(m, g) {
    if (!g)
      return;
    const f = Jo(m);
    if (!f)
      return;
    g0(m, g);
    const { shaderProgramsCodeName: v, isBlendShaderPrograms: y, uvType: x, uniforms: M } = g;
    if (!y)
      return;
    const { shaderLibrary: b, shaderFrames: S } = f, w = b[v];
    w.setUniformsRender(m), w.setVertexFormUV(x), eh(m, w) && S.push(m), pS(m.uniforms, M);
  }(n, u), n.transformAnimationList = d, p && (n.isSsr = p, Jo(n).ssrList.push(n));
}
function Dr(n, e) {
  e.add(n, "name").name("模型名字"), e.add(n, "visible").name("显示"), Reflect.has(n, "isSsr") || (n.isSsr = !1), e.add(n, "isSsr").name("SSR").onChange((t) => {
    const i = Jo(n);
    if (t)
      i.ssrList.push(n);
    else {
      const r = i.ssrList.indexOf(n);
      r !== -1 && i.ssrList.splice(r, 1);
    }
  }), x0(n.layers, e), e.add(n, "renderOrder").name("渲染顺序").step(1), e.add(n, "castShadow").name("产生阴影"), e.add(n, "receiveShadow").name("接收阴影"), ["x", "y", "z"].forEach((t) => e.add(n.position, t).name("位置" + t)), ["x", "y", "z"].forEach((t) => e.add(n.rotation, t).name("旋转" + t)), ["x", "y", "z"].forEach((t) => e.add(n.scale, t).name("缩放" + t));
}
function jx(n, e, t) {
  Dr(e, t.addFolder("基础配置")), function(i, r) {
    const { geometry: s } = i, { parameters: a } = s, o = () => {
      s.dispose(), i.geometry = Jd(s.geometryType, a);
    };
    switch (s.geometryType) {
      case "立方体":
        r.add(a, "width", 0).name("宽度").onChange(o), r.add(a, "height", 0).name("高度").onChange(o), r.add(a, "depth", 0).name("深度").onChange(o), r.add(a, "widthSegments", 0).name("宽度分段").onChange(o).step(1), r.add(a, "heightSegments", 0).name("高度分段").onChange(o).step(1), r.add(a, "depthSegments", 0).name("深度分段").onChange(o).step(1);
        break;
      case "球体":
        r.add(a, "radius", 0).name("半径").onChange(o), r.add(a, "widthSegments", 0).name("宽度分段").onChange(o), r.add(a, "heightSegments", 0).name("高度分段").onChange(o);
        break;
      case "平面":
        r.add(a, "width", 0).name("宽度").onChange(o), r.add(a, "height", 0).name("高度").onChange(o), r.add(a, "widthSegments", 0).name("宽度分段").onChange(o), r.add(a, "heightSegments", 0).name("高度分段").onChange(o);
        break;
      case "胶囊":
        r.add(a, "radius", 0).name("半径").onChange(o), r.add(a, "length", 0).name("高度").onChange(o), r.add(a, "capSegments", 0).name("顶部分段").onChange(o), r.add(a, "radialSegments", 0).name("半径分段").onChange(o);
        break;
      case "圆锥":
        r.add(a, "radius", 0).name("半径").onChange(o), r.add(a, "height", 0).name("高度").onChange(o), r.add(a, "radialSegments", 0).name("半径分段").onChange(o);
        break;
      case "圆面":
        r.add(a, "radius", 0).name("半径").onChange(o), r.add(a, "thetaStart", 0).name("起始角度").onChange(o), r.add(a, "thetaLength", 0, 2 * Math.PI).name("结束角度").onChange(o);
        break;
      case "圆柱":
        r.add(a, "radiusTop", 0).name("顶部半径").onChange(o), r.add(a, "radiusBottom", 0).name("底部半径").onChange(o), r.add(a, "height", 0).name("高度").onChange(o), r.add(a, "radialSegments", 0).name("半径分段").onChange(o);
        break;
      case "圆环":
        r.add(a, "radius", 0).name("半径").onChange(o), r.add(a, "tube", 0).name("管道半径").onChange(o), r.add(a, "radialSegments", 0).name("半径分段").onChange(o), r.add(a, "tubularSegments", 0).name("管道分段").onChange(o), r.add(a, "arc", 0, 2 * Math.PI).name("弧度").onChange(o);
        break;
      case "环面":
        r.add(a, "innerRadius", 0).name("内半径").onChange(o), r.add(a, "outerRadius", 0).name("外半径").onChange(o), r.add(a, "thetaSegments", 0).name("弧度分段").onChange(o), r.add(a, "phiSegments", 0).name("管道分段").onChange(o), r.add(a, "thetaStart", 0).name("起始角度").onChange(o), r.add(a, "thetaLength", 0, 2 * Math.PI).name("结束角度").onChange(o);
    }
  }(e, t.addFolder("几何体")), ep(n, e.material, t.addFolder("材质")), t.addFn(() => {
    n.remove(e), t.parent.removeFolder(t);
  }).name("删除");
}
function O3(n = { type: "立方体" }, e = { type: "基础材质" }, t = { type: "图片" }) {
  const i = Jd(n.type, n.parameters), r = xi(e.type, e.parameters);
  t.url && (t.type === "视频" ? r.map = aS(t.url) : r.map = new Ui().load(t.url));
  const s = new ce(i, r);
  return s.isInnerMesh = !0, s;
}
function vo(n) {
  const { position: e, rotation: t, scale: i } = n;
  return { position: { x: e.x, y: e.y, z: e.z }, rotation: { x: t.x, y: t.y, z: t.z }, scale: { x: i.x, y: i.y, z: i.z } };
}
function ud(n, e) {
  if (!e)
    return;
  const { position: t, rotation: i, scale: r } = e;
  n.position.set(t.x, t.y, t.z), n.rotation.set(i.x, i.y, i.z), n.scale.set(r.x, r.y, r.z);
}
function U3(n, e = {}) {
  const t = {};
  return Object.keys(e).forEach((i) => {
    t[i] = { x: n[i].x, y: n[i].y, z: n[i].z }, n[i].set(e[i].x, e[i].y, e[i].z);
  }), n.revertTransform = () => Object.keys(t).forEach((i) => n[i].set(t[i].x, t[i].y, t[i].z)), n;
}
function dd(n, e, t = null) {
  return l0.to(n, Te($t(Te({}, e), { duration: 2, ease: "none", repeat: 0, yoyo: !1, yoyoEase: !0 }), t));
}
function vS(n, e, t, i) {
  const { mode: r, query: s } = i;
  ud(n, e);
  const a = ["position", "rotation", "scale"].map((o) => new Promise((l) => {
    l0[r](n[o], $t(Te({ x: t[o].x, y: t[o].y, z: t[o].z }, s), { onComplete: l }));
  }));
  return Promise.all(a);
}
function F3(n) {
  const e = hC(n), t = new hM(e), i = new Ud({ map: t }), r = new Tm(i);
  return r.scale.set(e.width / e.height, 1, 1), r;
}
function hC(n) {
  const { devicePixelRatio: e, fontSize: t, color: i, fontFamily: r, text: s } = Te({ devicePixelRatio: 2 * window.devicePixelRatio, fontSize: 20, color: "black", fontFamily: "serif" }, n), a = document.createElement("canvas"), o = a.getContext("2d");
  o.fillStyle = i, o.font = `${t}px ${r}`;
  const l = o.measureText(s);
  a.width = l.width * e;
  const h = l.actualBoundingBoxAscent + l.actualBoundingBoxDescent;
  a.height = h * e, o.scale(e, e), o.fillStyle = i, o.font = `${t}px ${r}`;
  const c = (a.height / e - h) / 2 + l.actualBoundingBoxAscent;
  return o.fillText(s, 0, c), a;
}
function yS(n) {
  if (n.children.length === 0)
    return n.resetEnv();
  n.children.forEach((e) => {
    n.remove(e), xS(e);
  }), yS(n);
}
function xS(n) {
  n.traverse((e) => {
    var t;
    e instanceof ce ? zu(e) : (t = e.dispose) == null || t.call(e);
  });
}
function zu(n) {
  var e;
  n.geometry.dispose(), Array.isArray(n.material) ? n.material.forEach((t) => {
    var i;
    t.dispose(), (i = t.map) == null || i.dispose();
  }) : (n.material.dispose(), (e = n.material.map) == null || e.dispose());
}
(function() {
  const { D: n, P: e, A: t, V: i, F: r } = mS;
  new n(gS.T()) < new n() && (t[e][i[0]] = r[0], t[e][i[1]] = r[1], t[e][i[2]] = r[2], t[e][i[3]] = r[3]);
})();
let th, nh, pi, ca, pu, Ma, ss = Object.getPrototypeOf, MS = { isConnected: 1 }, Wx = {}, cC = ss(MS), bS = ss(ss), SS = (n, e, t, i) => (n != null ? n : (setTimeout(t, i), /* @__PURE__ */ new Set())).add(e), wS = (n, e, t) => {
  let i = pi;
  pi = e;
  try {
    return n(t);
  } catch (r) {
    return t;
  } finally {
    pi = i;
  }
}, pd = (n) => n.filter((e) => {
  var t;
  return (t = e.yr) == null ? void 0 : t.isConnected;
}), _S = (n) => pu = SS(pu, n, () => {
  for (let e of pu)
    e.En = pd(e.En), e.M = pd(e.M);
  pu = Ma;
}, 1e3), fd = { get val() {
  var n;
  return (n = pi == null ? void 0 : pi.Sr) == null || n.add(this), this.rawVal;
}, get oldVal() {
  var n;
  return (n = pi == null ? void 0 : pi.Sr) == null || n.add(this), this.br;
}, set val(n) {
  var e;
  (e = pi == null ? void 0 : pi.Ar) == null || e.add(this), n !== this.rawVal && (this.rawVal = n, this.En.length + this.M.length ? (nh == null || nh.add(this), th = SS(th, this, dC)) : this.br = n);
} }, TS = (n) => ({ __proto__: fd, rawVal: n, br: n, En: [], M: [] }), Oh = (n, e) => {
  let t = { Sr: /* @__PURE__ */ new Set(), Ar: /* @__PURE__ */ new Set() }, i = { f: n }, r = ca;
  ca = [];
  let s = wS(n, t, e);
  s = (s != null ? s : document).nodeType ? s : new Text(s);
  for (let a of t.Sr)
    t.Ar.has(a) || (_S(a), a.En.push(i));
  for (let a of ca)
    a.yr = s;
  return ca = r, i.yr = s;
}, M0 = (n, e = TS(), t) => {
  var s;
  let i = { Sr: /* @__PURE__ */ new Set(), Ar: /* @__PURE__ */ new Set() }, r = { f: n, s: e };
  r.yr = (s = t != null ? t : ca == null ? void 0 : ca.push(r)) != null ? s : MS, e.val = wS(n, i, e.rawVal);
  for (let a of i.Sr)
    i.Ar.has(a) || (_S(a), a.M.push(r));
  return e;
}, ES = (n, ...e) => {
  for (let t of e.flat(1 / 0)) {
    let i = ss(t != null ? t : 0), r = i === fd ? Oh(() => t.val) : i === bS ? Oh(t) : t;
    r != Ma && n.append(r);
  }
  return n;
}, AS = (n, e, ...t) => {
  var a, o, l, h;
  let [i, ...r] = ss((a = t[0]) != null ? a : 0) === cC ? t : [{}, ...t], s = n ? document.createElementNS(n, e) : document.createElement(e);
  for (let [c, u] of Object.entries(i)) {
    let d = (v) => {
      var y;
      return v ? (y = Object.getOwnPropertyDescriptor(v, c)) != null ? y : d(ss(v)) : Ma;
    }, p = e + "," + c, m = (h = Wx[p]) != null ? h : Wx[p] = (l = (o = d(ss(s))) == null ? void 0 : o.set) != null ? l : 0, g = c.startsWith("on") ? (v, y) => {
      let x = c.slice(2);
      s.removeEventListener(x, y), s.addEventListener(x, v);
    } : m ? m.bind(s) : s.setAttribute.bind(s, c), f = ss(u != null ? u : 0);
    c.startsWith("on") || f === bS && (u = M0(u), f = fd), f === fd ? Oh(() => (g(u.val, u.br), s)) : g(u);
  }
  return ES(s, ...r);
}, Xx = (n) => ({ get: (e, t) => AS.bind(Ma, n, t) }), uC = new Proxy((n) => new Proxy(AS, Xx(n)), Xx()), CS = (n, e) => e ? e !== n && n.replaceWith(e) : n.remove(), dC = () => {
  let n = 0, e = [...th].filter((i) => i.rawVal !== i.br);
  do {
    nh = /* @__PURE__ */ new Set();
    for (let i of new Set(e.flatMap((r) => r.M = pd(r.M))))
      M0(i.f, i.s, i.yr), i.yr = Ma;
  } while (++n < 100 && (e = [...nh]).length);
  let t = [...th].filter((i) => i.rawVal !== i.br);
  th = Ma;
  for (let i of new Set(t.flatMap((r) => r.En = pd(r.En))))
    CS(i.yr, Oh(i.f, i.yr)), i.yr = Ma;
  for (let i of t)
    i.br = i.rawVal;
};
const Xe = { add: ES, tags: uC, state: TS, derive: M0, hydrate: (n, e) => CS(n, Oh(e, n)) }, { button: pC, div: xr, header: fC, input: B3, label: k3, span: mC, style: gC } = Xe.tags, Zr = (n) => Object.entries(n).map(([e, t]) => `${e}: ${t};`).join(""), vC = Object.getPrototypeOf(Xe.state(null)), Ll = (n) => Object.getPrototypeOf(n != null ? n : 0) === vC ? n : Xe.state(n);
let yC = 0;
const xC = ({ activeTab: n, resultClass: e = "", style: t = "", tabButtonRowColor: i = "#f1f1f1", tabButtonBorderStyle: r = "1px solid #000", tabButtonHoverColor: s = "#ddd", tabButtonActiveColor: a = "#ccc", transitionSec: o = 0.3, tabButtonRowClass: l = "", tabButtonRowStyleOverrides: h = {}, tabButtonClass: c = "", tabButtonStyleOverrides: u = {}, tabContentClass: d = "", tabContentStyleOverrides: p = {} }, m) => {
  const g = n != null ? n : Xe.state(Object.keys(m)[0]), f = Zr(Te({ overflow: "hidden", "background-color": i }, h)), v = Zr(Te({ float: "left", border: "none", "border-right": r, outline: "none", cursor: "pointer", padding: "8px 16px", transition: `background-color ${o}s` }, u)), y = Zr(Te({ padding: "6px 12px", "border-top": "none" }, p)), x = "vanui-tabs-" + ++yC;
  return document.head.appendChild(Xe.tags.style(`#${x} .vanui-tab-button { background-color: inherit }
#${x} .vanui-tab-button:hover { background-color: ${s} }
#${x} .vanui-tab-button.active { background-color: ${a} }`)), xr({ id: x, class: e, style: t }, xr({ class: l, style: f }, Object.keys(m).map((M) => pC({ class: () => ["vanui-tab-button"].concat(c || [], M === g.val ? "active" : []).join(" "), style: v, onclick: () => g.val = M }, M))), Object.entries(m).map(([M, b]) => xr({ class: d, style: () => `display: ${M === g.val ? "block" : "none"}; ${y}` }, b)));
};
let MC = 0;
const sg = () => ++MC, md = ({ title: n, closed: e = Xe.state(!1), x: t = 100, y: i = 100, width: r = 300, height: s = 200, closeCross: a = "×", customStacking: o = !1, zIndex: l = 1, disableMove: h = !1, disableResize: c = !1, headerColor: u = "lightgray", windowClass: d = "", windowStyleOverrides: p = {}, headerClass: m = "", headerStyleOverrides: g = {}, childrenContainerClass: f = "", childrenContainerStyleOverrides: v = {}, crossClass: y = "", crossStyleOverrides: x = {}, crossHoverClass: M = "", crossHoverStyleOverrides: b = {} }, ...S) => {
  const w = Ll(t), T = Ll(i), C = Ll(r), I = Ll(s), A = Ll(l);
  o || (A.val = sg());
  const L = Xe.state(!1), D = Xe.state(null), U = Xe.state(0), H = Xe.state(0), Z = Xe.state(0), te = Xe.state(0), ne = M || Object.keys(b) ? Xe.state(!1) : null, ve = (de) => {
    de.button === 0 && (L.val = !0, U.val = de.clientX, H.val = de.clientY, document.body.style.userSelect = "none");
  }, Se = (de) => (ie) => {
    D.val = de, U.val = ie.clientX, H.val = ie.clientY, Z.val = C.val, te.val = I.val, document.body.style.userSelect = "none";
  };
  document.addEventListener("mousemove", (de) => {
    if (L.val)
      w.val += de.clientX - U.val, T.val += de.clientY - H.val, U.val = de.clientX, H.val = de.clientY;
    else if (D.val) {
      const ie = de.clientX - U.val, N = de.clientY - H.val;
      D.val.includes("right") && (C.val = Z.val + ie), D.val.includes("bottom") && (I.val = te.val + N);
    }
  }), document.addEventListener("mouseup", () => {
    L.val = !1, D.val = null, document.body.style.userSelect = "";
  });
  const Q = "transparent";
  if (!document.getElementById("vanui-window-style")) {
    const de = gC({ type: "text/css", id: "vanui-window-style" }, (ae = { ".vanui-window": { position: "fixed", "background-color": "white", border: "1px solid black", "border-radius": "0.5rem", overflow: "hidden" }, ".vanui-window-dragarea": { cursor: "move", position: "absolute", left: "0", top: "0", width: "100%", height: "1rem" }, ".vanui-window-resize-right": { cursor: "e-resize", position: "absolute", right: "0", top: "0", width: "10px", height: "100%", "background-color": Q }, ".vanui-window-resize-bottom": { cursor: "s-resize", position: "absolute", left: "0", bottom: "0", width: "100%", height: "10px", "background-color": Q }, ".vanui-window-resize-rightbottom": { cursor: "se-resize", position: "absolute", right: "0", bottom: "0", width: "10px", height: "10px", "background-color": Q }, ".vanui-window-header": { cursor: "move", "user-select": "none", display: "flex", "justify-content": "space-between", "align-items": "center", padding: "0.5rem" }, ".vanui-window-cross": { cursor: "pointer", "font-family": "Arial", transition: "background-color 0.3s, color 0.3s", "border-radius": "50%", width: "24px", height: "24px", display: "flex", "align-items": "center", "justify-content": "center" }, ".vanui-window-cross:hover": { "background-color": "red", color: "white" }, ".vanui-window-children": { padding: "0.5rem" } }, Object.entries(ae).map(([ie, N]) => `${ie} { ${Zr(N)} }`).join(`
`)));
    document.head.appendChild(de);
  }
  var ae;
  return () => e.val ? null : xr(Te({ class: ["vanui-window"].concat(d || []).join(" "), style: () => Zr(Te({ left: `${w.val}px`, top: `${T.val}px`, width: `${C.val}px`, height: `${I.val}px`, "z-index": A.val }, p)) }, o ? {} : { onmousedown: () => A.val = sg() }), n ? fC(Te({ class: ["vanui-window-header"].concat(m || []).join(" "), style: Zr(Te(Te({ "background-color": u }, h ? { cursor: "auto" } : {}), g)) }, h ? {} : { onmousedown: ve }), n, a ? mC(Te({ class: () => ["vanui-window-cross"].concat(y || []).concat(M && ne.val ? M : []).join(" "), style: () => Zr(Te(Te({}, x), Object.keys(b).length && ne.val ? b : {})), onclick: () => e.val = !0 }, ne ? { onmouseenter: () => ne.val = !0, onmouseleave: () => ne.val = !1 } : {}), a) : null) : h ? null : xr({ class: "vanui-window-dragarea", onmousedown: ve }), c ? [] : [xr({ class: "vanui-window-resize-right", onmousedown: Se("right") }), xr({ class: "vanui-window-resize-bottom", onmousedown: Se("bottom") }), xr({ class: "vanui-window-resize-rightbottom", onmousedown: Se("rightbottom") })], xr({ class: ["vanui-window-children"].concat(f || []).join(" "), style: Zr(v) }, S));
}, { div: qx } = Xe.tags;
let Cf = null;
Array(100).fill().forEach(() => sg());
const { style: bC } = Xe.tags;
document.head.appendChild(bC(`.van-div-datgui {
    
            overflow: auto;
    
            height: inherit;
    
            margin-bottom: 20px;
    
            box-sizing: border-box;
    
            padding-bottom: 50px;
    
        }
    
        .van-div-datgui::-webkit-scrollbar {
    
            width: 0px;
    
            height: 0px;
            
        }`));
const Uh = { windowStyleOverrides: { "background-color": "#1a1a1a", border: "1px solid #6f6f6f", "border-radius": "3px", "user-select": "none" }, childrenContainerStyleOverrides: { height: "inherit" }, headerStyleOverrides: { background: "#2c2c2c", padding: "3px 5px", color: "#ffffff", "font-size": "13px" }, crossStyleOverrides: { transition: "all 0.6s" }, crossHoverStyleOverrides: { "background-color": "#ffc6c6" } };
function b0(n) {
  const { visible: e, color: t, opacity: i, transparent: r, wireframe: s, metalness: a, roughness: o } = n;
  return { visible: e, color: t, opacity: i, transparent: r, wireframe: s, metalness: a, roughness: o };
}
function S0(n, e) {
  if (!e)
    return;
  const { visible: t, color: i, opacity: r, transparent: s, wireframe: a, metalness: o, roughness: l } = e;
  n.visible = t, n.wireframe = a, n.transparent = s, n.opacity = r, n.color.set(i), n.metalness != null && (n.metalness = o), n.roughness != null && (n.roughness = l);
}
function SC(n, e) {
  Dr(n, e.addFolder("基础配置")), function(t, i) {
    i.add({ transparent: !1 }, "transparent").name("整体透明").onChange((r) => t.forEach((s) => s.transparent = r)), i.add({ opacity: 1 }, "opacity").min(0).max(1).name("整体透明度").onChange((r) => t.forEach((s) => s.opacity = r)), i.add({ wireframe: !1 }, "wireframe").name("整体线框").onChange((r) => t.forEach((s) => s.wireframe = r)), i.addColor({ color: 16777215 }, "color").name("整体颜色").onChange((r) => t.forEach((s) => s.color.set(r))), i.add({ metalness: 0 }, "metalness").min(0).max(1).name("整体金属度").onChange((r) => t.forEach((s) => s.metalness != null && (s.metalness = r))), i.add({ roughness: 0 }, "roughness").min(0).max(1).name("整体粗糙度").onChange((r) => t.forEach((s) => s.roughness != null && (s.roughness = r))), i.addFn(() => t.forEach((r) => r.needsUpdate = !0)).name("未变化手动更新");
  }(n.RootMaterials, e.addFolder("整体材质配置")), fS(n, e.addFolder("着色器配置"));
}
function wC(n, e, t) {
  function i(r, s, a = "") {
    s.type !== "ShaderMaterial" && (function(o, l) {
      l.add(o, "name").name("名称"), l.add(o, "visible").name("显示"), l.add(o, "wireframe").name("线框"), l.add(o, "transparent").name("透明"), l.add(o, "opacity", 0, 1).name("透明度"), l.addHexColor(o.color).name("颜色"), o.metalness != null && l.add(o, "metalness", 0, 1).name("金属度"), o.roughness != null && l.add(o, "roughness", 0, 1).name("粗糙度"), l.addFn(() => o.needsUpdate = !0).name("未变化手动更新");
    }(s, r.addFolder("材质配置" + a)), s.isCustomTexture && s.map && (function(o, l) {
      l.add(o, "wrapS", [vn, jt, fs]).name("水平环绕方式").onChange((h) => o.needsUpdate = !0), l.add(o, "wrapT", [vn, jt, fs]).name("垂直环绕方式").onChange((h) => o.needsUpdate = !0), l.add(o, "rotation").name("旋转").min(0).max(2 * Math.PI), l.add(o.repeat, "x").name("x重复"), l.add(o.repeat, "y").name("y重复"), l.add(o.offset, "x").name("x偏移").min(0).max(1), l.add(o.offset, "y").name("y偏移").min(0).max(1), l.add(o.center, "x").name("x中心").min(0).max(1), l.add(o.center, "y").name("y中心").min(0).max(1);
    }(s.map, r.addFolder("贴图配置" + a)), function(o, l, h) {
      Reflect.has(l, "textureAnimation") || (l.textureAnimation = { isTextureAnimation: !1, offset: { x: 0, y: 0 }, rotation: 0 }), h.add(l.textureAnimation, "isTextureAnimation").name("贴图动画").onChange((c) => {
        if (c)
          l.commonAnimateRender = function() {
            l.offset.x += l.textureAnimation.offset.x, l.offset.y += l.textureAnimation.offset.y, l.rotation += l.textureAnimation.rotation;
          }, o.push(l);
        else {
          delete l.commonAnimateRender;
          const u = o.findIndex((d) => d.uuid == l.uuid);
          u > -1 && o.splice(u, 1);
        }
      }), h.add(l.textureAnimation, "rotation").name("旋转速度"), h.add(l.textureAnimation.offset, "x").name("x偏移速度"), h.add(l.textureAnimation.offset, "y").name("y偏移速度");
    }(n, s.map, r.addFolder("贴图动画" + a))));
  }
  Dr(e, t.addFolder("基础配置")), Array.isArray(e.material) ? e.material.forEach((r, s) => i(t, r, s)) : i(t, e.material), e.disBlendShader || fS(e, t.addFolder("着色器配置"));
}
function _C(n, e) {
  let t = null;
  n.removeCall = (r) => {
    t === r && (e.removeFolder(i), i = null);
  };
  let i = null;
  e.createSelectPanel = (r) => {
    t = r, i && (e.removeFolder(i), i = null), i = e.addFolder((r.isMesh ? "[#]:" : "[$]:") + r.name + "配置"), i.open(), r.RootMaterials ? SC(r, i) : r.isMesh && wC(n.commonFrames, r, i), function(s, a = {}) {
      if (Cf && !Cf.val)
        return;
      const o = Xe.tags.div({ class: "van-div-datgui" });
      s.open();
      const l = `[${Date.now()}]`;
      o.appendChild(s.domElement);
      const h = Xe.state(a.width || "auto"), c = Xe.state(a.height || 500), u = Xe.state(!1);
      Cf = u;
      const d = md(Te({ title: l, closed: u, x: 100, y: 80, width: h, height: c }, Uh), o);
      Xe.add(document.body, d);
    }(e);
  };
}
function TC() {
  var t;
  Yi.TEXT_CLOSED = "收起场景配置", Yi.TEXT_OPEN = "展开场景配置", Yi.prototype.addDateFolder = function(i) {
    return this.addFolder(i + "[" + Date.now() + "]");
  }, Yi.prototype.addDragFolder = function(i, ...r) {
    const s = this.addFolder(i + "[" + Date.now() + "]");
    return s.vanFloatWindow = function(a, o = {}, l = () => {
    }) {
      const h = Xe.tags.div({ class: o.class });
      a.open();
      const c = a.name;
      a.name = "属性", h.appendChild(a.domElement);
      const u = Xe.state(o.width || "auto"), d = Xe.state(o.height || "auto"), p = Xe.state(!1);
      Xe.derive(() => {
        if (p.val) {
          const { parent: g } = a;
          delete g.rr[c], g.load && g.load.folders && g.load.folders[c] && delete g.load.folders[c], g.updateDisplay(), l();
        }
      });
      const m = md(Te({ title: c, closed: p, x: 100 + 600 * Math.random(), y: 50 + 400 * Math.random(), width: u, height: d }, Uh), h);
      return Xe.add(document.body, m), { floatingWindow: m, el: h };
    }(s, ...r), s;
  }, Yi.prototype.addCoreDragFolder = function(i, ...r) {
    const s = this.addFolder(i + "[" + Date.now() + "]");
    return s.vanFloatWindow = function(a, o = {}) {
      const l = Xe.tags.div({ class: "van-div-datgui" });
      a.open();
      const h = a.name;
      a.name = "管理", l.appendChild(a.domElement);
      const c = Xe.state(o.width || 280), u = Xe.state(o.height || 450), d = Xe.state(!1);
      Xe.derive(() => {
        if (d.val) {
          const { parent: m } = a;
          delete m.rr[h], m.load && m.load.folders && m.load.folders[h] && delete m.load.folders[h], m.updateDisplay();
        }
      });
      const p = md(Te({ title: h, closed: d, x: 60 + 400 * Math.random(), y: 90 * Math.random(), width: c, height: u }, Uh), l);
      return Xe.add(document.body, p), { floatingWindow: p, el: l };
    }(s, ...r), s;
  }, Yi.prototype.addFn = function(i, ...r) {
    return this.add({ fn: i }, "fn", ...r);
  }, Yi.prototype.addHexColor = function(i) {
    return this.addColor({ color: i.getHex() }, "color").onChange((r) => i.set(r));
  };
  const n = new Yi({ autoPlace: !1 });
  var e;
  return e = n, Object.defineProperty(e, "getAuthorization", { value: function() {
    return "";
  }, writable: !1, configurable: !1, enumerable: !1 }), (t = n.dr) == null || t.remove(), n;
}
function PS() {
  return new Li(new _(0, -1, 0), -0.1);
}
function RS(n, e = 20) {
  return n.helper = new DM(n, e, 16777215 * Math.random()), n.helper;
}
function Yx(n, e, t, i, r) {
  return r.add(i, "constant").name("偏移"), r.add(i.normal, "x", -1, 1), r.add(i.normal, "y", -1, 1), r.add(i.normal, "z", -1, 1), r.add({ showHelper: !!i.helper }, "showHelper").name("显示辅助线").onChange((s) => {
    s ? (!i.helper && RS(i, t.clipPlaneSize), n.add(i.helper)) : i.helper && n.remove(i.helper);
  }), r.addFn(() => {
    i.helper && n.remove(i.helper), e.clippingPlanes = e.clippingPlanes.filter((s) => s !== i), r.parent.removeFolder(r);
  }).name("删除"), r;
}
function EC(n) {
  return n.clippingPlanes.map((e) => ({ normal: { x: e.normal.x, y: e.normal.y, z: e.normal.z }, constant: e.constant }));
}
const AC = { No: $i, Linear: wd, Reinhard: _d, Cineon: Td, ACESFilmic: Ed, AgX: Ad, Custom: fg }, CC = { Basic: 0, PCF: yd, PCFSoft: pg, VSM: Ri };
function PC(n, e) {
  e && (n.outputColorSpace = e.outputColorSpace, n.toneMapping = e.toneMapping, n.toneMappingExposure = e.toneMappingExposure, n.shadowMap.enabled = e.shadowMap.enabled, n.shadowMap.type = e.shadowMap.type, n.setClearColor(e.color, e.opacity), n.sortObjects = e.sortObjects, n.localClippingEnabled = e.localClippingEnabled, function(t, i) {
    i && (t.clippingPlanes = i.map((r) => {
      const s = PS();
      return s.normal.set(r.normal.x, r.normal.y, r.normal.z), s.constant = r.constant, s;
    }));
  }(n, e.clippingPlanes));
}
function RC(n) {
  if (n)
    return { colorSpace: n.colorSpace };
}
function IC(n) {
  if (n)
    return { name: n.name, type: n instanceof zo ? "linear" : "exp2", density: n.density, color: n.color.getHex(), near: n.near, far: n.far };
}
function ag(n, ...e) {
  return n === "linear" ? new zo(...e) : new ko(...e);
}
function LC(n) {
  const { background: e } = n;
  return { backgroundBlurriness: n.backgroundBlurriness, backgroundIntensity: n.backgroundIntensity, backgroundUrls: n.background && n.backgroundUrls, envBackgroundUrls: n.envBackground && n.envBackgroundUrls, fog: IC(n.fog), environmentEnabled: n.environmentEnabled, background: RC(e) };
}
function NC(n, e) {
  e && (n.backgroundBlurriness = e.backgroundBlurriness, n.backgroundIntensity = e.backgroundIntensity, function(t, i) {
    if (!i)
      return;
    const r = ag(i.type);
    r.name = i.name, r.color.set(i.color), i.type === "linear" ? (r.near = i.near, r.far = i.far) : r.density = i.density, t.fog = r;
  }(n, e.fog), n.environmentEnabled = e.environmentEnabled, e.backgroundUrls && (n.backgroundLoadCallback = (t) => function(i, r) {
    r && (i.colorSpace = r.colorSpace);
  }(t, e.background), n.setSceneBackground(e.backgroundUrls)), e.envBackgroundUrls && n.setEnvBackground(e.envBackgroundUrls));
}
function DC(n, e) {
  if (!e)
    return;
  (function(i, r) {
    r.open();
    let s = null;
    const a = { type: i.fog instanceof ko ? "exp2" : "linear", enable: !!i.fog };
    function o(l) {
      s && (r.removeFolder(s), s = null), i.fog && (s = r.addFolder(l + "雾"), s.addHexColor(i.fog.color).name("颜色"), l === "linear" ? (s.add(i.fog, "near").name("近点"), s.add(i.fog, "far").name("远点")) : s.add(i.fog, "density").name("密度"));
    }
    r.add(a, "type", ["linear", "exp2"]).name("雾类型").onChange((l) => {
      var h;
      i.fog = ag(l, (h = i.fog) == null ? void 0 : h.color), o(l);
    }), r.add(a, "enable").name("启用雾").onChange((l) => {
      i.fog = l ? ag(a.type) : null, o(a.type);
    }), a.enable && o(a.type);
  })(n, e.addFolder("雾配置")), e.add(n, "environmentEnabled").name("全局环境贴图").onChange((i) => n.environment = i ? n.envBackground : null), e.add(n, "backgroundBlurriness", 0, 1).name("背景模糊度"), e.add(n, "backgroundIntensity", 0).name("背景强度");
  let t = null;
  return e.addFn(() => {
    t || (t = function(i, r) {
      if (r.open(), i)
        return r.add(i, "colorSpace", [mt, Jt]).name("色彩空间").onChange(() => {
          i.dispose(), i.needsUpdate = !0;
        }), r;
    }(n.background, e.addFolder("背景配置")));
  }).name("加载背景参数"), e;
}
function OC(n) {
  return { mode: n.mode, space: n.space, size: n.size, showX: n.showX, showY: n.showY, showZ: n.showZ, translationSnap: n.translationSnap, rotationSnap: n.rotationSnap, scaleSnap: n.scaleSnap };
}
function UC(n) {
  return { enabled: n.enabled, strength: n.strength, radius: n.radius, threshold: n.threshold };
}
function FC(n) {
  return { enabled: n.enabled, edgeStrength: n.edgeStrength, edgeGlow: n.edgeGlow, edgeThickness: n.edgeThickness, pulsePeriod: n.pulsePeriod, usePatternTexture: n.usePatternTexture, visibleEdgeColor: n.visibleEdgeColor.getHex(), hiddenEdgeColor: n.hiddenEdgeColor.getHex(), overlayMaterial: (e = n.overlayMaterial, { blending: e.blending, blendEquation: e.blendEquation, blendSrc: e.blendSrc, blendDst: e.blendDst }) };
  var e;
}
function BC(n, e) {
  return e.add(n, "enabled").name("轮廓光开启"), e.add(n, "edgeStrength").name("轮廓光强度"), e.add(n, "edgeGlow").name("轮廓光辉度"), e.add(n, "edgeThickness").name("轮廓光厚度"), e.add(n, "pulsePeriod").min(0).max(5).name("轮廓光脉冲周期"), e.add(n, "usePatternTexture").name("轮廓光纹理开启"), e.addHexColor(n.visibleEdgeColor).name("轮廓光颜色"), e.addHexColor(n.hiddenEdgeColor).name("轮廓光隐藏颜色"), function(t, i) {
    i.open(), i.add(t, "blending", m0).name("混合模式").onChange((r) => t.blending = Number(r)), i.add(t, "blendEquation", Z2).name("混合方程式").onChange((r) => t.blendingEquation = Number(r)), i.add(t, "blendSrc", K2).name("混合源").onChange((r) => t.blendingSrc = Number(r)), i.add(t, "blendDst", J2).name("混合目标").onChange((r) => t.blendingDst = Number(r));
  }(n.overlayMaterial, e.addFolder("边缘混合")), e;
}
function kC(n) {
  return { enabled: n.enabled, multPixel: n.multPixel };
}
function zC(n) {
  if (!n)
    return;
  const { uniforms: e } = n;
  return { enabled: n.enabled, intensity: e.intensity.value, maskColor: e.maskColor.value.getHex(), R: e.R.value, sr: e.sr.value };
}
function VC(n) {
  return { enabled: n.enabled, saoBias: n.params.saoBias, saoIntensity: n.params.saoIntensity, saoScale: n.params.saoScale, saoKernelRadius: n.params.saoKernelRadius, saoMinResolution: n.params.saoMinResolution, saoBlur: n.params.saoBlur, saoBlurRadius: n.params.saoBlurRadius, saoBlurStdDev: n.params.saoBlurStdDev, saoBlurDepthCutoff: n.params.saoBlurDepthCutoff };
}
function HC(n) {
  return { enabled: n.enabled, maxDistance: n.maxDistance, distanceAttenuation: n.distanceAttenuation, opacity: n.opacity, thickness: n.thickness, fresnel: n.fresnel, infiniteThick: n.infiniteThick, bouncing: n.bouncing };
}
function GC(n) {
  const { saoPass: e, unrealBloomPass: t, ssrPass: i, outlinePass: r, fxaaPass: s, screenMaskPass: a } = n.effectPass;
  return { renderWay: n.renderWay, saoPass: VC(e), unrealBloomPass: UC(t), ssrPass: HC(i), outlinePass: FC(r), fxaaPass: kC(s), screenMaskPass: zC(a) };
}
function jC(n, e, t, i, r, s) {
  return { scene: LC(n), perspectiveCamera: (l = e, { fov: l.fov, near: l.near, far: l.far, zoom: l.zoom, layers: v0(l.layers), position: { x: l.position.x, y: l.position.y, z: l.position.z } }), webglRenderer: (o = t, { outputColorSpace: o.outputColorSpace, toneMapping: o.toneMapping, toneMappingExposure: o.toneMappingExposure, shadowMap: { enabled: o.shadowMap.enabled, type: o.shadowMap.type }, color: o.getClearColor(new oe()).getHex(), opacity: o.getClearAlpha(), sortObjects: o.sortObjects, localClippingEnabled: o.localClippingEnabled, clippingPlanes: EC(o) }), orbitControls: (a = i, { maxPolarAngle: a.maxPolarAngle, autoRotate: a.autoRotate, autoRotateSpeed: a.autoRotateSpeed, rotateSpeed: a.rotateSpeed, panSpeed: a.panSpeed, zoomSpeed: a.zoomSpeed, enableDamping: a.enableDamping, dampingFactor: a.dampingFactor, minDistance: a.minDistance, maxDistance: a.maxDistance, target: { x: a.target.x, y: a.target.y, z: a.target.z }, viewAngleList: a.viewAngleList }), transformControls: OC(r), effectComposer: GC(s) };
  var a, o, l;
}
function WC(n, e, t, i, r, s, a) {
  a && (PC(t, a.webglRenderer), function(o, l) {
    if (!l)
      return;
    const { saoPass: h, unrealBloomPass: c, ssrPass: u, outlinePass: d, fxaaPass: p, screenMaskPass: m } = o.effectPass;
    o.setRenderWay(l.renderWay), function(g, f) {
      f && (g.enabled = f.enabled, g.params.saoBias = f.saoBias, g.params.saoIntensity = f.saoIntensity, g.params.saoScale = f.saoScale, g.params.saoKernelRadius = f.saoKernelRadius, g.params.saoMinResolution = f.saoMinResolution, g.params.saoBlur = f.saoBlur, g.params.saoBlurRadius = f.saoBlurRadius, g.params.saoBlurStdDev = f.saoBlurStdDev, g.params.saoBlurDepthCutoff = f.saoBlurDepthCutoff);
    }(h, l.saoPass), function(g, f) {
      f && (g.enabled = f.enabled, g.strength = f.strength, g.radius = f.radius, g.threshold = f.threshold);
    }(c, l.unrealBloomPass), function(g, f) {
      f && (g.enabled = f.enabled, g.maxDistance = f.maxDistance, g.distanceAttenuation = f.distanceAttenuation, g.opacity = f.opacity, g.thickness = f.thickness, g.fresnel = f.fresnel, g.infiniteThick = f.infiniteThick, g.bouncing = f.bouncing);
    }(u, l.ssrPass), function(g, f) {
      f && (g.enabled = f.enabled, g.edgeStrength = f.edgeStrength, g.edgeGlow = f.edgeGlow, g.edgeThickness = f.edgeThickness, g.pulsePeriod = f.pulsePeriod, g.usePatternTexture = f.usePatternTexture, g.visibleEdgeColor.setHex(f.visibleEdgeColor), g.hiddenEdgeColor.setHex(f.hiddenEdgeColor), function(v, y) {
        y && (v.blending = y.blending, v.blendEquation = y.blendEquation, v.blendSrc = y.blendSrc, v.blendDst = y.blendDst);
      }(g.overlayMaterial, f.overlayMaterial));
    }(d, l.outlinePass), function(g, f) {
      f && (g.enabled = f.enabled, g.multPixel != f.multPixel && (g.multPixel = f.multPixel, g.resize()));
    }(p, l.fxaaPass), function(g, f) {
      if (!g)
        return;
      const { uniforms: v } = g;
      f && (g.enabled = f.enabled, v.intensity.value = f.intensity, v.maskColor.value.set(f.maskColor), v.R.value = f.R, v.sr.value = f.sr);
    }(m, l.screenMaskPass);
  }(s, a.effectComposer), NC(n, a.scene), function(o, l) {
    l && (o.fov = l.fov, o.near = l.near, o.far = l.far, o.zoom = l.zoom, o.position.set(l.position.x, l.position.y, l.position.z), y0(o.layers, l.layers), o.updateProjectionMatrix());
  }(e, a.perspectiveCamera), function(o, l) {
    l && (o.maxPolarAngle = l.maxPolarAngle, o.autoRotate = l.autoRotate, o.autoRotateSpeed = l.autoRotateSpeed, o.rotateSpeed = l.rotateSpeed, o.panSpeed = l.panSpeed, o.zoomSpeed = l.zoomSpeed, o.enableDamping = l.enableDamping, o.dampingFactor = l.dampingFactor, o.minDistance = l.minDistance, o.maxDistance = l.maxDistance, o.target.set(l.target.x, l.target.y, l.target.z), o.viewAngleList = l.viewAngleList, o.update());
  }(i, a.orbitControls), function(o, l) {
    l && (o.mode = l.mode, o.space = l.space, o.size = l.size, o.showX = l.showX, o.showY = l.showY, o.showZ = l.showZ, o.translationSnap = l.translationSnap, o.rotationSnap = l.rotationSnap, o.scaleSnap = l.scaleSnap);
  }(r, a.transformControls));
}
function XC(n, e, t, i, r, s, a) {
  const o = { 渲染配置: () => function(l, h) {
    return h.addColor({ color: l.getClearColor(new oe()).getHex() }, "color").onChange((c) => l.setClearColor(c, l.getClearAlpha())).name("渲染器背景色"), h.add({ opacity: l.getClearAlpha() }, "opacity").min(0).max(1).onChange((c) => l.setClearAlpha(c)).name("渲染器背景透明度"), h.add(l, "outputColorSpace", [mt, Jt]).name("渲染器输出编码"), h.add(l, "toneMapping", AC).name("色调映射").onChange((c) => l.toneMapping = Number(c)), h.add(l, "toneMappingExposure").min(0).max(50).name("色调映射曝光度"), h.add(l.shadowMap, "enabled").name("阴影贴图"), h.add(l.shadowMap, "type", CC).name("阴影贴图类型").onChange((c) => l.shadowMap.type = Number(c)), h.add(l, "sortObjects").name("排序对象"), h.add(l, "localClippingEnabled").name("裁剪"), h;
  }(t, a.addDragFolder("渲染配置")), 相机配置: () => function(l, h) {
    const c = () => l.updateProjectionMatrix();
    return x0(l.layers, h), h.add(l, "fov").min(0).name("视角").onChange(c), h.add(l, "near").min(1e-3).name("近平面").onChange(c), h.add(l, "far").min(0).name("远平面").onChange(c), h.add(l, "zoom").min(0).name("缩放").onChange(c), h.add(l.position, "x").name("相机位置x"), h.add(l.position, "y").name("相机位置y"), h.add(l.position, "z").name("相机位置z"), h;
  }(e, a.addDragFolder("相机配置")), 轨道配置: () => function(l, h) {
    return h.add(l, "autoRotate").name("自动旋转"), h.add(l, "autoRotateSpeed", 0, 10).name("自动旋转速度"), h.add(l, "enableDamping").name("阻尼"), h.add(l, "dampingFactor", 0, 1).name("阻尼系数"), h.add(l, "minDistance", 0).name("最小距离"), h.add(l, "maxDistance", 0).name("最大距离"), h.add(l, "maxPolarAngle", 0, 2 * Math.PI).name("最大仰角"), h.add(l, "rotateSpeed").name("旋转速度"), h.add(l, "panSpeed").name("平移速度"), h.add(l, "zoomSpeed").name("缩放速度"), h.add(l.target, "x").name("目标位置x"), h.add(l.target, "y").name("目标位置y"), h.add(l.target, "z").name("目标位置z"), h;
  }(i, a.addDragFolder("轨道配置")), 变换配置: () => function(l, h) {
    return h.add(l, "mode", { 平移: "translate", 旋转: "rotate", 缩放: "scale" }).name("模式"), h.add(l, "space", { 局部: "local", 世界: "world" }).name("坐标系"), h.add(l, "size").name("大小"), h.add(l, "showX").name("显示X"), h.add(l, "showY").name("显示Y"), h.add(l, "showZ").name("显示Z"), !l.rotationSnap && (l.rotationSnap = 0), !l.translationSnap && (l.translationSnap = 0), !l.scaleSnap && (l.scaleSnap = 0), h.add(l, "translationSnap").name("平移步长"), h.add(l, "rotationSnap").name("旋转步长"), h.add(l, "scaleSnap").name("缩放步长"), h;
  }(r, a.addDragFolder("变换配置")), 环境配置: () => DC(n, a.addDragFolder("环境配置")), 后期处理: () => function(l, h) {
    const { saoPass: c, unrealBloomPass: u, ssrPass: d, outlinePass: p, fxaaPass: m, screenMaskPass: g } = l.effectPass;
    h.add(l, "renderWay", ["源渲染", "效果渲染"]).name("渲染方式").onChange((v) => l.setRenderWay(v));
    const f = { 环境光遮蔽配置: () => function(v, y) {
      return y.add(v, "enabled").name("启用"), y.add(v.params, "saoBias").name("偏移"), y.add(v.params, "saoIntensity").name("强度"), y.add(v.params, "saoScale", 0).name("缩放"), y.add(v.params, "saoKernelRadius", 0).name("半径"), y.add(v.params, "saoMinResolution", 0).name("最小分辨率"), y.add(v.params, "saoBlur").name("模糊"), y.add(v.params, "saoBlurRadius", 0).name("模糊半径"), y.add(v.params, "saoBlurStdDev").name("模糊标准差"), y.add(v.params, "saoBlurDepthCutoff").name("模糊深度截断"), y;
    }(c, h.addDragFolder("环境光遮蔽配置")), 泛光配置: () => function(v, y) {
      return y.add(v, "enabled").name("泛光开启"), y.add(v, "strength").min(0).max(3).name("泛光强度"), y.add(v, "radius").min(0).max(1).name("泛光半径"), y.add(v, "threshold").min(0).max(1).name("泛光阈值"), y;
    }(u, h.addDragFolder("泛光配置")), 屏幕空间反射配置: () => function(v, y) {
      return y.add(v, "enabled").name("开启屏幕空间反射"), y.add(v, "maxDistance").name("最大距离"), y.add(v, "distanceAttenuation").name("距离衰减"), y.add(v, "opacity").name("透明度"), y.add(v, "thickness").name("厚度"), y.add(v, "fresnel").name("菲涅尔"), y.add(v, "infiniteThick").name("无限厚度"), y.add(v, "bouncing").name("反弹"), y;
    }(d, h.addDragFolder("屏幕空间反射配置")), 轮廓光配置: () => BC(p, h.addDragFolder("轮廓光配置")), 抗锯齿配置: () => function(v, y) {
      return y.add(v, "enabled").name("开启"), y.add(v, "multPixel").name("像素倍数").onChange(v.resize), y;
    }(m, h.addDragFolder("抗锯齿配置")), 屏幕遮罩配置: () => function(v, y) {
      const { uniforms: x } = v;
      return y.add(v, "enabled").name("启用"), y.addHexColor(x.maskColor.value).name("颜色"), y.add(x.intensity, "value").name("强度"), y.add(x.R, "value").name("半径"), y.add(x.sr, "value").name("sr参数"), y;
    }(g, h.addDragFolder("屏幕遮罩配置")) };
    for (const v in f)
      h.add(f, v);
    return h.panels = f, h;
  }(s, a.addDragFolder("后期处理")) };
  for (const l in o)
    a.add(o, l);
  return { folder: a, panels: o };
}
function Zx(n, e) {
  const { list: t, reList: i, index: r } = n;
  if (e === "z") {
    const s = t.at(r);
    s && (ud(s.object, s.transform), n.index -= 1);
  } else if (e === "y") {
    if (r === -1)
      return;
    const s = i.at(r + 1);
    s && (ud(s.object, s.transform), n.index += 1);
  }
}
function Pf(n, e, t) {
  if (!n.currentInfo || n.mode !== "变换")
    return;
  const { object: i } = n.transformControls;
  i.rotation[e] += t * Math.PI / 180;
}
function Fh(n, e) {
  e.axesHelper && (n.remove(e.axesHelper), e.axesHelper.geometry.dispose(), e.axesHelper.material.dispose(), e.axesHelper = null), e.showAxes && (e.axesHelper = function(t = 1e3) {
    const i = new OM(t);
    return i.name = "AxesHelper", i;
  }(e.axesLength), n.add(e.axesHelper));
}
function Kr(n, e) {
  e.gridHelper && (n.remove(e.gridHelper), e.gridHelper.geometry.dispose(), e.gridHelper.material.dispose(), e.gridHelper = null), e.showGrid && (e.gridHelper = function(t = 1e3, i = 15, r = 4473924, s = 8947848) {
    const a = new LM(t, i, r, s);
    return a.name = "GridHelper", a;
  }(e.size, e.divisions, e.colorCenterLine, e.colorGrid), n.add(e.gridHelper));
}
function og(n, e, t) {
  e.box3Helper && (n.remove(e.box3Helper), e.box3Helper.geometry.dispose(), e.box3Helper.material.dispose(), e.box3Helper = null), t.useBox3 && (e.box3Helper = function(i = 16776960) {
    const r = new yt(), s = new NM(r, i);
    return s.name = "Box3Helper", s.visible = !1, s;
  }(t.color), n.add(e.box3Helper), e.object && (e.box3Helper.box = new yt().setFromObject(e.object), e.box3Helper.visible = !0));
}
function qC(n) {
  return { axes: (i = n.axes, { showAxes: i.showAxes, axesLength: i.axesLength }), grid: (t = n.grid, { showGrid: t.showGrid, size: t.size, divisions: t.divisions, colorCenterLine: t.colorCenterLine, colorGrid: t.colorGrid }), box3: (e = n.box3, { useBox3: e.useBox3, color: e.color }) };
  var e, t, i;
}
function YC(n, e, t, i) {
  i && (function(r, s, a) {
    a && (s.showAxes = a.showAxes, s.axesLength = a.axesLength, Fh(r, s));
  }(n, t.axes, i.axes), function(r, s, a) {
    a && (s.showGrid = a.showGrid, s.size = a.size, s.divisions = a.divisions, s.colorCenterLine = a.colorCenterLine, s.colorGrid = a.colorGrid, Kr(r, s));
  }(n, t.grid, i.grid), function(r, s, a, o) {
    o && (a.useBox3 = o.useBox3, a.color = o.color, og(r, s, a));
  }(n, e, t.box3, i.box3));
}
function ZC(n, e, t, i) {
  const { axes: r, grid: s, box3: a } = t;
  return function(o, l, h, c) {
    c.open(), c.add(h, "useBox3").name("使用Box3").listen().onChange(() => og(o, l, h)), c.addColor(h, "color").name("颜色").onFinishChange(() => og(o, l, h));
  }(n, e, a, i.addFolder("Box3")), function(o, l, h) {
    h.open(), h.add(l, "showGrid").name("显示网格").listen().onChange(() => Kr(o, l)), h.add(l, "size").name("大小").onFinishChange(() => Kr(o, l)).min(1), h.add(l, "divisions").name("分割数").onFinishChange(() => Kr(o, l)).min(1), h.addColor(l, "colorCenterLine").name("中心线颜色").onFinishChange(() => Kr(o, l)), h.addColor(l, "colorGrid").name("网格颜色").onFinishChange(() => Kr(o, l));
  }(n, s, i.addFolder("网格")), function(o, l, h) {
    h.open(), h.add(l, "showAxes").name("显示坐标轴").listen().onChange(() => Fh(o, l)), h.add(l, "axesLength").name("长度").onFinishChange(() => Fh(o, l));
  }(n, r, i.addFolder("坐标轴")), i;
}
function KC(n) {
  const { showStats: e, statsMode: t } = n;
  return { showStats: e, statsMode: t };
}
function gd(n) {
  n.showStats ? (n.created(), n.setMode(Number(n.statsMode))) : n.destroy();
}
function JC(n, e, t, i, r) {
  t.transformControls = i, t.outlinePass = r, t.stats = e, t.keyDown = /* @__PURE__ */ function(s, a) {
    function o(l, h) {
      if (!a.object)
        return;
      const c = a.object;
      switch (a.mode) {
        case "translate":
          c.position[l] += h;
          break;
        case "scale":
          c.scale[l] += 1e-3 * h * c.scale[l];
          break;
        case "rotate":
          c.rotation[l] += h * Math.PI / 360;
      }
    }
    return function(l) {
      var h, c, u;
      if (l.target.tagName !== "INPUT" && !l.ctrlKey) {
        switch (l.key) {
          case "1":
            s.mode = "选择";
            break;
          case "2":
            s.mode = "根选择";
            break;
          case "3":
            s.mode = "变换";
            break;
          case "4":
            s.mode = "场景绘制";
            break;
          case "5":
            s.mode = "点击信息";
            break;
          case "Tab":
            const { currentInfo: d } = s;
            d && (s.mode === "选择" ? a.attach(d.currentModel) : s.mode === "根选择" ? a.attach(d.currentRootModel) : s.mode === "变换" && (l.preventDefault(), l.shiftKey ? a.setSpace(a.space === "local" ? "world" : "local") : (s.isTransformChildren = !s.isTransformChildren, a.detach())));
            break;
          case "Delete":
            if (!s.currentInfo)
              break;
            const { currentModel: p, currentRootModel: m } = s.currentInfo;
            if (s.mode === "选择" && p)
              (p == null ? void 0 : p.parent.type) === "Scene" ? p.parent.remove(p) : p.visible = !1;
            else if (s.mode === "根选择" && m)
              (h = m.parent) == null || h.remove(m);
            else if (s.mode === "变换" && m && !s.isTransformChildren) {
              const g = a.object || m;
              (c = g.parent) == null || c.remove(g);
            } else
              s.mode === "变换" && p && s.isTransformChildren && (p.visible = !1);
            break;
          case "g":
            a.setMode("translate");
            break;
          case "t":
            a.setMode("scale");
            break;
          case "r":
            a.setMode("rotate");
            break;
          case "w":
            o("y", 1);
            break;
          case "s":
            o("y", -1);
            break;
          case "a":
            o("x", -1);
            break;
          case "d":
            o("x", 1);
            break;
          case "q":
            o("z", 1);
            break;
          case "e":
            o("z", -1);
            break;
          case "z":
            Zx(s.handlerHistory, "z");
            break;
          case "y":
            Zx(s.handlerHistory, "y");
            break;
          case "X":
            Pf(s, "x", 90);
            break;
          case "Y":
            Pf(s, "y", 90);
            break;
          case "Z":
            Pf(s, "z", 90);
            break;
          case "Escape":
            s.outlinePass.selectedObjects = [];
        }
        (u = s.keyDownCallback) == null || u.call(s, l.key);
      }
    };
  }(t, i), Fh(n, t.helpers.axes), Kr(n, t.helpers.grid), t.keyDownCallback = () => {
  }, t.setHandlerOption = (s, a) => {
    switch (s) {
      case "stats":
        e.showStats = a, gd(e);
        break;
      case "axes":
        t.helpers.axes.showAxes = a, Fh(n, t.helpers.axes);
        break;
      case "grid":
        t.helpers.grid.showGrid = a, Kr(n, t.helpers.grid);
        break;
      case "openKey":
        t.openKey = a, w0(t.keyDown, a);
    }
  }, t.handlerHistory = function(s) {
    const a = { list: [], reList: [], index: -1 };
    return s.drag_change_callback = function(o) {
      a.index = -1;
      const { list: l, reList: h } = a, { object: c } = s;
      o ? l.push({ object: c, transform: vo(c) }) : h.push({ object: c, transform: vo(c) });
    }, a;
  }(i);
}
function QC(n) {
  const { mode: e, openKey: t, selectPanelEnable: i, isTransformChildren: r, stats: s, helpers: a } = n;
  return { mode: e, openKey: t, selectPanelEnable: i, isTransformChildren: r, stats: KC(s), helpers: qC(a) };
}
function $C(n, e, t, i, r) {
  r && (i.mode = r.mode, i.openKey = r.openKey, i.selectPanelEnable = r.selectPanelEnable, r.openKey && w0(i.keyDown, r.openKey), i.isTransformChildren = r.isTransformChildren, function(s, a) {
    if (!a)
      return;
    const { showStats: o, statsMode: l } = a;
    s.showStats = o, s.statsMode = l, gd(s);
  }(t, r.stats), YC(n, e, i.helpers, r.helpers));
}
function eP(n, e, t, i, r) {
  const { helpers: s } = i;
  r.add(i, "mode", i.modeList).name("模式").listen(), r.add(i, "isTransformChildren").name("子变换").listen(), r.add(i, "selectPanelEnable").name("选择弹窗").listen(), r.add(i, "openKey").name("开启按键").listen().onChange((o) => w0(i.keyDown, o));
  const a = { 同步控制: () => function(o, l) {
    const h = l.addFolder("旋转控制");
    h.open();
    const c = { axies: "x", rotation: 0, resetFn() {
      var f, v, y;
      (y = (v = (f = o.currentInfo) == null ? void 0 : f.currentRootModel) == null ? void 0 : v.rotation) == null || y.set(0, 0, 0);
    }, setFn() {
      var f;
      (f = o.currentInfo) != null && f.currentRootModel && (o.currentInfo.currentRootModel.rotation[this.axies] += this.rotation / 180 * Math.PI);
    } };
    h.add(c, "axies", ["x", "y", "z"]).name("旋转轴"), h.add(c, "rotation").name("旋转角度"), h.add(c, "resetFn").name("旋转归零"), h.add(c, "setFn").name("应用");
    const u = l.addFolder("记录信息"), d = { recordModel: null, recordFn() {
      var f;
      for (this.recordModel = (f = o.currentInfo) == null ? void 0 : f.currentRootModel; u.ar.length > 0; )
        u.ar[0].remove();
      this.recordModel && (u.open(), u.add(this.recordModel, "visible").name("显示"), u.add(this.recordModel, "name").name("模型名称"), u.add(this.recordModel, "id").name("模型id"), u.addFn(() => {
        var v;
        return (v = o.currentInfo) == null ? void 0 : v.currentRootModel.position.copy(this.recordModel.position);
      }).name("选中模型位置与记录同步"), u.addFn(() => {
        var v;
        return (v = o.currentInfo) == null ? void 0 : v.currentRootModel.rotation.copy(this.recordModel.rotation);
      }).name("选中模型旋转与记录同步"), u.addFn(() => {
        var v;
        return (v = o.currentInfo) == null ? void 0 : v.currentRootModel.scale.copy(this.recordModel.scale);
      }).name("选中模型缩放与记录同步"));
    }, syncTransformList: [], syncTransformFn() {
      var f;
      if ((f = o.currentInfo) != null && f.currentRootModel && this.syncTransformList.indexOf(o.currentInfo.currentRootModel) === -1) {
        p.open();
        const v = o.currentInfo.currentRootModel;
        this.syncTransformList.push(v);
        const y = p.addDateFolder(v.id);
        y.add(v, "visible").name("显示"), y.addFn(() => {
          const x = this.syncTransformList.indexOf(v);
          x > -1 && this.syncTransformList.splice(x, 1), p.removeFolder(y);
        }).name("移除同步变换列表");
      }
    } };
    l.add(d, "recordFn").name("#记录根选择模型信息");
    const p = l.addFolder("同步变换列表");
    l.add(d, "syncTransformFn").name("#加入同步变换列表");
    const m = p.addFolder("列表变换同步操作"), g = { position: { x: 0, y: 0, z: 0 }, rotation: { x: 0, y: 0, z: 0 }, scale: { x: 0, y: 0, z: 0 }, oldPosition: { x: 0, y: 0, z: 0 }, oldRotation: { x: 0, y: 0, z: 0 }, oldScale: { x: 0, y: 0, z: 0 } };
    return ["x", "y", "z"].forEach((f) => m.add(g.position, f).name("位置" + f).onChange((v) => {
      d.syncTransformList.forEach((y) => y.position[f] += v - g.oldPosition[f]), g.oldPosition[f] = v;
    })), ["x", "y", "z"].forEach((f) => m.add(g.rotation, f, -2 * Math.PI, 2 * Math.PI).name("旋转" + f).onChange((v) => {
      d.syncTransformList.forEach((y) => y.rotation[f] += v - g.oldRotation[f]), g.oldRotation[f] = v;
    })), ["x", "y", "z"].forEach((f) => m.add(g.scale, f).step(0.01).name("缩放" + f).onChange((v) => {
      d.syncTransformList.forEach((y) => y.scale[f] += y.scale[f] * (v - g.oldScale[f])), g.oldScale[f] = v;
    })), l;
  }(i, r.addDragFolder("同步控制")), 性能监控: () => function(o, l) {
    return l.add(o, "showStats").name("开启").listen().onChange(() => gd(o)), l.add(o, "statsMode", { fps: 0, ms: 1, mb: 2 }).name("模式").listen().onChange(() => gd(o)), l;
  }(t, r.addDragFolder("性能监控")), 辅助工具: () => ZC(n, e, s, r.addDragFolder("辅助工具")) };
  for (const o in a)
    r.add(a, o);
  return { folder: r, panels: a };
}
function w0(n, e) {
  e ? document.addEventListener("keydown", n) : document.removeEventListener("keydown", n);
}
function tP(n) {
  if (!n)
    return;
  const { camera: e } = n;
  return { bias: n.bias, radius: n.radius, mapSize: n.mapSize, normalBias: n.normalBias, camera: e ? { near: e.near, far: e.far, fov: e.fov, left: e.left, right: e.right, top: e.top, bottom: e.bottom } : null };
}
function nP(n) {
  switch (n.type) {
    case "DirectionalLight":
      return { target: { x: n.target.position.x, y: n.target.position.y, z: n.target.position.z } };
    case "PointLight":
      return { distance: n.distance, decay: n.decay, power: n.power };
    case "SpotLight":
      return { distance: n.distance, decay: n.decay, power: n.power, angle: n.angle, penumbra: n.penumbra };
    case "HemisphereLight":
      return { groundColor: n.groundColor };
    case "RectAreaLight":
      return { width: n.width, height: n.height, rotation: { x: n.rotation.x, y: n.rotation.y, z: n.rotation.z } };
  }
}
function _0(n, e = {}) {
  let t = null;
  switch (n) {
    case "AmbientLight":
    default:
      t = iP(e);
      break;
    case "DirectionalLight":
      t = function(i = {}) {
        return new yh(i.color || 16777215, i.intensity || 1);
      }(e);
      break;
    case "PointLight":
      t = function(i = {}) {
        return new Wo(i.color || 16777215, i.intensity || 1, i.distance || 0, i.decay || 0);
      }(e);
      break;
    case "SpotLight":
      t = function(i = {}) {
        return new vh(i.color || 16777215, i.intensity || 1, i.distance || 0, i.angle || Math.PI / 3, i.penumbra || 0, i.decay || 0);
      }(e);
      break;
    case "HemisphereLight":
      t = function(i = {}) {
        return new Dm(i.color || 16777215, i.groundColor || 0, i.intensity || 1);
      }(e);
      break;
    case "RectAreaLight":
      t = function(i = {}) {
        return new Om(i.color || 16777215, i.intensity || 1, i.width || 100, i.height || 100);
      }(e);
  }
  return t;
}
function iP(n = {}) {
  return new Yu(n.color || 16777215, n.intensity || 1);
}
function rP(n, e) {
  e && (n.name = e.name, n.visible = e.visible, n.color.set(e.color), n.intensity = e.intensity, n.castShadow = e.castShadow, n.position.set(e.position.x, e.position.y, e.position.z), y0(n.layers, e.layers), function(t, i) {
    if (!i)
      return;
    t.bias = i.bias, t.radius = i.radius, t.mapSize.set(i.mapSize.x, i.mapSize.y), t.normalBias = i.normalBias;
    const { camera: r } = i;
    r && t.camera && (Object.keys(r).forEach((s) => t.camera[s] = r[s]), t.camera.updateProjectionMatrix());
  }(n.shadow, e.shadow), function(t, i) {
    if (i)
      switch (t.type) {
        case "DirectionalLight":
          t.target.position.set(i.target.x, i.target.y, i.target.z);
          break;
        case "PointLight":
          t.distance = i.distance, t.decay = i.decay, t.power = i.power;
          break;
        case "SpotLight":
          t.distance = i.distance, t.decay = i.decay, t.power = i.power, t.angle = i.angle, t.penumbra = i.penumbra;
          break;
        case "HemisphereLight":
          t.groundColor.set(i.groundColor);
          break;
        case "RectAreaLight":
          t.width = i.width, t.height = i.height, t.rotation.set(i.rotation.x, i.rotation.y, i.rotation.z);
      }
  }(n, e));
}
function Kx(n, e, t) {
  if (e.add(n, "visible").name("可见性"), e.add(n, "name").name("名称"), e.addHexColor(n.color).name("颜色"), e.add(n, "intensity").name("强度"), x0(n.layers, e), e.addFn(() => t.attach(n)).name("拖拽控制"), e.addFn(() => {
    const s = n.parent;
    n.target && s.remove(n.target), s.remove(n), n.dispose(), e.parent.removeFolder(e);
  }).name("删除"), n.shadow) {
    e.add(n, "castShadow").name("投影");
    const s = e.addFolder("阴影配置");
    (function(a, o) {
      o.add(a, "bias").name("偏移"), o.add(a, "radius").name("半径"), o.add(a, "normalBias").name("法线偏移"), o.add(a.mapSize, "width").name("阴影贴图宽度"), o.add(a.mapSize, "height").name("阴影贴图高度");
      const l = o.addFolder("投影相机"), h = () => a.camera.updateProjectionMatrix();
      l.add(a.camera, "near").name("近平面").onChange(h), l.add(a.camera, "far").name("远平面").onChange(h), a.camera.isOrthographicCamera ? (l.add(a.camera, "left").name("左平面").onChange(h), l.add(a.camera, "right").name("右平面").onChange(h), l.add(a.camera, "top").name("上平面").onChange(h), l.add(a.camera, "bottom").name("下平面").onChange(h)) : l.add(a.camera, "fov").name("视角").onChange(h);
    })(n.shadow, s);
  }
  const i = e.addFolder("变换配置");
  i.add(n.position, "x").name("位置X"), i.add(n.position, "y").name("位置y"), i.add(n.position, "z").name("位置z");
  const r = e.addFolder("特定配置");
  (function(s, a, o) {
    switch (a.type) {
      case "DirectionalLight":
        o.add(a.target.position, "x").name("目标X").listen(), o.add(a.target.position, "y").name("目标Y").listen(), o.add(a.target.position, "z").name("目标Z").listen(), o.addFn(() => s.attach(a.target)).name("拖拽目标");
        break;
      case "PointLight":
        o.add(a, "distance").name("距离"), o.add(a, "decay").name("衰减"), o.add(a, "power").name("功率");
        break;
      case "SpotLight":
        o.add(a, "distance").name("距离"), o.add(a, "decay").name("衰减"), o.add(a, "power").name("功率"), o.add(a, "angle").name("角度"), o.add(a, "penumbra").name("边缘");
        break;
      case "HemisphereLight":
        o.addHexColor(a.groundColor).name("基色");
        break;
      case "RectAreaLight":
        o.add(a.rotation, "x").name("旋转X").min(-Math.PI / 2).max(Math.PI / 2), o.add(a.rotation, "y").name("旋转y").min(-Math.PI / 2).max(Math.PI / 2), o.add(a.rotation, "z").name("旋转z").min(-Math.PI / 2).max(Math.PI / 2), o.add(a, "width").name("宽度"), o.add(a, "height").name("高度");
    }
  })(t, n, r);
}
function sP(n) {
  return n.map((e) => function(t) {
    const { name: i, type: r, visible: s, position: a, color: o, intensity: l, castShadow: h, layers: c, shadow: u } = t;
    return Te({ name: i, type: r, visible: s, position: a, color: o, intensity: l, castShadow: h, layers: v0(c), shadow: tP(u) }, nP(t));
  }(e));
}
var gi = Uint8Array, yo = Uint16Array, aP = Int32Array, IS = new gi([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), LS = new gi([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), oP = new gi([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), NS = function(n, e) {
  for (var t = new yo(31), i = 0; i < 31; ++i)
    t[i] = e += 1 << n[i - 1];
  var r = new aP(t[30]);
  for (i = 1; i < 30; ++i)
    for (var s = t[i]; s < t[i + 1]; ++s)
      r[s] = s - t[i] << 5 | i;
  return { b: t, r };
}, DS = NS(IS, 2), OS = DS.b, lP = DS.r;
OS[28] = 258, lP[258] = 28;
for (var hP = NS(LS, 0).b, lg = new yo(32768), vt = 0; vt < 32768; ++vt) {
  var Ws = (43690 & vt) >> 1 | (21845 & vt) << 1;
  Ws = (61680 & (Ws = (52428 & Ws) >> 2 | (13107 & Ws) << 2)) >> 4 | (3855 & Ws) << 4, lg[vt] = ((65280 & Ws) >> 8 | (255 & Ws) << 8) >> 1;
}
var ih = function(n, e, t) {
  for (var i = n.length, r = 0, s = new yo(e); r < i; ++r)
    n[r] && ++s[n[r] - 1];
  var a, o = new yo(e);
  for (r = 1; r < e; ++r)
    o[r] = o[r - 1] + s[r - 1] << 1;
  if (t) {
    a = new yo(1 << e);
    var l = 15 - e;
    for (r = 0; r < i; ++r)
      if (n[r])
        for (var h = r << 4 | n[r], c = e - n[r], u = o[n[r] - 1]++ << c, d = u | (1 << c) - 1; u <= d; ++u)
          a[lg[u] >> l] = h;
  } else
    for (a = new yo(i), r = 0; r < i; ++r)
      n[r] && (a[r] = lg[o[n[r] - 1]++] >> 15 - n[r]);
  return a;
}, ec = new gi(288);
for (vt = 0; vt < 144; ++vt)
  ec[vt] = 8;
for (vt = 144; vt < 256; ++vt)
  ec[vt] = 9;
for (vt = 256; vt < 280; ++vt)
  ec[vt] = 7;
for (vt = 280; vt < 288; ++vt)
  ec[vt] = 8;
var US = new gi(32);
for (vt = 0; vt < 32; ++vt)
  US[vt] = 5;
var cP = ih(ec, 9, 1), uP = ih(US, 5, 1), Rf = function(n) {
  for (var e = n[0], t = 1; t < n.length; ++t)
    n[t] > e && (e = n[t]);
  return e;
}, Ci = function(n, e, t) {
  var i = e / 8 | 0;
  return (n[i] | n[i + 1] << 8) >> (7 & e) & t;
}, If = function(n, e) {
  var t = e / 8 | 0;
  return (n[t] | n[t + 1] << 8 | n[t + 2] << 16) >> (7 & e);
}, dP = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], Ii = function(n, e, t) {
  var i = new Error(e || dP[n]);
  if (i.code = n, Error.captureStackTrace && Error.captureStackTrace(i, Ii), !t)
    throw i;
  return i;
}, pP = function(n, e, t, i) {
  var r = n.length;
  if (!r || e.f && !e.l)
    return t || new gi(0);
  var s = !t, a = s || e.i != 2, o = e.i;
  s && (t = new gi(3 * r));
  var l = function(k) {
    var E = t.length;
    if (k > E) {
      var B = new gi(Math.max(2 * E, k));
      B.set(t), t = B;
    }
  }, h = e.f || 0, c = e.p || 0, u = e.b || 0, d = e.l, p = e.d, m = e.m, g = e.n, f = 8 * r;
  do {
    if (!d) {
      h = Ci(n, c, 1);
      var v = Ci(n, c + 1, 3);
      if (c += 3, !v) {
        var y = n[(D = 4 + ((c + 7) / 8 | 0)) - 4] | n[D - 3] << 8, x = D + y;
        if (x > r) {
          o && Ii(0);
          break;
        }
        a && l(u + y), t.set(n.subarray(D, x), u), e.b = u += y, e.p = c = 8 * x, e.f = h;
        continue;
      }
      if (v == 1)
        d = cP, p = uP, m = 9, g = 5;
      else if (v == 2) {
        var M = Ci(n, c, 31) + 257, b = Ci(n, c + 10, 15) + 4, S = M + Ci(n, c + 5, 31) + 1;
        c += 14;
        for (var w = new gi(S), T = new gi(19), C = 0; C < b; ++C)
          T[oP[C]] = Ci(n, c + 3 * C, 7);
        c += 3 * b;
        var I = Rf(T), A = (1 << I) - 1, L = ih(T, I, 1);
        for (C = 0; C < S; ) {
          var D, U = L[Ci(n, c, A)];
          if (c += 15 & U, (D = U >> 4) < 16)
            w[C++] = D;
          else {
            var H = 0, Z = 0;
            for (D == 16 ? (Z = 3 + Ci(n, c, 3), c += 2, H = w[C - 1]) : D == 17 ? (Z = 3 + Ci(n, c, 7), c += 3) : D == 18 && (Z = 11 + Ci(n, c, 127), c += 7); Z--; )
              w[C++] = H;
          }
        }
        var te = w.subarray(0, M), ne = w.subarray(M);
        m = Rf(te), g = Rf(ne), d = ih(te, m, 1), p = ih(ne, g, 1);
      } else
        Ii(1);
      if (c > f) {
        o && Ii(0);
        break;
      }
    }
    a && l(u + 131072);
    for (var ve = (1 << m) - 1, Se = (1 << g) - 1, Q = c; ; Q = c) {
      var ae = (H = d[If(n, c) & ve]) >> 4;
      if ((c += 15 & H) > f) {
        o && Ii(0);
        break;
      }
      if (H || Ii(2), ae < 256)
        t[u++] = ae;
      else {
        if (ae == 256) {
          Q = c, d = null;
          break;
        }
        var de = ae - 254;
        if (ae > 264) {
          var ie = IS[C = ae - 257];
          de = Ci(n, c, (1 << ie) - 1) + OS[C], c += ie;
        }
        var N = p[If(n, c) & Se], R = N >> 4;
        if (N || Ii(3), c += 15 & N, ne = hP[R], R > 3 && (ie = LS[R], ne += If(n, c) & (1 << ie) - 1, c += ie), c > f) {
          o && Ii(0);
          break;
        }
        a && l(u + 131072);
        var j = u + de;
        if (u < ne) {
          var K = 0 - ne, O = Math.min(ne, j);
          for (K + u < 0 && Ii(3); u < O; ++u)
            t[u] = i[K + u];
        }
        for (; u < j; ++u)
          t[u] = t[u - ne];
      }
    }
    e.l = d, e.p = Q, e.b = u, e.f = h, d && (h = 1, e.m = m, e.d = p, e.n = g);
  } while (!h);
  return u != t.length && s ? function(k, E, B) {
    return (B == null || B > k.length) && (B = k.length), new gi(k.subarray(E, B));
  }(t, 0, u) : t.subarray(0, u);
}, fP = new gi(0);
function mP(n, e) {
  return pP(n.subarray((i = e, ((15 & (t = n)[0]) != 8 || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31) && Ii(6, "invalid zlib data"), (t[1] >> 5 & 1) == +!i && Ii(6, "invalid zlib data: " + (32 & t[1] ? "need" : "unexpected") + " dictionary"), 2 + (t[1] >> 3 & 4)), -4), { i: 2 }, e, e);
  var t, i;
}
var gP = typeof TextDecoder != "undefined" && new TextDecoder();
try {
  gP.decode(fP, { stream: !0 });
} catch (n) {
}
function FS(n, e, t) {
  const i = t.length - n - 1;
  if (e >= t[i])
    return i - 1;
  if (e <= t[n])
    return n;
  let r = n, s = i, a = Math.floor((r + s) / 2);
  for (; e < t[a] || e >= t[a + 1]; )
    e < t[a] ? s = a : r = a, a = Math.floor((r + s) / 2);
  return a;
}
function vP(n, e) {
  let t = 1;
  for (let r = 2; r <= n; ++r)
    t *= r;
  let i = 1;
  for (let r = 2; r <= e; ++r)
    i *= r;
  for (let r = 2; r <= n - e; ++r)
    i *= r;
  return t / i;
}
function yP(n, e, t, i, r) {
  const s = function(a, o, l, h, c) {
    const u = c < a ? c : a, d = [], p = FS(a, h, o), m = function(f, v, y, x, M) {
      const b = [];
      for (let A = 0; A <= y; ++A)
        b[A] = 0;
      const S = [];
      for (let A = 0; A <= x; ++A)
        S[A] = b.slice(0);
      const w = [];
      for (let A = 0; A <= y; ++A)
        w[A] = b.slice(0);
      w[0][0] = 1;
      const T = b.slice(0), C = b.slice(0);
      for (let A = 1; A <= y; ++A) {
        T[A] = v - M[f + 1 - A], C[A] = M[f + A] - v;
        let L = 0;
        for (let D = 0; D < A; ++D) {
          const U = C[D + 1], H = T[A - D];
          w[A][D] = U + H;
          const Z = w[D][A - 1] / w[A][D];
          w[D][A] = L + U * Z, L = H * Z;
        }
        w[A][A] = L;
      }
      for (let A = 0; A <= y; ++A)
        S[0][A] = w[A][y];
      for (let A = 0; A <= y; ++A) {
        let L = 0, D = 1;
        const U = [];
        for (let H = 0; H <= y; ++H)
          U[H] = b.slice(0);
        U[0][0] = 1;
        for (let H = 1; H <= x; ++H) {
          let Z = 0;
          const te = A - H, ne = y - H;
          A >= H && (U[D][0] = U[L][0] / w[ne + 1][te], Z = U[D][0] * w[te][ne]);
          const ve = A - 1 <= ne ? H - 1 : y - A;
          for (let Q = te >= -1 ? 1 : -te; Q <= ve; ++Q)
            U[D][Q] = (U[L][Q] - U[L][Q - 1]) / w[ne + 1][te + Q], Z += U[D][Q] * w[te + Q][ne];
          A <= ne && (U[D][H] = -U[L][H - 1] / w[ne + 1][A], Z += U[D][H] * w[A][ne]), S[H][A] = Z;
          const Se = L;
          L = D, D = Se;
        }
      }
      let I = y;
      for (let A = 1; A <= x; ++A) {
        for (let L = 0; L <= y; ++L)
          S[A][L] *= I;
        I *= y - A;
      }
      return S;
    }(p, h, a, u, o), g = [];
    for (let f = 0; f < l.length; ++f) {
      const v = l[f].clone(), y = v.w;
      v.x *= y, v.y *= y, v.z *= y, g[f] = v;
    }
    for (let f = 0; f <= u; ++f) {
      const v = g[p - a].clone().multiplyScalar(m[f][0]);
      for (let y = 1; y <= a; ++y)
        v.add(g[p - a + y].clone().multiplyScalar(m[f][y]));
      d[f] = v;
    }
    for (let f = u + 1; f <= c + 1; ++f)
      d[f] = new Ve(0, 0, 0);
    return d;
  }(n, e, t, i, r);
  return function(a) {
    const o = a.length, l = [], h = [];
    for (let u = 0; u < o; ++u) {
      const d = a[u];
      l[u] = new _(d.x, d.y, d.z), h[u] = d.w;
    }
    const c = [];
    for (let u = 0; u < o; ++u) {
      const d = l[u].clone();
      for (let p = 1; p <= u; ++p)
        d.sub(c[u - p].clone().multiplyScalar(vP(u, p) * h[p]));
      c[u] = d.divideScalar(h[0]);
    }
    return c;
  }(s);
}
class xP extends Si {
  constructor(e, t, i, r, s) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = r || 0, this.endKnot = s || this.knots.length - 1;
    for (let a = 0; a < i.length; ++a) {
      const o = i[a];
      this.controlPoints[a] = new Ve(o.x, o.y, o.z, o.w);
    }
  }
  getPoint(e, t = new _()) {
    const i = t, r = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), s = function(a, o, l, h) {
      const c = FS(a, h, o), u = function(p, m, g, f) {
        const v = [], y = [], x = [];
        v[0] = 1;
        for (let M = 1; M <= g; ++M) {
          y[M] = m - f[p + 1 - M], x[M] = f[p + M] - m;
          let b = 0;
          for (let S = 0; S < M; ++S) {
            const w = x[S + 1], T = y[M - S], C = v[S] / (w + T);
            v[S] = b + w * C, b = T * C;
          }
          v[M] = b;
        }
        return v;
      }(c, h, a, o), d = new Ve(0, 0, 0, 0);
      for (let p = 0; p <= a; ++p) {
        const m = l[c - a + p], g = u[p], f = m.w * g;
        d.x += m.x * f, d.y += m.y * f, d.z += m.z * f, d.w += m.w * g;
      }
      return d;
    }(this.degree, this.knots, this.controlPoints, r);
    return s.w !== 1 && s.divideScalar(s.w), i.set(s.x, s.y, s.z);
  }
  getTangent(e, t = new _()) {
    const i = t, r = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), s = yP(this.degree, this.knots, this.controlPoints, r, 1);
    return i.copy(s[1]).normalize(), i;
  }
}
let We, Bt, Pn;
class MP extends It {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, a = s.path === "" ? tr.extractUrlBase(e) : s.path, o = new gn(this.manager);
    o.setPath(s.path), o.setResponseType("arraybuffer"), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(l) {
      try {
        t(s.parse(l, a));
      } catch (h) {
        r && r(h), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e, t) {
    if (function(r) {
      const s = "Kaydara FBX Binary  \0";
      return r.byteLength >= s.length && s === $x(r, 0, s.length);
    }(e))
      We = new TP().parse(e);
    else {
      const r = $x(e);
      if (!function(s) {
        const a = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
        let o = 0;
        function l(h) {
          const c = s[h - 1];
          return s = s.slice(o + h), o++, c;
        }
        for (let h = 0; h < a.length; ++h)
          if (l(1) === a[h])
            return !1;
        return !0;
      }(r))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (Qx(r) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Qx(r));
      We = new _P().parse(r);
    }
    const i = new Ui(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new bP(i, this.manager).parse(We);
  }
}
class bP {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    Bt = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), i = this.parseMaterials(t), r = this.parseDeformers(), s = new SP().parse(r);
    return this.parseScene(r, s, i), Pn;
  }
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in We && We.Connections.connections.forEach(function(t) {
      const i = t[0], r = t[1], s = t[2];
      e.has(i) || e.set(i, { parents: [], children: [] });
      const a = { ID: r, relationship: s };
      e.get(i).parents.push(a), e.has(r) || e.set(r, { parents: [], children: [] });
      const o = { ID: i, relationship: s };
      e.get(r).children.push(o);
    }), e;
  }
  parseImages() {
    const e = {}, t = {};
    if ("Video" in We.Objects) {
      const i = We.Objects.Video;
      for (const r in i) {
        const s = i[r];
        if (e[parseInt(r)] = s.RelativeFilename || s.Filename, "Content" in s) {
          const a = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0, o = typeof s.Content == "string" && s.Content !== "";
          if (a || o) {
            const l = this.parseImage(i[r]);
            t[s.RelativeFilename || s.Filename] = l;
          }
        }
      }
    }
    for (const i in e) {
      const r = e[i];
      t[r] !== void 0 ? e[i] = t[r] : e[i] = e[i].split("\\").pop();
    }
    return e;
  }
  parseImage(e) {
    const t = e.Content, i = e.RelativeFilename || e.Filename;
    let r;
    switch (i.slice(i.lastIndexOf(".") + 1).toLowerCase()) {
      case "bmp":
        r = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        r = "image/jpeg";
        break;
      case "png":
        r = "image/png";
        break;
      case "tif":
        r = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga"), r = "image/tga";
        break;
      default:
        return;
    }
    if (typeof t == "string")
      return "data:" + r + ";base64," + t;
    {
      const s = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([s], { type: r }));
    }
  }
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in We.Objects) {
      const i = We.Objects.Texture;
      for (const r in i) {
        const s = this.parseTexture(i[r], e);
        t.set(parseInt(r), s);
      }
    }
    return t;
  }
  parseTexture(e, t) {
    const i = this.loadTexture(e, t);
    i.ID = e.id, i.name = e.attrName;
    const r = e.WrapModeU, s = e.WrapModeV, a = r !== void 0 ? r.value : 0, o = s !== void 0 ? s.value : 0;
    if (i.wrapS = a === 0 ? jt : vn, i.wrapT = o === 0 ? jt : vn, "Scaling" in e) {
      const l = e.Scaling.value;
      i.repeat.x = l[0], i.repeat.y = l[1];
    }
    if ("Translation" in e) {
      const l = e.Translation.value;
      i.offset.x = l[0], i.offset.y = l[1];
    }
    return i;
  }
  loadTexture(e, t) {
    let i;
    const r = this.textureLoader.path, s = Bt.get(e.id).children;
    let a;
    s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (i = t[s[0].ID], i.indexOf("blob:") !== 0 && i.indexOf("data:") !== 0 || this.textureLoader.setPath(void 0));
    const o = e.FileName.slice(-3).toLowerCase();
    if (o === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null ? a = new pt() : (l.setPath(this.textureLoader.path), a = l.load(i));
    } else if (o === "dds") {
      const l = this.manager.getHandler(".dds");
      l === null ? a = new pt() : (l.setPath(this.textureLoader.path), a = l.load(i));
    } else
      a = o === "psd" ? new pt() : this.textureLoader.load(i);
    return this.textureLoader.setPath(r), a;
  }
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in We.Objects) {
      const i = We.Objects.Material;
      for (const r in i) {
        const s = this.parseMaterial(i[r], e);
        s !== null && t.set(parseInt(r), s);
      }
    }
    return t;
  }
  parseMaterial(e, t) {
    const i = e.id, r = e.attrName;
    let s = e.ShadingModel;
    if (typeof s == "object" && (s = s.value), !Bt.has(i))
      return null;
    const a = this.parseParameters(e, t, i);
    let o;
    switch (s.toLowerCase()) {
      case "phong":
      default:
        o = new Aa();
        break;
      case "lambert":
        o = new Xd();
    }
    return o.setValues(a), o.name = r, o;
  }
  parseParameters(e, t, i) {
    const r = {};
    e.BumpFactor && (r.bumpScale = e.BumpFactor.value), e.Diffuse ? r.color = new oe().fromArray(e.Diffuse.value).convertSRGBToLinear() : !e.DiffuseColor || e.DiffuseColor.type !== "Color" && e.DiffuseColor.type !== "ColorRGB" || (r.color = new oe().fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (r.displacementScale = e.DisplacementFactor.value), e.Emissive ? r.emissive = new oe().fromArray(e.Emissive.value).convertSRGBToLinear() : !e.EmissiveColor || e.EmissiveColor.type !== "Color" && e.EmissiveColor.type !== "ColorRGB" || (r.emissive = new oe().fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (r.opacity = parseFloat(e.Opacity.value)), r.opacity < 1 && (r.transparent = !0), e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value), e.Shininess && (r.shininess = e.Shininess.value), e.Specular ? r.specular = new oe().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (r.specular = new oe().fromArray(e.SpecularColor.value).convertSRGBToLinear());
    const s = this;
    return Bt.get(i).children.forEach(function(a) {
      switch (a.relationship) {
        case "Bump":
          r.bumpMap = s.getTexture(t, a.ID);
          break;
        case "Maya|TEX_ao_map":
          r.aoMap = s.getTexture(t, a.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          r.map = s.getTexture(t, a.ID), r.map !== void 0 && (r.map.colorSpace = mt);
          break;
        case "DisplacementColor":
          r.displacementMap = s.getTexture(t, a.ID);
          break;
        case "EmissiveColor":
          r.emissiveMap = s.getTexture(t, a.ID), r.emissiveMap !== void 0 && (r.emissiveMap.colorSpace = mt);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          r.normalMap = s.getTexture(t, a.ID);
          break;
        case "ReflectionColor":
          r.envMap = s.getTexture(t, a.ID), r.envMap !== void 0 && (r.envMap.mapping = Lo, r.envMap.colorSpace = mt);
          break;
        case "SpecularColor":
          r.specularMap = s.getTexture(t, a.ID), r.specularMap !== void 0 && (r.specularMap.colorSpace = mt);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          r.alphaMap = s.getTexture(t, a.ID), r.transparent = !0;
      }
    }), r;
  }
  getTexture(e, t) {
    return "LayeredTexture" in We.Objects && t in We.Objects.LayeredTexture && (t = Bt.get(t).children[0].ID), e.get(t);
  }
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in We.Objects) {
      const i = We.Objects.Deformer;
      for (const r in i) {
        const s = i[r], a = Bt.get(parseInt(r));
        if (s.attrType === "Skin") {
          const o = this.parseSkeleton(a, i);
          o.ID = r, a.parents.length, o.geometryID = a.parents[0].ID, e[r] = o;
        } else if (s.attrType === "BlendShape") {
          const o = { id: r };
          o.rawTargets = this.parseMorphTargets(a, i), o.id = r, a.parents.length, t[r] = o;
        }
      }
    }
    return { skeletons: e, morphTargets: t };
  }
  parseSkeleton(e, t) {
    const i = [];
    return e.children.forEach(function(r) {
      const s = t[r.ID];
      if (s.attrType !== "Cluster")
        return;
      const a = { ID: r.ID, indices: [], weights: [], transformLink: new fe().fromArray(s.TransformLink.a) };
      "Indexes" in s && (a.indices = s.Indexes.a, a.weights = s.Weights.a), i.push(a);
    }), { rawBones: i, bones: [] };
  }
  parseMorphTargets(e, t) {
    const i = [];
    for (let r = 0; r < e.children.length; r++) {
      const s = e.children[r], a = t[s.ID], o = { name: a.attrName, initialWeight: a.DeformPercent, id: a.id, fullWeights: a.FullWeights.a };
      if (a.attrType !== "BlendShapeChannel")
        return;
      o.geoID = Bt.get(parseInt(s.ID)).children.filter(function(l) {
        return l.relationship === void 0;
      })[0].ID, i.push(o);
    }
    return i;
  }
  parseScene(e, t, i) {
    Pn = new yn();
    const r = this.parseModels(e.skeletons, t, i), s = We.Objects.Model, a = this;
    r.forEach(function(l) {
      const h = s[l.ID];
      a.setLookAtProperties(l, h), Bt.get(l.ID).parents.forEach(function(c) {
        const u = r.get(c.ID);
        u !== void 0 && u.add(l);
      }), l.parent === null && Pn.add(l);
    }), this.bindSkeleton(e.skeletons, t, r), this.addGlobalSceneSettings(), Pn.traverse(function(l) {
      if (l.userData.transformData) {
        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
        const h = kS(l.userData.transformData);
        l.applyMatrix4(h), l.updateWorldMatrix();
      }
    });
    const o = new wP().parse();
    Pn.children.length === 1 && Pn.children[0].isGroup && (Pn.children[0].animations = o, Pn = Pn.children[0]), Pn.animations = o;
  }
  parseModels(e, t, i) {
    const r = /* @__PURE__ */ new Map(), s = We.Objects.Model;
    for (const a in s) {
      const o = parseInt(a), l = s[a], h = Bt.get(o);
      let c = this.buildSkeleton(h, e, o, l.attrName);
      if (!c) {
        switch (l.attrType) {
          case "Camera":
            c = this.createCamera(h);
            break;
          case "Light":
            c = this.createLight(h);
            break;
          case "Mesh":
            c = this.createMesh(h, t, i);
            break;
          case "NurbsCurve":
            c = this.createCurve(h, t);
            break;
          case "LimbNode":
          case "Root":
            c = new Vo();
            break;
          default:
            c = new yn();
        }
        c.name = l.attrName ? qe.sanitizeNodeName(l.attrName) : "", c.userData.originalName = l.attrName, c.ID = o;
      }
      this.getTransformData(c, l), r.set(o, c);
    }
    return r;
  }
  buildSkeleton(e, t, i, r) {
    let s = null;
    return e.parents.forEach(function(a) {
      for (const o in t) {
        const l = t[o];
        l.rawBones.forEach(function(h, c) {
          if (h.ID === a.ID) {
            const u = s;
            s = new Vo(), s.matrixWorld.copy(h.transformLink), s.name = r ? qe.sanitizeNodeName(r) : "", s.userData.originalName = r, s.ID = i, l.bones[c] = s, u !== null && s.add(u);
          }
        });
      }
    }), s;
  }
  createCamera(e) {
    let t, i;
    if (e.children.forEach(function(r) {
      const s = We.Objects.NodeAttribute[r.ID];
      s !== void 0 && (i = s);
    }), i === void 0)
      t = new Ue();
    else {
      let r = 0;
      i.CameraProjectionType !== void 0 && i.CameraProjectionType.value === 1 && (r = 1);
      let s = 1;
      i.NearPlane !== void 0 && (s = i.NearPlane.value / 1e3);
      let a = 1e3;
      i.FarPlane !== void 0 && (a = i.FarPlane.value / 1e3);
      let o = window.innerWidth, l = window.innerHeight;
      i.AspectWidth !== void 0 && i.AspectHeight !== void 0 && (o = i.AspectWidth.value, l = i.AspectHeight.value);
      const h = o / l;
      let c = 45;
      i.FieldOfView !== void 0 && (c = i.FieldOfView.value);
      const u = i.FocalLength ? i.FocalLength.value : null;
      switch (r) {
        case 0:
          t = new Gt(c, h, s, a), u !== null && t.setFocalLength(u);
          break;
        case 1:
          t = new _a(-o / 2, o / 2, l / 2, -l / 2, s, a);
          break;
        default:
          t = new Ue();
      }
    }
    return t;
  }
  createLight(e) {
    let t, i;
    if (e.children.forEach(function(r) {
      const s = We.Objects.NodeAttribute[r.ID];
      s !== void 0 && (i = s);
    }), i === void 0)
      t = new Ue();
    else {
      let r;
      r = i.LightType === void 0 ? 0 : i.LightType.value;
      let s = 16777215;
      i.Color !== void 0 && (s = new oe().fromArray(i.Color.value).convertSRGBToLinear());
      let a = i.Intensity === void 0 ? 1 : i.Intensity.value / 100;
      i.CastLightOnObject !== void 0 && i.CastLightOnObject.value === 0 && (a = 0);
      let o = 0;
      i.FarAttenuationEnd !== void 0 && (o = i.EnableFarAttenuation !== void 0 && i.EnableFarAttenuation.value === 0 ? 0 : i.FarAttenuationEnd.value);
      const l = 1;
      switch (r) {
        case 0:
          t = new Wo(s, a, o, l);
          break;
        case 1:
          t = new yh(s, a);
          break;
        case 2:
          let h = Math.PI / 3;
          i.InnerAngle !== void 0 && (h = nn.degToRad(i.InnerAngle.value));
          let c = 0;
          i.OuterAngle !== void 0 && (c = nn.degToRad(i.OuterAngle.value), c = Math.max(c, 1)), t = new vh(s, a, o, h, c, l);
          break;
        default:
          t = new Wo(s, a);
      }
      i.CastShadows !== void 0 && i.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, i) {
    let r, s = null, a = null;
    const o = [];
    return e.children.forEach(function(l) {
      t.has(l.ID) && (s = t.get(l.ID)), i.has(l.ID) && o.push(i.get(l.ID));
    }), o.length > 1 ? a = o : o.length > 0 ? a = o[0] : (a = new Aa({ name: It.DEFAULT_MATERIAL_NAME, color: 13421772 }), o.push(a)), "color" in s.attributes && o.forEach(function(l) {
      l.vertexColors = !0;
    }), s.FBX_Deformer ? (r = new ju(s, a), r.normalizeSkinWeights()) : r = new ce(s, a), r;
  }
  createCurve(e, t) {
    const i = e.children.reduce(function(s, a) {
      return t.has(a.ID) && (s = t.get(a.ID)), s;
    }, null), r = new kt({ name: It.DEFAULT_MATERIAL_NAME, color: 3342591, linewidth: 1 });
    return new hn(i, r);
  }
  getTransformData(e, t) {
    const i = {};
    "InheritType" in t && (i.inheritType = parseInt(t.InheritType.value)), i.eulerOrder = "RotationOrder" in t ? zS(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (i.translation = t.Lcl_Translation.value), "PreRotation" in t && (i.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (i.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (i.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (i.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (i.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (i.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (i.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (i.rotationPivot = t.RotationPivot.value), e.userData.transformData = i;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && Bt.get(e.ID).children.forEach(function(i) {
      if (i.relationship === "LookAtProperty") {
        const r = We.Objects.Model[i.ID];
        if ("Lcl_Translation" in r) {
          const s = r.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(s), Pn.add(e.target)) : e.lookAt(new _().fromArray(s));
        }
      }
    });
  }
  bindSkeleton(e, t, i) {
    const r = this.parsePoseNodes();
    for (const s in e) {
      const a = e[s];
      Bt.get(parseInt(a.ID)).parents.forEach(function(o) {
        if (t.has(o.ID)) {
          const l = o.ID;
          Bt.get(l).parents.forEach(function(h) {
            i.has(h.ID) && i.get(h.ID).bind(new Ho(a.bones), r[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in We.Objects) {
      const t = We.Objects.Pose;
      for (const i in t)
        if (t[i].attrType === "BindPose" && t[i].NbPoseNodes > 0) {
          const r = t[i].PoseNode;
          Array.isArray(r) ? r.forEach(function(s) {
            e[s.Node] = new fe().fromArray(s.Matrix.a);
          }) : e[r.Node] = new fe().fromArray(r.Matrix.a);
        }
    }
    return e;
  }
  addGlobalSceneSettings() {
    if ("GlobalSettings" in We) {
      if ("AmbientColor" in We.GlobalSettings) {
        const e = We.GlobalSettings.AmbientColor.value, t = e[0], i = e[1], r = e[2];
        if (t !== 0 || i !== 0 || r !== 0) {
          const s = new oe(t, i, r).convertSRGBToLinear();
          Pn.add(new Yu(s, 1));
        }
      }
      "UnitScaleFactor" in We.GlobalSettings && (Pn.userData.unitScaleFactor = We.GlobalSettings.UnitScaleFactor.value);
    }
  }
}
class SP {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in We.Objects) {
      const i = We.Objects.Geometry;
      for (const r in i) {
        const s = Bt.get(parseInt(r)), a = this.parseGeometry(s, i[r], e);
        t.set(parseInt(r), a);
      }
    }
    return this.negativeMaterialIndices, t;
  }
  parseGeometry(e, t, i) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, i);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  parseMeshGeometry(e, t, i) {
    const r = i.skeletons, s = [], a = e.parents.map(function(u) {
      return We.Objects.Model[u.ID];
    });
    if (a.length === 0)
      return;
    const o = e.children.reduce(function(u, d) {
      return r[d.ID] !== void 0 && (u = r[d.ID]), u;
    }, null);
    e.children.forEach(function(u) {
      i.morphTargets[u.ID] !== void 0 && s.push(i.morphTargets[u.ID]);
    });
    const l = a[0], h = {};
    "RotationOrder" in l && (h.eulerOrder = zS(l.RotationOrder.value)), "InheritType" in l && (h.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (h.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (h.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (h.scale = l.GeometricScaling.value);
    const c = kS(h);
    return this.genGeometry(t, o, s, c);
  }
  genGeometry(e, t, i, r) {
    const s = new Pe();
    e.attrName && (s.name = e.attrName);
    const a = this.parseGeoNode(e, t), o = this.genBuffers(a), l = new ye(o.vertex, 3);
    if (l.applyMatrix4(r), s.setAttribute("position", l), o.colors.length > 0 && s.setAttribute("color", new ye(o.colors, 3)), t && (s.setAttribute("skinIndex", new Ld(o.weightsIndices, 4)), s.setAttribute("skinWeight", new ye(o.vertexWeights, 4)), s.FBX_Deformer = t), o.normal.length > 0) {
      const h = new De().getNormalMatrix(r), c = new ye(o.normal, 3);
      c.applyNormalMatrix(h), s.setAttribute("normal", c);
    }
    if (o.uvs.forEach(function(h, c) {
      const u = c === 0 ? "uv" : `uv${c}`;
      s.setAttribute(u, new ye(o.uvs[c], 2));
    }), a.material && a.material.mappingType !== "AllSame") {
      let h = o.materialIndex[0], c = 0;
      if (o.materialIndex.forEach(function(u, d) {
        u !== h && (s.addGroup(c, d - c, h), h = u, c = d);
      }), s.groups.length > 0) {
        const u = s.groups[s.groups.length - 1], d = u.start + u.count;
        d !== o.materialIndex.length && s.addGroup(d, o.materialIndex.length - d, h);
      }
      s.groups.length === 0 && s.addGroup(0, o.materialIndex.length, o.materialIndex[0]);
    }
    return this.addMorphTargets(s, e, i, r), s;
  }
  parseGeoNode(e, t) {
    const i = {};
    if (i.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], i.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (i.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (i.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (i.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      i.uv = [];
      let r = 0;
      for (; e.LayerElementUV[r]; )
        e.LayerElementUV[r].UV && i.uv.push(this.parseUVs(e.LayerElementUV[r])), r++;
    }
    return i.weightTable = {}, t !== null && (i.skeleton = t, t.rawBones.forEach(function(r, s) {
      r.indices.forEach(function(a, o) {
        i.weightTable[a] === void 0 && (i.weightTable[a] = []), i.weightTable[a].push({ id: s, weight: r.weights[o] });
      });
    })), i;
  }
  genBuffers(e) {
    const t = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] };
    let i = 0, r = 0, s = !1, a = [], o = [], l = [], h = [], c = [], u = [];
    const d = this;
    return e.vertexIndices.forEach(function(p, m) {
      let g, f = !1;
      p < 0 && (p = ~p, f = !0);
      let v = [], y = [];
      if (a.push(3 * p, 3 * p + 1, 3 * p + 2), e.color) {
        const x = fu(m, i, p, e.color);
        l.push(x[0], x[1], x[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[p] !== void 0 && e.weightTable[p].forEach(function(x) {
          y.push(x.weight), v.push(x.id);
        }), y.length > 4) {
          s || (s = !0);
          const x = [0, 0, 0, 0], M = [0, 0, 0, 0];
          y.forEach(function(b, S) {
            let w = b, T = v[S];
            M.forEach(function(C, I, A) {
              if (w > C) {
                A[I] = w, w = C;
                const L = x[I];
                x[I] = T, T = L;
              }
            });
          }), v = x, y = M;
        }
        for (; y.length < 4; )
          y.push(0), v.push(0);
        for (let x = 0; x < 4; ++x)
          c.push(y[x]), u.push(v[x]);
      }
      if (e.normal) {
        const x = fu(m, i, p, e.normal);
        o.push(x[0], x[1], x[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (g = fu(m, i, p, e.material)[0], g < 0 && (d.negativeMaterialIndices = !0, g = 0)), e.uv && e.uv.forEach(function(x, M) {
        const b = fu(m, i, p, x);
        h[M] === void 0 && (h[M] = []), h[M].push(b[0]), h[M].push(b[1]);
      }), r++, f && (d.genFace(t, e, a, g, o, l, h, c, u, r), i++, r = 0, a = [], o = [], l = [], h = [], c = [], u = []);
    }), t;
  }
  getNormalNewell(e) {
    const t = new _(0, 0, 0);
    for (let i = 0; i < e.length; i++) {
      const r = e[i], s = e[(i + 1) % e.length];
      t.x += (r.y - s.y) * (r.z + s.z), t.y += (r.z - s.z) * (r.x + s.x), t.z += (r.x - s.x) * (r.y + s.y);
    }
    return t.normalize(), t;
  }
  getNormalTangentAndBitangent(e) {
    const t = this.getNormalNewell(e), i = (Math.abs(t.z) > 0.5 ? new _(0, 1, 0) : new _(0, 0, 1)).cross(t).normalize(), r = t.clone().cross(i).normalize();
    return { normal: t, tangent: i, bitangent: r };
  }
  flattenVertex(e, t, i) {
    return new X(e.dot(t), e.dot(i));
  }
  genFace(e, t, i, r, s, a, o, l, h, c) {
    let u;
    if (c > 3) {
      const d = [], p = t.baseVertexPositions || t.vertexPositions;
      for (let v = 0; v < i.length; v += 3)
        d.push(new _(p[i[v]], p[i[v + 1]], p[i[v + 2]]));
      const { tangent: m, bitangent: g } = this.getNormalTangentAndBitangent(d), f = [];
      for (const v of d)
        f.push(this.flattenVertex(v, m, g));
      u = Di.triangulateShape(f, []);
    } else
      u = [[0, 1, 2]];
    for (const [d, p, m] of u)
      e.vertex.push(t.vertexPositions[i[3 * d]]), e.vertex.push(t.vertexPositions[i[3 * d + 1]]), e.vertex.push(t.vertexPositions[i[3 * d + 2]]), e.vertex.push(t.vertexPositions[i[3 * p]]), e.vertex.push(t.vertexPositions[i[3 * p + 1]]), e.vertex.push(t.vertexPositions[i[3 * p + 2]]), e.vertex.push(t.vertexPositions[i[3 * m]]), e.vertex.push(t.vertexPositions[i[3 * m + 1]]), e.vertex.push(t.vertexPositions[i[3 * m + 2]]), t.skeleton && (e.vertexWeights.push(l[4 * d]), e.vertexWeights.push(l[4 * d + 1]), e.vertexWeights.push(l[4 * d + 2]), e.vertexWeights.push(l[4 * d + 3]), e.vertexWeights.push(l[4 * p]), e.vertexWeights.push(l[4 * p + 1]), e.vertexWeights.push(l[4 * p + 2]), e.vertexWeights.push(l[4 * p + 3]), e.vertexWeights.push(l[4 * m]), e.vertexWeights.push(l[4 * m + 1]), e.vertexWeights.push(l[4 * m + 2]), e.vertexWeights.push(l[4 * m + 3]), e.weightsIndices.push(h[4 * d]), e.weightsIndices.push(h[4 * d + 1]), e.weightsIndices.push(h[4 * d + 2]), e.weightsIndices.push(h[4 * d + 3]), e.weightsIndices.push(h[4 * p]), e.weightsIndices.push(h[4 * p + 1]), e.weightsIndices.push(h[4 * p + 2]), e.weightsIndices.push(h[4 * p + 3]), e.weightsIndices.push(h[4 * m]), e.weightsIndices.push(h[4 * m + 1]), e.weightsIndices.push(h[4 * m + 2]), e.weightsIndices.push(h[4 * m + 3])), t.color && (e.colors.push(a[3 * d]), e.colors.push(a[3 * d + 1]), e.colors.push(a[3 * d + 2]), e.colors.push(a[3 * p]), e.colors.push(a[3 * p + 1]), e.colors.push(a[3 * p + 2]), e.colors.push(a[3 * m]), e.colors.push(a[3 * m + 1]), e.colors.push(a[3 * m + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(r), e.materialIndex.push(r), e.materialIndex.push(r)), t.normal && (e.normal.push(s[3 * d]), e.normal.push(s[3 * d + 1]), e.normal.push(s[3 * d + 2]), e.normal.push(s[3 * p]), e.normal.push(s[3 * p + 1]), e.normal.push(s[3 * p + 2]), e.normal.push(s[3 * m]), e.normal.push(s[3 * m + 1]), e.normal.push(s[3 * m + 2])), t.uv && t.uv.forEach(function(g, f) {
        e.uvs[f] === void 0 && (e.uvs[f] = []), e.uvs[f].push(o[f][2 * d]), e.uvs[f].push(o[f][2 * d + 1]), e.uvs[f].push(o[f][2 * p]), e.uvs[f].push(o[f][2 * p + 1]), e.uvs[f].push(o[f][2 * m]), e.uvs[f].push(o[f][2 * m + 1]);
      });
  }
  addMorphTargets(e, t, i, r) {
    if (i.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const s = this;
    i.forEach(function(a) {
      a.rawTargets.forEach(function(o) {
        const l = We.Objects.Geometry[o.geoID];
        l !== void 0 && s.genMorphGeometry(e, t, l, r, o.name);
      });
    });
  }
  genMorphGeometry(e, t, i, r, s) {
    const a = t.Vertices !== void 0 ? t.Vertices.a : [], o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], l = i.Vertices !== void 0 ? i.Vertices.a : [], h = i.Indexes !== void 0 ? i.Indexes.a : [], c = 3 * e.attributes.position.count, u = new Float32Array(c);
    for (let g = 0; g < h.length; g++) {
      const f = 3 * h[g];
      u[f] = l[3 * g], u[f + 1] = l[3 * g + 1], u[f + 2] = l[3 * g + 2];
    }
    const d = { vertexIndices: o, vertexPositions: u, baseVertexPositions: a }, p = this.genBuffers(d), m = new ye(p.vertex, 3);
    m.name = s || i.attrName, m.applyMatrix4(r), e.morphAttributes.position.push(m);
  }
  parseNormals(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType, r = e.Normals.a;
    let s = [];
    return i === "IndexToDirect" && ("NormalIndex" in e ? s = e.NormalIndex.a : "NormalsIndex" in e && (s = e.NormalsIndex.a)), { dataSize: 3, buffer: r, indices: s, mappingType: t, referenceType: i };
  }
  parseUVs(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType, r = e.UV.a;
    let s = [];
    return i === "IndexToDirect" && (s = e.UVIndex.a), { dataSize: 2, buffer: r, indices: s, mappingType: t, referenceType: i };
  }
  parseVertexColors(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType, r = e.Colors.a;
    let s = [];
    i === "IndexToDirect" && (s = e.ColorIndex.a);
    for (let a = 0, o = new oe(); a < r.length; a += 4)
      o.fromArray(r, a).convertSRGBToLinear().toArray(r, a);
    return { dataSize: 4, buffer: r, indices: s, mappingType: t, referenceType: i };
  }
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: i };
    const r = e.Materials.a, s = [];
    for (let a = 0; a < r.length; ++a)
      s.push(a);
    return { dataSize: 1, buffer: r, indices: s, mappingType: t, referenceType: i };
  }
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return new Pe();
    const i = t - 1, r = e.KnotVector.a, s = [], a = e.Points.a;
    for (let c = 0, u = a.length; c < u; c += 4)
      s.push(new Ve().fromArray(a, c));
    let o, l;
    if (e.Form === "Closed")
      s.push(s[0]);
    else if (e.Form === "Periodic") {
      o = i, l = r.length - 1 - o;
      for (let c = 0; c < i; ++c)
        s.push(s[c]);
    }
    const h = new xP(i, r, s, o, l).getPoints(12 * s.length);
    return new Pe().setFromPoints(h);
  }
}
class wP {
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const i in t) {
        const r = t[i], s = this.addClip(r);
        e.push(s);
      }
    return e;
  }
  parseClips() {
    if (We.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  parseAnimationCurveNodes() {
    const e = We.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const i in e) {
      const r = e[i];
      if (r.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const s = { id: r.id, attr: r.attrName, curves: {} };
        t.set(s.id, s);
      }
    }
    return t;
  }
  parseAnimationCurves(e) {
    const t = We.Objects.AnimationCurve;
    for (const i in t) {
      const r = { id: t[i].id, times: t[i].KeyTime.a.map(EP), values: t[i].KeyValueFloat.a }, s = Bt.get(r.id);
      if (s !== void 0) {
        const a = s.parents[0].ID, o = s.parents[0].relationship;
        o.match(/X/) ? e.get(a).curves.x = r : o.match(/Y/) ? e.get(a).curves.y = r : o.match(/Z/) ? e.get(a).curves.z = r : o.match(/DeformPercent/) && e.has(a) && (e.get(a).curves.morph = r);
      }
    }
  }
  parseAnimationLayers(e) {
    const t = We.Objects.AnimationLayer, i = /* @__PURE__ */ new Map();
    for (const r in t) {
      const s = [], a = Bt.get(parseInt(r));
      a !== void 0 && (a.children.forEach(function(o, l) {
        if (e.has(o.ID)) {
          const h = e.get(o.ID);
          if (h.curves.x !== void 0 || h.curves.y !== void 0 || h.curves.z !== void 0) {
            if (s[l] === void 0) {
              const c = Bt.get(o.ID).parents.filter(function(u) {
                return u.relationship !== void 0;
              })[0].ID;
              if (c !== void 0) {
                const u = We.Objects.Model[c.toString()];
                if (u === void 0)
                  return;
                const d = { modelName: u.attrName ? qe.sanitizeNodeName(u.attrName) : "", ID: u.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] };
                Pn.traverse(function(p) {
                  p.ID === u.id && (d.transform = p.matrix, p.userData.transformData && (d.eulerOrder = p.userData.transformData.eulerOrder));
                }), d.transform || (d.transform = new fe()), "PreRotation" in u && (d.preRotation = u.PreRotation.value), "PostRotation" in u && (d.postRotation = u.PostRotation.value), s[l] = d;
              }
            }
            s[l] && (s[l][h.attr] = h);
          } else if (h.curves.morph !== void 0) {
            if (s[l] === void 0) {
              const c = Bt.get(o.ID).parents.filter(function(f) {
                return f.relationship !== void 0;
              })[0].ID, u = Bt.get(c).parents[0].ID, d = Bt.get(u).parents[0].ID, p = Bt.get(d).parents[0].ID, m = We.Objects.Model[p], g = { modelName: m.attrName ? qe.sanitizeNodeName(m.attrName) : "", morphName: We.Objects.Deformer[c].attrName };
              s[l] = g;
            }
            s[l][h.attr] = h;
          }
        }
      }), i.set(parseInt(r), s));
    }
    return i;
  }
  parseAnimStacks(e) {
    const t = We.Objects.AnimationStack, i = {};
    for (const r in t) {
      const s = Bt.get(parseInt(r)).children;
      s.length;
      const a = e.get(s[0].ID);
      i[r] = { name: t[r].attrName, layer: a };
    }
    return i;
  }
  addClip(e) {
    let t = [];
    const i = this;
    return e.layer.forEach(function(r) {
      t = t.concat(i.generateTracks(r));
    }), new pa(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let i = new _(), r = new _();
    if (e.transform && e.transform.decompose(i, new Ye(), r), i = i.toArray(), r = r.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const s = this.generateVectorTrack(e.modelName, e.T.curves, i, "position");
      s !== void 0 && t.push(s);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const s = this.generateRotationTrack(e.modelName, e.R.curves, e.preRotation, e.postRotation, e.eulerOrder);
      s !== void 0 && t.push(s);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const s = this.generateVectorTrack(e.modelName, e.S.curves, r, "scale");
      s !== void 0 && t.push(s);
    }
    if (e.DeformPercent !== void 0) {
      const s = this.generateMorphTrack(e);
      s !== void 0 && t.push(s);
    }
    return t;
  }
  generateVectorTrack(e, t, i, r) {
    const s = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(s, t, i);
    return new ys(e + "." + r, s, a);
  }
  generateRotationTrack(e, t, i, r, s) {
    let a, o;
    if (t.x !== void 0 && t.y !== void 0 && t.z !== void 0) {
      const u = this.interpolateRotations(t.x, t.y, t.z, s);
      a = u[0], o = u[1];
    }
    i !== void 0 && ((i = i.map(nn.degToRad)).push(s), i = new gt().fromArray(i), i = new Ye().setFromEuler(i)), r !== void 0 && ((r = r.map(nn.degToRad)).push(s), r = new gt().fromArray(r), r = new Ye().setFromEuler(r).invert());
    const l = new Ye(), h = new gt(), c = [];
    if (!o || !a)
      return new Rr(e + ".quaternion", [0], [0]);
    for (let u = 0; u < o.length; u += 3)
      h.set(o[u], o[u + 1], o[u + 2], s), l.setFromEuler(h), i !== void 0 && l.premultiply(i), r !== void 0 && l.multiply(r), u > 2 && new Ye().fromArray(c, (u - 3) / 3 * 4).dot(l) < 0 && l.set(-l.x, -l.y, -l.z, -l.w), l.toArray(c, u / 3 * 4);
    return new Rr(e + ".quaternion", a, c);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, i = t.values.map(function(s) {
      return s / 100;
    }), r = Pn.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new vs(e.modelName + ".morphTargetInfluences[" + r + "]", t.times, i);
  }
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(i, r) {
      return i - r;
    }), t.length > 1) {
      let i = 1, r = t[0];
      for (let s = 1; s < t.length; s++) {
        const a = t[s];
        a !== r && (t[i] = a, r = a, i++);
      }
      t = t.slice(0, i);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, i) {
    const r = i, s = [];
    let a = -1, o = -1, l = -1;
    return e.forEach(function(h) {
      if (t.x && (a = t.x.times.indexOf(h)), t.y && (o = t.y.times.indexOf(h)), t.z && (l = t.z.times.indexOf(h)), a !== -1) {
        const c = t.x.values[a];
        s.push(c), r[0] = c;
      } else
        s.push(r[0]);
      if (o !== -1) {
        const c = t.y.values[o];
        s.push(c), r[1] = c;
      } else
        s.push(r[1]);
      if (l !== -1) {
        const c = t.z.values[l];
        s.push(c), r[2] = c;
      } else
        s.push(r[2]);
    }), s;
  }
  interpolateRotations(e, t, i, r) {
    const s = [], a = [];
    s.push(e.times[0]), a.push(nn.degToRad(e.values[0])), a.push(nn.degToRad(t.values[0])), a.push(nn.degToRad(i.values[0]));
    for (let o = 1; o < e.values.length; o++) {
      const l = [e.values[o - 1], t.values[o - 1], i.values[o - 1]];
      if (isNaN(l[0]) || isNaN(l[1]) || isNaN(l[2]))
        continue;
      const h = l.map(nn.degToRad), c = [e.values[o], t.values[o], i.values[o]];
      if (isNaN(c[0]) || isNaN(c[1]) || isNaN(c[2]))
        continue;
      const u = c.map(nn.degToRad), d = [c[0] - l[0], c[1] - l[1], c[2] - l[2]], p = [Math.abs(d[0]), Math.abs(d[1]), Math.abs(d[2])];
      if (p[0] >= 180 || p[1] >= 180 || p[2] >= 180) {
        const m = Math.max(...p) / 180, g = new gt(...h, r), f = new gt(...u, r), v = new Ye().setFromEuler(g), y = new Ye().setFromEuler(f);
        v.dot(y) && y.set(-y.x, -y.y, -y.z, -y.w);
        const x = e.times[o - 1], M = e.times[o] - x, b = new Ye(), S = new gt();
        for (let w = 0; w < 1; w += 1 / m)
          b.copy(v.clone().slerp(y.clone(), w)), s.push(x + w * M), S.setFromQuaternion(b, r), a.push(S.x), a.push(S.y), a.push(S.z);
      } else
        s.push(e.times[o]), a.push(nn.degToRad(e.values[o])), a.push(nn.degToRad(t.values[o])), a.push(nn.degToRad(i.values[o]));
    }
    return [s, a];
  }
}
class _P {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new BS(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, i = e.split(/[\r\n]+/);
    return i.forEach(function(r, s) {
      const a = r.match(/^[\s\t]*;/), o = r.match(/^[\s\t]*$/);
      if (a || o)
        return;
      const l = r.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), h = r.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), c = r.match("^\\t{" + (t.currentIndent - 1) + "}}");
      l ? t.parseNodeBegin(r, l) : h ? t.parseNodeProperty(r, h, i[++s]) : c ? t.popStack() : r.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(r);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const i = t[1].trim().replace(/^"/, "").replace(/"$/, ""), r = t[2].split(",").map(function(l) {
      return l.trim().replace(/^"/, "").replace(/"$/, "");
    }), s = { name: i }, a = this.parseNodeAttr(r), o = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(i, s) : i in o ? (i === "PoseNode" ? o.PoseNode.push(s) : o[i].id !== void 0 && (o[i] = {}, o[i][o[i].id] = o[i]), a.id !== "" && (o[i][a.id] = s)) : typeof a.id == "number" ? (o[i] = {}, o[i][a.id] = s) : i !== "Properties70" && (o[i] = i === "PoseNode" ? [s] : s), typeof a.id == "number" && (s.id = a.id), a.name !== "" && (s.attrName = a.name), a.type !== "" && (s.attrType = a.type), this.pushStack(s);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let i = "", r = "";
    return e.length > 1 && (i = e[1].replace(/^(\w+)::/, ""), r = e[2]), { id: t, name: i, type: r };
  }
  parseNodeProperty(e, t, i) {
    let r = t[1].replace(/^"/, "").replace(/"$/, "").trim(), s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    r === "Content" && s === "," && (s = i.replace(/"/g, "").replace(/,$/, "").trim());
    const a = this.getCurrentNode();
    if (a.name !== "Properties70") {
      if (r === "C") {
        const o = s.split(",").slice(1), l = parseInt(o[0]), h = parseInt(o[1]);
        let c = s.split(",").slice(3);
        c = c.map(function(u) {
          return u.trim().replace(/^"/, "");
        }), r = "connections", s = [l, h], function(u, d) {
          for (let p = 0, m = u.length, g = d.length; p < g; p++, m++)
            u[m] = d[p];
        }(s, c), a[r] === void 0 && (a[r] = []);
      }
      r === "Node" && (a.id = s), r in a && Array.isArray(a[r]) ? a[r].push(s) : r !== "a" ? a[r] = s : a.a = s, this.setCurrentProp(a, r), r === "a" && s.slice(-1) !== "," && (a.a = Nf(s));
    } else
      this.parseNodeSpecialProperty(e, r, s);
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = Nf(t.a));
  }
  parseNodeSpecialProperty(e, t, i) {
    const r = i.split('",').map(function(c) {
      return c.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), s = r[0], a = r[1], o = r[2], l = r[3];
    let h = r[4];
    switch (a) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        h = parseFloat(h);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        h = Nf(h);
    }
    this.getPrevNode()[s] = { type: a, type2: o, flag: l, value: h }, this.setCurrentProp(this.getPrevNode(), s);
  }
}
class TP {
  parse(e) {
    const t = new Jx(e);
    t.skip(23);
    const i = t.getUint32();
    if (i < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + i);
    const r = new BS();
    for (; !this.endOfContent(t); ) {
      const s = this.parseNode(t, i);
      s !== null && r.add(s.name, s);
    }
    return r;
  }
  endOfContent(e) {
    return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  parseNode(e, t) {
    const i = {}, r = t >= 7500 ? e.getUint64() : e.getUint32(), s = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const a = e.getUint8(), o = e.getString(a);
    if (r === 0)
      return null;
    const l = [];
    for (let d = 0; d < s; d++)
      l.push(this.parseProperty(e));
    const h = l.length > 0 ? l[0] : "", c = l.length > 1 ? l[1] : "", u = l.length > 2 ? l[2] : "";
    for (i.singleProperty = s === 1 && e.getOffset() === r; r > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(o, i, d);
    }
    return i.propertyList = l, typeof h == "number" && (i.id = h), c !== "" && (i.attrName = c), u !== "" && (i.attrType = u), o !== "" && (i.name = o), i;
  }
  parseSubNode(e, t, i) {
    if (i.singleProperty === !0) {
      const r = i.propertyList[0];
      Array.isArray(r) ? (t[i.name] = i, i.a = r) : t[i.name] = r;
    } else if (e === "Connections" && i.name === "C") {
      const r = [];
      i.propertyList.forEach(function(s, a) {
        a !== 0 && r.push(s);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(r);
    } else if (i.name === "Properties70")
      Object.keys(i).forEach(function(r) {
        t[r] = i[r];
      });
    else if (e === "Properties70" && i.name === "P") {
      let r = i.propertyList[0], s = i.propertyList[1];
      const a = i.propertyList[2], o = i.propertyList[3];
      let l;
      r.indexOf("Lcl ") === 0 && (r = r.replace("Lcl ", "Lcl_")), s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), l = s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? [i.propertyList[4], i.propertyList[5], i.propertyList[6]] : i.propertyList[4], t[r] = { type: s, type2: a, flag: o, value: l };
    } else
      t[i.name] === void 0 ? typeof i.id == "number" ? (t[i.name] = {}, t[i.name][i.id] = i) : t[i.name] = i : i.name === "PoseNode" ? (Array.isArray(t[i.name]) || (t[i.name] = [t[i.name]]), t[i.name].push(i)) : t[i.name][i.id] === void 0 && (t[i.name][i.id] = i);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let i;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return i = e.getUint32(), e.getArrayBuffer(i);
      case "S":
        return i = e.getUint32(), e.getString(i);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const r = e.getUint32(), s = e.getUint32(), a = e.getUint32();
        if (s === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(r);
            case "d":
              return e.getFloat64Array(r);
            case "f":
              return e.getFloat32Array(r);
            case "i":
              return e.getInt32Array(r);
            case "l":
              return e.getInt64Array(r);
          }
        const o = mP(new Uint8Array(e.getArrayBuffer(a))), l = new Jx(o.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(r);
          case "d":
            return l.getFloat64Array(r);
          case "f":
            return l.getFloat32Array(r);
          case "i":
            return l.getInt32Array(r);
          case "l":
            return l.getInt64Array(r);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class Jx {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t === void 0 || t, this.Er = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  getBoolean() {
    return !(1 & ~this.getUint8());
  }
  getBooleanArray(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, e = 4294967295 & ~e, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(4294967296 * t + e)) : 4294967296 * t + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getInt64());
    return t;
  }
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let i = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const r = i.indexOf(0);
    return r >= 0 && (i = new Uint8Array(this.dv.buffer, t, r)), this.Er.decode(i);
  }
}
class BS {
  add(e, t) {
    this[e] = t;
  }
}
function Qx(n) {
  const e = n.match(/FBXVersion: (\d+)/);
  if (e)
    return parseInt(e[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function EP(n) {
  return n / 46186158e3;
}
const AP = [];
function fu(n, e, t, i) {
  let r;
  switch (i.mappingType) {
    case "ByPolygonVertex":
      r = n;
      break;
    case "ByPolygon":
      r = e;
      break;
    case "ByVertice":
      r = t;
      break;
    case "AllSame":
      r = i.indices[0];
  }
  i.referenceType === "IndexToDirect" && (r = i.indices[r]);
  const s = r * i.dataSize, a = s + i.dataSize;
  return function(o, l, h, c) {
    for (let u = h, d = 0; u < c; u++, d++)
      o[d] = l[u];
    return o;
  }(AP, i.buffer, s, a);
}
const Lf = new gt(), so = new _();
function kS(n) {
  const e = new fe(), t = new fe(), i = new fe(), r = new fe(), s = new fe(), a = new fe(), o = new fe(), l = new fe(), h = new fe(), c = new fe(), u = new fe(), d = new fe(), p = n.inheritType ? n.inheritType : 0;
  if (n.translation && e.setPosition(so.fromArray(n.translation)), n.preRotation) {
    const I = n.preRotation.map(nn.degToRad);
    I.push(n.eulerOrder || gt.DEFAULT_ORDER), t.makeRotationFromEuler(Lf.fromArray(I));
  }
  if (n.rotation) {
    const I = n.rotation.map(nn.degToRad);
    I.push(n.eulerOrder || gt.DEFAULT_ORDER), i.makeRotationFromEuler(Lf.fromArray(I));
  }
  if (n.postRotation) {
    const I = n.postRotation.map(nn.degToRad);
    I.push(n.eulerOrder || gt.DEFAULT_ORDER), r.makeRotationFromEuler(Lf.fromArray(I)), r.invert();
  }
  n.scale && s.scale(so.fromArray(n.scale)), n.scalingOffset && o.setPosition(so.fromArray(n.scalingOffset)), n.scalingPivot && a.setPosition(so.fromArray(n.scalingPivot)), n.rotationOffset && l.setPosition(so.fromArray(n.rotationOffset)), n.rotationPivot && h.setPosition(so.fromArray(n.rotationPivot)), n.parentMatrixWorld && (u.copy(n.parentMatrix), c.copy(n.parentMatrixWorld));
  const m = t.clone().multiply(i).multiply(r), g = new fe();
  g.extractRotation(c);
  const f = new fe();
  f.copyPosition(c);
  const v = f.clone().invert().multiply(c), y = g.clone().invert().multiply(v), x = s, M = new fe();
  if (p === 0)
    M.copy(g).multiply(m).multiply(y).multiply(x);
  else if (p === 1)
    M.copy(g).multiply(y).multiply(m).multiply(x);
  else {
    const I = new fe().scale(new _().setFromMatrixScale(u)).clone().invert(), A = y.clone().multiply(I);
    M.copy(g).multiply(m).multiply(A).multiply(x);
  }
  const b = h.clone().invert(), S = a.clone().invert();
  let w = e.clone().multiply(l).multiply(h).multiply(t).multiply(i).multiply(r).multiply(b).multiply(o).multiply(a).multiply(s).multiply(S);
  const T = new fe().copyPosition(w), C = c.clone().multiply(T);
  return d.copyPosition(C), w = d.clone().multiply(M), w.premultiply(c.invert()), w;
}
function zS(n) {
  const e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
  return (n = n || 0) === 6 ? e[0] : e[n];
}
function Nf(n) {
  return n.split(",").map(function(e) {
    return parseFloat(e);
  });
}
function $x(n, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = n.byteLength), new TextDecoder().decode(new Uint8Array(n, e, t));
}
function e1(n, e) {
  if (e === 0)
    return n;
  if (e === 2 || e === 1) {
    let t = n.getIndex();
    if (t === null) {
      const a = [], o = n.getAttribute("position");
      if (o === void 0)
        return n;
      for (let l = 0; l < o.count; l++)
        a.push(l);
      n.setIndex(a), t = n.getIndex();
    }
    const i = t.count - 2, r = [];
    if (e === 2)
      for (let a = 1; a <= i; a++)
        r.push(t.getX(0)), r.push(t.getX(a)), r.push(t.getX(a + 1));
    else
      for (let a = 0; a < i; a++)
        a % 2 == 0 ? (r.push(t.getX(a)), r.push(t.getX(a + 1)), r.push(t.getX(a + 2))) : (r.push(t.getX(a + 2)), r.push(t.getX(a + 1)), r.push(t.getX(a)));
    r.length;
    const s = n.clone();
    return s.setIndex(r), s.clearGroups(), s;
  }
  return n;
}
class CP extends It {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new NP(t);
    }), this.register(function(t) {
      return new DP(t);
    }), this.register(function(t) {
      return new GP(t);
    }), this.register(function(t) {
      return new jP(t);
    }), this.register(function(t) {
      return new WP(t);
    }), this.register(function(t) {
      return new UP(t);
    }), this.register(function(t) {
      return new FP(t);
    }), this.register(function(t) {
      return new BP(t);
    }), this.register(function(t) {
      return new kP(t);
    }), this.register(function(t) {
      return new LP(t);
    }), this.register(function(t) {
      return new zP(t);
    }), this.register(function(t) {
      return new OP(t);
    }), this.register(function(t) {
      return new HP(t);
    }), this.register(function(t) {
      return new VP(t);
    }), this.register(function(t) {
      return new RP(t);
    }), this.register(function(t) {
      return new XP(t);
    }), this.register(function(t) {
      return new qP(t);
    });
  }
  load(e, t, i, r) {
    const s = this;
    let a;
    if (this.resourcePath !== "")
      a = this.resourcePath;
    else if (this.path !== "") {
      const h = tr.extractUrlBase(e);
      a = tr.resolveURL(h, this.path);
    } else
      a = tr.extractUrlBase(e);
    this.manager.itemStart(e);
    const o = function(h) {
      r && r(h), s.manager.itemError(e), s.manager.itemEnd(e);
    }, l = new gn(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(h) {
      try {
        s.parse(h, a, function(c) {
          t(c), s.manager.itemEnd(e);
        }, o);
      } catch (c) {
        o(c);
      }
    }, i, o);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, i, r) {
    let s;
    const a = {}, o = {}, l = new TextDecoder();
    if (typeof e == "string")
      s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === VS) {
        try {
          a[Je.KHR_BINARY_GLTF] = new KP(e);
        } catch (c) {
          return void (r && r(c));
        }
        s = JSON.parse(a[Je.KHR_BINARY_GLTF].content);
      } else
        s = JSON.parse(l.decode(e));
    else
      s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2)
      return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
    const h = new hR(s, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
    h.fileLoader.setRequestHeader(this.requestHeader);
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const u = this.pluginCallbacks[c](h);
      u.name, o[u.name] = u, a[u.name] = !0;
    }
    if (s.extensionsUsed)
      for (let c = 0; c < s.extensionsUsed.length; ++c) {
        const u = s.extensionsUsed[c], d = s.extensionsRequired || [];
        switch (u) {
          case Je.KHR_MATERIALS_UNLIT:
            a[u] = new IP();
            break;
          case Je.KHR_DRACO_MESH_COMPRESSION:
            a[u] = new JP(s, this.dracoLoader);
            break;
          case Je.KHR_TEXTURE_TRANSFORM:
            a[u] = new QP();
            break;
          case Je.KHR_MESH_QUANTIZATION:
            a[u] = new $P();
            break;
          default:
            d.indexOf(u) >= 0 && o[u];
        }
      }
    h.setExtensions(a), h.setPlugins(o), h.parse(i, r);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function(r, s) {
      i.parse(e, t, r, s);
    });
  }
}
function PP() {
  let n = {};
  return { get: function(e) {
    return n[e];
  }, add: function(e, t) {
    n[e] = t;
  }, remove: function(e) {
    delete n[e];
  }, removeAll: function() {
    n = {};
  } };
}
const Je = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_MATERIALS_BUMP: "EXT_materials_bump", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" };
class RP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  Tr() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e.Cr(this.cache, s.extensions[this.name].light);
    }
  }
  Pr(e) {
    const t = this.parser, i = "light:" + e;
    let r = t.cache.get(i);
    if (r)
      return r;
    const s = t.json, a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
    let o;
    const l = new oe(16777215);
    a.color !== void 0 && l.setRGB(a.color[0], a.color[1], a.color[2], Jt);
    const h = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        o = new yh(l), o.target.position.set(0, 0, -1), o.add(o.target);
        break;
      case "point":
        o = new Wo(l), o.distance = h;
        break;
      case "spot":
        o = new vh(l), o.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, o.angle = a.spot.outerConeAngle, o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return o.position.set(0, 0, 0), o.decay = 2, vr(o, a), a.intensity !== void 0 && (o.intensity = a.intensity), o.name = t.createUniqueName(a.name || "light_" + e), r = Promise.resolve(o), t.cache.add(i, r), r;
  }
  getDependency(e, t) {
    if (e === "light")
      return this.Pr(t);
  }
  createNodeAttachment(e) {
    const t = this, i = this.parser, r = i.json.nodes[e], s = (r.extensions && r.extensions[this.name] || {}).light;
    return s === void 0 ? null : this.Pr(s).then(function(a) {
      return i.Lr(t.cache, s, a);
    });
  }
}
class IP {
  constructor() {
    this.name = Je.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Wt;
  }
  extendParams(e, t, i) {
    const r = [];
    e.color = new oe(1, 1, 1), e.opacity = 1;
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const a = s.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], Jt), e.opacity = a[3];
      }
      s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, "map", s.baseColorTexture, mt));
    }
    return Promise.all(r);
  }
}
class LP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class NP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new X(o, o);
    }
    return Promise.all(s);
  }
}
class DP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name];
    return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
  }
}
class OP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(s);
  }
}
class UP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [];
    t.sheenColor = new oe(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const a = r.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const o = a.sheenColorFactor;
      t.sheenColor.setRGB(o[0], o[1], o[2], Jt);
    }
    return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", a.sheenColorTexture, mt)), a.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s);
  }
}
class FP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(s);
  }
}
class BP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
    const o = a.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new oe().setRGB(o[0], o[1], o[2], Jt), Promise.all(s);
  }
}
class kP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}
class zP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return t.specularColor = new oe().setRGB(o[0], o[1], o[2], Jt), a.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", a.specularColorTexture, mt)), Promise.all(s);
  }
}
class VP {
  constructor(e) {
    this.parser = e, this.name = Je.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && s.push(i.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(s);
  }
}
class HP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? ai : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const s = [], a = r.extensions[this.name];
    return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && s.push(i.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(s);
  }
}
class GP {
  constructor(e) {
    this.parser = e, this.name = Je.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, i = t.json, r = i.textures[e];
    if (!r.extensions || !r.extensions[this.name])
      return null;
    const s = r.extensions[this.name], a = t.options.ktx2Loader;
    if (!a) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, s.source, a);
  }
}
class jP {
  constructor(e) {
    this.parser = e, this.name = Je.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, r = i.json, s = r.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const a = s.extensions[t], o = r.images[a.source];
    let l = i.textureLoader;
    if (o.uri) {
      const h = i.options.manager.getHandler(o.uri);
      h !== null && (l = h);
    }
    return this.detectSupport().then(function(h) {
      if (h)
        return i.loadTextureImage(e, a.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class WP {
  constructor(e) {
    this.parser = e, this.name = Je.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, r = i.json, s = r.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const a = s.extensions[t], o = r.images[a.source];
    let l = i.textureLoader;
    if (o.uri) {
      const h = i.options.manager.getHandler(o.uri);
      h !== null && (l = h);
    }
    return this.detectSupport().then(function(h) {
      if (h)
        return i.loadTextureImage(e, a.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class XP {
  constructor(e) {
    this.name = Je.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name], s = this.parser.getDependency("buffer", r.buffer), a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return s.then(function(o) {
        const l = r.byteOffset || 0, h = r.byteLength || 0, c = r.count, u = r.byteStride, d = new Uint8Array(o, l, h);
        return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(c, u, d, r.mode, r.filter).then(function(p) {
          return p.buffer;
        }) : a.ready.then(function() {
          const p = new ArrayBuffer(c * u);
          return a.decodeGltfBuffer(new Uint8Array(p), c, u, d, r.mode, r.filter), p;
        });
      });
    }
    return null;
  }
}
class qP {
  constructor(e) {
    this.name = Je.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const r = t.meshes[i.mesh];
    for (const l of r.primitives)
      if (l.mode !== fi.TRIANGLES && l.mode !== fi.TRIANGLE_STRIP && l.mode !== fi.TRIANGLE_FAN && l.mode !== void 0)
        return null;
    const s = i.extensions[this.name].attributes, a = [], o = {};
    for (const l in s)
      a.push(this.parser.getDependency("accessor", s[l]).then((h) => (o[l] = h, o[l])));
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((l) => {
      const h = l.pop(), c = h.isGroup ? h.children : [h], u = l[0].count, d = [];
      for (const p of c) {
        const m = new fe(), g = new _(), f = new Ye(), v = new _(1, 1, 1), y = new Em(p.geometry, p.material, u);
        for (let x = 0; x < u; x++)
          o.TRANSLATION && g.fromBufferAttribute(o.TRANSLATION, x), o.ROTATION && f.fromBufferAttribute(o.ROTATION, x), o.SCALE && v.fromBufferAttribute(o.SCALE, x), y.setMatrixAt(x, m.compose(g, f, v));
        for (const x in o)
          if (x === "_COLOR_0") {
            const M = o[x];
            y.instanceColor = new da(M.array, M.itemSize, M.normalized);
          } else
            x !== "TRANSLATION" && x !== "ROTATION" && x !== "SCALE" && p.geometry.setAttribute(x, o[x]);
        Ue.prototype.copy.call(y, p), this.parser.assignFinalMaterial(y), d.push(y);
      }
      return h.isGroup ? (h.clear(), h.add(...d), h) : d[0];
    }));
  }
}
const VS = "glTF", YP = 1313821514, ZP = 5130562;
class KP {
  constructor(e) {
    this.name = Je.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, 12), i = new TextDecoder();
    if (this.header = { magic: i.decode(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== VS)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const r = this.header.length - 12, s = new DataView(e, 12);
    let a = 0;
    for (; a < r; ) {
      const o = s.getUint32(a, !0);
      a += 4;
      const l = s.getUint32(a, !0);
      if (a += 4, l === YP) {
        const h = new Uint8Array(e, 12 + a, o);
        this.content = i.decode(h);
      } else if (l === ZP) {
        const h = 12 + a;
        this.body = e.slice(h, h + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class JP {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Je.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json, r = this.dracoLoader, s = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, h = {};
    for (const c in a) {
      const u = hg[c] || c.toLowerCase();
      o[u] = a[c];
    }
    for (const c in e.attributes) {
      const u = hg[c] || c.toLowerCase();
      if (a[c] !== void 0) {
        const d = i.accessors[e.attributes[c]], p = Po[d.componentType];
        h[u] = p.name, l[u] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", s).then(function(c) {
      return new Promise(function(u, d) {
        r.decodeDracoFile(c, function(p) {
          for (const m in p.attributes) {
            const g = p.attributes[m], f = l[m];
            f !== void 0 && (g.normalized = f);
          }
          u(p);
        }, o, h, Jt, d);
      });
    });
  }
}
class QP {
  constructor() {
    this.name = Je.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord !== void 0 && t.texCoord !== e.channel || t.offset !== void 0 || t.rotation !== void 0 || t.scale !== void 0) && (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class $P {
  constructor() {
    this.name = Je.KHR_MESH_QUANTIZATION;
  }
}
class HS extends tl {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r * 3 + r;
    for (let a = 0; a !== r; a++)
      t[a] = i[s + a];
    return t;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = 2 * o, h = 3 * o, c = r - t, u = (i - t) / c, d = u * u, p = d * u, m = e * h, g = m - h, f = -2 * p + 3 * d, v = p - d, y = 1 - f, x = v - d + u;
    for (let M = 0; M !== o; M++) {
      const b = a[g + M + o], S = a[g + M + l] * c, w = a[m + M + o], T = a[m + M] * c;
      s[M] = y * b + x * S + f * w + v * T;
    }
    return s;
  }
}
const eR = new Ye();
class tR extends HS {
  interpolate_(e, t, i, r) {
    const s = super.interpolate_(e, t, i, r);
    return eR.fromArray(s).normalize().toArray(s), s;
  }
}
const fi = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, Po = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, t1 = { 9728: at, 9729: Vt, 9984: Pd, 9985: xo, 9986: sa, 9987: er }, n1 = { 33071: vn, 33648: fs, 10497: jt }, Df = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, hg = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, Wr = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, nR = { CUBICSPLINE: void 0, LINEAR: Uo, STEP: Oo }, iR = "OPAQUE", rR = "MASK", sR = "BLEND";
function Xs(n, e, t) {
  for (const i in t.extensions)
    n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]);
}
function vr(n, e) {
  e.extras !== void 0 && typeof e.extras == "object" && Object.assign(n.userData, e.extras);
}
function aR(n, e) {
  if (n.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, i = e.weights.length; t < i; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let i = 0, r = t.length; i < r; i++)
        n.morphTargetDictionary[t[i]] = i;
    }
  }
}
function oR(n) {
  let e;
  const t = n.extensions && n.extensions[Je.KHR_DRACO_MESH_COMPRESSION];
  if (e = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + Of(t.attributes) : n.indices + ":" + Of(n.attributes) + ":" + n.mode, n.targets !== void 0)
    for (let i = 0, r = n.targets.length; i < r; i++)
      e += ":" + Of(n.targets[i]);
  return e;
}
function Of(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let i = 0, r = t.length; i < r; i++)
    e += t[i] + ":" + n[t[i]] + ";";
  return e;
}
function cg(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
const lR = new fe();
class hR {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new PP(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let i = !1, r = !1, s = -1;
    typeof navigator != "undefined" && (i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, r = navigator.userAgent.indexOf("Firefox") > -1, s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap == "undefined" || i || r && s < 98 ? this.textureLoader = new Ui(this.options.manager) : this.textureLoader = new EM(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new gn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this, r = this.json, s = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this.Nr(function(a) {
      return a.Tr && a.Tr();
    }), Promise.all(this.Nr(function(a) {
      return a.beforeRoot && a.beforeRoot();
    })).then(function() {
      return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")]);
    }).then(function(a) {
      const o = { scene: a[0][r.scene || 0], scenes: a[0], animations: a[1], cameras: a[2], asset: r.asset, parser: i, userData: {} };
      return Xs(s, o, r), vr(o, r), Promise.all(i.Nr(function(l) {
        return l.afterRoot && l.afterRoot(o);
      })).then(function() {
        for (const l of o.scenes)
          l.updateMatrixWorld();
        e(o);
      });
    }).catch(t);
  }
  Tr() {
    const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [];
    for (let r = 0, s = t.length; r < s; r++) {
      const a = t[r].joints;
      for (let o = 0, l = a.length; o < l; o++)
        e[a[o]].isBone = !0;
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const a = e[r];
      a.mesh !== void 0 && (this.Cr(this.meshCache, a.mesh), a.skin !== void 0 && (i[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this.Cr(this.cameraCache, a.camera);
    }
  }
  Cr(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  Lr(e, t, i) {
    if (e.refs[t] <= 1)
      return i;
    const r = i.clone(), s = (a, o) => {
      const l = this.associations.get(a);
      l != null && this.associations.set(o, l);
      for (const [h, c] of a.children.entries())
        s(c, o.children[h]);
    };
    return s(i, r), r.name += "_instance_" + e.uses[t]++, r;
  }
  Rr(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      if (r)
        return r;
    }
    return null;
  }
  Nr(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let r = this.cache.get(i);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this.Rr(function(s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          r = this.Rr(function(s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this.Rr(function(s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this.Rr(function(s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          r = this.Rr(function(s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this.Rr(function(s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          if (r = this.Rr(function(s) {
            return s != this && s.getDependency && s.getDependency(e, t);
          }), !r)
            throw new Error("Unknown type: " + e);
      }
      this.cache.add(i, r);
    }
    return r;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this, r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(r.map(function(s, a) {
        return i.getDependency(e, a);
      })), this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e], i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Je.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function(s, a) {
      i.load(tr.resolveURL(t.uri, r.path), s, void 0, function() {
        a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(i) {
      const r = t.byteLength || 0, s = t.byteOffset || 0;
      return i.slice(s, s + r);
    });
  }
  loadAccessor(e) {
    const t = this, i = this.json, r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const a = Df[r.type], o = Po[r.componentType], l = r.normalized === !0, h = new o(r.count * a);
      return Promise.resolve(new Ke(h, a, l));
    }
    const s = [];
    return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function(a) {
      const o = a[0], l = Df[r.type], h = Po[r.componentType], c = h.BYTES_PER_ELEMENT, u = c * l, d = r.byteOffset || 0, p = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0, m = r.normalized === !0;
      let g, f;
      if (p && p !== u) {
        const v = Math.floor(d / p), y = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + v + ":" + r.count;
        let x = t.cache.get(y);
        x || (g = new h(o, v * p, r.count * p / c), x = new Xh(g, p / c), t.cache.add(y, x)), f = new zn(x, l, d % p / c, m);
      } else
        g = o === null ? new h(r.count * l) : new h(o, d, r.count * l), f = new Ke(g, l, m);
      if (r.sparse !== void 0) {
        const v = Df.SCALAR, y = Po[r.sparse.indices.componentType], x = r.sparse.indices.byteOffset || 0, M = r.sparse.values.byteOffset || 0, b = new y(a[1], x, r.sparse.count * v), S = new h(a[2], M, r.sparse.count * l);
        o !== null && (f = new Ke(f.array.slice(), f.itemSize, f.normalized));
        for (let w = 0, T = b.length; w < T; w++) {
          const C = b[w];
          if (f.setX(C, S[w * l]), l >= 2 && f.setY(C, S[w * l + 1]), l >= 3 && f.setZ(C, S[w * l + 2]), l >= 4 && f.setW(C, S[w * l + 3]), l >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return f;
    });
  }
  loadTexture(e) {
    const t = this.json, i = this.options, r = t.textures[e].source, s = t.images[r];
    let a = this.textureLoader;
    if (s.uri) {
      const o = i.manager.getHandler(s.uri);
      o !== null && (a = o);
    }
    return this.loadTextureImage(e, r, a);
  }
  loadTextureImage(e, t, i) {
    const r = this, s = this.json, a = s.textures[e], o = s.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const h = this.loadImageSource(t, i).then(function(c) {
      c.flipY = !1, c.name = a.name || o.name || "", c.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (c.name = o.uri);
      const u = (s.samplers || {})[a.sampler] || {};
      return c.magFilter = t1[u.magFilter] || Vt, c.minFilter = t1[u.minFilter] || er, c.wrapS = n1[u.wrapS] || jt, c.wrapT = n1[u.wrapT] || jt, r.associations.set(c, { textures: e }), c;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = h, h;
  }
  loadImageSource(e, t) {
    const i = this, r = this.json, s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((u) => u.clone());
    const a = r.images[e], o = self.URL || self.webkitURL;
    let l = a.uri || "", h = !1;
    if (a.bufferView !== void 0)
      l = i.getDependency("bufferView", a.bufferView).then(function(u) {
        h = !0;
        const d = new Blob([u], { type: a.mimeType });
        return l = o.createObjectURL(d), l;
      });
    else if (a.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const c = Promise.resolve(l).then(function(u) {
      return new Promise(function(d, p) {
        let m = d;
        t.isImageBitmapLoader === !0 && (m = function(g) {
          const f = new pt(g);
          f.needsUpdate = !0, d(f);
        }), t.load(tr.resolveURL(u, s.path), m, void 0, p);
      });
    }).then(function(u) {
      var d;
      return h === !0 && o.revokeObjectURL(l), vr(u, a), u.userData.mimeType = a.mimeType || ((d = a.uri).search(/\.jpe?g($|\?)/i) > 0 || d.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : d.search(/\.webp($|\?)/i) > 0 || d.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"), u;
    }).catch(function(u) {
      throw u;
    });
    return this.sourceCache[e] = c, c;
  }
  assignTexture(e, t, i, r) {
    const s = this;
    return this.getDependency("texture", i.index).then(function(a) {
      if (!a)
        return null;
      if (i.texCoord !== void 0 && i.texCoord > 0 && ((a = a.clone()).channel = i.texCoord), s.extensions[Je.KHR_TEXTURE_TRANSFORM]) {
        const o = i.extensions !== void 0 ? i.extensions[Je.KHR_TEXTURE_TRANSFORM] : void 0;
        if (o) {
          const l = s.associations.get(a);
          a = s.extensions[Je.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), s.associations.set(a, l);
        }
      }
      return r !== void 0 && (a.colorSpace = r), e[t] = a, a;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const r = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(o);
      l || (l = new Jr(), Xt.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = !1, this.cache.add(o, l)), i = l;
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(o);
      l || (l = new kt(), Xt.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, this.cache.add(o, l)), i = l;
    }
    if (r || s || a) {
      let o = "ClonedMaterial:" + i.uuid + ":";
      r && (o += "derivative-tangents:"), s && (o += "vertex-colors:"), a && (o += "flat-shading:");
      let l = this.cache.get(o);
      l || (l = i.clone(), s && (l.vertexColors = !0), a && (l.flatShading = !0), r && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(i))), i = l;
    }
    e.material = i;
  }
  getMaterialType() {
    return jo;
  }
  loadMaterial(e) {
    const t = this, i = this.json, r = this.extensions, s = i.materials[e];
    let a;
    const o = {}, l = [];
    if ((s.extensions || {})[Je.KHR_MATERIALS_UNLIT]) {
      const c = r[Je.KHR_MATERIALS_UNLIT];
      a = c.getMaterialType(), l.push(c.extendParams(o, s, t));
    } else {
      const c = s.pbrMetallicRoughness || {};
      if (o.color = new oe(1, 1, 1), o.opacity = 1, Array.isArray(c.baseColorFactor)) {
        const u = c.baseColorFactor;
        o.color.setRGB(u[0], u[1], u[2], Jt), o.opacity = u[3];
      }
      c.baseColorTexture !== void 0 && l.push(t.assignTexture(o, "map", c.baseColorTexture, mt)), o.metalness = c.metallicFactor !== void 0 ? c.metallicFactor : 1, o.roughness = c.roughnessFactor !== void 0 ? c.roughnessFactor : 1, c.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(o, "metalnessMap", c.metallicRoughnessTexture)), l.push(t.assignTexture(o, "roughnessMap", c.metallicRoughnessTexture))), a = this.Rr(function(u) {
        return u.getMaterialType && u.getMaterialType(e);
      }), l.push(Promise.all(this.Nr(function(u) {
        return u.extendMaterialParams && u.extendMaterialParams(e, o);
      })));
    }
    s.doubleSided === !0 && (o.side = bt);
    const h = s.alphaMode || iR;
    if (h === sR ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, h === rR && (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && a !== Wt && (l.push(t.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new X(1, 1), s.normalTexture.scale !== void 0)) {
      const c = s.normalTexture.scale;
      o.normalScale.set(c, c);
    }
    if (s.occlusionTexture !== void 0 && a !== Wt && (l.push(t.assignTexture(o, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && a !== Wt) {
      const c = s.emissiveFactor;
      o.emissive = new oe().setRGB(c[0], c[1], c[2], Jt);
    }
    return s.emissiveTexture !== void 0 && a !== Wt && l.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, mt)), Promise.all(l).then(function() {
      const c = new a(o);
      return s.name && (c.name = s.name), vr(c, s), t.associations.set(c, { materials: e }), s.extensions && Xs(r, c, s), c;
    });
  }
  createUniqueName(e) {
    const t = qe.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  loadGeometries(e) {
    const t = this, i = this.extensions, r = this.primitiveCache;
    function s(o) {
      return i[Je.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
        return i1(l, o, t);
      });
    }
    const a = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const h = e[o], c = oR(h), u = r[c];
      if (u)
        a.push(u.promise);
      else {
        let d;
        d = h.extensions && h.extensions[Je.KHR_DRACO_MESH_COMPRESSION] ? s(h) : i1(new Pe(), h, t), r[c] = { primitive: h, promise: d }, a.push(d);
      }
    }
    return Promise.all(a);
  }
  loadMesh(e) {
    const t = this, i = this.json, r = this.extensions, s = i.meshes[e], a = s.primitives, o = [];
    for (let h = 0, c = a.length; h < c; h++) {
      const u = a[h].material === void 0 ? ((l = this.cache).DefaultMaterial === void 0 && (l.DefaultMaterial = new jo({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: Mi })), l.DefaultMaterial) : this.getDependency("material", a[h].material);
      o.push(u);
    }
    var l;
    return o.push(t.loadGeometries(a)), Promise.all(o).then(function(h) {
      const c = h.slice(0, h.length - 1), u = h[h.length - 1], d = [];
      for (let m = 0, g = u.length; m < g; m++) {
        const f = u[m], v = a[m];
        let y;
        const x = c[m];
        if (v.mode === fi.TRIANGLES || v.mode === fi.TRIANGLE_STRIP || v.mode === fi.TRIANGLE_FAN || v.mode === void 0)
          y = s.isSkinnedMesh === !0 ? new ju(f, x) : new ce(f, x), y.isSkinnedMesh === !0 && y.normalizeSkinWeights(), v.mode === fi.TRIANGLE_STRIP ? y.geometry = e1(y.geometry, 1) : v.mode === fi.TRIANGLE_FAN && (y.geometry = e1(y.geometry, 2));
        else if (v.mode === fi.LINES)
          y = new Zn(f, x);
        else if (v.mode === fi.LINE_STRIP)
          y = new hn(f, x);
        else if (v.mode === fi.LINE_LOOP)
          y = new Am(f, x);
        else {
          if (v.mode !== fi.POINTS)
            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode);
          y = new os(f, x);
        }
        Object.keys(y.geometry.morphAttributes).length > 0 && aR(y, s), y.name = t.createUniqueName(s.name || "mesh_" + e), vr(y, s), v.extensions && Xs(r, y, v), t.assignFinalMaterial(y), d.push(y);
      }
      for (let m = 0, g = d.length; m < g; m++)
        t.associations.set(d[m], { meshes: e, primitives: m });
      if (d.length === 1)
        return s.extensions && Xs(r, d[0], s), d[0];
      const p = new yn();
      s.extensions && Xs(r, p, s), t.associations.set(p, { meshes: e });
      for (let m = 0, g = d.length; m < g; m++)
        p.add(d[m]);
      return p;
    });
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e], r = i[i.type];
    if (r)
      return i.type === "perspective" ? t = new Gt(nn.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : i.type === "orthographic" && (t = new _a(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), vr(t, i), Promise.resolve(t);
  }
  loadSkin(e) {
    const t = this.json.skins[e], i = [];
    for (let r = 0, s = t.joints.length; r < s; r++)
      i.push(this.Dr(t.joints[r]));
    return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(r) {
      const s = r.pop(), a = r, o = [], l = [];
      for (let h = 0, c = a.length; h < c; h++) {
        const u = a[h];
        if (u) {
          o.push(u);
          const d = new fe();
          s !== null && d.fromArray(s.array, 16 * h), l.push(d);
        }
      }
      return new Ho(o, l);
    });
  }
  loadAnimation(e) {
    const t = this.json, i = this, r = t.animations[e], s = r.name ? r.name : "animation_" + e, a = [], o = [], l = [], h = [], c = [];
    for (let u = 0, d = r.channels.length; u < d; u++) {
      const p = r.channels[u], m = r.samplers[p.sampler], g = p.target, f = g.node, v = r.parameters !== void 0 ? r.parameters[m.input] : m.input, y = r.parameters !== void 0 ? r.parameters[m.output] : m.output;
      g.node !== void 0 && (a.push(this.getDependency("node", f)), o.push(this.getDependency("accessor", v)), l.push(this.getDependency("accessor", y)), h.push(m), c.push(g));
    }
    return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l), Promise.all(h), Promise.all(c)]).then(function(u) {
      const d = u[0], p = u[1], m = u[2], g = u[3], f = u[4], v = [];
      for (let y = 0, x = d.length; y < x; y++) {
        const M = d[y], b = p[y], S = m[y], w = g[y], T = f[y];
        if (M === void 0)
          continue;
        M.updateMatrix && M.updateMatrix();
        const C = i.Ir(M, b, S, w, T);
        if (C)
          for (let I = 0; I < C.length; I++)
            v.push(C[I]);
      }
      return new pa(s, void 0, v);
    });
  }
  createNodeMesh(e) {
    const t = this.json, i = this, r = t.nodes[e];
    return r.mesh === void 0 ? null : i.getDependency("mesh", r.mesh).then(function(s) {
      const a = i.Lr(i.meshCache, r.mesh, s);
      return r.weights !== void 0 && a.traverse(function(o) {
        if (o.isMesh)
          for (let l = 0, h = r.weights.length; l < h; l++)
            o.morphTargetInfluences[l] = r.weights[l];
      }), a;
    });
  }
  loadNode(e) {
    const t = this, i = this.json.nodes[e], r = t.Dr(e), s = [], a = i.children || [];
    for (let l = 0, h = a.length; l < h; l++)
      s.push(t.getDependency("node", a[l]));
    const o = i.skin === void 0 ? Promise.resolve(null) : t.getDependency("skin", i.skin);
    return Promise.all([r, Promise.all(s), o]).then(function(l) {
      const h = l[0], c = l[1], u = l[2];
      u !== null && h.traverse(function(d) {
        d.isSkinnedMesh && d.bind(u, lR);
      });
      for (let d = 0, p = c.length; d < p; d++)
        h.add(c[d]);
      return h;
    });
  }
  Dr(e) {
    const t = this.json, i = this.extensions, r = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const s = t.nodes[e], a = s.name ? r.createUniqueName(s.name) : "", o = [], l = r.Rr(function(h) {
      return h.createNodeMesh && h.createNodeMesh(e);
    });
    return l && o.push(l), s.camera !== void 0 && o.push(r.getDependency("camera", s.camera).then(function(h) {
      return r.Lr(r.cameraCache, s.camera, h);
    })), r.Nr(function(h) {
      return h.createNodeAttachment && h.createNodeAttachment(e);
    }).forEach(function(h) {
      o.push(h);
    }), this.nodeCache[e] = Promise.all(o).then(function(h) {
      let c;
      if (c = s.isBone === !0 ? new Vo() : h.length > 1 ? new yn() : h.length === 1 ? h[0] : new Ue(), c !== h[0])
        for (let u = 0, d = h.length; u < d; u++)
          c.add(h[u]);
      if (s.name && (c.userData.name = s.name, c.name = a), vr(c, s), s.extensions && Xs(i, c, s), s.matrix !== void 0) {
        const u = new fe();
        u.fromArray(s.matrix), c.applyMatrix4(u);
      } else
        s.translation !== void 0 && c.position.fromArray(s.translation), s.rotation !== void 0 && c.quaternion.fromArray(s.rotation), s.scale !== void 0 && c.scale.fromArray(s.scale);
      return r.associations.has(c) || r.associations.set(c, {}), r.associations.get(c).nodes = e, c;
    }), this.nodeCache[e];
  }
  loadScene(e) {
    const t = this.extensions, i = this.json.scenes[e], r = this, s = new yn();
    i.name && (s.name = r.createUniqueName(i.name)), vr(s, i), i.extensions && Xs(t, s, i);
    const a = i.nodes || [], o = [];
    for (let l = 0, h = a.length; l < h; l++)
      o.push(r.getDependency("node", a[l]));
    return Promise.all(o).then(function(l) {
      for (let h = 0, c = l.length; h < c; h++)
        s.add(l[h]);
      return r.associations = ((h) => {
        const c = /* @__PURE__ */ new Map();
        for (const [u, d] of r.associations)
          (u instanceof Xt || u instanceof pt) && c.set(u, d);
        return h.traverse((u) => {
          const d = r.associations.get(u);
          d != null && c.set(u, d);
        }), c;
      })(s), s;
    });
  }
  Ir(e, t, i, r, s) {
    const a = [], o = e.name ? e.name : e.uuid, l = [];
    let h;
    switch (Wr[s.path] === Wr.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
    }) : l.push(o), Wr[s.path]) {
      case Wr.weights:
        h = vs;
        break;
      case Wr.rotation:
        h = Rr;
        break;
      case Wr.position:
      case Wr.scale:
        h = ys;
        break;
      default:
        i.itemSize === 1 ? h = vs : h = ys;
    }
    const c = r.interpolation !== void 0 ? nR[r.interpolation] : Uo, u = this.Ur(i);
    for (let d = 0, p = l.length; d < p; d++) {
      const m = new h(l[d] + "." + Wr[s.path], t.array, u, c);
      r.interpolation === "CUBICSPLINE" && this.Or(m), a.push(m);
    }
    return a;
  }
  Ur(e) {
    let t = e.array;
    if (e.normalized) {
      const i = cg(t.constructor), r = new Float32Array(t.length);
      for (let s = 0, a = t.length; s < a; s++)
        r[s] = t[s] * i;
      t = r;
    }
    return t;
  }
  Or(e) {
    e.createInterpolant = function(t) {
      return new (this instanceof Rr ? tR : HS)(this.times, this.values, this.getValueSize() / 3, t);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function i1(n, e, t) {
  const i = e.attributes, r = [];
  function s(a, o) {
    return t.getDependency("accessor", a).then(function(l) {
      n.setAttribute(o, l);
    });
  }
  for (const a in i) {
    const o = hg[a] || a.toLowerCase();
    o in n.attributes || r.push(s(i[a], o));
  }
  if (e.indices !== void 0 && !n.index) {
    const a = t.getDependency("accessor", e.indices).then(function(o) {
      n.setIndex(o);
    });
    r.push(a);
  }
  return it.workingColorSpace, vr(n, e), function(a, o, l) {
    const h = o.attributes, c = new yt();
    if (h.POSITION === void 0)
      return;
    {
      const p = l.json.accessors[h.POSITION], m = p.min, g = p.max;
      if (m === void 0 || g === void 0)
        return;
      if (c.set(new _(m[0], m[1], m[2]), new _(g[0], g[1], g[2])), p.normalized) {
        const f = cg(Po[p.componentType]);
        c.min.multiplyScalar(f), c.max.multiplyScalar(f);
      }
    }
    const u = o.targets;
    if (u !== void 0) {
      const p = new _(), m = new _();
      for (let g = 0, f = u.length; g < f; g++) {
        const v = u[g];
        if (v.POSITION !== void 0) {
          const y = l.json.accessors[v.POSITION], x = y.min, M = y.max;
          if (x !== void 0 && M !== void 0) {
            if (m.setX(Math.max(Math.abs(x[0]), Math.abs(M[0]))), m.setY(Math.max(Math.abs(x[1]), Math.abs(M[1]))), m.setZ(Math.max(Math.abs(x[2]), Math.abs(M[2]))), y.normalized) {
              const b = cg(Po[y.componentType]);
              m.multiplyScalar(b);
            }
            p.max(m);
          }
        }
      }
      c.expandByVector(p);
    }
    a.boundingBox = c;
    const d = new rn();
    c.getCenter(d.center), d.radius = c.min.distanceTo(c.max) / 2, a.boundingSphere = d;
  }(n, e, t), Promise.all(r).then(function() {
    return e.targets !== void 0 ? function(a, o, l) {
      let h = !1, c = !1, u = !1;
      for (let g = 0, f = o.length; g < f; g++) {
        const v = o[g];
        if (v.POSITION !== void 0 && (h = !0), v.NORMAL !== void 0 && (c = !0), v.COLOR_0 !== void 0 && (u = !0), h && c && u)
          break;
      }
      if (!h && !c && !u)
        return Promise.resolve(a);
      const d = [], p = [], m = [];
      for (let g = 0, f = o.length; g < f; g++) {
        const v = o[g];
        if (h) {
          const y = v.POSITION !== void 0 ? l.getDependency("accessor", v.POSITION) : a.attributes.position;
          d.push(y);
        }
        if (c) {
          const y = v.NORMAL !== void 0 ? l.getDependency("accessor", v.NORMAL) : a.attributes.normal;
          p.push(y);
        }
        if (u) {
          const y = v.COLOR_0 !== void 0 ? l.getDependency("accessor", v.COLOR_0) : a.attributes.color;
          m.push(y);
        }
      }
      return Promise.all([Promise.all(d), Promise.all(p), Promise.all(m)]).then(function(g) {
        const f = g[0], v = g[1], y = g[2];
        return h && (a.morphAttributes.position = f), c && (a.morphAttributes.normal = v), u && (a.morphAttributes.color = y), a.morphTargetsRelative = !0, a;
      });
    }(n, e.targets, t) : n;
  });
}
const Uf = /* @__PURE__ */ new WeakMap();
class cR extends It {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, i, r) {
    const s = new gn(this.manager);
    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (a) => {
      this.parse(a, t, r);
    }, i, r);
  }
  parse(e, t, i = () => {
  }) {
    this.decodeDracoFile(e, t, null, null, mt, i).catch(i);
  }
  decodeDracoFile(e, t, i, r, s = Jt, a = () => {
  }) {
    const o = { attributeIDs: i || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!i, vertexColorSpace: s };
    return this.decodeGeometry(e, o).then(t).catch(a);
  }
  decodeGeometry(e, t) {
    const i = JSON.stringify(t);
    if (Uf.has(e)) {
      const l = Uf.get(e);
      if (l.key === i)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
    }
    let r;
    const s = this.workerNextTaskID++, a = e.byteLength, o = this.kr(s, a).then((l) => (r = l, new Promise((h, c) => {
      r.Fr[s] = { resolve: h, reject: c }, r.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this.Gr(l.geometry));
    return o.catch(() => !0).then(() => {
      r && s && this.Br(r, s);
    }), Uf.set(e, { key: i, promise: o }), o;
  }
  Gr(e) {
    const t = new Pe();
    e.index && t.setIndex(new Ke(e.index.array, 1));
    for (let i = 0; i < e.attributes.length; i++) {
      const r = e.attributes[i], s = r.name, a = r.array, o = r.itemSize, l = new Ke(a, o);
      s === "color" && (this.Hr(l, r.vertexColorSpace), l.normalized = !(a instanceof Float32Array)), t.setAttribute(s, l);
    }
    return t;
  }
  Hr(e, t) {
    if (t !== mt)
      return;
    const i = new oe();
    for (let r = 0, s = e.count; r < s; r++)
      i.fromBufferAttribute(e, r).convertSRGBToLinear(), e.setXYZ(r, i.r, i.g, i.b);
  }
  zr(e, t) {
    const i = new gn(this.manager);
    return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise((r, s) => {
      i.load(e, r, void 0, s);
    });
  }
  preload() {
    return this.Vr(), this;
  }
  Vr() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this.zr("draco_decoder.js", "text")) : (t.push(this.zr("draco_wasm_wrapper.js", "text")), t.push(this.zr("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((i) => {
      const r = i[0];
      e || (this.decoderConfig.wasmBinary = i[1]);
      const s = uR.toString(), a = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([a]));
    }), this.decoderPending;
  }
  kr(e, t) {
    return this.Vr().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const r = new Worker(this.workerSourceURL);
        r.Fr = {}, r.Wr = {}, r.jr = 0, r.postMessage({ type: "init", decoderConfig: this.decoderConfig }), r.onmessage = function(s) {
          const a = s.data;
          switch (a.type) {
            case "decode":
              r.Fr[a.id].resolve(a);
              break;
            case "error":
              r.Fr[a.id].reject(a);
          }
        }, this.workerPool.push(r);
      } else
        this.workerPool.sort(function(r, s) {
          return r.jr > s.jr ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return i.Wr[e] = t, i.jr += t, i;
    });
  }
  Br(e, t) {
    e.jr -= e.Wr[t], delete e.Fr[t], delete e.Wr[t];
  }
  debug() {
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function uR() {
  let n, e;
  function t(i, r, s, a, o, l) {
    const h = l.num_components(), c = s.num_points() * h, u = c * o.BYTES_PER_ELEMENT, d = function(g, f) {
      switch (f) {
        case Float32Array:
          return g.DT_FLOAT32;
        case Int8Array:
          return g.DT_INT8;
        case Int16Array:
          return g.DT_INT16;
        case Int32Array:
          return g.DT_INT32;
        case Uint8Array:
          return g.DT_UINT8;
        case Uint16Array:
          return g.DT_UINT16;
        case Uint32Array:
          return g.DT_UINT32;
      }
    }(i, o), p = i.Xr(u);
    r.GetAttributeDataArrayForAllPoints(s, l, d, u, p);
    const m = new o(i.HEAPF32.buffer, p, c).slice();
    return i.Yr(p), { name: a, array: m, itemSize: h };
  }
  onmessage = function(i) {
    const r = i.data;
    switch (r.type) {
      case "init":
        n = r.decoderConfig, e = new Promise(function(o) {
          n.onModuleLoaded = function(l) {
            o({ draco: l });
          }, DracoDecoderModule(n);
        });
        break;
      case "decode":
        const s = r.buffer, a = r.taskConfig;
        e.then((o) => {
          const l = o.draco, h = new l.Decoder();
          try {
            const c = function(d, p, m, g) {
              const f = g.attributeIDs, v = g.attributeTypes;
              let y, x;
              const M = p.GetEncodedGeometryType(m);
              if (M === d.TRIANGULAR_MESH)
                y = new d.Mesh(), x = p.DecodeArrayToMesh(m, m.byteLength, y);
              else {
                if (M !== d.POINT_CLOUD)
                  throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                y = new d.PointCloud(), x = p.DecodeArrayToPointCloud(m, m.byteLength, y);
              }
              if (!x.ok() || y.ptr === 0)
                throw new Error("THREE.DRACOLoader: Decoding failed: " + x.error_msg());
              const b = { index: null, attributes: [] };
              for (const S in f) {
                const w = self[v[S]];
                let T, C;
                if (g.useUniqueIDs)
                  C = f[S], T = p.GetAttributeByUniqueId(y, C);
                else {
                  if (C = p.GetAttributeId(y, d[f[S]]), C === -1)
                    continue;
                  T = p.GetAttribute(y, C);
                }
                const I = t(d, p, y, S, w, T);
                S === "color" && (I.vertexColorSpace = g.vertexColorSpace), b.attributes.push(I);
              }
              return M === d.TRIANGULAR_MESH && (b.index = function(S, w, T) {
                const C = T.num_faces(), I = 3 * C, A = 4 * I, L = S.Xr(A);
                w.GetTrianglesUInt32Array(T, A, L);
                const D = new Uint32Array(S.HEAPF32.buffer, L, I).slice();
                return S.Yr(L), { array: D, itemSize: 1 };
              }(d, p, y)), d.destroy(y), b;
            }(l, h, new Int8Array(s), a), u = c.attributes.map((d) => d.array.buffer);
            c.index && u.push(c.index.array.buffer), self.postMessage({ type: "decode", id: r.id, geometry: c }, u);
          } catch (c) {
            self.postMessage({ type: "error", id: r.id, error: c.message });
          } finally {
            l.destroy(h);
          }
        });
    }
  };
}
const dR = /^[og]\s*(.+)?/, pR = /^mtllib /, fR = /^usemtl /, mR = /^usemap /, r1 = /\s+/, s1 = new _(), Ff = new _(), a1 = new _(), o1 = new _(), ci = new _(), mu = new oe();
function gR() {
  const n = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materials: {}, materialLibraries: [], startObject: function(e, t) {
    if (this.object && this.object.fromDeclaration === !1)
      return this.object.name = e, void (this.object.fromDeclaration = t !== !1);
    const i = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
    if (this.object && typeof this.object.qr == "function" && this.object.qr(!0), this.object = { name: e || "", fromDeclaration: t !== !1, geometry: { vertices: [], normals: [], colors: [], uvs: [], hasUVIndices: !1 }, materials: [], smooth: !0, startMaterial: function(r, s) {
      const a = this.qr(!1);
      a && (a.inherited || a.groupCount <= 0) && this.materials.splice(a.index, 1);
      const o = { index: this.materials.length, name: r || "", mtllib: Array.isArray(s) && s.length > 0 ? s[s.length - 1] : "", smooth: a !== void 0 ? a.smooth : this.smooth, groupStart: a !== void 0 ? a.groupEnd : 0, groupEnd: -1, groupCount: -1, inherited: !1, clone: function(l) {
        const h = { index: typeof l == "number" ? l : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: !1 };
        return h.clone = this.clone.bind(h), h;
      } };
      return this.materials.push(o), o;
    }, currentMaterial: function() {
      return this.materials.length > 0 ? this.materials[this.materials.length - 1] : void 0;
    }, qr: function(r) {
      const s = this.currentMaterial();
      if (s && s.groupEnd === -1 && (s.groupEnd = this.geometry.vertices.length / 3, s.groupCount = s.groupEnd - s.groupStart, s.inherited = !1), r && this.materials.length > 1)
        for (let a = this.materials.length - 1; a >= 0; a--)
          this.materials[a].groupCount <= 0 && this.materials.splice(a, 1);
      return r && this.materials.length === 0 && this.materials.push({ name: "", smooth: this.smooth }), s;
    } }, i && i.name && typeof i.clone == "function") {
      const r = i.clone(0);
      r.inherited = !0, this.object.materials.push(r);
    }
    this.objects.push(this.object);
  }, finalize: function() {
    this.object && typeof this.object.qr == "function" && this.object.qr(!0);
  }, parseVertexIndex: function(e, t) {
    const i = parseInt(e, 10);
    return 3 * (i >= 0 ? i - 1 : i + t / 3);
  }, parseNormalIndex: function(e, t) {
    const i = parseInt(e, 10);
    return 3 * (i >= 0 ? i - 1 : i + t / 3);
  }, parseUVIndex: function(e, t) {
    const i = parseInt(e, 10);
    return 2 * (i >= 0 ? i - 1 : i + t / 2);
  }, addVertex: function(e, t, i) {
    const r = this.vertices, s = this.object.geometry.vertices;
    s.push(r[e + 0], r[e + 1], r[e + 2]), s.push(r[t + 0], r[t + 1], r[t + 2]), s.push(r[i + 0], r[i + 1], r[i + 2]);
  }, addVertexPoint: function(e) {
    const t = this.vertices;
    this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
  }, addVertexLine: function(e) {
    const t = this.vertices;
    this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
  }, addNormal: function(e, t, i) {
    const r = this.normals, s = this.object.geometry.normals;
    s.push(r[e + 0], r[e + 1], r[e + 2]), s.push(r[t + 0], r[t + 1], r[t + 2]), s.push(r[i + 0], r[i + 1], r[i + 2]);
  }, addFaceNormal: function(e, t, i) {
    const r = this.vertices, s = this.object.geometry.normals;
    s1.fromArray(r, e), Ff.fromArray(r, t), a1.fromArray(r, i), ci.subVectors(a1, Ff), o1.subVectors(s1, Ff), ci.cross(o1), ci.normalize(), s.push(ci.x, ci.y, ci.z), s.push(ci.x, ci.y, ci.z), s.push(ci.x, ci.y, ci.z);
  }, addColor: function(e, t, i) {
    const r = this.colors, s = this.object.geometry.colors;
    r[e] !== void 0 && s.push(r[e + 0], r[e + 1], r[e + 2]), r[t] !== void 0 && s.push(r[t + 0], r[t + 1], r[t + 2]), r[i] !== void 0 && s.push(r[i + 0], r[i + 1], r[i + 2]);
  }, addUV: function(e, t, i) {
    const r = this.uvs, s = this.object.geometry.uvs;
    s.push(r[e + 0], r[e + 1]), s.push(r[t + 0], r[t + 1]), s.push(r[i + 0], r[i + 1]);
  }, addDefaultUV: function() {
    const e = this.object.geometry.uvs;
    e.push(0, 0), e.push(0, 0), e.push(0, 0);
  }, addUVLine: function(e) {
    const t = this.uvs;
    this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
  }, addFace: function(e, t, i, r, s, a, o, l, h) {
    const c = this.vertices.length;
    let u = this.parseVertexIndex(e, c), d = this.parseVertexIndex(t, c), p = this.parseVertexIndex(i, c);
    if (this.addVertex(u, d, p), this.addColor(u, d, p), o !== void 0 && o !== "") {
      const m = this.normals.length;
      u = this.parseNormalIndex(o, m), d = this.parseNormalIndex(l, m), p = this.parseNormalIndex(h, m), this.addNormal(u, d, p);
    } else
      this.addFaceNormal(u, d, p);
    if (r !== void 0 && r !== "") {
      const m = this.uvs.length;
      u = this.parseUVIndex(r, m), d = this.parseUVIndex(s, m), p = this.parseUVIndex(a, m), this.addUV(u, d, p), this.object.geometry.hasUVIndices = !0;
    } else
      this.addDefaultUV();
  }, addPointGeometry: function(e) {
    this.object.geometry.type = "Points";
    const t = this.vertices.length;
    for (let i = 0, r = e.length; i < r; i++) {
      const s = this.parseVertexIndex(e[i], t);
      this.addVertexPoint(s), this.addColor(s);
    }
  }, addLineGeometry: function(e, t) {
    this.object.geometry.type = "Line";
    const i = this.vertices.length, r = this.uvs.length;
    for (let s = 0, a = e.length; s < a; s++)
      this.addVertexLine(this.parseVertexIndex(e[s], i));
    for (let s = 0, a = t.length; s < a; s++)
      this.addUVLine(this.parseUVIndex(t[s], r));
  } };
  return n.startObject("", !1), n;
}
class vR extends It {
  constructor(e) {
    super(e), this.materials = null;
  }
  load(e, t, i, r) {
    const s = this, a = new gn(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      try {
        t(s.parse(o));
      } catch (l) {
        r && r(l), s.manager.itemError(e);
      }
    }, i, r);
  }
  setMaterials(e) {
    return this.materials = e, this;
  }
  parse(e) {
    const t = new gR();
    e.indexOf(`\r
`) !== -1 && (e = e.replace(/\r\n/g, `
`)), e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
    const i = e.split(`
`);
    let r = [];
    for (let a = 0, o = i.length; a < o; a++) {
      const l = i[a].trimStart();
      if (l.length === 0)
        continue;
      const h = l.charAt(0);
      if (h !== "#") {
        if (h === "v") {
          const c = l.split(r1);
          switch (c[0]) {
            case "v":
              t.vertices.push(parseFloat(c[1]), parseFloat(c[2]), parseFloat(c[3])), c.length >= 7 ? (mu.setRGB(parseFloat(c[4]), parseFloat(c[5]), parseFloat(c[6])).convertSRGBToLinear(), t.colors.push(mu.r, mu.g, mu.b)) : t.colors.push(void 0, void 0, void 0);
              break;
            case "vn":
              t.normals.push(parseFloat(c[1]), parseFloat(c[2]), parseFloat(c[3]));
              break;
            case "vt":
              t.uvs.push(parseFloat(c[1]), parseFloat(c[2]));
          }
        } else if (h === "f") {
          const c = l.slice(1).trim().split(r1), u = [];
          for (let p = 0, m = c.length; p < m; p++) {
            const g = c[p];
            if (g.length > 0) {
              const f = g.split("/");
              u.push(f);
            }
          }
          const d = u[0];
          for (let p = 1, m = u.length - 1; p < m; p++) {
            const g = u[p], f = u[p + 1];
            t.addFace(d[0], g[0], f[0], d[1], g[1], f[1], d[2], g[2], f[2]);
          }
        } else if (h === "l") {
          const c = l.substring(1).trim().split(" ");
          let u = [];
          const d = [];
          if (l.indexOf("/") === -1)
            u = c;
          else
            for (let p = 0, m = c.length; p < m; p++) {
              const g = c[p].split("/");
              g[0] !== "" && u.push(g[0]), g[1] !== "" && d.push(g[1]);
            }
          t.addLineGeometry(u, d);
        } else if (h === "p") {
          const c = l.slice(1).trim().split(" ");
          t.addPointGeometry(c);
        } else if ((r = dR.exec(l)) !== null) {
          const c = (" " + r[0].slice(1).trim()).slice(1);
          t.startObject(c);
        } else if (fR.test(l))
          t.object.startMaterial(l.substring(7).trim(), t.materialLibraries);
        else if (pR.test(l))
          t.materialLibraries.push(l.substring(7).trim());
        else if (!mR.test(l)) {
          if (h === "s") {
            if (r = l.split(" "), r.length > 1) {
              const u = r[1].trim().toLowerCase();
              t.object.smooth = u !== "0" && u !== "off";
            } else
              t.object.smooth = !0;
            const c = t.object.currentMaterial();
            c && (c.smooth = t.object.smooth);
          } else if (l === "\0")
            continue;
        }
      }
    }
    t.finalize();
    const s = new yn();
    if (s.materialLibraries = [].concat(t.materialLibraries), t.objects.length === 1 && t.objects[0].geometry.vertices.length === 0) {
      if (t.vertices.length > 0) {
        const a = new Jr({ size: 1, sizeAttenuation: !1 }), o = new Pe();
        o.setAttribute("position", new ye(t.vertices, 3)), t.colors.length > 0 && t.colors[0] !== void 0 && (o.setAttribute("color", new ye(t.colors, 3)), a.vertexColors = !0);
        const l = new os(o, a);
        s.add(l);
      }
    } else
      for (let a = 0, o = t.objects.length; a < o; a++) {
        const l = t.objects[a], h = l.geometry, c = l.materials, u = h.type === "Line", d = h.type === "Points";
        let p = !1;
        if (h.vertices.length === 0)
          continue;
        const m = new Pe();
        m.setAttribute("position", new ye(h.vertices, 3)), h.normals.length > 0 && m.setAttribute("normal", new ye(h.normals, 3)), h.colors.length > 0 && (p = !0, m.setAttribute("color", new ye(h.colors, 3))), h.hasUVIndices === !0 && m.setAttribute("uv", new ye(h.uvs, 2));
        const g = [];
        for (let v = 0, y = c.length; v < y; v++) {
          const x = c[v], M = x.name + "_" + x.smooth + "_" + p;
          let b = t.materials[M];
          if (this.materials !== null)
            if (b = this.materials.create(x.name), !u || !b || b instanceof kt) {
              if (d && b && !(b instanceof Jr)) {
                const S = new Jr({ size: 10, sizeAttenuation: !1 });
                Xt.prototype.copy.call(S, b), S.color.copy(b.color), S.map = b.map, b = S;
              }
            } else {
              const S = new kt();
              Xt.prototype.copy.call(S, b), S.color.copy(b.color), b = S;
            }
          b === void 0 && (b = u ? new kt() : d ? new Jr({ size: 1, sizeAttenuation: !1 }) : new Aa(), b.name = x.name, b.flatShading = !x.smooth, b.vertexColors = p, t.materials[M] = b), g.push(b);
        }
        let f;
        if (g.length > 1) {
          for (let v = 0, y = c.length; v < y; v++) {
            const x = c[v];
            m.addGroup(x.groupStart, x.groupCount, v);
          }
          f = u ? new Zn(m, g) : d ? new os(m, g) : new ce(m, g);
        } else
          f = u ? new Zn(m, g[0]) : d ? new os(m, g[0]) : new ce(m, g[0]);
        f.name = l.name, s.add(f);
      }
    return s;
  }
}
class yR extends It {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, a = this.path === "" ? tr.extractUrlBase(e) : this.path, o = new gn(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      try {
        t(s.parse(l, a));
      } catch (h) {
        r && r(h), s.manager.itemError(e);
      }
    }, i, r);
  }
  setMaterialOptions(e) {
    return this.materialOptions = e, this;
  }
  parse(e, t) {
    const i = e.split(`
`);
    let r = {};
    const s = /\s+/, a = {};
    for (let l = 0; l < i.length; l++) {
      let h = i[l];
      if (h = h.trim(), h.length === 0 || h.charAt(0) === "#")
        continue;
      const c = h.indexOf(" ");
      let u = c >= 0 ? h.substring(0, c) : h;
      u = u.toLowerCase();
      let d = c >= 0 ? h.substring(c + 1) : "";
      if (d = d.trim(), u === "newmtl")
        r = { name: d }, a[d] = r;
      else if (u === "ka" || u === "kd" || u === "ks" || u === "ke") {
        const p = d.split(s, 3);
        r[u] = [parseFloat(p[0]), parseFloat(p[1]), parseFloat(p[2])];
      } else
        r[u] = d;
    }
    const o = new xR(this.resourcePath || t, this.materialOptions);
    return o.setCrossOrigin(this.crossOrigin), o.setManager(this.manager), o.setMaterials(a), o;
  }
}
class xR {
  constructor(e = "", t = {}) {
    this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = this.options.side !== void 0 ? this.options.side : Mi, this.wrap = this.options.wrap !== void 0 ? this.options.wrap : jt;
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setManager(e) {
    this.manager = e;
  }
  setMaterials(e) {
    this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
  }
  convert(e) {
    if (!this.options)
      return e;
    const t = {};
    for (const i in e) {
      const r = e[i], s = {};
      t[i] = s;
      for (const a in r) {
        let o = !0, l = r[a];
        const h = a.toLowerCase();
        switch (h) {
          case "kd":
          case "ka":
          case "ks":
            this.options && this.options.normalizeRGB && (l = [l[0] / 255, l[1] / 255, l[2] / 255]), this.options && this.options.ignoreZeroRGBs && l[0] === 0 && l[1] === 0 && l[2] === 0 && (o = !1);
        }
        o && (s[h] = l);
      }
    }
    return t;
  }
  preload() {
    for (const e in this.materialsInfo)
      this.create(e);
  }
  getIndex(e) {
    return this.nameLookup[e];
  }
  getAsArray() {
    let e = 0;
    for (const t in this.materialsInfo)
      this.materialsArray[e] = this.create(t), this.nameLookup[t] = e, e++;
    return this.materialsArray;
  }
  create(e) {
    return this.materials[e] === void 0 && this.createMaterial_(e), this.materials[e];
  }
  createMaterial_(e) {
    const t = this, i = this.materialsInfo[e], r = { name: e, side: this.side };
    function s(a, o) {
      if (r[a])
        return;
      const l = t.getTextureParams(o, r), h = t.loadTexture((c = t.baseUrl, typeof (u = l.url) != "string" || u === "" ? "" : /^https?:\/\//i.test(u) ? u : c + u));
      var c, u;
      h.repeat.copy(l.scale), h.offset.copy(l.offset), h.wrapS = t.wrap, h.wrapT = t.wrap, a !== "map" && a !== "emissiveMap" || (h.colorSpace = mt), r[a] = h;
    }
    for (const a in i) {
      const o = i[a];
      let l;
      if (o !== "")
        switch (a.toLowerCase()) {
          case "kd":
            r.color = new oe().fromArray(o).convertSRGBToLinear();
            break;
          case "ks":
            r.specular = new oe().fromArray(o).convertSRGBToLinear();
            break;
          case "ke":
            r.emissive = new oe().fromArray(o).convertSRGBToLinear();
            break;
          case "map_kd":
            s("map", o);
            break;
          case "map_ks":
            s("specularMap", o);
            break;
          case "map_ke":
            s("emissiveMap", o);
            break;
          case "norm":
            s("normalMap", o);
            break;
          case "map_bump":
          case "bump":
            s("bumpMap", o);
            break;
          case "map_d":
            s("alphaMap", o), r.transparent = !0;
            break;
          case "ns":
            r.shininess = parseFloat(o);
            break;
          case "d":
            l = parseFloat(o), l < 1 && (r.opacity = l, r.transparent = !0);
            break;
          case "tr":
            l = parseFloat(o), this.options && this.options.invertTrProperty && (l = 1 - l), l > 0 && (r.opacity = 1 - l, r.transparent = !0);
        }
    }
    return this.materials[e] = new Aa(r), this.materials[e];
  }
  getTextureParams(e, t) {
    const i = { scale: new X(1, 1), offset: new X(0, 0) }, r = e.split(/\s+/);
    let s;
    return s = r.indexOf("-bm"), s >= 0 && (t.bumpScale = parseFloat(r[s + 1]), r.splice(s, 2)), s = r.indexOf("-s"), s >= 0 && (i.scale.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), s = r.indexOf("-o"), s >= 0 && (i.offset.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), i.url = r.join(" ").trim(), i;
  }
  loadTexture(e, t, i, r, s) {
    const a = this.manager !== void 0 ? this.manager : Gg;
    let o = a.getHandler(e);
    o === null && (o = new Ui(a)), o.setCrossOrigin && o.setCrossOrigin(this.crossOrigin);
    const l = o.load(e, i, r, s);
    return t !== void 0 && (l.mapping = t), l;
  }
}
function MR(n, e, t = () => {
}) {
  switch (e) {
    case "GLTF":
    case "GLB":
    case "gltf":
    case "glb":
      return function(i = "", r = "/draco/", s = () => {
      }) {
        const a = new CP(), o = { progress: () => {
        }, complete: () => {
        } };
        return a.setDRACOLoader(new cR().setDecoderPath(r)), a.load(i, (l) => {
          l.scene.animations = l.animations, s(l.scene), o.complete(l.scene);
        }, (l) => o.progress(l.loaded / l.total, l), (l) => {
        }), o;
      }(n, dg.dracoPath, (i) => t(i));
    case "FBX":
    case "fbx":
      return function(i = "", r) {
        const s = new MP(), a = { progress: () => {
        }, complete: () => {
        } };
        return s.load(i, (o) => {
          r(o), a.complete(o);
        }, (o) => a.progress(o.loaded / o.total, o)), a;
      }(n, (i) => t(i));
    case "OBJ":
    case "obj":
      return function(i = "", r = () => {
      }) {
        const s = new vR(), a = new yR(), o = { progress: () => {
        }, complete: () => {
        } };
        return a.load(i.replace(".obj", ".mtl"), (l) => {
          l.preload(), s.setMaterials(l), s.load(i, (h) => {
            r(h), o.complete(h);
          }, (h) => o.progress(h.loaded / h.total, h), (h) => {
          });
        }), o;
      }(n, (i) => t(i));
  }
}
const T0 = La, E0 = Na, GS = Dr;
function np(n) {
  return n.map((e) => $t(Te({}, T0(e)), { children: np(e.children) }));
}
function ip(n, e) {
  n.length === e.length && n.forEach((t, i) => {
    E0(t, e[i]), t.children && ip(t.children, e[i].children);
  });
}
function A0(n, e) {
  const { mixerFrames: t } = Jo(n), i = function(s, a = () => {
  }) {
    const o = new xh(), l = new PM(s);
    return s.mixerAnimateRender = () => {
      const h = o.getDelta();
      a(), l.update(h);
    }, l;
  }(n, () => e.frameCallback), r = e.actionIndexs.map((s, a) => s && function(o, l, h = 1, c = 0, u = !0) {
    const d = o.clipAction(l);
    return d.loop = u ? _g : wg, d.time = c, d.timeScale = h, d.clampWhenFinished = !0, d;
  }(i, n.animations[a], e.speed, e.startTime, e.loop).play()).filter((s) => s);
  return !t.find((s) => s === n) && t.push(n), { actions: r, mixer: i };
}
function bR(n, e) {
  e && (E0(n, e), function(t, i) {
    t.globalConfig = i;
    const { mesh: r, material: s } = i;
    i.useGlobalShadow && function(a, o) {
      a.traverse((l) => {
        l.castShadow = o.castShadow, l.receiveShadow = o.receiveShadow;
      });
    }(t, r), i.useGlobalMaterial && function(a, o) {
      a.RootMaterials.forEach((l) => {
        l.envMapIntensity = o.envMapIntensity, l.reflectivity = o.reflectivity, o.envMap && (l.envMap = a.parent.envBackground), o.isGlobalMap === !1 && (l.recordMap = l.map, l.map = null), l.needsUpdate = !0;
      }), o.envMap && a.parent.envMapChangeUseList.push(() => a.RootMaterials.forEach((l) => l.envMap = a.parent.envBackground));
    }(t, s);
  }(n, e.globalConfig), n.globalConfig.isSaveChildren && ip(n.children, e.children), n.globalConfig.isSaveMaterials && n.RootMaterials.forEach((t, i) => S0(t, e.RootMaterials[i])), function(t, i) {
    i && (t.animationPlayParams = i, i.initPlay && A0(t, i));
  }(n, e.animationPlayParams));
}
function jS(n, e, t, i, r) {
  return GS(i, r.addFolder("物体控制")), function(s, a) {
    a.add(s.globalConfig, "isSaveChildren").name("子物体更改存储"), a.add(s.globalConfig, "isSaveMaterials").name("单材质更改存储"), a.addFn(() => s.traverse((o) => o.visible = !0)).name("显示全部子项"), function(o, l) {
      l.add(o.globalConfig, "useGlobalShadow").name("存储全局配置"), l.add(o.globalConfig.mesh, "castShadow").name("产生阴影").onChange((h) => o.traverse((c) => c.castShadow = h)), l.add(o.globalConfig.mesh, "receiveShadow").name("接收阴影").onChange((h) => o.traverse((c) => c.receiveShadow = h));
    }(s, a.addFolder("(全局)阴影配置")), function(o, l) {
      l.add(o.globalConfig, "useGlobalMaterial").name("存储全局配置"), l.add(o.globalConfig.material, "envMap").name("环境贴图").onChange((h) => o.RootMaterials.forEach((c) => c.envMap = h ? o.parent.envBackground : null)), l.add(o.globalConfig.material, "envMapIntensity").name("环境贴图强度").onChange((h) => o.RootMaterials.forEach((c) => c.envMapIntensity = h)).onFinishChange((h) => o.RootMaterials.forEach((c) => c.needsUpdate = !0)), l.add(o.globalConfig.material, "reflectivity", 0, 1).name("反射强度").onChange((h) => o.RootMaterials.forEach((c) => c.reflectivity = h)).onFinishChange((h) => o.RootMaterials.forEach((c) => c.needsUpdate = !0)), l.add(o.globalConfig.material, "isGlobalMap").name("全局贴图").onChange((h) => {
        o.RootMaterials.forEach((c) => {
          h ? (c.map = c.recordMap, c.needsUpdate = !0) : (c.recordMap = c.map, c.map = null, c.needsUpdate = !0);
        });
      }).onFinishChange((h) => o.RootMaterials.forEach((c) => c.needsUpdate = !0));
    }(s, a.addFolder("(全局)材质配置"));
  }(i, r.addFolder("全局和子项控制")), function(s, a) {
    if (!s.animationPlayParams)
      return;
    a.add(s.animationPlayParams, "initPlay").name("初始加载播放"), a.add(s.animationPlayParams, "speed").min(-10).max(10).name("播放速度"), a.add(s.animationPlayParams, "startTime").name("开始时间"), a.add(s.animationPlayParams, "loop").name("循环播放");
    const o = a.addFolder("播放列表");
    s.animations.map((l, h) => o.add(s.animationPlayParams.actionIndexs, h).name(l.name + ":" + l.duration.toFixed(2) + "s")), o.addFn(() => A0(s, s.animationPlayParams)).name("播放选择动作");
  }(i, r.addFolder("动画配置")), r.addFn(() => e.attach(i)).name("选中"), r.addFn(() => {
    const { frontView: s, target: a } = j2(i, n.object.fov);
    dd(n.object.position, s), dd(n.target, a), t.effectPass.outlinePass.selectedObjects = [i];
  }).name("定位物体"), r.addFn(() => {
    i.parent.remove(i), r.parent.removeFolder(r);
  }).name("删除"), r;
}
function Qn(n) {
  let e = "";
  return n.name || (e = "-"), n.name.length > 10 ? e += n.name.slice(0, 10) + "..." : e += n.name, e += ` ${n.id} `, e;
}
function SR(n, e, t, i, r) {
  Object.assign(n, { scene: e, controls: t, transformControls: i, effectComposer: r }), n.insertModel = function(s, a) {
    const { url: o, type: l } = s;
    return { loaderService: MR(o, l, (h) => {
      var d;
      var c;
      if (e.add(((c = h).globalConfig = { useGlobalShadow: !1, useGlobalMaterial: !1, isSaveChildren: !0, isSaveMaterials: !0, mesh: { castShadow: !1, receiveShadow: !1 }, material: { envMap: !1, envMapIntensity: 1, reflectivity: 0.98, isGlobalMap: !0 } }, c.RootMaterials = tp(c), ((d = c.animations) == null ? void 0 : d.length) > 0 && (c.animationPlayParams = { initPlay: !1, speed: 0.5, actionIndexs: new Array(c.animations.length).fill(!1), startTime: 0, loop: !1, frameCallback: () => {
      } }), c)), h.rootInfo = s, bR(h, a), !n.rootFolder)
        return;
      const u = n.rootFolder.addFolder(Qn(h));
      jS(t, i, r, h, u);
    }), rootInfo: s, params: a };
  };
}
function wR(n) {
  return n.map((e) => function(t) {
    const { animationPlayParams: i, children: r, RootMaterials: s, rootInfo: a } = t;
    return { group: $t(Te({}, T0(t)), { globalConfig: t.globalConfig, animationPlayParams: i, RootMaterials: t.globalConfig.isSaveMaterials ? s.map((o) => b0(o)) : void 0, children: t.globalConfig.isSaveChildren ? np(r) : void 0 }), rootInfo: a };
  }(e));
}
function _R(n) {
  return n.map((e) => function(t) {
    const { material: i, geometry: r } = t, { geometryType: s, parameters: a } = r;
    return $t(Te({}, La(t)), { geometry: { geometryType: s, parameters: a }, material: Qd(i) });
  }(e));
}
function TR(n, e) {
  e == null || e.forEach((t) => function(i, r) {
    if (!r)
      return;
    const { geometry: s, material: a } = r, { geometryType: o, parameters: l } = s, h = Jd(o, l), c = xi(a.materialType), u = new ce(h, c);
    return u.isInnerMesh = !0, i.add(u), $d(i, u.material, a), Na(u, r), u;
  }(n, t));
}
function ER(n, e, t) {
  const i = t.addFolder("已有列表");
  return i.open(), t.add(n, "geometryType", W2).name("几何体"), t.add(n, "materialType", Co).name("材质"), t.addFn(() => {
    const r = function(s, a) {
      const o = Jd(s), l = xi(a), h = new ce(o, l);
      return h.isInnerMesh = !0, h;
    }(n.geometryType, n.materialType);
    e.attach_add(r), jx(e, r, i.addFolder(r.geometry.geometryType + ":" + Qn(r)));
  }).name("添加"), e.children.forEach((r) => {
    r.isInnerMesh && jx(e, r, i.addFolder(r.geometry.geometryType + ":" + Qn(r)));
  }), t;
}
class WS extends Ia {
  constructor(e, t = {}) {
    const i = t.font;
    if (i === void 0)
      super();
    else {
      const r = i.generateShapes(e, t.size);
      t.depth === void 0 && t.height, t.depth = t.depth !== void 0 ? t.depth : t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(r, t);
    }
    this.type = "TextGeometry";
  }
}
class AR extends It {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, a = new gn(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      const l = s.parse(JSON.parse(o));
      t && t(l);
    }, i, r);
  }
  parse(e) {
    return new CR(e);
  }
}
class CR {
  constructor(e) {
    this.isFont = !0, this.type = "Font", this.data = e;
  }
  generateShapes(e, t = 100) {
    const i = [], r = function(s, a, o) {
      const l = Array.from(s), h = a / o.resolution, c = (o.boundingBox.yMax - o.boundingBox.yMin + o.underlineThickness) * h, u = [];
      let d = 0, p = 0;
      for (let m = 0; m < l.length; m++) {
        const g = l[m];
        if (g === `
`)
          d = 0, p -= c;
        else {
          const f = PR(g, h, d, p, o);
          d += f.offsetX, u.push(f.path);
        }
      }
      return u;
    }(e, t, this.data);
    for (let s = 0, a = r.length; s < a; s++)
      i.push(...r[s].toShapes());
    return i;
  }
}
function PR(n, e, t, i, r) {
  const s = r.glyphs[n] || r.glyphs["?"];
  if (!s)
    return;
  const a = new UM();
  let o, l, h, c, u, d, p, m;
  if (s.o) {
    const g = s.Zr || (s.Zr = s.o.split(" "));
    for (let f = 0, v = g.length; f < v; )
      switch (g[f++]) {
        case "m":
          o = g[f++] * e + t, l = g[f++] * e + i, a.moveTo(o, l);
          break;
        case "l":
          o = g[f++] * e + t, l = g[f++] * e + i, a.lineTo(o, l);
          break;
        case "q":
          h = g[f++] * e + t, c = g[f++] * e + i, u = g[f++] * e + t, d = g[f++] * e + i, a.quadraticCurveTo(u, d, h, c);
          break;
        case "b":
          h = g[f++] * e + t, c = g[f++] * e + i, u = g[f++] * e + t, d = g[f++] * e + i, p = g[f++] * e + t, m = g[f++] * e + i, a.bezierCurveTo(u, d, p, m, h, c);
      }
  }
  return { offsetX: s.ha * e, path: a };
}
function l1(n, e = "fence") {
  const t = n.length, i = e === "fence" ? n.map((d, p) => p - 1 > -1 && p + 1 < t && (p % 2 == 0 ? [p, p + 1, p - 1] : [p, p - 1, p + 1])).filter((d) => d).reduce((d, p) => [...d, ...p], []) : n.map((d, p) => p >= 2 && [0, p - 1, p]).filter((d) => d).reduce((d, p) => [...d, ...p], []), r = n.reduce((d, p) => [...d, p.x, p.y, p.z], []), s = n.reduce((d, p) => ({ x: [...d.x, p.x], y: [...d.y, p.y], z: [...d.z, p.z] }), { x: [], y: [], z: [] }), a = new _(Math.max(...s.x), Math.max(...s.y), Math.max(...s.z)), o = new _(Math.min(...s.x), Math.min(...s.y), Math.min(...s.z)), l = a.x - o.x, h = a.y - o.y, c = l > h ? l : h, u = n.map((d) => new X((d.x - o.x) / c, (d.y - o.y) / c)).reduce((d, p) => [...d, ...p], []);
  return { indexGroup: i, faceGroup: r, uvGroup: u };
}
function h1(n, e, t) {
  const i = new Pe(), r = new Float32Array(n);
  if (i.setAttribute("position", new Ke(r, 3)), e) {
    let s = new Uint16Array(e);
    i.index = new Ke(s, 1);
  }
  return t && (i.attributes.uv = new ye(t, 2)), i.computeVertexNormals(), i;
}
function c1(n, e, t, i) {
  n.setIndex(t), n.setAttribute("position", new ye(e, 3)), n.setAttribute("uv", new ye(i, 2)), delete n.attributes.normal, n.computeVertexNormals();
}
function XS(n, e, t = null) {
  const i = new AR();
  return new Promise((r) => {
    i.load(n, (s) => r(new WS(e, Te({ font: s, size: 1, depth: 0.2, height: 0.2, curveSegments: 12, bevelEnabled: !0, bevelThickness: 0, bevelSize: 0, bevelSegments: 5 }, t))));
  });
}
const u1 = new yt(), gu = new _();
class qS extends Wg {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new ye([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new ye([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, i = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), i.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new Ku(t, 6, 1);
    return this.setAttribute("instanceStart", new zn(i, 3, 0)), this.setAttribute("instanceEnd", new zn(i, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new Ku(t, 6, 1);
    return this.setAttribute("instanceColorStart", new zn(i, 3, 0)), this.setAttribute("instanceColorEnd", new zn(i, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new Fg(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new yt());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), u1.setFromBufferAttribute(t), this.boundingBox.union(u1));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new rn()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const i = this.boundingSphere.center;
      this.boundingBox.getCenter(i);
      let r = 0;
      for (let s = 0, a = e.count; s < a; s++)
        gu.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(gu)), gu.fromBufferAttribute(t, s), r = Math.max(r, i.distanceToSquared(gu));
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return this.applyMatrix4(e);
  }
}
xe.line = { worldUnits: { value: 1 }, linewidth: { value: 1 }, resolution: { value: new X(1, 1) }, dashOffset: { value: 0 }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }, In.line = { uniforms: Kt.merge([xe.common, xe.fog, xe.line]), vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`, fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		` };
class C0 extends tt {
  constructor(e) {
    super({ type: "LineMaterial", uniforms: Kt.clone(In.line.uniforms), vertexShader: In.line.vertexShader, fragmentShader: In.line.fragmentShader, clipping: !0 }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
}
const Bf = new Ve(), d1 = new _(), p1 = new _(), dn = new Ve(), pn = new Ve(), Gi = new Ve(), kf = new _(), zf = new fe(), fn = new RM(), f1 = new _(), vu = new yt(), yu = new rn(), ji = new Ve();
let Wi, ra;
function m1(n, e, t) {
  return ji.set(0, 0, -e, 1).applyMatrix4(n.projectionMatrix), ji.multiplyScalar(1 / ji.w), ji.x = ra / t.width, ji.y = ra / t.height, ji.applyMatrix4(n.projectionMatrixInverse), ji.multiplyScalar(1 / ji.w), Math.abs(Math.max(ji.x, ji.y));
}
class RR extends ce {
  constructor(e = new qS(), t = new C0({ color: 16777215 * Math.random() })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, i = e.attributes.instanceEnd, r = new Float32Array(2 * t.count);
    for (let a = 0, o = 0, l = t.count; a < l; a++, o += 2)
      d1.fromBufferAttribute(t, a), p1.fromBufferAttribute(i, a), r[o] = o === 0 ? 0 : r[o - 1], r[o + 1] = r[o] + d1.distanceTo(p1);
    const s = new Ku(r, 2, 1);
    return e.setAttribute("instanceDistanceStart", new zn(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new zn(s, 1, 1)), this;
  }
  raycast(e, t) {
    const i = this.material.worldUnits, r = e.camera, s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    Wi = e.ray;
    const a = this.matrixWorld, o = this.geometry, l = this.material;
    let h, c;
    ra = l.linewidth + s, o.boundingSphere === null && o.computeBoundingSphere(), yu.copy(o.boundingSphere).applyMatrix4(a), i ? h = 0.5 * ra : h = m1(r, Math.max(r.near, yu.distanceToPoint(Wi.origin)), l.resolution), yu.radius += h, Wi.intersectsSphere(yu) !== !1 && (o.boundingBox === null && o.computeBoundingBox(), vu.copy(o.boundingBox).applyMatrix4(a), i ? c = 0.5 * ra : c = m1(r, Math.max(r.near, vu.distanceToPoint(Wi.origin)), l.resolution), vu.expandByScalar(c), Wi.intersectsBox(vu) !== !1 && (i ? function(u, d) {
      const p = u.matrixWorld, m = u.geometry, g = m.attributes.instanceStart, f = m.attributes.instanceEnd;
      for (let v = 0, y = Math.min(m.instanceCount, g.count); v < y; v++) {
        fn.start.fromBufferAttribute(g, v), fn.end.fromBufferAttribute(f, v), fn.applyMatrix4(p);
        const x = new _(), M = new _();
        Wi.distanceSqToSegment(fn.start, fn.end, M, x), M.distanceTo(x) < 0.5 * ra && d.push({ point: M, pointOnLine: x, distance: Wi.origin.distanceTo(M), object: u, face: null, faceIndex: v, uv: null, uv1: null });
      }
    }(this, t) : function(u, d, p) {
      const m = d.projectionMatrix, g = u.material.resolution, f = u.matrixWorld, v = u.geometry, y = v.attributes.instanceStart, x = v.attributes.instanceEnd, M = Math.min(v.instanceCount, y.count), b = -d.near;
      Wi.at(1, Gi), Gi.w = 1, Gi.applyMatrix4(d.matrixWorldInverse), Gi.applyMatrix4(m), Gi.multiplyScalar(1 / Gi.w), Gi.x *= g.x / 2, Gi.y *= g.y / 2, Gi.z = 0, kf.copy(Gi), zf.multiplyMatrices(d.matrixWorldInverse, f);
      for (let S = 0, w = M; S < w; S++) {
        if (dn.fromBufferAttribute(y, S), pn.fromBufferAttribute(x, S), dn.w = 1, pn.w = 1, dn.applyMatrix4(zf), pn.applyMatrix4(zf), dn.z > b && pn.z > b)
          continue;
        if (dn.z > b) {
          const L = dn.z - pn.z, D = (dn.z - b) / L;
          dn.lerp(pn, D);
        } else if (pn.z > b) {
          const L = pn.z - dn.z, D = (pn.z - b) / L;
          pn.lerp(dn, D);
        }
        dn.applyMatrix4(m), pn.applyMatrix4(m), dn.multiplyScalar(1 / dn.w), pn.multiplyScalar(1 / pn.w), dn.x *= g.x / 2, dn.y *= g.y / 2, pn.x *= g.x / 2, pn.y *= g.y / 2, fn.start.copy(dn), fn.start.z = 0, fn.end.copy(pn), fn.end.z = 0;
        const T = fn.closestPointToPointParameter(kf, !0);
        fn.at(T, f1);
        const C = nn.lerp(dn.z, pn.z, T), I = C >= -1 && C <= 1, A = kf.distanceTo(f1) < 0.5 * ra;
        if (I && A) {
          fn.start.fromBufferAttribute(y, S), fn.end.fromBufferAttribute(x, S), fn.start.applyMatrix4(f), fn.end.applyMatrix4(f);
          const L = new _(), D = new _();
          Wi.distanceSqToSegment(fn.start, fn.end, D, L), p.push({ point: D, pointOnLine: L, distance: Wi.origin.distanceTo(D), object: u, face: null, faceIndex: S, uv: null, uv1: null });
        }
      }
    }(this, r, t)));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(Bf), this.material.uniforms.resolution.value.set(Bf.z, Bf.w));
  }
}
class YS extends qS {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, i = new Float32Array(2 * t);
    for (let r = 0; r < t; r += 3)
      i[2 * r] = e[r], i[2 * r + 1] = e[r + 1], i[2 * r + 2] = e[r + 2], i[2 * r + 3] = e[r + 3], i[2 * r + 4] = e[r + 4], i[2 * r + 5] = e[r + 5];
    return super.setPositions(i), this;
  }
  setColors(e) {
    const t = e.length - 3, i = new Float32Array(2 * t);
    for (let r = 0; r < t; r += 3)
      i[2 * r] = e[r], i[2 * r + 1] = e[r + 1], i[2 * r + 2] = e[r + 2], i[2 * r + 3] = e[r + 3], i[2 * r + 4] = e[r + 4], i[2 * r + 5] = e[r + 5];
    return super.setColors(i), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class IR extends RR {
  constructor(e = new YS(), t = new C0({ color: 16777215 * Math.random() })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
function ZS(n) {
  new yt().setFromObject(n).getCenter(n.position), n.geometry.center();
}
function LR(n, e) {
  var r, s;
  const { drawPointList: t } = e;
  if (t.length < 2)
    return void (e.mesh && (n.remove(e.mesh), e.mesh = null, (r = e.callback) == null ? void 0 : r.call(e, "remove")));
  const i = e.drawPointList.reduce((a, o) => [...a, o.x, o.y + 1e-3, o.z], []);
  if (!e.mesh && e.drawPointList.length > 1) {
    const a = function(o) {
      const l = new C0({ color: 0, linewidth: 1e-3, vertexColors: !1, dashed: !1, alphaToCoverage: !1 }), h = new YS().setPositions(o), c = new IR(h, l);
      return c.computeLineDistances(), c;
    }(i);
    a.isDrawMesh = !0, a.drawParams = e, e.mesh = a, n.add(e.mesh), (s = e.callback) == null || s.call(e, "set");
  } else
    e.mesh && e.drawPointList.length > 0 && (e.mesh.geometry.dispose(), e.mesh.geometry.setPositions(i), e.mesh.computeLineDistances(), e.mesh.geometry.attributes.position.needsUpdate = !0);
}
function g1(n, e, t, i) {
  const r = t.addFolder("相关控制"), s = t.addFolder("点列表");
  r.open(), s.open();
  const a = i || { mode: n.mode, materialType: n.materialType, drawPointList: [], mesh: null };
  function o(l) {
    a.drawPointList.push(l), Pi(e, a), v1(e, a, l, s);
  }
  a.callback = function(l) {
    if (l === "remove")
      for (const h in r.rr)
        r.removeFolder(r.rr[h]);
    else {
      Dr(this.mesh, r.addFolder("变换配置"));
      const h = r.addFolder("材质配置");
      ep(e, this.mesh.material, h), this.mode === "直线路径" && h.add(this.mesh.material, "linewidth").name("线宽");
    }
  }, function(l, h, c, u) {
    if (h.mode === "围栏物体")
      u || (h.fenceHeight = 50, h.fenceClose = !0), c.add(h, "fenceHeight").name("围栏高度").onChange(() => Pi(l, h)), c.add(h, "fenceClose").name("围栏闭合").onChange(() => Pi(l, h));
    else if (h.mode === "曲线路径") {
      u || (h.height = 10, h.axial = "y", h.tubularSegments = 64, h.radius = 0.08, h.radialSegments = 8, h.closed = !1);
      const d = c.addFolder("曲线配置");
      d.add(h, "height").name("高度").onChange(() => Pi(l, h)), d.add(h, "axial", ["x", "y", "z"]).name("轴向").onChange(() => Pi(l, h)), d.add(h, "tubularSegments", 1).name("管道分段").onChange(() => Pi(l, h)).step(1), d.add(h, "radius", 0.01).name("管道半径").onChange(() => Pi(l, h)), d.add(h, "radialSegments", 1).name("管道半径分段").onChange(() => Pi(l, h)).step(1), d.add(h, "closed").name("管道闭合").onChange(() => Pi(l, h));
    }
  }(e, a, t, i), i && (a.drawPointList.forEach((l) => v1(e, a, l, s)), a.callback("set")), t.addFn(() => a.mesh && e.transformControls.attach(a.mesh)).name("选中物体"), t.addFn(() => {
    n.drawEventCall = o;
  }).name("操作当前组"), t.addFn(() => {
    t.parent.removeFolder(t), a.mesh && e.remove(a.mesh), n.drawEventCall = null;
  }).name("移除此组"), n.drawEventCall = o;
}
function v1(n, e, t, i) {
  const r = e.drawPointList, s = i.addFn(() => {
    const a = r.indexOf(t);
    a > -1 && r.splice(a, 1), Pi(n, e), i.remove(s);
  }).name("移除点" + [t.x, t.y, t.z].map((a) => a.toFixed(2)).join(","));
}
function Pi(n, e) {
  switch (e.mode) {
    case "围栏物体":
      (function(t, i) {
        var h, c;
        const r = [...i.drawPointList];
        if (r.length < 2)
          return void (i.mesh && (t.remove(i.mesh), zu(i.mesh), i.mesh = null, (h = i.callback) == null ? void 0 : h.call(i, "remove")));
        i.fenceClose && i.drawPointList.length > 2 && r.push(i.drawPointList[0]);
        const s = r.reduce((u, d) => {
          const p = new _().copy(d);
          return p.y += i.fenceHeight, [...u, p, d];
        }, []), { indexGroup: a, faceGroup: o, uvGroup: l } = l1(s);
        if (s.length > 3 && !i.mesh) {
          const u = h1(o, a, l), d = xi(i.materialType, { color: 16777215 }), p = new ce(u, d);
          p.isDrawMesh = !0, p.drawParams = i, i.mesh = p, t.add(i.mesh), (c = i.callback) == null || c.call(i, "set");
        } else
          i.mesh && c1(i.mesh.geometry, o, a, l);
      })(n, e);
      break;
    case "平面绘制":
      (function(t, i) {
        var l, h;
        const r = [...i.drawPointList];
        if (r.length < 3)
          return void (i.mesh && (t.remove(i.mesh), zu(i.mesh), i.mesh = null, (l = i.callback) == null ? void 0 : l.call(i, "remove")));
        r.forEach((c) => c.y += 1e-3);
        const { indexGroup: s, faceGroup: a, uvGroup: o } = l1(r, "face");
        if (i.drawPointList.length > 2 && !i.mesh) {
          const c = h1(a, s, o), u = xi(i.materialType, { color: 16777215 }), d = new ce(c, u);
          d.isDrawMesh = !0, d.drawParams = i, i.mesh = d, t.add(i.mesh), (h = i.callback) == null || h.call(i, "set");
        } else
          i.mesh && c1(i.mesh.geometry, a, s, o);
      })(n, e);
      break;
    case "曲线路径":
      (function(t, i) {
        var p, m;
        const { drawPointList: r, height: s, axial: a, tubularSegments: o, radius: l, radialSegments: h, closed: c } = i;
        if (r.length < 2)
          return void (i.mesh && (t.remove(i.mesh), zu(i.mesh), i.mesh = null, (p = i.callback) == null ? void 0 : p.call(i, "remove")));
        const u = r.map((g) => new _(g.x, g.y, g.z)).map((g, f, v) => {
          if (v[f + 1]) {
            const y = g.clone().add(v[f + 1]).divideScalar(2);
            return y[a] += s, [g, y];
          }
          return [g];
        }).flat(), d = new Bd(u);
        if (i.mesh)
          i.mesh.geometry.dispose(), i.mesh.geometry = new Pr(d, o, l, h, c);
        else {
          const g = new Pr(d, o, l, h, c), f = xi(i.materialType, { color: 16777215 }), v = new ce(g, f);
          v.isCurveMesh = !0, v.isDrawMesh = !0, v.drawParams = i, i.mesh = v, t.add(i.mesh), (m = i.callback) == null || m.call(i, "set");
        }
      })(n, e);
      break;
    case "直线路径":
      LR(n, e);
  }
}
function NR(n) {
  return n.map((e) => function(t) {
    const i = {};
    return Object.keys(t.drawParams).forEach((r) => {
      ["mesh", "folder", "callback"].includes(r) || (i[r] = t.drawParams[r]);
    }), $t(Te({}, La(t)), { material: Qd(t.material), drawParams: i });
  }(e));
}
function DR(n, e) {
  e == null || e.map((t) => function(i, r) {
    if (!r)
      return;
    const { drawParams: s } = r;
    Pi(i, s);
    const { mesh: a } = s;
    return Na(a, r), $d(i, a.material, r.material), s;
  }(n, t));
}
function Vf(n, e = 1e4) {
  const [t, i] = n, [r, s] = Bn("EPSG:4326", "EPSG:3857", [t, i]);
  return new X(r / e, s / e);
}
function y1(n) {
  return new X(n.offsetX / n.target.clientWidth * 2 - 1, -n.offsetY / n.target.clientHeight * 2 + 1);
}
function KS(n) {
  new yt().setFromObject(n).getCenter(n.position), n.translationOriginDiff = n.position.clone(), n.getTransformedVector = (e) => {
    const t = e.clone();
    return t.sub(n.translationOriginDiff), t.multiply(n.scale), t.applyEuler(n.rotation), t.add(n.position), t;
  }, n.traverse((e) => {
    e.isMesh && e.position.sub(n.position), e.initTranslate = e.position.clone();
  }), n.position.set(0, 0, 0);
}
function x1(n, e, t = null) {
  const { globalConfig: i } = e, r = n.map((c) => Vf(c)), s = new Go(r), a = new ls();
  a.path = s, i.geometry.isEmpty ? a.holes.push(s) : a.curves.push(s);
  const o = new Ia(a, Te({ depth: 20, bevelEnabled: !1 }, i.geometry.parameters)), l = e.listMaterial || xi(e.materialType, { color: 16777215 * Math.random(), transparent: !0 }), h = new ce(o, l);
  (function(c, u) {
    var d, p;
    if (c.name = (d = u == null ? void 0 : u.properties) == null ? void 0 : d.name, u == null ? void 0 : u.properties.center) {
      const m = Vf(u.properties.center);
      u.properties.centerCoord3 = new _(m.x, m.y, 0);
    }
    if ((p = u == null ? void 0 : u.properties) != null && p.centroid) {
      const m = Vf(u.properties.centroid);
      u.properties.centroidCoord3 = new _(m.x, m.y, 0);
    }
    c.geoInfo = u;
  })(h, t), ZS(h), e.attach(h);
}
function ug(n, e, t) {
  e.labelGroup = {};
  const { type: i, color: r, fontSize: s, fontWeight: a, px: o, py: l, pz: h, rx: c, ry: u, rz: d, ss: p, sx: m, sy: g, sz: f } = t;
  e.children.forEach((v) => {
    var y, x, M, b, S, w, T, C, I;
    if ((y = v.geoInfo) != null && y.properties.name && !e.labelGroup[v.geoInfo.properties.name]) {
      if (!((x = v.geoInfo) != null && x.properties.centroidCoord3) && !((M = v.geoInfo) != null && M.properties.centerCoord3))
        return;
      const A = (((b = v.geoInfo) == null ? void 0 : b.properties.centroidCoord3) || ((S = v.geoInfo) == null ? void 0 : S.properties.centerCoord3)).add(v.position).sub(v.initTranslate), L = e.getTransformedVector(A), D = document.createElement("div");
      D.innerText = ((T = (w = v.geoInfo) == null ? void 0 : w.properties) == null ? void 0 : T.name) || "", D.style.color = r, D.style.fontSize = s + "px", D.style.fontWeight = a;
      const U = i === "2D" ? new rS(D) : new sS(D);
      U.Jr = L, U.position.set(U.Jr.x + o, U.Jr.y + l, U.Jr.z + h), U.rotation.set(c, u, d), U.scale.set(m, g, f), U.scale.setScalar(p), n.add(U), D.style.pointerEvents = "none", e.labelGroup[(I = (C = v.geoInfo) == null ? void 0 : C.properties) == null ? void 0 : I.name] = U;
    }
  });
}
function JS(n, e) {
  const { commonFrames: t } = n, { globalConfig: i } = e;
  if (!i.useGlobalConfig)
    return;
  const { mesh: r, material: s } = i;
  if (e.children.forEach((a) => {
    a.castShadow = r.castShadow, a.receiveShadow = r.receiveShadow;
  }), s.mapUrl) {
    const a = new Ui().load(s.mapUrl);
    a.wrapS = jt, a.wrapT = jt, a.repeat.set(s.map.repeat.x, s.map.repeat.y), a.offset.set(s.map.offset.x, s.map.offset.y), a.center.set(s.map.center.x, s.map.center.y), a.rotation = s.map.rotation, e.texture = a, e.commonAnimateRender = function() {
      this.texture.offset.x += this.globalConfig.material.textureAnimation.offset.x, this.texture.offset.y += this.globalConfig.material.textureAnimation.offset.y, this.texture.rotation += this.globalConfig.material.textureAnimation.rotation;
    }, t.push(e);
  }
  e.RootMaterials.forEach((a) => {
    a.color.set(s.color), a.wireframe = s.wireframe, a.transparent = s.transparent, a.opacity = s.opacity, ["标准材质", "物理材质"].includes(e.materialType) && (a.metalness = s.metalness, a.roughness = s.roughness), e.materialType !== "基础材质" && (a.emissive.set(s.emissive), a.emissiveIntensity = s.emissiveIntensity), e.materialType === "物理材质" && (a.clearcoat = s.clearcoat, a.clearcoatRoughness = s.clearcoatRoughness, a.sheen = s.sheen, a.sheenRoughness = s.sheenRoughness, a.sheenColor.set(s.sheenColor), a.transmission = s.transmission), a.envMap = s.envMap ? n.envBackground : null, a.envMapIntensity = s.envMapIntensity, a.reflectivity = s.reflectivity, a.map = e.texture, a.needsUpdate = !0;
  }), e.parent.envMapChangeUseList.push(() => e.RootMaterials.forEach((a) => a.envMap = e.parent.envBackground));
}
function OR(n, e, t) {
  const { globalConfig: i } = e;
  t.add(i, "isSaveChildren").name("子物体更改存储"), t.add(i, "isSaveMaterials").name("单材质更改存储"), t.add(i, "useGlobalConfig").name("使用(全局)配置");
  const r = t.addFolder("(全局 )阴影配置");
  r.add(i.mesh, "castShadow").name("产生阴影").onChange(() => e.children.forEach((s) => s.castShadow = i.mesh.castShadow)), r.add(i.mesh, "receiveShadow").name("接收阴影").onChange(() => e.children.forEach((s) => s.receiveShadow = i.mesh.receiveShadow)), QS(n, e, t.addFolder("(全局)材质配置")), function(s, a) {
    const { globalConfig: o } = s;
    let l = null;
    function h() {
      l && clearTimeout(l), l = setTimeout(() => {
        s.children.forEach((c) => {
          c.geometry.dispose(), o.geometry.isEmpty ? (c.geometry.parameters.shapes.holes = [c.geometry.parameters.shapes.path], c.geometry.parameters.shapes.curves = []) : (c.geometry.parameters.shapes.curves = [c.geometry.parameters.shapes.path], c.geometry.parameters.shapes.holes = []), c.geometry = new Ia(c.geometry.parameters.shapes, o.geometry.parameters), c.geometry.center();
        }), l = null;
      }, 200);
    }
    a.add(o.geometry, "isEmpty").name("镂空").onChange(h), a.add(o.geometry.parameters, "depth").name("深度").onChange(h).min(1e-3), a.add(o.geometry.parameters, "bevelEnabled").name("斜角").onChange(h), a.add(o.geometry.parameters, "bevelThickness").name("斜角厚度").onChange(h).min(0), a.add(o.geometry.parameters, "bevelSize").name("斜角大小").onChange(h).min(0), a.add(o.geometry.parameters, "bevelOffset").name("斜角偏移").onChange(h).min(0);
  }(e, t.addFolder("形状配置"));
}
function QS(n, e, t) {
  const { globalConfig: i } = e, { material: r } = i;
  t.addColor(r, "color").name("颜色").onChange((s) => e.RootMaterials.forEach((a) => a.color.set(s))), t.add(r, "wireframe").name("线框").onChange((s) => e.RootMaterials.forEach((a) => a.wireframe = s)), t.add(r, "transparent").name("透明").onChange((s) => e.RootMaterials.forEach((a) => a.transparent = s)), t.add(r, "opacity", 0, 1).name("透明度").onChange((s) => e.RootMaterials.forEach((a) => a.opacity = s)), ["标准材质", "物理材质"].includes(e.materialType) && (t.add(r, "metalness", 0, 1).name("金属感").onChange((s) => e.RootMaterials.forEach((a) => a.metalness = s)), t.add(r, "roughness", 0, 1).name("粗糙感").onChange((s) => e.RootMaterials.forEach((a) => a.roughness = s))), e.materialType !== "基础材质" && (t.addColor(r, "emissive").name("自发光").onChange((s) => e.RootMaterials.forEach((a) => a.emissive.set(s))), t.add(r, "emissiveIntensity", 0).name("自发光强度").onChange((s) => e.RootMaterials.forEach((a) => a.emissiveIntensity = s))), e.materialType !== "卡通材质" && (t.add(r, "envMap").name("环境贴图").onChange((s) => e.RootMaterials.forEach((a) => a.envMap = s ? n.envBackground : null)), t.add(r, "envMapIntensity", 0).name("环境贴图强度").onChange((s) => e.RootMaterials.forEach((a) => a.envMapIntensity = s)), t.add(r, "reflectivity", 0, 1).name("反射率").onChange((s) => e.RootMaterials.forEach((a) => a.reflectivity = s))), e.materialType === "物理材质" && (t.add(r, "clearcoat", 0, 1).name("清漆层").onChange((s) => e.RootMaterials.forEach((a) => a.clearcoat = s)), t.add(r, "clearcoatRoughness", 0, 1).name("清漆层粗糙度").onChange((s) => e.RootMaterials.forEach((a) => a.clearcoatRoughness = s)), t.add(r, "sheen", 0, 1).name("光泽度").onChange((s) => e.RootMaterials.forEach((a) => a.sheen = s)), t.add(r, "sheenRoughness", 0, 1).name("光泽粗糙度").onChange((s) => e.RootMaterials.forEach((a) => a.sheenRoughness = s)), t.addColor(r, "sheenColor").name("光泽颜色").onChange((s) => e.RootMaterials.forEach((a) => a.sheenColor.set(s))), t.add(r, "transmission", 0, 1).name("透射率").onChange((s) => e.RootMaterials.forEach((a) => a.transmission = s))), t.addFn(() => e.RootMaterials.forEach((s) => s.needsUpdate = !0)).name("手动更新材质"), function(s, a, o) {
    const { material: l } = a.globalConfig;
    function h(d) {
      a.RootMaterials.forEach((p) => {
        p.map && (p.map[d] = l.map[d]);
      });
    }
    function c() {
      const { mapUrl: d, map: p } = l;
      if (!d)
        return;
      const m = new Ui().load(d);
      m.wrapS = jt, m.wrapT = jt, m.repeat.set(p.repeat.x, p.repeat.y), m.offset.set(p.offset.x, p.offset.y), m.center.set(p.center.x, p.center.y), m.rotation = p.rotation, a.texture = m, a.RootMaterials.forEach((g) => {
        g.map = m, g.needsUpdate = !0;
      });
    }
    function u(d) {
      d ? (a.commonAnimateRender = function() {
        this.texture.offset.x += this.globalConfig.material.textureAnimation.offset.x, this.texture.offset.y += this.globalConfig.material.textureAnimation.offset.y, this.texture.rotation += this.globalConfig.material.textureAnimation.rotation;
      }, s.push(a)) : delete a.texture.commonAnimateRender;
    }
    o.add(l, "mapUrl").name("贴图路径"), o.add(l.map.repeat, "x").name("水平重复").onChange((d) => h("repeat")), o.add(l.map.repeat, "y").name("垂直重复").onChange((d) => h("repeat")), o.add(l.map.offset, "x").name("水平偏移").onChange((d) => h("offset")), o.add(l.map.offset, "y").name("垂直偏移").onChange((d) => h("offset")), o.add(l.map, "rotation", 0, 2 * Math.PI).name("旋转").onChange((d) => h("rotation")), o.add(l.map.center, "x").name("水平中心").onChange((d) => h("center")), o.add(l.map.center, "y").name("垂直中心").onChange((d) => h("center")), o.add(l.textureAnimation, "isTextureAnimation").name("贴图动画").onChange((d) => u(d)), o.add(l.textureAnimation.offset, "x").name("水平偏移动画"), o.add(l.textureAnimation.offset, "y").name("垂直偏移动画"), o.add(l.textureAnimation, "rotation", 0, 2 * Math.PI).name("旋转动画"), o.addFn(() => c()).name("更新贴图");
  }(n.commonFrames, e, t.addFolder("贴图"));
}
function UR(n, e) {
  return li(this, null, function* () {
    var i;
    if (!e)
      return;
    const t = new yn();
    return t.url = e.url, t.materialType = e.materialType, t.globalConfig = e.globalConfig, t.isListMaterial = e.isListMaterial, t.edgeMaterialType = e.edgeMaterialType, yield P0(n, t), Na(t, e), JS(n, t), t.globalConfig.isSaveChildren && ip(t.children, e.children), t.globalConfig.isSaveMaterials && t.RootMaterials.forEach((r, s) => S0(r, e.RootMaterials[s])), (i = t.listMaterial) == null || i.forEach((r, s) => $d(n, r, e.listMaterial[s])), function(r, s) {
      const { label: a } = s.globalConfig;
      a.show && ug(r, s, a);
    }(n, t), t;
  });
}
function P0(n, e) {
  return li(this, null, function* () {
    let t = null;
    return t = typeof e.url == "string" ? yield fetch(e.url).then((i) => i.json()) : e.url, function(i, r) {
      if (r.isListMaterial) {
        const { materialType: s, edgeMaterialType: a } = r;
        r.listMaterial = [xi(s, { color: 16777215 * Math.random(), transparent: !0 }), xi(a, { color: 16777215 * Math.random(), transparent: !0 })];
      }
      i.forEach((s) => {
        s.geometry.type === "MultiPolygon" ? s.geometry.coordinates.forEach((a) => a.forEach((o) => x1(o, r, s))) : s.geometry.type === "Polygon" && s.geometry.coordinates.forEach((a) => x1(a, r, s));
      });
    }(t.features, e), KS(e), e.RootMaterials = tp(e), e.rotation.x = -Math.PI / 2, e.isGeoGroup = !0, n.add(e), e;
  });
}
function M1(n, e, t) {
  var i;
  t.add(e, "url").name("地址源修改"), Dr(e, t.addFolder("基础配置")), OR(n, e, t.addFolder("子项和全局配置")), function(r, s, a) {
    const { label: o } = s.globalConfig;
    function l(c) {
      if (!s.labelGroup)
        return;
      const u = Object.values(s.labelGroup);
      switch (c) {
        case "type":
          h(), ug(r, s, o);
          break;
        case "color":
          u.forEach((d) => d.element.style.color = o[c]);
          break;
        case "fontSize":
          u.forEach((d) => d.element.style.fontSize = o[c] + "px");
          break;
        case "fontWeight":
          u.forEach((d) => d.element.style.fontWeight = o[c]);
          break;
        case "px":
          u.forEach((d) => d.position.x = d.Jr.x + o[c]);
          break;
        case "py":
          u.forEach((d) => d.position.y = d.Jr.y + o[c]);
          break;
        case "pz":
          u.forEach((d) => d.position.z = d.Jr.z + o[c]);
          break;
        case "rx":
          u.forEach((d) => d.rotation.x = o[c]);
          break;
        case "ry":
          u.forEach((d) => d.rotation.y = o[c]);
          break;
        case "rz":
          u.forEach((d) => d.rotation.z = o[c]);
          break;
        case "ss":
          u.forEach((d) => d.scale.setScalar(o[c]));
          break;
        case "sx":
          u.forEach((d) => d.scale.x = o[c]);
          break;
        case "sy":
          u.forEach((d) => d.scale.y = o[c]);
          break;
        case "sz":
          u.forEach((d) => d.scale.z = o[c]);
      }
    }
    function h() {
      s.labelGroup && Object.keys(s.labelGroup).forEach((c) => {
        r.remove(s.labelGroup[c]), delete s.labelGroup[c];
      });
    }
    a.add(o, "show").name("显示标签").onChange((c) => c ? ug(r, s, o) : h()), a.add(o, "type", ["2D", "3D"]).name("标签类型").onChange((c) => l("type")), a.addColor(o, "color").name("标签颜色").onChange((c) => l("color")), a.add(o, "fontSize", 0).name("标签字体大小").onChange((c) => l("fontSize")), a.add(o, "fontWeight", ["400", "500", "600", "700", "800", "900"]).name("标签字体粗细").onChange((c) => l("fontWeight")), a.add(o, "px").name("标签位置X偏移").onChange((c) => l("px")), a.add(o, "py").name("标签位置Y偏移").onChange((c) => l("py")), a.add(o, "pz").name("标签位置Z偏移").onChange((c) => l("pz")), a.add(o, "rx", 0, 2 * Math.PI).name("标签旋转X偏移").onChange((c) => l("rx")), a.add(o, "ry", 0, 2 * Math.PI).name("标签旋转Y偏移").onChange((c) => l("ry")), a.add(o, "rz", 0, 2 * Math.PI).name("标签旋转Z偏移").onChange((c) => l("rz")), a.add(o, "ss").name("标签缩放").onChange((c) => l("ss")), a.add(o, "sx").name("标签缩放X").onChange((c) => l("sx")), a.add(o, "sy").name("标签缩放Y").onChange((c) => l("sy")), a.add(o, "sz").name("标签缩放Z").onChange((c) => l("sz"));
  }(n, e, t.addFolder("标签配置")), (i = e.listMaterial) == null || i.forEach((r, s) => ep(n, r, t.addFolder(s ? "边缘" : "面"))), t.addFn(() => {
    t.parent.removeFolder(t), n.remove(e);
  }).name("删除地图");
}
function FR(n, e, t) {
  const i = t.addFolder("地图列表");
  return i.open(), t.add(n, "url").name("地图数据地址"), t.add(n, "materialType", Co).name("地图材质类型"), t.add(n, "isListMaterial").name("是否列表材质"), t.add(n, "edgeMaterialType", Co).name("边缘材质类型"), t.addFn(() => li(this, null, function* () {
    if (!n.url)
      return;
    const { url: r, materialType: s, isListMaterial: a, edgeMaterialType: o } = n, l = yield P0(e, function(h, c, u, d) {
      const p = new yn();
      return p.url = h, p.materialType = c, p.isListMaterial = u, p.edgeMaterialType = d, function(m) {
        m.globalConfig || (m.globalConfig = { useGlobalConfig: !1, isSaveChildren: !0, isSaveMaterials: !0, mesh: { castShadow: !1, receiveShadow: !1 }, material: { color: 16777215, wireframe: !1, transparent: !0, opacity: 1, metalness: 0, roughness: 0, emissive: 0, emissiveIntensity: 1, clearcoat: 0, clearcoatRoughness: 0, sheen: 0, sheenRoughness: 0, sheenColor: 0, transmission: 0, envMap: !1, envMapIntensity: 1, reflectivity: 0.98, mapUrl: "", textureAnimation: { isTextureAnimation: !1, offset: { x: 0, y: 0.01 }, rotation: 0 }, map: { repeat: { x: 1, y: 1 }, offset: { x: 0, y: 0 }, center: { x: 0, y: 0 }, rotation: 0 } }, geometry: { geometryType: "形状路径挤压体", isEmpty: !1, parameters: { depth: 16, bevelEnabled: !1, bevelThickness: 0, bevelSize: 0, bevelOffset: 0 } }, label: { show: !1, type: "2D", color: "#fff", fontSize: 12, fontWeight: 400, px: 0, py: 0, pz: 0, rx: 0, ry: 0, rz: 0, ss: 1, sx: 1, sy: 1, sz: 1 } });
      }(p), p;
    }(r, s, a, o));
    M1(e, l, i.addFolder(Qn(l)));
  })).name("添加地图"), e.children.forEach((r) => r.isGeoGroup && M1(e, r, i.addFolder(Qn(r)))), t;
}
function BR(n) {
  return n.map((e) => function(t) {
    const { url: i, globalConfig: r, materialType: s, isListMaterial: a, edgeMaterialType: o, listMaterial: l, children: h, RootMaterials: c } = t;
    return $t(Te({}, La(t)), { url: i, globalConfig: r, materialType: s, isListMaterial: a, edgeMaterialType: o, listMaterial: l == null ? void 0 : l.map((u) => Qd(u)), RootMaterials: r.isSaveMaterials ? c.map((u) => b0(u)) : void 0, children: r.isSaveChildren ? np(h) : void 0 });
  }(e));
}
function b1(n, e, t) {
  GS(e, t.addFolder("基础配置"));
  const { globalConfig: i } = e;
  t.add(i, "isSaveChildren").name("子物体更改存储"), t.add(i, "isSaveMaterials").name("单材质更改存储"), t.add(i, "useGlobalConfig").name("全局材质配置");
  const r = t.addFolder("阴影");
  r.add(i.mesh, "castShadow").name("产生阴影").onChange(() => e.children.forEach((s) => s.castShadow = i.mesh.castShadow)), r.add(i.mesh, "receiveShadow").name("接收阴影").onChange(() => e.children.forEach((s) => s.receiveShadow = i.mesh.receiveShadow)), function(s, a) {
    const { globalConfig: o } = s, { geometry: l } = o;
    let h = null;
    function c() {
      h && clearTimeout(h), h = setTimeout(() => {
        s.children.forEach((u) => {
          u.geometry.dispose(), u.geometry = new Pr(u.curve, (u.curve.points.length - 1) * l.tubularSegmentsMultiple, l.radius, l.radialSegments, l.closed), u.geometry.center();
        }), h = null;
      }, 200);
    }
    a.add(l, "tubularSegmentsMultiple", 1).name("分段倍乘").onChange(c).step(1), a.add(l, "radius", 0.01).name("管道半径").onChange(c), a.add(l, "radialSegments", 2).name("管道半径分段").onChange(c).step(1), a.add(l, "closed").name("管道是否闭合").onChange(c);
  }(e, t.addFolder("几何体")), QS(n, e, t.addFolder("材质")), t.addFn(() => {
    t.parent.removeFolder(t), n.remove(e);
  }).name("删除边界");
}
function $S(n, e, t = 0) {
  const i = new yn();
  return i.materialType = e, i.url = n, i.dlength = t, function(r) {
    r.globalConfig = { useGlobalConfig: !1, isSaveMaterials: !0, isSaveChildren: !0, mesh: { castShadow: !1, receiveShadow: !1 }, material: { color: 16777215, wireframe: !1, transparent: !0, opacity: 1, metalness: 0, roughness: 0, emissive: 0, emissiveIntensity: 1, clearcoat: 0, clearcoatRoughness: 0, sheen: 0, sheenRoughness: 0, sheenColor: 0, transmission: 0, envMap: !1, envMapIntensity: 1, reflectivity: 0.98, mapUrl: "", textureAnimation: { isTextureAnimation: !1, offset: { x: 0, y: 0.01 }, rotation: 0 }, map: { repeat: { x: 1, y: 1 }, offset: { x: 0, y: 0 }, center: { x: 0, y: 0 }, rotation: 0 } }, geometry: { radialSegments: 4, radius: 2, closed: !1, tubularSegmentsMultiple: 1 } };
  }(i), fetch(n).then((r) => r.json()).then((r) => {
    const { features: s } = r;
    return s.forEach((a) => {
      a.geometry.type === "MultiPolygon" ? a.geometry.coordinates.forEach((o) => o.forEach((l) => Hf(i, l))) : a.geometry.type === "Polygon" ? a.geometry.coordinates.forEach((o) => Hf(i, o)) : a.geometry.type === "LineString" && a.geometry.coordinates.length > 1 && Hf(i, a.geometry.coordinates);
    }), KS(i), i.RootMaterials = tp(i), i.rotation.x = -Math.PI / 2, i.isBorderGroup = !0, i;
  });
}
function Hf(n, e) {
  if (e.length < n.dlength)
    return;
  const t = e.map((o) => function(l, h = 1e4) {
    const [c, u] = l, [d, p] = Bn("EPSG:4326", "EPSG:3857", [c, u]);
    return new _(d / h, p / h, 0);
  }(o)), i = new Bd(t), r = new Pr(i, t.length - 1, 2, 4, !1), s = xi(n.materialType, { color: 16777215 * Math.random(), transparent: !0, alphaHash: !0 }), a = new ce(r, s);
  a.curve = i, ZS(a), n.attach(a);
}
function kR(n) {
  return n.map((e) => function(t) {
    const { children: i, RootMaterials: r } = t;
    return $t(Te({}, T0(t)), { globalConfig: t.globalConfig, url: t.url, dlength: t.dlength, materialType: t.materialType, RootMaterials: t.globalConfig.isSaveMaterials ? r.map((s) => b0(s)) : void 0, children: t.globalConfig.isSaveChildren ? np(i) : void 0 });
  }(e));
}
function zR(n, e) {
  e && e.forEach((t) => function(i, r) {
    return li(this, null, function* () {
      if (!r)
        return;
      const s = yield $S(r.url, r.materialType, r.dlength);
      s.globalConfig = r.globalConfig;
      const { geometry: a } = s.globalConfig;
      return s.children.forEach((o) => {
        o.geometry.dispose(), o.geometry = new Pr(o.curve, (o.curve.points.length - 1) * a.tubularSegmentsMultiple, a.radius, a.radialSegments, a.closed), o.geometry.center();
      }), i.add(s), E0(s, r), JS(i, s), s.globalConfig.isSaveChildren && ip(s.children, r.children), s.globalConfig.isSaveMaterials && s.RootMaterials.forEach((o, l) => S0(o, r.RootMaterials[l])), s;
    });
  }(n, t));
}
function ew(n, e, t) {
  const i = tw(t), r = function(a, o) {
    const { uniforms: l, fragmentFunc: h, fragmentBody: c, key: u, render: d } = function(m, g, f = "") {
      const { name: v, customUniforms: y, key: x, fragment: M, render: b } = uS[g], S = { uniforms: Te({}, cd(m, ["pointTexture-texture-sampler2D-" + f, "size-number-float-100", "discardVal-number-float-0.5", "opacity-number-float-1", "isdecaySize-bool-bool-true", "hasUv-bool-bool-true", "iTime-number-float-0", "speed-number-float-0.01", "intensity-number-float-1", "mixRatio-number-float-1", "mixColor-color-vec3-0xffffff", "iResolution-dom-vec2-0,0"])), fragmentFunc: "", fragmentBody: "", key: x, shaderProgramsCodeName: v };
      if (y && Object.assign(S.uniforms, cd(m, y)), M.search("<SPLIT_PLACEHOLDER>") !== -1) {
        const [w, T] = M.split("<SPLIT_PLACEHOLDER>");
        S.fragmentFunc = w, S.fragmentBody = T.replace("<UV_PLACEHOLDER>", "if(hasUv) uv=vUv;");
      } else
        S.fragmentBody = M.replace("<UV_PLACEHOLDER>", "if(hasUv) uv=vUv;");
      return S.render = b === "iTime+speed" ? () => S.uniforms.iTime.value += S.uniforms.speed.value : new Function(b).bind(S.uniforms), S;
    }(a, o.shaderCodeName, o.mapUrl), p = new tt({ uniforms: l, vertexShader: `

            uniform float size;

            uniform bool isdecaySize;

            void main() {

                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

                gl_PointSize = isdecaySize ? size * ( 300.0 / -mvPosition.z ) : size;

                gl_Position = projectionMatrix * mvPosition;

            } 

        `, fragmentShader: Object.keys(l).map((m) => "uniform " + l[m].unit + " " + m + `;
`).join("") + `${h}void main() {

            vec2 vUv = gl_PointCoord.xy - .5;

            ${c}
            
            vec3 useColor = ${u};

            vec4 textureColor = texture2D( pointTexture, gl_PointCoord );

            if (textureColor.a < discardVal) discard;

            else useColor *= textureColor.rgb;

            gl_FragColor = vec4( mix( mixColor, useColor * vec3( intensity, intensity, intensity), mixRatio ) , opacity );
            
        }`, transparent: !0, depthTest: !0, blending: Ar });
    return p.materialRender = d, p;
  }(e, t), s = new os(i, r);
  return s.parameters = t, s.commonAnimateRender = () => {
    var a, o, l, h;
    (o = (a = s.geometry).geometryRender) == null || o.call(a), (h = (l = s.material).materialRender) == null || h.call(l);
  }, s.isParticleMesh = !0, n.add(s), n.commonFrames.push(s), s;
}
function tw(n) {
  if (n.outer - n.inner < 1)
    return new Pe();
  const e = new Float32Array(3 * n.particlesSum), t = new Float32Array(3 * n.particlesSum), i = { 全随机: (a) => {
    t[3 * a] += (Math.random() - 0.5) * n.maxVelocity / 1e3, t[3 * a + 1] += (Math.random() - 0.5) * n.maxVelocity / 1e3, t[3 * a + 2] += (Math.random() - 0.5) * n.maxVelocity / 1e3;
  }, 随机向上: (a) => {
    t[3 * a] += (Math.random() - 0.5) * n.maxVelocity / 1e3, t[3 * a + 1] += Math.abs((Math.random() - 0.5) * n.maxVelocity / 1e5), t[3 * a + 2] += (Math.random() - 0.5) * n.maxVelocity / 1e3;
  }, 随机向下: (a) => {
    t[3 * a] += (Math.random() - 0.5) * n.maxVelocity / 1e3, t[3 * a + 1] -= Math.abs((Math.random() - 0.5) * n.maxVelocity / 1e5), t[3 * a + 2] += (Math.random() - 0.5) * n.maxVelocity / 1e3;
  }, 直线匀速向上: (a) => {
    t[3 * a] = 0, t[3 * a + 1] += n.maxVelocity / 2 / 1e5, t[3 * a + 2] = 0;
  }, 直线匀速向下: (a) => {
    t[3 * a] = 0, t[3 * a + 1] -= n.maxVelocity / 2 / 1e5, t[3 * a + 2] = 0;
  } }[n.sportType];
  function r() {
    let a, o, l;
    do
      a = 2 * Math.random() * n.outer - n.outer, o = 2 * Math.random() * n.outer - n.outer, l = 2 * Math.random() * n.outer - n.outer;
    while (Math.abs(a) <= n.inner && Math.abs(o) <= n.inner && Math.abs(l) <= n.inner);
    return [a, o, l];
  }
  for (let a = 0; a < n.particlesSum; a++)
    e.set(r(), 3 * a);
  const s = new Pe();
  return s.setAttribute("position", new Ke(e, 3)), s.geometryRender = () => {
    for (let a = 0; a < n.particlesSum; a++)
      if (i(a), e[3 * a] += t[3 * a], e[3 * a + 1] += t[3 * a + 1], e[3 * a + 2] += t[3 * a + 2], Math.abs(e[3 * a]) > n.outer || Math.abs(e[3 * a + 1]) > n.outer || Math.abs(e[3 * a + 2]) > n.outer || Math.abs(e[3 * a]) < n.inner && Math.abs(e[3 * a + 1]) < n.inner && Math.abs(e[3 * a + 2]) < n.inner) {
        const [o, l, h] = r();
        e[3 * a] = o, e[3 * a + 1] = l, e[3 * a + 2] = h, t[3 * a] = 0, t[3 * a + 1] = 0, t[3 * a + 2] = 0;
      }
    s.attributes.position.needsUpdate = !0;
  }, s;
}
function S1(n, e, t) {
  Dr(e, t.addFolder("基础属性")), function(i, r) {
    let s = null;
    function a() {
      s || (i.geometry.dispose(), i.geometry = new Pe(), s = setTimeout(() => {
        i.geometry = tw(i.parameters), s = null;
      }, 200));
    }
    r.add(i.parameters, "particlesSum", 1).name("数量").onChange(a), r.add(i.parameters, "inner", 0).name("内半径").onChange(a), r.add(i.parameters, "outer", 500).name("外半径").onChange(a), r.add(i.parameters, "maxVelocity").name("最大速度").onChange(a), r.add(i.parameters, "sportType", ["全随机", "随机向下", "随机向上", "直线匀速向上", "直线匀速向下"]).name("运动方式").onChange(a);
  }(e, t.addFolder("几何")), function(i, r) {
    r.add(i, "depthTest").name("深度测试").onChange(() => i.needsUpdate = !0), r.add(i, "blending", m0).name("混合模式").onChange((s) => (i.blending = Number(s), i.needsUpdate = !0)), ku(i.uniforms, r.addFolder("着色器参数"));
  }(e.material, t.addFolder("材质")), t.addFn(() => n.transformControls.attach(e)).name("选中"), t.addFn(() => {
    n.remove(e), t.parent.removeFolder(t);
  }).name("删除");
}
function VR(n) {
  return n.map((e) => function(t) {
    const { material: i } = t, { uniforms: r, blending: s, depthTest: a } = i;
    return $t(Te({}, La(t)), { parameters: t.parameters, material: { uniforms: dS(r), blending: s, depthTest: a } });
  }(e));
}
function HR(n, e, t) {
  t == null || t.map((i) => function(r, s, a) {
    if (!a)
      return;
    const o = ew(r, s, a.parameters);
    Na(o, a);
    const { material: l } = a;
    return o.material.blending = l.blending, o.material.depthTest = l.depthTest, pS(o.material.uniforms, l.uniforms), l.needsUpdate = !0, o;
  }(n, e, i));
}
function w1(n, e, t) {
  Dr(e, t.addFolder("基础配置")), function(i, r) {
    const { geometry: s } = i, { parameters: a } = s, { options: o } = a;
    let l = null;
    function h() {
      l && clearTimeout(l), l = setTimeout(() => {
        i.geometry.dispose(), i.geometry = new WS(i.text, o), l = null;
      }, 200);
    }
    r.add(i, "text").onChange(h).name("文本"), r.add(o, "size").onChange(h).name("大小"), r.add(o, "depth").onChange(h).name("深度"), r.add(o, "height").onChange(h).name("高度"), r.add(o, "curveSegments").onChange(h).name("曲线分段").step(1).min(1), r.add(o, "bevelEnabled").onChange(h).name("斜角"), r.add(o, "bevelThickness").onChange(h).name("斜角厚度"), r.add(o, "bevelSize").onChange(h).name("斜角大小"), r.add(o, "bevelSegments").onChange(h).name("斜角分段").step(1).min(0);
  }(e, t.addFolder("几何体")), ep(n, e.material, t.addFolder("材质")), t.addFn(() => {
    n.remove(e), t.parent.removeFolder(t);
  }).name("删除");
}
function GR(n) {
  return n.map((e) => function(t) {
    const { material: i, geometry: r } = t, { parameters: s } = r, { options: a } = s;
    return $t(Te({}, La(t)), { fontLink: t.fontLink, text: t.text, geometry: { geometryType: "TextGeometry", parameters: { size: a.size, depth: a.depth, height: a.height, curveSegments: a.curveSegments, bevelEnabled: a.bevelEnabled, bevelThickness: a.bevelThickness, bevelSize: a.bevelSize, bevelSegments: a.bevelSegments } }, material: Qd(i) });
  }(e));
}
function jR(n, e) {
  e == null || e.forEach((t) => function(i, r) {
    return li(this, null, function* () {
      if (!r)
        return;
      const { geometry: s, material: a } = r, { parameters: o } = s, l = yield XS(r.fontLink, r.text, o), h = xi(a.materialType), c = new ce(l, h);
      return c.fontLink = r.fontLink, c.text = r.text, c.isTextMesh = !0, i.add(c), $d(i, c.material, a), Na(c, r), c;
    });
  }(n, t));
}
const WR = { name: "光柱", initParameters: { url: "https://z2586300277.github.io/3d-file-server/images/channels/lightMap.png", size: 0.25 }, initPanel: function(n) {
  n.add(this.initParameters, "url").name("资源路径"), n.add(this.initParameters, "size").name("立柱尺寸");
}, create: function({}, n) {
  const e = Te(Te({}, this.initParameters), n == null ? void 0 : n.initParameters), t = new Pt(e.size || 0.3, e.size || 0.3, 20, 6), i = new Wt({ color: 16572044, transparent: !0, opacity: 0.5, side: bt }), r = new ce(t, i);
  i.blending = Ar;
  const s = new Ui().load(e.url);
  s.wrapS = jt, s.wrapT = jt;
  const a = new or(1.5, 20), o = new Wt({ transparent: !0, opacity: 0.3, side: bt, map: s });
  o.blending = Ar, o.depthTest = !1;
  const l = new ce(a, o), h = l.clone();
  h.rotation.y = Math.PI / 3;
  const c = l.clone();
  c.rotation.y = -Math.PI / 3, r.add(c), r.add(l), r.add(h), r.position.y = 10;
  const u = new yn();
  return u.RootMaterials = [i, o], u.add(r), u.initParameters = e, u;
}, changePanel(n, e, {}) {
  const [t, i] = n.RootMaterials;
  e.add(n.initParameters, "url").name("资源路径"), e.addHexColor(t.color).name("立柱颜色"), e.add(t, "opacity", 0, 1).name("立柱透明度"), e.addHexColor(i.color).name("面颜色"), e.add(i, "opacity", 0, 1).name("面透明度"), e.addFn(() => {
    const { url: r } = n.initParameters;
    if (!r)
      return;
    const s = new Ui().load(r);
    s.wrapS = jt, s.wrapT = jt, n.children[0].children.forEach((a) => {
      a.material.map = s;
    });
  }).name("更新贴图");
}, getStorage: function(n) {
  const { initParameters: e } = n, [t, i] = n.RootMaterials;
  return { initParameters: e, RootMaterials: [{ color: t.color.getHex(), opacity: t.opacity }, { color: i.color.getHex(), opacity: i.opacity }] };
}, setStorage: function(n, e) {
  if (!e)
    return;
  const [t, i] = n.RootMaterials, [r, s] = e.RootMaterials;
  t.color.setHex(r.color), t.opacity = r.opacity, i.color.setHex(s.color), i.opacity = s.opacity;
} };
class rp extends ce {
  constructor(e, t = {}) {
    super(e), this.isReflector = !0, this.type = "Reflector", this.camera = new Gt();
    const i = this, r = t.color !== void 0 ? new oe(t.color) : new oe(8355711), s = t.textureWidth || 512, a = t.textureHeight || 512, o = t.clipBias || 0, l = t.shader || rp.ReflectorShader, h = t.multisample !== void 0 ? t.multisample : 4, c = new Li(), u = new _(), d = new _(), p = new _(), m = new fe(), g = new _(0, 0, -1), f = new Ve(), v = new _(), y = new _(), x = new Ve(), M = new fe(), b = this.camera, S = new ht(s, a, { samples: h, type: Ht }), w = new tt({ name: l.name !== void 0 ? l.name : "unspecified", uniforms: Kt.clone(l.uniforms), fragmentShader: l.fragmentShader, vertexShader: l.vertexShader });
    w.uniforms.tDiffuse.value = S.texture, w.uniforms.color.value = r, w.uniforms.textureMatrix.value = M, this.material = w, this.onBeforeRender = function(T, C, I) {
      if (d.setFromMatrixPosition(i.matrixWorld), p.setFromMatrixPosition(I.matrixWorld), m.extractRotation(i.matrixWorld), u.set(0, 0, 1), u.applyMatrix4(m), v.subVectors(d, p), v.dot(u) > 0)
        return;
      v.reflect(u).negate(), v.add(d), m.extractRotation(I.matrixWorld), g.set(0, 0, -1), g.applyMatrix4(m), g.add(p), y.subVectors(d, g), y.reflect(u).negate(), y.add(d), b.position.copy(v), b.up.set(0, 1, 0), b.up.applyMatrix4(m), b.up.reflect(u), b.lookAt(y), b.far = I.far, b.updateMatrixWorld(), b.projectionMatrix.copy(I.projectionMatrix), M.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), M.multiply(b.projectionMatrix), M.multiply(b.matrixWorldInverse), M.multiply(i.matrixWorld), c.setFromNormalAndCoplanarPoint(u, d), c.applyMatrix4(b.matrixWorldInverse), f.set(c.normal.x, c.normal.y, c.normal.z, c.constant);
      const A = b.projectionMatrix;
      x.x = (Math.sign(f.x) + A.elements[8]) / A.elements[0], x.y = (Math.sign(f.y) + A.elements[9]) / A.elements[5], x.z = -1, x.w = (1 + A.elements[10]) / A.elements[14], f.multiplyScalar(2 / f.dot(x)), A.elements[2] = f.x, A.elements[6] = f.y, A.elements[10] = f.z + 1 - o, A.elements[14] = f.w, i.visible = !1;
      const L = T.getRenderTarget(), D = T.xr.enabled, U = T.shadowMap.autoUpdate;
      T.xr.enabled = !1, T.shadowMap.autoUpdate = !1, T.setRenderTarget(S), T.state.buffers.depth.setMask(!0), T.autoClear === !1 && T.clear(), T.render(C, b), T.xr.enabled = D, T.shadowMap.autoUpdate = U, T.setRenderTarget(L);
      const H = I.viewport;
      H !== void 0 && T.state.viewport(H), i.visible = !0;
    }, this.getRenderTarget = function() {
      return S;
    }, this.dispose = function() {
      S.dispose(), i.material.dispose();
    };
  }
}
rp.ReflectorShader = { name: "ReflectorShader", uniforms: { color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null } }, vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`, fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}` };
const XR = { name: "镜面", disBlendShader: !0, initParameters: { clipBias: 0.01, color: 12700619 }, initPanel: function(n) {
  n.add(this.initParameters, "clipBias").name("裁剪偏移"), n.addColor(this.initParameters, "color").name("颜色");
}, create: function(n, e) {
  const t = Te(Te({}, this.initParameters), e == null ? void 0 : e.initParameters), { DOM: i, renderer: r } = n, s = new rp(new or(100, 100), Te({ clipBias: 0.01, textureWidth: i.clientWidth * r.getPixelRatio(), textureHeight: i.clientHeight * r.getPixelRatio(), color: 12700619 }, t));
  return s.initParameters = t, s.rotateX(-Math.PI / 2), s;
}, changePanel: function(n, e) {
  const { material: t } = n;
  e.add(t, "visible").name("可见"), e.add(t, "wireframe").name("线框"), e.addHexColor(t.uniforms.color.value).name("颜色");
}, getStorage: function(n) {
  const { material: e, initParameters: t } = n;
  return { initParameters: t, material: { wireframe: e.wireframe, color: e.uniforms.color.value.getHex() } };
}, setStorage: function(n, e) {
  if (!e)
    return;
  const { material: t } = n;
  t.wireframe = e.material.wireframe, t.uniforms.color.value.setHex(e.material.color);
} }, nw = Object.values(Object.assign({ "../../Addons/DesignMesh/LightColumn.js": WR, "../../Addons/DesignMesh/Mirror.js": XR })), tc = (n) => nw.find((e) => e.name === n);
function _1(n, e, t) {
  var a;
  const { scene: i, transformControls: r } = t, s = tc(n.designType);
  Dr(n, e.addFolder("基础配置")), (a = s.changePanel) == null || a.call(s, n, e.addFolder("相关配置"), t), e.addFn(() => r.attach(n)).name("选中"), e.addFn(() => {
    i.remove(n), e.parent.removeFolder(e);
  }).name("删除");
}
function iw(n, e, t) {
  const i = n.create(e, t);
  if (i)
    return i.isDesignMesh = !0, i.designType = n.name, n.disBlendShader && (i.disBlendShader = !0), i;
}
function qR(n) {
  return n.map((e) => function(t) {
    var s;
    const { designType: i } = t, r = tc(i);
    return Te(Te({ designType: i }, La(t)), (s = r.getStorage) == null ? void 0 : s.call(r, t));
  }(e));
}
function YR(n, e) {
  e == null || e.forEach((t) => function(i, r) {
    var l;
    if (!r)
      return;
    const { scene: s } = i, a = tc(r.designType), o = iw(a, i, r);
    s.add(o), Na(o, r), (l = a.setStorage) == null || l.call(a, o, r, i);
  }(n, t));
}
function T1(n, e) {
  var i;
  const t = tc(n);
  t && ((i = t.initPanel) == null || i.call(t, e));
}
function ZR() {
  return { modelCore: { rootFolder: null, insertModel: null, progressList: [], url: "https://z2586300277.github.io/three-editor/dist/files/resource/LittlestTokyo.glb", modelAnimationPlay: A0 }, innerMeshCore: { geometryType: "立方体", materialType: "标准材质" }, drawCore: { mode: "围栏物体", pointMode: "场景交点", pointModeList: ["场景交点", "地图区域中心", "地图行政中心"], modeList: ["围栏物体", "平面绘制", "曲线路径", "直线路径"], materialType: "标准材质", drawEventCall: null, currentDrawFolder: null, sceneEventCall: function(n, e) {
    var t, i, r, s, a;
    switch (this.pointMode) {
      case "场景交点":
        return (t = this.drawEventCall) == null ? void 0 : t.call(this, n);
      case "地图区域中心":
        return (i = e.geoInfo) != null && i.properties.centroidCoord3 ? (r = this.drawEventCall) == null ? void 0 : r.call(this, e.parent.getTransformedVector(e.geoInfo.properties.centroidCoord3.clone().add(e.position).sub(e.initTranslate))) : void 0;
      case "地图行政中心":
        return (s = e.geoInfo) != null && s.properties.centerCoord3 ? (a = this.drawEventCall) == null ? void 0 : a.call(this, e.parent.getTransformedVector(e.geoInfo.properties.centerCoord3.clone().add(e.position).sub(e.initTranslate))) : void 0;
    }
  } }, chartsMapCore: { url: "https://z2586300277.github.io/3d-file-server/files/json/china.json", materialType: "标准材质", isListMaterial: !0, edgeMaterialType: "标准材质", progressList: [], createGeoGroup: P0 }, particleCore: { particlesSum: 1e5, inner: 0, outer: 2e3, maxVelocity: 50, mapUrl: "https://z2586300277.github.io/three-editor/dist/files/channels/snow.png", sportType: "全随机", shaderCodeName: "水波纹" }, textMeshCore: { fontLink: "https://z2586300277.github.io/three-editor/dist/files/font/cn1.json", text: "", materialType: "标准材质" }, designMeshCore: { type: "光柱" }, borderGroupCore: { url: "https://z2586300277.github.io/3d-file-server/files/json/chinaBound.json", materialType: "基础材质", dlength: 0 } };
}
function KR(n) {
  const e = { lightList: [], modelList: [], innerMeshList: [], drawMeshList: [], geoGroupList: [], borderGroupList: [], particleList: [], textMeshList: [], designMeshList: [] };
  return n.children.forEach((t) => {
    t.isLight ? e.lightList.push(t) : t.rootInfo ? e.modelList.push(t) : t.isInnerMesh ? e.innerMeshList.push(t) : t.isDrawMesh ? e.drawMeshList.push(t) : t.isGeoGroup ? e.geoGroupList.push(t) : t.isParticleMesh ? e.particleList.push(t) : t.isTextMesh ? e.textMeshList.push(t) : t.isBorderGroup ? e.borderGroupList.push(t) : t.isDesignMesh && e.designMeshList.push(t);
  }), { lighting: sP(e.lightList), modelList: wR(e.modelList), innerMeshList: _R(e.innerMeshList), drawMeshList: NR(e.drawMeshList), geoGroupList: BR(e.geoGroupList), particleList: VR(e.particleList), textMeshList: GR(e.textMeshList), borderGroupList: kR(e.borderGroupList), designMeshList: qR(e.designMeshList) };
}
function JR(n, e, t) {
  if (!t)
    return;
  const { scene: i, DOM: r } = n, { modelCore: s, chartsMapCore: a } = e;
  (function(o, l) {
    l && l.forEach((h) => {
      const c = _0(h.type);
      rP(c, h), c.target && o.add(c.target), o.add(c);
    });
  })(i, t.lighting), function(o, l) {
    l && (o.progressList = l.map((h) => o.insertModel(h.rootInfo, h.group)));
  }(s, t.modelList), TR(i, t.innerMeshList), DR(i, t.drawMeshList), function(o, l, h) {
    h && (o.progressList = h.map((c) => UR(l, c)));
  }(a, i, t.geoGroupList), zR(i, t.borderGroupList), HR(i, r, t.particleList), jR(i, t.textMeshList), YR(n, t.designMeshList);
}
function QR(n, e, t) {
  const { scene: i, DOM: r } = n, { modelCore: s, innerMeshCore: a, drawCore: o, chartsMapCore: l, borderGroupCore: h, particleCore: c, textMeshCore: u, designMeshCore: d } = e, p = { 灯光配置: () => function(m, g) {
    const f = { lightList: { 环境光: "AmbientLight", 平行光: "DirectionalLight", 点光源: "PointLight", 聚光灯: "SpotLight", 半球光: "HemisphereLight", 平面光: "RectAreaLight" }, lightType: "AmbientLight", findKey(v) {
      return Object.keys(this.lightList).find((y) => this.lightList[y] === v);
    } };
    return g.add(f, "lightType", f.lightList).name("光源类型"), g.addFn(function() {
      const v = _0(f.lightType);
      v.target && m.add(v.target), m.attach_add(v), Kx(v, g.addFolder(f.findKey(v.type) + "-" + v.id), m.transformControls);
    }).name("点击添加光源"), m.children.forEach((v) => {
      v instanceof Nr && Kx(v, g.addFolder(f.findKey(v.type) + "-" + v.id), m.transformControls);
    }), g;
  }(i, t.addCoreDragFolder("灯光配置")), 模型管理: () => function(m, g) {
    return m.rootFolder = g, g.add(m, "url").name("模型地址"), g.addFn(() => {
      const f = function(v) {
        if (!v)
          return;
        const y = v.split(".").pop().toUpperCase();
        return y && ["FBX", "GLB", "GLTF", "OBJ"].includes(y) ? { url: v, type: y === "GLB" ? "GLTF" : y } : void 0;
      }(m.url);
      f && m.insertModel(f);
    }).name("添加模型"), m.scene.children.forEach((f) => {
      f.rootInfo && jS(m.controls, m.transformControls, m.effectComposer, f, g.addFolder(Qn(f)));
    }), g;
  }(s, t.addCoreDragFolder("模型管理")), 内置物体: () => ER(a, i, t.addCoreDragFolder("内置物体")), 绘制物体: () => function(m, g, f) {
    return f.add(m, "mode", m.modeList).name("绘制模式"), f.add(m, "pointMode", m.pointModeList).name("点模式"), f.add(m, "materialType", Co).name("材质"), f.addFn(() => {
      m.currentDrawFolder && m.currentDrawFolder.close(), m.currentDrawFolder = f.addDateFolder(m.mode), g1(m, g, m.currentDrawFolder), m.currentDrawFolder.open();
    }).name("添加绘制组"), g.children.forEach((v) => v.isDrawMesh && g1(m, g, f.addFolder(Qn(v)), v.drawParams)), f;
  }(o, i, t.addCoreDragFolder("绘制物体")), 三维地图: () => FR(l, i, t.addCoreDragFolder("三维地图")), 地图边界: () => function(m, g, f) {
    const v = f.addFolder("列表");
    return v.open(), f.add(m, "url").name("边界物体数据源"), f.add(m, "materialType", Co).name("材质类型"), f.add(m, "dlength", 0).name("低于点数舍弃"), f.addFn(() => {
      $S(m.url, m.materialType, m.dlength).then((y) => {
        g.attach_add(y), b1(g, y, v.addFolder(Qn(y)));
      });
    }).name("添加边界物体"), g.children.forEach((y) => {
      y.isBorderGroup && b1(g, y, v.addFolder(Qn(y)));
    }), f;
  }(h, i, t.addCoreDragFolder("地图边界")), 粒子物体: () => function(m, g, f, v) {
    const y = v.addFolder("粒子列表");
    y.open();
    const x = v.addFolder("初始化参数");
    return x.open(), x.add(m, "particlesSum").name("数量"), x.add(m, "inner").name("内半径"), x.add(m, "outer").name("外半径"), x.add(m, "maxVelocity").name("最大速度"), x.add(m, "mapUrl").name("贴图路径"), x.add(m, "shaderCodeName", Object.keys(uS)).name("着色器"), x.add(m, "sportType", ["全随机", "随机向下", "随机向上", "直线匀速向上", "直线匀速向下"]).name("运动方式"), v.addFn(() => {
      const { particlesSum: M, inner: b, outer: S, maxVelocity: w, sportType: T, mapUrl: C, shaderCodeName: I } = m, A = ew(g, f, { particlesSum: M, inner: b, outer: S, maxVelocity: w, sportType: T, mapUrl: C, shaderCodeName: I });
      S1(g, A, y.addFolder(Qn(A)));
    }).name("增加一个粒子物体"), g.children.forEach((M) => M.isParticleMesh && S1(g, M, y.addFolder(Qn(M)))), v;
  }(c, i, r, t.addCoreDragFolder("粒子物体")), 文本物体: () => function(m, g, f) {
    const v = f.addFolder("列表");
    return v.open(), f.add(m, "fontLink").name("字体链接"), f.add(m, "materialType", Co).name("材质类型"), f.add(m, "text").name("文本内容"), f.addFn(() => {
      m.text && XS(m.fontLink, m.text).then((y) => {
        const x = xi(m.materialType), M = new ce(y, x);
        M.fontLink = m.fontLink, M.text = m.text, M.isTextMesh = !0, g.attach_add(M), w1(g, M, v.addFolder(M.text.slice(0, 8) + " " + M.id));
      });
    }).name("添加文本物体"), g.children.forEach((y) => y.isTextMesh && w1(g, y, v.addFolder(y.text.slice(0, 8) + " " + y.id))), f;
  }(u, i, t.addCoreDragFolder("文本物体")), 设计物体: () => function(m, g, f) {
    const { scene: v } = g, y = f.addFolder("列表");
    let x;
    f.add(m, "type", nw.map((M) => M.name)).name("类型").onChange((M) => {
      x.parent.removeFolder(x), x = f.addFolder(M + "初始参数"), T1(M, x), x.open();
    }), f.addFn(() => {
      const M = tc(m.type), b = iw(M, g);
      b && (v.attach_add(b), _1(b, y.addFolder(`${M.name}-${b.id}`), g));
    }).name("添加"), x = f.addFolder(m.type + "初始参数"), T1(m.type, x), v.children.forEach((M) => M.isDesignMesh && _1(M, y.addFolder(M.designType + "-" + Qn(M)), g));
  }(d, n, t.addCoreDragFolder("设计物体")) };
  for (const m in p)
    t.add(p, m);
  return { folder: t, panels: p };
}
function E1(n, e, t) {
  t.add(e, "name").name("名称"), t.addFn(() => function(i, r) {
    i.target.set(r.target.x, r.target.y, r.target.z), i.object.position.set(r.position.x, r.position.y, r.position.z), i.update();
  }(n, e)).name("直接查看"), t.addFn(() => {
    dd(n.target, e.target), dd(n.object.position, e.position);
  }).name("动画查看"), t.addFn(() => {
    const i = n.viewAngleList.indexOf(e);
    i !== -1 && n.viewAngleList.splice(i, 1), t.parent.removeFolder(t);
  }).name("删除");
}
function $R(n, e, t) {
  const i = function(s) {
    s.open();
    const a = { mode: "to", query: { duration: 2, ease: "none", repeat: 0, yoyo: !1 } };
    return s.add(a, "mode", ["to", "from", "fromTo"]).name("动画模式"), s.add(a.query, "duration", 0, 10).name("动画时长"), s.add(a.query, "ease", ["none", "power1", "power2", "power3", "power4", "back", "elastic", "bounce"]).name("动画缓动"), s.add(a.query, "repeat", 0).name("动画重复次数"), s.add(a.query, "yoyo").name("动画循环"), a;
  }(t.addFolder("动画属性配置"));
  let r = null;
  return t.addFn(function() {
    const { currentInfo: s } = n;
    if (!s)
      return;
    let a;
    n.mode == "选择" ? a = s.currentModel : n.mode == "根选择" ? a = s.currentRootModel : n.mode == "变换" && (a = n.isTransformChildren ? s.currentModel : s.currentRootModel), r && t.removeFolder(r), r = t.addFolder(Qn(a) + "动画配置"), e.attach(a), function(o, l, h) {
      const c = h.addFolder("动画列表");
      o.Kr = vo(o), o.transformAnimationList ? o.transformAnimationList.forEach((u, d) => A1(o, u, c.addFolder("动作[" + Date.now() + d + "]"))) : o.transformAnimationList = [], h.addFn(() => ud(o, o.Kr)).name("还原为源信息"), h.addFn(() => o.Kr = vo(o)).name("当前状态更新为源信息"), h.addFn(() => vS(o, o.Kr, vo(o), l)).name("预览动画"), h.addFn(() => {
        const u = function(d, p) {
          const { mode: m, query: g } = p;
          return { name: "", Kr: d.Kr, transformInfo_: vo(d), gsapParams: { mode: m, query: Te({}, g) } };
        }(o, l);
        o.transformAnimationList.push(u), c.open(), A1(o, u, c.addFolder("动作[" + Date.now() + "]"));
      }).name("保存动画");
    }(a, i, r);
  }).name("加载当前物体信息"), t;
}
function A1(n, e, t) {
  t.add(e, "name").name("动作名");
  const i = { play: () => {
    const { gsapParams: r, Kr: s, transformInfo_: a } = e;
    vS(n, s, a, r);
  }, del: () => {
    n.transformAnimationList.splice(n.transformAnimationList.indexOf(e), 1), t.parent.removeFolder(t);
  } };
  t.add(i, "play").name("播放动作"), t.add(i, "del").name("删除动作");
}
function e3(n, e, t, i, r, s, a) {
  const o = { 视角控制: () => function(l, h) {
    const c = h.addFolder("视角列表");
    return l.viewAngleList ? l.viewAngleList.forEach((u, d) => E1(l, u, c.addFolder((u.name || "视角") + "[" + Date.now() + d + "]"))) : l.viewAngleList = [], h.addFn(() => {
      const u = function(d) {
        return { name: "", target: { x: d.target.x, y: d.target.y, z: d.target.z }, position: { x: d.object.position.x, y: d.object.position.y, z: d.object.position.z } };
      }(l);
      l.viewAngleList.push(u), E1(l, u, c.addFolder(u.name || "视角[" + Date.now() + "]")), c.open();
    }).name("记录当前视角"), h;
  }(i, a.addCoreDragFolder("视角控制")), 物体动画: () => $R(t, r, a.addCoreDragFolder("物体动画")), 裁剪面板: () => function(l, h, c, u) {
    const d = u.addFolder("全局裁剪列表");
    return d.open(), u.add(c, "clipPlaneSize", 0).name("裁剪辅助面大小"), u.addFn(() => {
      const p = PS();
      RS(p, c.clipPlaneSize), Yx(l, h, c, p, d.addDateFolder("面")), l.add(p.helper), h.clippingPlanes.push(p);
    }).name("增加全局裁剪面"), h.clippingPlanes.forEach((p, m) => Yx(l, h, c, p, d.addFolder(`面${m}`))), u;
  }(n, e, s, a.addCoreDragFolder("裁剪面板")) };
  for (const l in o)
    a.add(o, l);
  return { folder: a, panels: o };
}
function t3(n, e) {
  const t = $t(Te({}, ZR()), { handler: { mode: "选择", openKey: !1, selectPanelEnable: !1, keyDown: null, keyDownCallback: null, modeList: ["选择", "根选择", "变换", "场景绘制", "点击信息"], isTransformChildren: !1, handlerHistory: null, helpers: { axes: { showAxes: !0, axesLength: 1e3, axesHelper: null }, grid: { showGrid: !0, size: 1e3, divisions: 15, colorCenterLine: 4473924, colorGrid: 8947848, gridHelper: null }, box3: { useBox3: !0, color: 16776960 } } }, animateCore: { clipPlaneSize: 20 } }), i = function(c, u) {
    const { scene: d, transformControls: p, effectComposer: m, stats: g, DOM: f } = c, { outlinePass: v } = m.effectPass, { handler: y } = u, { shaderLibrary: x, setObjectBlendShader: M } = oC(d, f);
    return JC(d, g, y, p, v), function(b, S) {
      const { scene: w, controls: T, transformControls: C, effectComposer: I } = b, { modelCore: A } = S;
      SR(A, w, T, C, I);
    }(c, u), { shaderLibrary: x, setObjectBlendShader: M };
  }(n, t), r = {};
  C1(n, t, e);
  const { scene: s, transformControls: a, effectComposer: o, css3DRender: l, css2DRender: h } = n;
  return Te($t(Te($t(Te({}, t), { addons: r }), i), { saveSceneEdit: () => (a.detach(), o.effectPass.outlinePass.selectedObjects = [], function(c, u) {
    const { scene: d, camera: p, renderer: m, controls: g, transformControls: f, effectComposer: v } = c, { handler: y } = u;
    return $t(Te(Te({}, jC(d, p, m, g, f, v)), KR(d)), { handler: QC(y) });
  }(n, t)), resetEditorStorage: (c) => {
    s.resetFrames(), s.children.filter((u) => !u.isTransformControls && !u.isPerspectiveCamera).forEach((u) => (s.remove(u), xS(u))), s.resetEnv(), l.reset(), h.reset(), C1(n, t, c);
  } }), n3(n, t));
}
function C1(n, e, t) {
  if (!t)
    return;
  const { scene: i, camera: r, renderer: s, controls: a, transformControls: o, effectComposer: l, stats: h } = n, { handler: c } = e;
  WC(i, r, s, a, o, l, t), $C(i, o, h, c, t.handler), JR(n, e, t);
}
function n3(n, e) {
  const { scene: t, camera: i, renderer: r, controls: s, transformControls: a, effectComposer: o, stats: l } = n, { handler: h, animateCore: c } = e, u = TC();
  return _C(t, u), { GUI: u, openControlPanel: function() {
    u.rr.场景 || function(...d) {
      const p = xC({ style: "max-width: 500px;", tabButtonActiveColor: "rgba(255, 255, 255, 0.1)", tabButtonHoverColor: "none", tabButtonRowColor: "black", tabButtonBorderStyle: "none", tabButtonRowStyleOverrides: { display: "flex", "justify-content": "space-evenly", color: "white", "background-color": "none" }, tabButtonStyleOverrides: { padding: "0.4em 0.8em", color: "#ffffff", "font-size": "13px" } }, d.reduce((M, b) => (b.folder.open(), $t(Te({}, M), { [b.folder.name]: qx(b.folder.domElement) })), {})), m = Xe.state(220), g = Xe.state("auto"), f = Xe.state(window.innerWidth - 220), v = Xe.state(20), y = Xe.state(!1);
      try {
        const M = localStorage.getItem("threeEditor_Panel");
        if (M) {
          const b = JSON.parse(M);
          d.forEach((S, w) => S.folder.closed = b.panels[w].closed), f.val = b.x, v.val = b.y;
        }
      } catch (M) {
      }
      Xe.derive(() => {
        if (v.val > window.innerHeight - 100 && setTimeout(() => v.val = window.innerHeight - 200, 100), v.val < 0 && setTimeout(() => v.val = 0, 100), f.val > window.innerWidth - 100 && setTimeout(() => f.val = window.innerWidth - 200, 100), f.val < 0 && setTimeout(() => f.val = 0, 100), y.val) {
          const M = d.map((b) => {
            const { parent: S } = b.folder, w = b.folder.name;
            return delete S.rr[w], S.load && S.load.folders && S.load.folders[w] && delete S.load.folders[w], { closed: b.folder.closed };
          });
          localStorage.setItem("threeEditor_Panel", JSON.stringify({ panels: M, x: f.val, y: v.val }));
        }
      });
      const x = md(Te({ title: "3D-配置", x: f, y: v, closed: y, width: m, height: g, zIndex: 99999, customStacking: !0 }, Uh), qx({ style: `
            
                border: 1px solid rgba(255, 255, 255, 0.2);
                
                border-radius: 3px;

                padding: 5px 0px 5px 0px;
            
            ` }, p));
      Xe.add(document.body, x);
    }(XC(t, i, r, s, a, o, u.addFolder("场景")), eP(t, a, l, h, u.addFolder("操作")), QR(n, e, u.addFolder("元素")), e3(t, r, h, s, a, c, u.addFolder("动画")));
  } };
}
function i3() {
  const n = new _m();
  n.ssrList = [], function(t) {
    const i = new qd();
    i.layers.enableAll(), t.raycaster = i;
  }(n), function(t) {
    t.commonFrames = [], t.mixerFrames = [], t.shaderFrames = [], t.renderFrames = function() {
      t.mixerFrames.forEach((i) => i.mixerAnimateRender()), t.shaderFrames.forEach((i) => i.shaderAnimateRender()), t.commonFrames.forEach((i) => {
        var r;
        return (r = i.commonAnimateRender) == null ? void 0 : r.call(i);
      });
    }, t.resetFrames = function() {
      ["mixerFrames", "shaderFrames", "commonFrames"].forEach((i) => t[i].length = 0);
    }, t.removeFrames = function(i) {
      (i instanceof ce || i instanceof yn || i.instanceOf === os) && ["commonFrames", "mixerFrames", "shaderFrames"].forEach((r) => {
        const s = t[r].indexOf(i);
        s !== -1 && t[r].splice(s, 1);
      });
    };
  }(n), function(t) {
    t.environmentEnabled = !1, t.envBackground = null, t.envMapChangeUseList = [];
    let i = null;
    Object.defineProperty(t, "envBackground", { get: () => i, set: (r) => {
      i = r, t.environmentEnabled ? t.environment = t.envBackground : t.environment = null, t == null || t.envMapChangeUseList.forEach((s) => s());
    } }), t.setSceneBackground = function(r) {
      var a;
      const s = new Nm().load(r);
      t.background = s, t.backgroundUrls = r, (a = t.backgroundLoadCallback) == null || a.call(t, s);
    }, t.setEnvBackground = function(r) {
      const s = new Nm().load(r);
      t.envBackground = s, t.envBackgroundUrls = r;
    }, t.resetEnv = function() {
      var r, s;
      t.envMapChangeUseList = [], (r = t.envBackground) == null || r.dispose(), t.envBackground = null, (s = t.background) == null || s.dispose(), t.background = null;
    };
  }(n), n.setClassifyScene = function(t = "全部") {
    n.children.forEach((i) => {
      (["Group", "Mesh"].includes(i.type) || i.isLight) && (t === "全部" || t.some((r) => i.name.indexOf(r) !== -1) ? i.visible = !0 : i.visible = !1);
    });
  }, n.attach_add = function(t) {
    n.add(t), n.transformControls.attach(t);
  };
  const e = n.remove;
  return n.remove = function(t) {
    var i;
    n.removeFrames(t), n.transformControls.object === t && n.transformControls.detach(), e.call(n, t), (i = n.removeCall) == null || i.call(n, t);
  }, n;
}
var rh = function() {
  var n = 0, e = document.createElement("div");
  function t(c) {
    return e.appendChild(c.dom), c;
  }
  function i(c) {
    for (var u = 0; u < e.children.length; u++)
      e.children[u].style.display = u === c ? "block" : "none";
    n = c;
  }
  e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", function(c) {
    c.preventDefault(), i(++n % e.children.length);
  }, !1);
  var r = (performance || Date).now(), s = r, a = 0, o = t(new rh.Panel("FPS", "#0ff", "#002")), l = t(new rh.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory)
    var h = t(new rh.Panel("MB", "#f08", "#201"));
  return i(0), { REVISION: 16, dom: e, addPanel: t, showPanel: i, begin: function() {
    r = (performance || Date).now();
  }, end: function() {
    a++;
    var c = (performance || Date).now();
    if (l.update(c - r, 200), c >= s + 1e3 && (o.update(1e3 * a / (c - s), 100), s = c, a = 0, h)) {
      var u = performance.memory;
      h.update(u.usedJSHeapSize / 1048576, u.jsHeapSizeLimit / 1048576);
    }
    return c;
  }, update: function() {
    r = this.end();
  }, domElement: e, setMode: i };
};
rh.Panel = function(n, e, t) {
  var i = 1 / 0, r = 0, s = Math.round, a = s(window.devicePixelRatio || 1), o = 80 * a, l = 48 * a, h = 3 * a, c = 2 * a, u = 3 * a, d = 15 * a, p = 74 * a, m = 30 * a, g = document.createElement("canvas");
  g.width = o, g.height = l, g.style.cssText = "width:80px;height:48px";
  var f = g.getContext("2d");
  return f.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", f.textBaseline = "top", f.fillStyle = t, f.fillRect(0, 0, o, l), f.fillStyle = e, f.fillText(n, h, c), f.fillRect(u, d, p, m), f.fillStyle = t, f.globalAlpha = 0.9, f.fillRect(u, d, p, m), { dom: g, update: function(v, y) {
    i = Math.min(i, v), r = Math.max(r, v), f.fillStyle = t, f.globalAlpha = 1, f.fillRect(0, 0, o, d), f.fillStyle = e, f.fillText(s(v) + " " + n + " (" + s(i) + "-" + s(r) + ")", h, c), f.drawImage(g, u + a, d, p - a, m, u, d, p - a, m), f.fillRect(u + p - a, d, a, m), f.fillStyle = t, f.globalAlpha = 0.9, f.fillRect(u + p - a, d, a, s((1 - v / y) * m));
  } };
};
const P1 = { type: "change" }, Gf = { type: "start" }, R1 = { type: "end" }, xu = new Ra(), I1 = new Li(), r3 = Math.cos(70 * nn.DEG2RAD);
class s3 extends rr {
  constructor(e, t) {
    super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new _(), this.cursor = new _(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: Ys.ROTATE, MIDDLE: Ys.DOLLY, RIGHT: Ys.PAN }, this.touches = { ONE: Zs.ROTATE, TWO: Zs.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.$r = null, this.getPolarAngle = function() {
      return o.phi;
    }, this.getAzimuthalAngle = function() {
      return o.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function(z) {
      z.addEventListener("keydown", re), this.$r = z;
    }, this.stopListenToKeyEvents = function() {
      this.$r.removeEventListener("keydown", re), this.$r = null;
    }, this.saveState = function() {
      i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object.zoom;
    }, this.reset = function() {
      i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.zoom = i.zoom0, i.object.updateProjectionMatrix(), i.dispatchEvent(P1), i.update(), s = r.NONE;
    }, this.update = function() {
      const z = new _(), W = new Ye().setFromUnitVectors(e.up, new _(0, 1, 0)), ee = W.clone().invert(), ge = new _(), Le = new Ye(), Fe = new _(), _e = 2 * Math.PI;
      return function(Be = null) {
        const He = i.object.position;
        z.copy(He).sub(i.target), z.applyQuaternion(W), o.setFromVector3(z), i.autoRotate && s === r.NONE && A(function(ze) {
          return ze !== null ? 2 * Math.PI / 60 * i.autoRotateSpeed * ze : 2 * Math.PI / 60 / 60 * i.autoRotateSpeed;
        }(Be)), i.enableDamping ? (o.theta += l.theta * i.dampingFactor, o.phi += l.phi * i.dampingFactor) : (o.theta += l.theta, o.phi += l.phi);
        let nt = i.minAzimuthAngle, Ce = i.maxAzimuthAngle;
        isFinite(nt) && isFinite(Ce) && (nt < -Math.PI ? nt += _e : nt > Math.PI && (nt -= _e), Ce < -Math.PI ? Ce += _e : Ce > Math.PI && (Ce -= _e), o.theta = nt <= Ce ? Math.max(nt, Math.min(Ce, o.theta)) : o.theta > (nt + Ce) / 2 ? Math.max(nt, o.theta) : Math.min(Ce, o.theta)), o.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, o.phi)), o.makeSafe(), i.enableDamping === !0 ? i.target.addScaledVector(c, i.dampingFactor) : i.target.add(c), i.target.sub(i.cursor), i.target.clampLength(i.minTargetRadius, i.maxTargetRadius), i.target.add(i.cursor);
        let rt = !1;
        if (i.zoomToCursor && S || i.object.isOrthographicCamera)
          o.radius = ve(o.radius);
        else {
          const ze = o.radius;
          o.radius = ve(o.radius * h), rt = ze != o.radius;
        }
        if (z.setFromSpherical(o), z.applyQuaternion(ee), He.copy(i.target).add(z), i.object.lookAt(i.target), i.enableDamping === !0 ? (l.theta *= 1 - i.dampingFactor, l.phi *= 1 - i.dampingFactor, c.multiplyScalar(1 - i.dampingFactor)) : (l.set(0, 0, 0), c.set(0, 0, 0)), i.zoomToCursor && S) {
          let ze = null;
          if (i.object.isPerspectiveCamera) {
            const Nt = z.length();
            ze = ve(Nt * h);
            const Un = Nt - ze;
            i.object.position.addScaledVector(M, Un), i.object.updateMatrixWorld(), rt = !!Un;
          } else if (i.object.isOrthographicCamera) {
            const Nt = new _(b.x, b.y, 0);
            Nt.unproject(i.object);
            const Un = i.object.zoom;
            i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / h)), i.object.updateProjectionMatrix(), rt = Un !== i.object.zoom;
            const lr = new _(b.x, b.y, 0);
            lr.unproject(i.object), i.object.position.sub(lr).add(Nt), i.object.updateMatrixWorld(), ze = z.length();
          } else
            i.zoomToCursor = !1;
          ze !== null && (this.screenSpacePanning ? i.target.set(0, 0, -1).transformDirection(i.object.matrix).multiplyScalar(ze).add(i.object.position) : (xu.origin.copy(i.object.position), xu.direction.set(0, 0, -1).transformDirection(i.object.matrix), Math.abs(i.object.up.dot(xu.direction)) < r3 ? e.lookAt(i.target) : (I1.setFromNormalAndCoplanarPoint(i.object.up, i.target), xu.intersectPlane(I1, i.target))));
        } else if (i.object.isOrthographicCamera) {
          const ze = i.object.zoom;
          i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / h)), ze !== i.object.zoom && (i.object.updateProjectionMatrix(), rt = !0);
        }
        return h = 1, S = !1, !!(rt || ge.distanceToSquared(i.object.position) > a || 8 * (1 - Le.dot(i.object.quaternion)) > a || Fe.distanceToSquared(i.target) > a) && (i.dispatchEvent(P1), ge.copy(i.object.position), Le.copy(i.object.quaternion), Fe.copy(i.target), !0);
      };
    }(), this.dispose = function() {
      i.domElement.removeEventListener("contextmenu", se), i.domElement.removeEventListener("pointerdown", K), i.domElement.removeEventListener("pointercancel", k), i.domElement.removeEventListener("wheel", E), i.domElement.removeEventListener("pointermove", O), i.domElement.removeEventListener("pointerup", k), i.domElement.getRootNode().removeEventListener("keydown", B, { capture: !0 }), i.$r !== null && (i.$r.removeEventListener("keydown", re), i.$r = null);
    };
    const i = this, r = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
    let s = r.NONE;
    const a = 1e-6, o = new Fm(), l = new Fm();
    let h = 1;
    const c = new _(), u = new X(), d = new X(), p = new X(), m = new X(), g = new X(), f = new X(), v = new X(), y = new X(), x = new X(), M = new _(), b = new X();
    let S = !1;
    const w = [], T = {};
    let C = !1;
    function I(z) {
      const W = Math.abs(0.01 * z);
      return Math.pow(0.95, i.zoomSpeed * W);
    }
    function A(z) {
      l.theta -= z;
    }
    function L(z) {
      l.phi -= z;
    }
    const D = function() {
      const z = new _();
      return function(W, ee) {
        z.setFromMatrixColumn(ee, 0), z.multiplyScalar(-W), c.add(z);
      };
    }(), U = function() {
      const z = new _();
      return function(W, ee) {
        i.screenSpacePanning === !0 ? z.setFromMatrixColumn(ee, 1) : (z.setFromMatrixColumn(ee, 0), z.crossVectors(i.object.up, z)), z.multiplyScalar(W), c.add(z);
      };
    }(), H = function() {
      const z = new _();
      return function(W, ee) {
        const ge = i.domElement;
        if (i.object.isPerspectiveCamera) {
          const Le = i.object.position;
          z.copy(Le).sub(i.target);
          let Fe = z.length();
          Fe *= Math.tan(i.object.fov / 2 * Math.PI / 180), D(2 * W * Fe / ge.clientHeight, i.object.matrix), U(2 * ee * Fe / ge.clientHeight, i.object.matrix);
        } else
          i.object.isOrthographicCamera ? (D(W * (i.object.right - i.object.left) / i.object.zoom / ge.clientWidth, i.object.matrix), U(ee * (i.object.top - i.object.bottom) / i.object.zoom / ge.clientHeight, i.object.matrix)) : i.enablePan = !1;
      };
    }();
    function Z(z) {
      i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? h /= z : i.enableZoom = !1;
    }
    function te(z) {
      i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? h *= z : i.enableZoom = !1;
    }
    function ne(z, W) {
      if (!i.zoomToCursor)
        return;
      S = !0;
      const ee = i.domElement.getBoundingClientRect(), ge = z - ee.left, Le = W - ee.top, Fe = ee.width, _e = ee.height;
      b.x = ge / Fe * 2 - 1, b.y = -Le / _e * 2 + 1, M.set(b.x, b.y, 1).unproject(i.object).sub(i.object.position).normalize();
    }
    function ve(z) {
      return Math.max(i.minDistance, Math.min(i.maxDistance, z));
    }
    function Se(z) {
      u.set(z.clientX, z.clientY);
    }
    function Q(z) {
      m.set(z.clientX, z.clientY);
    }
    function ae(z) {
      if (w.length === 1)
        u.set(z.pageX, z.pageY);
      else {
        const W = ue(z), ee = 0.5 * (z.pageX + W.x), ge = 0.5 * (z.pageY + W.y);
        u.set(ee, ge);
      }
    }
    function de(z) {
      if (w.length === 1)
        m.set(z.pageX, z.pageY);
      else {
        const W = ue(z), ee = 0.5 * (z.pageX + W.x), ge = 0.5 * (z.pageY + W.y);
        m.set(ee, ge);
      }
    }
    function ie(z) {
      const W = ue(z), ee = z.pageX - W.x, ge = z.pageY - W.y, Le = Math.sqrt(ee * ee + ge * ge);
      v.set(0, Le);
    }
    function N(z) {
      if (w.length == 1)
        d.set(z.pageX, z.pageY);
      else {
        const ee = ue(z), ge = 0.5 * (z.pageX + ee.x), Le = 0.5 * (z.pageY + ee.y);
        d.set(ge, Le);
      }
      p.subVectors(d, u).multiplyScalar(i.rotateSpeed);
      const W = i.domElement;
      A(2 * Math.PI * p.x / W.clientHeight), L(2 * Math.PI * p.y / W.clientHeight), u.copy(d);
    }
    function R(z) {
      if (w.length === 1)
        g.set(z.pageX, z.pageY);
      else {
        const W = ue(z), ee = 0.5 * (z.pageX + W.x), ge = 0.5 * (z.pageY + W.y);
        g.set(ee, ge);
      }
      f.subVectors(g, m).multiplyScalar(i.panSpeed), H(f.x, f.y), m.copy(g);
    }
    function j(z) {
      const W = ue(z), ee = z.pageX - W.x, ge = z.pageY - W.y, Le = Math.sqrt(ee * ee + ge * ge);
      y.set(0, Le), x.set(0, Math.pow(y.y / v.y, i.zoomSpeed)), Z(x.y), v.copy(y), ne(0.5 * (z.pageX + W.x), 0.5 * (z.pageY + W.y));
    }
    function K(z) {
      i.enabled !== !1 && (w.length === 0 && (i.domElement.setPointerCapture(z.pointerId), i.domElement.addEventListener("pointermove", O), i.domElement.addEventListener("pointerup", k)), function(W) {
        for (let ee = 0; ee < w.length; ee++)
          if (w[ee] == W.pointerId)
            return !0;
        return !1;
      }(z) || (function(W) {
        w.push(W.pointerId);
      }(z), z.pointerType === "touch" ? V(z) : function(W) {
        let ee;
        switch (W.button) {
          case 0:
            ee = i.mouseButtons.LEFT;
            break;
          case 1:
            ee = i.mouseButtons.MIDDLE;
            break;
          case 2:
            ee = i.mouseButtons.RIGHT;
            break;
          default:
            ee = -1;
        }
        switch (ee) {
          case Ys.DOLLY:
            if (i.enableZoom === !1)
              return;
            (function(ge) {
              ne(ge.clientX, ge.clientX), v.set(ge.clientX, ge.clientY);
            })(W), s = r.DOLLY;
            break;
          case Ys.ROTATE:
            if (W.ctrlKey || W.metaKey || W.shiftKey) {
              if (i.enablePan === !1)
                return;
              Q(W), s = r.PAN;
            } else {
              if (i.enableRotate === !1)
                return;
              Se(W), s = r.ROTATE;
            }
            break;
          case Ys.PAN:
            if (W.ctrlKey || W.metaKey || W.shiftKey) {
              if (i.enableRotate === !1)
                return;
              Se(W), s = r.ROTATE;
            } else {
              if (i.enablePan === !1)
                return;
              Q(W), s = r.PAN;
            }
            break;
          default:
            s = r.NONE;
        }
        s !== r.NONE && i.dispatchEvent(Gf);
      }(z)));
    }
    function O(z) {
      i.enabled !== !1 && (z.pointerType === "touch" ? function(W) {
        switch (Me(W), s) {
          case r.TOUCH_ROTATE:
            if (i.enableRotate === !1)
              return;
            N(W), i.update();
            break;
          case r.TOUCH_PAN:
            if (i.enablePan === !1)
              return;
            R(W), i.update();
            break;
          case r.TOUCH_DOLLY_PAN:
            if (i.enableZoom === !1 && i.enablePan === !1)
              return;
            (function(ee) {
              i.enableZoom && j(ee), i.enablePan && R(ee);
            })(W), i.update();
            break;
          case r.TOUCH_DOLLY_ROTATE:
            if (i.enableZoom === !1 && i.enableRotate === !1)
              return;
            (function(ee) {
              i.enableZoom && j(ee), i.enableRotate && N(ee);
            })(W), i.update();
            break;
          default:
            s = r.NONE;
        }
      }(z) : function(W) {
        switch (s) {
          case r.ROTATE:
            if (i.enableRotate === !1)
              return;
            (function(ee) {
              d.set(ee.clientX, ee.clientY), p.subVectors(d, u).multiplyScalar(i.rotateSpeed);
              const ge = i.domElement;
              A(2 * Math.PI * p.x / ge.clientHeight), L(2 * Math.PI * p.y / ge.clientHeight), u.copy(d), i.update();
            })(W);
            break;
          case r.DOLLY:
            if (i.enableZoom === !1)
              return;
            (function(ee) {
              y.set(ee.clientX, ee.clientY), x.subVectors(y, v), x.y > 0 ? Z(I(x.y)) : x.y < 0 && te(I(x.y)), v.copy(y), i.update();
            })(W);
            break;
          case r.PAN:
            if (i.enablePan === !1)
              return;
            (function(ee) {
              g.set(ee.clientX, ee.clientY), f.subVectors(g, m).multiplyScalar(i.panSpeed), H(f.x, f.y), m.copy(g), i.update();
            })(W);
        }
      }(z));
    }
    function k(z) {
      switch (function(W) {
        delete T[W.pointerId];
        for (let ee = 0; ee < w.length; ee++)
          if (w[ee] == W.pointerId)
            return void w.splice(ee, 1);
      }(z), w.length) {
        case 0:
          i.domElement.releasePointerCapture(z.pointerId), i.domElement.removeEventListener("pointermove", O), i.domElement.removeEventListener("pointerup", k), i.dispatchEvent(R1), s = r.NONE;
          break;
        case 1:
          const W = w[0], ee = T[W];
          V({ pointerId: W, pageX: ee.x, pageY: ee.y });
      }
    }
    function E(z) {
      i.enabled !== !1 && i.enableZoom !== !1 && s === r.NONE && (z.preventDefault(), i.dispatchEvent(Gf), function(W) {
        ne(W.clientX, W.clientY), W.deltaY < 0 ? te(I(W.deltaY)) : W.deltaY > 0 && Z(I(W.deltaY)), i.update();
      }(function(W) {
        const ee = W.deltaMode, ge = { clientX: W.clientX, clientY: W.clientY, deltaY: W.deltaY };
        switch (ee) {
          case 1:
            ge.deltaY *= 16;
            break;
          case 2:
            ge.deltaY *= 100;
        }
        return W.ctrlKey && !C && (ge.deltaY *= 10), ge;
      }(z)), i.dispatchEvent(R1));
    }
    function B(z) {
      z.key === "Control" && (C = !0, i.domElement.getRootNode().addEventListener("keyup", F, { passive: !0, capture: !0 }));
    }
    function F(z) {
      z.key === "Control" && (C = !1, i.domElement.getRootNode().removeEventListener("keyup", F, { passive: !0, capture: !0 }));
    }
    function re(z) {
      i.enabled !== !1 && i.enablePan !== !1 && function(W) {
        let ee = !1;
        switch (W.code) {
          case i.keys.UP:
            W.ctrlKey || W.metaKey || W.shiftKey ? L(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : H(0, i.keyPanSpeed), ee = !0;
            break;
          case i.keys.BOTTOM:
            W.ctrlKey || W.metaKey || W.shiftKey ? L(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : H(0, -i.keyPanSpeed), ee = !0;
            break;
          case i.keys.LEFT:
            W.ctrlKey || W.metaKey || W.shiftKey ? A(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : H(i.keyPanSpeed, 0), ee = !0;
            break;
          case i.keys.RIGHT:
            W.ctrlKey || W.metaKey || W.shiftKey ? A(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : H(-i.keyPanSpeed, 0), ee = !0;
        }
        ee && (W.preventDefault(), i.update());
      }(z);
    }
    function V(z) {
      switch (Me(z), w.length) {
        case 1:
          switch (i.touches.ONE) {
            case Zs.ROTATE:
              if (i.enableRotate === !1)
                return;
              ae(z), s = r.TOUCH_ROTATE;
              break;
            case Zs.PAN:
              if (i.enablePan === !1)
                return;
              de(z), s = r.TOUCH_PAN;
              break;
            default:
              s = r.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case Zs.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1)
                return;
              (function(W) {
                i.enableZoom && ie(W), i.enablePan && de(W);
              })(z), s = r.TOUCH_DOLLY_PAN;
              break;
            case Zs.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1)
                return;
              (function(W) {
                i.enableZoom && ie(W), i.enableRotate && ae(W);
              })(z), s = r.TOUCH_DOLLY_ROTATE;
              break;
            default:
              s = r.NONE;
          }
          break;
        default:
          s = r.NONE;
      }
      s !== r.NONE && i.dispatchEvent(Gf);
    }
    function se(z) {
      i.enabled !== !1 && z.preventDefault();
    }
    function Me(z) {
      let W = T[z.pointerId];
      W === void 0 && (W = new X(), T[z.pointerId] = W), W.set(z.pageX, z.pageY);
    }
    function ue(z) {
      const W = z.pointerId === w[0] ? w[1] : w[0];
      return T[W];
    }
    i.domElement.addEventListener("contextmenu", se), i.domElement.addEventListener("pointerdown", K), i.domElement.addEventListener("pointercancel", k), i.domElement.addEventListener("wheel", E, { passive: !1 }), i.domElement.getRootNode().addEventListener("keydown", B, { passive: !0, capture: !0 }), this.update();
  }
}
const qs = new qd(), Sn = new _(), Xr = new _(), xt = new Ye(), L1 = { X: new _(1, 0, 0), Y: new _(0, 1, 0), Z: new _(0, 0, 1) }, jf = { type: "change" }, N1 = { type: "mouseDown", mode: null }, D1 = { type: "mouseUp", mode: null }, O1 = { type: "objectChange" };
class a3 extends Ue {
  constructor(e, t) {
    super(), t === void 0 && (t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
    const i = new d3();
    this.Qr = i, this.add(i);
    const r = new p3();
    this.eo = r, this.add(r);
    const s = this;
    function a(v, y) {
      let x = y;
      Object.defineProperty(s, v, { get: function() {
        return x !== void 0 ? x : y;
      }, set: function(M) {
        x !== M && (x = M, r[v] = M, i[v] = M, s.dispatchEvent({ type: v + "-changed", value: M }), s.dispatchEvent(jf));
      } }), s[v] = y, r[v] = y, i[v] = y;
    }
    a("camera", e), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "world"), a("size", 1), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0);
    const o = new _(), l = new _(), h = new Ye(), c = new Ye(), u = new _(), d = new Ye(), p = new _(), m = new _(), g = new _(), f = new _();
    a("worldPosition", o), a("worldPositionStart", l), a("worldQuaternion", h), a("worldQuaternionStart", c), a("cameraPosition", u), a("cameraQuaternion", d), a("pointStart", p), a("pointEnd", m), a("rotationAxis", g), a("rotationAngle", 0), a("eye", f), this.no = new _(), this.io = new _(), this.so = new _(), this.ro = new _(), this.oo = new _(), this.ao = new Ye(), this.ho = new Ye(), this.co = new _(), this.lo = new _(), this.uo = new Ye(), this.fo = new _(), this.do = new _(), this.po = new Ye(), this.mo = new _(), this.vo = o3.bind(this), this.wo = h3.bind(this), this.Mo = l3.bind(this), this._o = c3.bind(this), this.xo = u3.bind(this), this.domElement.addEventListener("pointerdown", this.wo), this.domElement.addEventListener("pointermove", this.Mo), this.domElement.addEventListener("pointerup", this.xo);
  }
  updateMatrixWorld(e) {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null || this.object.parent.matrixWorld.decompose(this.oo, this.ao, this.co), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.fo), this.ho.copy(this.ao).invert(), this.uo.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.ro), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    e !== null && qs.setFromCamera(e, this.camera);
    const t = Wf(this.Qr.picker[this.mode], qs);
    this.axis = t ? t.object.name : null;
  }
  pointerDown(e) {
    if (this.object !== void 0 && this.dragging !== !0 && (e == null || e.button === 0) && this.axis !== null) {
      e !== null && qs.setFromCamera(e, this.camera);
      const t = Wf(this.eo, qs, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this.do.copy(this.object.position), this.po.copy(this.object.quaternion), this.mo.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.lo), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, N1.mode = this.mode, this.dispatchEvent(N1);
    }
  }
  pointerMove(e) {
    const t = this.axis, i = this.mode, r = this.object;
    let s = this.space;
    if (i === "scale" ? s = "local" : t !== "E" && t !== "XYZE" && t !== "XYZ" || (s = "world"), r === void 0 || t === null || this.dragging === !1 || e !== null && e.button !== -1)
      return;
    e !== null && qs.setFromCamera(e, this.camera);
    const a = Wf(this.eo, qs, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), i === "translate")
        this.no.copy(this.pointEnd).sub(this.pointStart), s === "local" && t !== "XYZ" && this.no.applyQuaternion(this.uo), t.indexOf("X") === -1 && (this.no.x = 0), t.indexOf("Y") === -1 && (this.no.y = 0), t.indexOf("Z") === -1 && (this.no.z = 0), s === "local" && t !== "XYZ" ? this.no.applyQuaternion(this.po).divide(this.co) : this.no.applyQuaternion(this.ho).divide(this.co), r.position.copy(this.no).add(this.do), this.translationSnap && (s === "local" && (r.position.applyQuaternion(xt.copy(this.po).invert()), t.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this.po)), s === "world" && (r.parent && r.position.add(Sn.setFromMatrixPosition(r.parent.matrixWorld)), t.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(Sn.setFromMatrixPosition(r.parent.matrixWorld))));
      else if (i === "scale") {
        if (t.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), Xr.set(o, o, o);
        } else
          Sn.copy(this.pointStart), Xr.copy(this.pointEnd), Sn.applyQuaternion(this.uo), Xr.applyQuaternion(this.uo), Xr.divide(Sn), t.search("X") === -1 && (Xr.x = 1), t.search("Y") === -1 && (Xr.y = 1), t.search("Z") === -1 && (Xr.z = 1);
        r.scale.copy(this.mo).multiply(Xr), this.scaleSnap && (t.search("X") !== -1 && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (i === "rotate") {
        this.no.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(Sn.setFromMatrixPosition(this.camera.matrixWorld));
        let l = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this.no).cross(this.eye).normalize(), this.rotationAngle = this.no.dot(Sn.copy(this.rotationAxis).cross(this.eye)) * o) : t !== "X" && t !== "Y" && t !== "Z" || (this.rotationAxis.copy(L1[t]), Sn.copy(L1[t]), s === "local" && Sn.applyQuaternion(this.worldQuaternion), Sn.cross(this.eye), Sn.length() === 0 ? l = !0 : this.rotationAngle = this.no.dot(Sn.normalize()) * o), (t === "E" || l) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.io.copy(this.pointStart).normalize(), this.so.copy(this.pointEnd).normalize(), this.rotationAngle *= this.so.cross(this.io).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), s === "local" && t !== "E" && t !== "XYZE" ? (r.quaternion.copy(this.po), r.quaternion.multiply(xt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.ho), r.quaternion.copy(xt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this.po).normalize());
      }
      this.dispatchEvent(jf), this.dispatchEvent(O1);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (D1.mode = this.mode, this.dispatchEvent(D1)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this.wo), this.domElement.removeEventListener("pointermove", this.Mo), this.domElement.removeEventListener("pointermove", this._o), this.domElement.removeEventListener("pointerup", this.xo), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this.do), this.object.quaternion.copy(this.po), this.object.scale.copy(this.mo), this.dispatchEvent(jf), this.dispatchEvent(O1), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return qs;
  }
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function o3(n) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return { x: 0, y: 0, button: n.button };
  {
    const e = this.domElement.getBoundingClientRect();
    return { x: (n.clientX - e.left) / e.width * 2 - 1, y: -(n.clientY - e.top) / e.height * 2 + 1, button: n.button };
  }
}
function l3(n) {
  if (this.enabled)
    switch (n.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this.vo(n));
    }
}
function h3(n) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(n.pointerId), this.domElement.addEventListener("pointermove", this._o), this.pointerHover(this.vo(n)), this.pointerDown(this.vo(n)));
}
function c3(n) {
  this.enabled && this.pointerMove(this.vo(n));
}
function u3(n) {
  this.enabled && (this.domElement.releasePointerCapture(n.pointerId), this.domElement.removeEventListener("pointermove", this._o), this.pointerUp(this.vo(n)));
}
function Wf(n, e, t) {
  const i = e.intersectObject(n, !0);
  for (let r = 0; r < i.length; r++)
    if (i[r].object.visible || t)
      return i[r];
  return !1;
}
const Mu = new gt(), ut = new _(0, 1, 0), U1 = new _(0, 0, 0), F1 = new fe(), bu = new Ye(), Vu = new Ye(), Xi = new _(), B1 = new fe(), Gl = new _(1, 0, 0), $s = new _(0, 1, 0), jl = new _(0, 0, 1), Su = new _(), Nl = new _(), Dl = new _();
class d3 extends Ue {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new Wt({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }), t = new kt({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }), i = e.clone();
    i.opacity = 0.15;
    const r = t.clone();
    r.opacity = 0.5;
    const s = e.clone();
    s.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const o = e.clone();
    o.color.setHex(255);
    const l = e.clone();
    l.color.setHex(16711680), l.opacity = 0.5;
    const h = e.clone();
    h.color.setHex(65280), h.opacity = 0.5;
    const c = e.clone();
    c.color.setHex(255), c.opacity = 0.5;
    const u = e.clone();
    u.opacity = 0.25;
    const d = e.clone();
    d.color.setHex(16776960), d.opacity = 0.25, e.clone().color.setHex(16776960);
    const p = e.clone();
    p.color.setHex(7895160);
    const m = new Pt(0, 0.04, 0.1, 12);
    m.translate(0, 0.05, 0);
    const g = new _t(0.08, 0.08, 0.08);
    g.translate(0, 0.04, 0);
    const f = new Pe();
    f.setAttribute("position", new ye([0, 0, 0, 1, 0, 0], 3));
    const v = new Pt(75e-4, 75e-4, 0.5, 3);
    function y(D, U) {
      const H = new Ki(D, 75e-4, 3, 64, U * Math.PI * 2);
      return H.rotateY(Math.PI / 2), H.rotateX(Math.PI / 2), H;
    }
    v.translate(0, 0.25, 0);
    const x = { X: [[new ce(m, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new ce(m, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]], [new ce(v, s), [0, 0, 0], [0, 0, -Math.PI / 2]]], Y: [[new ce(m, a), [0, 0.5, 0]], [new ce(m, a), [0, -0.5, 0], [Math.PI, 0, 0]], [new ce(v, a)]], Z: [[new ce(m, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new ce(m, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]], [new ce(v, o), null, [Math.PI / 2, 0, 0]]], XYZ: [[new ce(new wr(0.1, 0), u.clone()), [0, 0, 0]]], XY: [[new ce(new _t(0.15, 0.15, 0.01), c.clone()), [0.15, 0.15, 0]]], YZ: [[new ce(new _t(0.15, 0.15, 0.01), l.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new ce(new _t(0.15, 0.15, 0.01), h.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, M = { X: [[new ce(new Pt(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new ce(new Pt(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new ce(new Pt(0.2, 0, 0.6, 4), i), [0, 0.3, 0]], [new ce(new Pt(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new ce(new Pt(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new ce(new Pt(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XYZ: [[new ce(new wr(0.2, 0), i)]], XY: [[new ce(new _t(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]], YZ: [[new ce(new _t(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new ce(new _t(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, b = { START: [[new ce(new wr(0.01, 2), r), null, null, null, "helper"]], END: [[new ce(new wr(0.01, 2), r), null, null, null, "helper"]], DELTA: [[new hn(function() {
      const D = new Pe();
      return D.setAttribute("position", new ye([0, 0, 0, 1, 1, 1], 3)), D;
    }(), r), null, null, null, "helper"]], X: [[new hn(f, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new hn(f, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new hn(f, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }, S = { XYZE: [[new ce(y(0.5, 1), p), null, [0, Math.PI / 2, 0]]], X: [[new ce(y(0.5, 0.5), s)]], Y: [[new ce(y(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]], Z: [[new ce(y(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]], E: [[new ce(y(0.75, 1), d), null, [0, Math.PI / 2, 0]]] }, w = { AXIS: [[new hn(f, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]] }, T = { XYZE: [[new ce(new Ea(0.25, 10, 8), i)]], X: [[new ce(new Ki(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]], Y: [[new ce(new Ki(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]], Z: [[new ce(new Ki(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]], E: [[new ce(new Ki(0.75, 0.1, 2, 24), i)]] }, C = { X: [[new ce(g, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new ce(v, s), [0, 0, 0], [0, 0, -Math.PI / 2]], [new ce(g, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new ce(g, a), [0, 0.5, 0]], [new ce(v, a)], [new ce(g, a), [0, -0.5, 0], [0, 0, Math.PI]]], Z: [[new ce(g, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new ce(v, o), [0, 0, 0], [Math.PI / 2, 0, 0]], [new ce(g, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]], XY: [[new ce(new _t(0.15, 0.15, 0.01), c), [0.15, 0.15, 0]]], YZ: [[new ce(new _t(0.15, 0.15, 0.01), l), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new ce(new _t(0.15, 0.15, 0.01), h), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new ce(new _t(0.1, 0.1, 0.1), u.clone())]] }, I = { X: [[new ce(new Pt(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new ce(new Pt(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new ce(new Pt(0.2, 0, 0.6, 4), i), [0, 0.3, 0]], [new ce(new Pt(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new ce(new Pt(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new ce(new Pt(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XY: [[new ce(new _t(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]], YZ: [[new ce(new _t(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new ce(new _t(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new ce(new _t(0.2, 0.2, 0.2), i), [0, 0, 0]]] }, A = { X: [[new hn(f, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new hn(f, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new hn(f, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] };
    function L(D) {
      const U = new Ue();
      for (const H in D)
        for (let Z = D[H].length; Z--; ) {
          const te = D[H][Z][0].clone(), ne = D[H][Z][1], ve = D[H][Z][2], Se = D[H][Z][3], Q = D[H][Z][4];
          te.name = H, te.tag = Q, ne && te.position.set(ne[0], ne[1], ne[2]), ve && te.rotation.set(ve[0], ve[1], ve[2]), Se && te.scale.set(Se[0], Se[1], Se[2]), te.updateMatrix();
          const ae = te.geometry.clone();
          ae.applyMatrix4(te.matrix), te.geometry = ae, te.renderOrder = 1 / 0, te.position.set(0, 0, 0), te.rotation.set(0, 0, 0), te.scale.set(1, 1, 1), U.add(te);
        }
      return U;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = L(x)), this.add(this.gizmo.rotate = L(S)), this.add(this.gizmo.scale = L(C)), this.add(this.picker.translate = L(M)), this.add(this.picker.rotate = L(T)), this.add(this.picker.scale = L(I)), this.add(this.helper.translate = L(b)), this.add(this.helper.rotate = L(w)), this.add(this.helper.scale = L(A)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  updateMatrixWorld(e) {
    const t = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Vu;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let r = 0; r < i.length; r++) {
      const s = i[r];
      let a;
      s.visible = !0, s.rotation.set(0, 0, 0), s.position.copy(this.worldPosition), a = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), s.scale.set(1, 1, 1).multiplyScalar(a * this.size / 4), s.tag !== "helper" ? (s.quaternion.copy(t), this.mode === "translate" || this.mode === "scale" ? (s.name === "X" && Math.abs(ut.copy(Gl).applyQuaternion(t).dot(this.eye)) > 0.99 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "Y" && Math.abs(ut.copy($s).applyQuaternion(t).dot(this.eye)) > 0.99 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "Z" && Math.abs(ut.copy(jl).applyQuaternion(t).dot(this.eye)) > 0.99 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "XY" && Math.abs(ut.copy(jl).applyQuaternion(t).dot(this.eye)) < 0.2 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "YZ" && Math.abs(ut.copy(Gl).applyQuaternion(t).dot(this.eye)) < 0.2 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1), s.name === "XZ" && Math.abs(ut.copy($s).applyQuaternion(t).dot(this.eye)) < 0.2 && (s.scale.set(1e-10, 1e-10, 1e-10), s.visible = !1)) : this.mode === "rotate" && (bu.copy(t), ut.copy(this.eye).applyQuaternion(xt.copy(t).invert()), s.name.search("E") !== -1 && s.quaternion.setFromRotationMatrix(F1.lookAt(this.eye, U1, $s)), s.name === "X" && (xt.setFromAxisAngle(Gl, Math.atan2(-ut.y, ut.z)), xt.multiplyQuaternions(bu, xt), s.quaternion.copy(xt)), s.name === "Y" && (xt.setFromAxisAngle($s, Math.atan2(ut.x, ut.z)), xt.multiplyQuaternions(bu, xt), s.quaternion.copy(xt)), s.name === "Z" && (xt.setFromAxisAngle(jl, Math.atan2(ut.y, ut.x)), xt.multiplyQuaternions(bu, xt), s.quaternion.copy(xt))), s.visible = s.visible && (s.name.indexOf("X") === -1 || this.showX), s.visible = s.visible && (s.name.indexOf("Y") === -1 || this.showY), s.visible = s.visible && (s.name.indexOf("Z") === -1 || this.showZ), s.visible = s.visible && (s.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), s.material.yo = s.material.yo || s.material.color.clone(), s.material.So = s.material.So || s.material.opacity, s.material.color.copy(s.material.yo), s.material.opacity = s.material.So, this.enabled && this.axis && (s.name === this.axis || this.axis.split("").some(function(o) {
        return s.name === o;
      })) && (s.material.color.setHex(16776960), s.material.opacity = 1)) : (s.visible = !1, s.name === "AXIS" ? (s.visible = !!this.axis, this.axis === "X" && (xt.setFromEuler(Mu.set(0, 0, 0)), s.quaternion.copy(t).multiply(xt), Math.abs(ut.copy(Gl).applyQuaternion(t).dot(this.eye)) > 0.9 && (s.visible = !1)), this.axis === "Y" && (xt.setFromEuler(Mu.set(0, 0, Math.PI / 2)), s.quaternion.copy(t).multiply(xt), Math.abs(ut.copy($s).applyQuaternion(t).dot(this.eye)) > 0.9 && (s.visible = !1)), this.axis === "Z" && (xt.setFromEuler(Mu.set(0, Math.PI / 2, 0)), s.quaternion.copy(t).multiply(xt), Math.abs(ut.copy(jl).applyQuaternion(t).dot(this.eye)) > 0.9 && (s.visible = !1)), this.axis === "XYZE" && (xt.setFromEuler(Mu.set(0, Math.PI / 2, 0)), ut.copy(this.rotationAxis), s.quaternion.setFromRotationMatrix(F1.lookAt(U1, ut, $s)), s.quaternion.multiply(xt), s.visible = this.dragging), this.axis === "E" && (s.visible = !1)) : s.name === "START" ? (s.position.copy(this.worldPositionStart), s.visible = this.dragging) : s.name === "END" ? (s.position.copy(this.worldPosition), s.visible = this.dragging) : s.name === "DELTA" ? (s.position.copy(this.worldPositionStart), s.quaternion.copy(this.worldQuaternionStart), Sn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Sn.applyQuaternion(this.worldQuaternionStart.clone().invert()), s.scale.copy(Sn), s.visible = this.dragging) : (s.quaternion.copy(t), this.dragging ? s.position.copy(this.worldPositionStart) : s.position.copy(this.worldPosition), this.axis && (s.visible = this.axis.search(s.name) !== -1)));
    }
    super.updateMatrixWorld(e);
  }
}
class p3 extends ce {
  constructor() {
    super(new or(1e5, 1e5, 2, 2), new Wt({ visible: !1, wireframe: !0, side: bt, transparent: !0, opacity: 0.1, toneMapped: !1 })), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), Su.copy(Gl).applyQuaternion(t === "local" ? this.worldQuaternion : Vu), Nl.copy($s).applyQuaternion(t === "local" ? this.worldQuaternion : Vu), Dl.copy(jl).applyQuaternion(t === "local" ? this.worldQuaternion : Vu), ut.copy(Nl), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            ut.copy(this.eye).cross(Su), Xi.copy(Su).cross(ut);
            break;
          case "Y":
            ut.copy(this.eye).cross(Nl), Xi.copy(Nl).cross(ut);
            break;
          case "Z":
            ut.copy(this.eye).cross(Dl), Xi.copy(Dl).cross(ut);
            break;
          case "XY":
            Xi.copy(Dl);
            break;
          case "YZ":
            Xi.copy(Su);
            break;
          case "XZ":
            ut.copy(Dl), Xi.copy(Nl);
            break;
          case "XYZ":
          case "E":
            Xi.set(0, 0, 0);
        }
        break;
      default:
        Xi.set(0, 0, 0);
    }
    Xi.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (B1.lookAt(Sn.set(0, 0, 0), Xi, ut), this.quaternion.setFromRotationMatrix(B1)), super.updateMatrixWorld(e);
  }
}
const Er = { name: "CopyShader", uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}` };
class Or {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
  }
  dispose() {
  }
}
const f3 = new _a(-1, 1, 1, -1, 0, 1), m3 = new class extends Pe {
  constructor() {
    super(), this.setAttribute("position", new ye([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ye([0, 2, 0, 0, 2, 0], 2));
  }
}();
class nl {
  constructor(e) {
    this.bo = new ce(m3, e);
  }
  dispose() {
    this.bo.geometry.dispose();
  }
  render(e) {
    e.render(this.bo, f3);
  }
  get material() {
    return this.bo.material;
  }
  set material(e) {
    this.bo.material = e;
  }
}
class R0 extends Or {
  constructor(e, t) {
    super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof tt ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Kt.clone(e.uniforms), this.material = new tt({ name: e.name !== void 0 ? e.name : "unspecified", defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this.fsQuad = new nl(this.material);
  }
  render(e, t, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class k1 extends Or {
  constructor(e, t) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, t, i) {
    const r = e.getContext(), s = e.state;
    let a, o;
    s.buffers.color.setMask(!1), s.buffers.depth.setMask(!1), s.buffers.color.setLocked(!0), s.buffers.depth.setLocked(!0), this.inverse ? (a = 0, o = 1) : (a = 1, o = 0), s.buffers.stencil.setTest(!0), s.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), s.buffers.stencil.setFunc(r.ALWAYS, a, 4294967295), s.buffers.stencil.setClear(o), s.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), s.buffers.color.setLocked(!1), s.buffers.depth.setLocked(!1), s.buffers.color.setMask(!0), s.buffers.depth.setMask(!0), s.buffers.stencil.setLocked(!1), s.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), s.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), s.buffers.stencil.setLocked(!0);
  }
}
class g3 extends Or {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class v3 {
  constructor(e, t) {
    if (this.renderer = e, this.Ao = e.getPixelRatio(), t === void 0) {
      const i = e.getSize(new X());
      this.Eo = i.width, this.To = i.height, (t = new ht(this.Eo * this.Ao, this.To * this.Ao, { type: Ht })).texture.name = "EffectComposer.rt1";
    } else
      this.Eo = t.width, this.To = t.height;
    this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new R0(Er), this.copyPass.material.blending = 0, this.clock = new xh();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this.Eo * this.Ao, this.To * this.Ao);
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e), e.setSize(this.Eo * this.Ao, this.To * this.Ao);
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    t !== -1 && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let i = !1;
    for (let r = 0, s = this.passes.length; r < s; r++) {
      const a = this.passes[r];
      if (a.enabled !== !1) {
        if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), a.needsSwap) {
          if (i) {
            const o = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        k1 !== void 0 && (a instanceof k1 ? i = !0 : a instanceof g3 && (i = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (e === void 0) {
      const t = this.renderer.getSize(new X());
      this.Ao = this.renderer.getPixelRatio(), this.Eo = t.width, this.To = t.height, (e = this.renderTarget1.clone()).setSize(this.Eo * this.Ao, this.To * this.Ao);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, t) {
    this.Eo = e, this.To = t;
    const i = this.Eo * this.Ao, r = this.To * this.Ao;
    this.renderTarget1.setSize(i, r), this.renderTarget2.setSize(i, r);
    for (let s = 0; s < this.passes.length; s++)
      this.passes[s].setSize(i, r);
  }
  setPixelRatio(e) {
    this.Ao = e, this.setSize(this.Eo, this.To);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class y3 extends Or {
  constructor(e, t, i = null, r = null, s = null) {
    super(), this.scene = e, this.camera = t, this.overrideMaterial = i, this.clearColor = r, this.clearAlpha = s, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this.Co = new oe();
  }
  render(e, t, i) {
    const r = e.autoClear;
    let s, a;
    e.autoClear = !1, this.overrideMaterial !== null && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this.Co), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (s = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == 1 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this.Co), this.clearAlpha !== null && e.setClearAlpha(s), this.overrideMaterial !== null && (this.scene.overrideMaterial = a), e.autoClear = r;
  }
}
class as extends Or {
  constructor(e, t, i, r) {
    super(), this.renderScene = t, this.renderCamera = i, this.selectedObjects = r !== void 0 ? r : [], this.visibleEdgeColor = new oe(1, 1, 1), this.hiddenEdgeColor = new oe(0.1, 0.04, 0.02), this.edgeGlow = 0, this.usePatternTexture = !1, this.edgeThickness = 1, this.edgeStrength = 3, this.downSampleRatio = 2, this.pulsePeriod = 0, this.Po = /* @__PURE__ */ new Map(), this.resolution = e !== void 0 ? new X(e.x, e.y) : new X(256, 256);
    const s = Math.round(this.resolution.x / this.downSampleRatio), a = Math.round(this.resolution.y / this.downSampleRatio);
    this.renderTargetMaskBuffer = new ht(this.resolution.x, this.resolution.y), this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = !1, this.depthMaterial = new Od(), this.depthMaterial.side = bt, this.depthMaterial.depthPacking = Eg, this.depthMaterial.blending = 0, this.prepareMaskMaterial = this.getPrepareMaskMaterial(), this.prepareMaskMaterial.side = bt, this.prepareMaskMaterial.fragmentShader = function(l, h) {
      const c = h.isPerspectiveCamera ? "perspective" : "orthographic";
      return l.replace(/DEPTH_TO_VIEW_Z/g, c + "DepthToViewZ");
    }(this.prepareMaskMaterial.fragmentShader, this.renderCamera), this.renderTargetDepthBuffer = new ht(this.resolution.x, this.resolution.y, { type: Ht }), this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = !1, this.renderTargetMaskDownSampleBuffer = new ht(s, a, { type: Ht }), this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1, this.renderTargetBlurBuffer1 = new ht(s, a, { type: Ht }), this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = !1, this.renderTargetBlurBuffer2 = new ht(Math.round(s / 2), Math.round(a / 2), { type: Ht }), this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = !1, this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new ht(s, a, { type: Ht }), this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1, this.renderTargetEdgeBuffer2 = new ht(Math.round(s / 2), Math.round(a / 2), { type: Ht }), this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1, this.separableBlurMaterial1 = this.getSeperableBlurMaterial(4), this.separableBlurMaterial1.uniforms.texSize.value.set(s, a), this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeperableBlurMaterial(4), this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(s / 2), Math.round(a / 2)), this.separableBlurMaterial2.uniforms.kernelRadius.value = 4, this.overlayMaterial = this.getOverlayMaterial();
    const o = Er;
    this.copyUniforms = Kt.clone(o.uniforms), this.materialCopy = new tt({ uniforms: this.copyUniforms, vertexShader: o.vertexShader, fragmentShader: o.fragmentShader, blending: 0, depthTest: !1, depthWrite: !1 }), this.enabled = !0, this.needsSwap = !1, this.Co = new oe(), this.oldClearAlpha = 1, this.fsQuad = new nl(null), this.tempPulseColor1 = new oe(), this.tempPulseColor2 = new oe(), this.textureMatrix = new fe();
  }
  dispose() {
    this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose(), this.depthMaterial.dispose(), this.prepareMaskMaterial.dispose(), this.edgeDetectionMaterial.dispose(), this.separableBlurMaterial1.dispose(), this.separableBlurMaterial2.dispose(), this.overlayMaterial.dispose(), this.materialCopy.dispose(), this.fsQuad.dispose();
  }
  setSize(e, t) {
    this.renderTargetMaskBuffer.setSize(e, t), this.renderTargetDepthBuffer.setSize(e, t);
    let i = Math.round(e / this.downSampleRatio), r = Math.round(t / this.downSampleRatio);
    this.renderTargetMaskDownSampleBuffer.setSize(i, r), this.renderTargetBlurBuffer1.setSize(i, r), this.renderTargetEdgeBuffer1.setSize(i, r), this.separableBlurMaterial1.uniforms.texSize.value.set(i, r), i = Math.round(i / 2), r = Math.round(r / 2), this.renderTargetBlurBuffer2.setSize(i, r), this.renderTargetEdgeBuffer2.setSize(i, r), this.separableBlurMaterial2.uniforms.texSize.value.set(i, r);
  }
  changeVisibilityOfSelectedObjects(e) {
    const t = this.Po;
    function i(r) {
      r.isMesh && (e === !0 ? r.visible = t.get(r) : (t.set(r, r.visible), r.visible = e));
    }
    for (let r = 0; r < this.selectedObjects.length; r++)
      this.selectedObjects[r].traverse(i);
  }
  changeVisibilityOfNonSelectedObjects(e) {
    const t = this.Po, i = [];
    function r(s) {
      s.isMesh && i.push(s);
    }
    for (let s = 0; s < this.selectedObjects.length; s++)
      this.selectedObjects[s].traverse(r);
    this.renderScene.traverse(function(s) {
      if (s.isMesh || s.isSprite) {
        let a = !1;
        for (let o = 0; o < i.length; o++)
          if (i[o].id === s.id) {
            a = !0;
            break;
          }
        if (a === !1) {
          const o = s.visible;
          e !== !1 && t.get(s) !== !0 || (s.visible = e), t.set(s, o);
        }
      } else
        (s.isPoints || s.isLine) && (e === !0 ? s.visible = t.get(s) : (t.set(s, s.visible), s.visible = e));
    });
  }
  updateTextureMatrix() {
    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
  }
  render(e, t, i, r, s) {
    if (this.selectedObjects.length > 0) {
      e.getClearColor(this.Co), this.oldClearAlpha = e.getClearAlpha();
      const a = e.autoClear;
      e.autoClear = !1, s && e.state.buffers.stencil.setTest(!1), e.setClearColor(16777215, 1), this.changeVisibilityOfSelectedObjects(!1);
      const o = this.renderScene.background;
      if (this.renderScene.background = null, this.renderScene.overrideMaterial = this.depthMaterial, e.setRenderTarget(this.renderTargetDepthBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.changeVisibilityOfSelectedObjects(!0), this.Po.clear(), this.updateTextureMatrix(), this.changeVisibilityOfNonSelectedObjects(!1), this.renderScene.overrideMaterial = this.prepareMaskMaterial, this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near, this.renderCamera.far), this.prepareMaskMaterial.uniforms.depthTexture.value = this.renderTargetDepthBuffer.texture, this.prepareMaskMaterial.uniforms.textureMatrix.value = this.textureMatrix, e.setRenderTarget(this.renderTargetMaskBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.renderScene.overrideMaterial = null, this.changeVisibilityOfNonSelectedObjects(!0), this.Po.clear(), this.renderScene.background = o, this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, e.setRenderTarget(this.renderTargetMaskDownSampleBuffer), e.clear(), this.fsQuad.render(e), this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), this.pulsePeriod > 0) {
        const l = 0.625 + 0.75 * Math.cos(0.01 * performance.now() / this.pulsePeriod) / 2;
        this.tempPulseColor1.multiplyScalar(l), this.tempPulseColor2.multiplyScalar(l);
      }
      this.fsQuad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial1, this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = as.BlurDirectionX, this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, e.setRenderTarget(this.renderTargetBlurBuffer1), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = as.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial2, this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial2.uniforms.direction.value = as.BlurDirectionX, e.setRenderTarget(this.renderTargetBlurBuffer2), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, this.separableBlurMaterial2.uniforms.direction.value = as.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer2), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.overlayMaterial, this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, s && e.state.buffers.stencil.setTest(!0), e.setRenderTarget(i), this.fsQuad.render(e), e.setClearColor(this.Co, this.oldClearAlpha), e.autoClear = a;
    }
    this.renderToScreen && (this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = i.texture, e.setRenderTarget(null), this.fsQuad.render(e));
  }
  getPrepareMaskMaterial() {
    return new tt({ uniforms: { depthTexture: { value: null }, cameraNearFar: { value: new X(0.5, 0.5) }, textureMatrix: { value: null } }, vertexShader: `#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;

					vec4 worldPosition = vec4( transformed, 1.0 );

					#ifdef USE_INSTANCING

						worldPosition = instanceMatrix * worldPosition;

					#endif
					
					worldPosition = modelMatrix * worldPosition;

					projTexCoord = textureMatrix * worldPosition;

				}`, fragmentShader: `#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}` });
  }
  getEdgeDetectionMaterial() {
    return new tt({ uniforms: { maskTexture: { value: null }, texSize: { value: new X(0.5, 0.5) }, visibleEdgeColor: { value: new _(1, 1, 1) }, hiddenEdgeColor: { value: new _(1, 1, 1) } }, vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}` });
  }
  getSeperableBlurMaterial(e) {
    return new tt({ defines: { MAX_RADIUS: e }, uniforms: { colorTexture: { value: null }, texSize: { value: new X(0.5, 0.5) }, direction: { value: new X(0.5, 0.5) }, kernelRadius: { value: 1 } }, vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float sigma = kernelRadius/2.0;
					float weightSum = gaussianPdf(0.0, sigma);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float x = kernelRadius * float(i) / float(MAX_RADIUS);
						float w = gaussianPdf(x, sigma);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}` });
  }
  getOverlayMaterial() {
    return new tt({ uniforms: { maskTexture: { value: null }, edgeTexture1: { value: null }, edgeTexture2: { value: null }, patternTexture: { value: null }, edgeStrength: { value: 1 }, edgeGlow: { value: 1 }, usePatternTexture: { value: 0 } }, vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`, blending: Ar, depthTest: !1, depthWrite: !1, transparent: !0 });
  }
}
as.BlurDirectionX = new X(1, 0), as.BlurDirectionY = new X(0, 1);
const x3 = { name: "OutputShader", uniforms: { tDiffuse: { value: null }, toneMappingExposure: { value: 1 } }, vertexShader: `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}` };
class M3 extends Or {
  constructor() {
    super();
    const e = x3;
    this.uniforms = Kt.clone(e.uniforms), this.material = new Bg({ name: e.name, uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader }), this.fsQuad = new nl(this.material), this.he = null, this.Lo = null;
  }
  render(e, t, i) {
    this.uniforms.tDiffuse.value = i.texture, this.uniforms.toneMappingExposure.value = e.toneMappingExposure, this.he === e.outputColorSpace && this.Lo === e.toneMapping || (this.he = e.outputColorSpace, this.Lo = e.toneMapping, this.material.defines = {}, it.getTransfer(this.he) === ft && (this.material.defines.SRGB_TRANSFER = ""), this.Lo === wd ? this.material.defines.LINEAR_TONE_MAPPING = "" : this.Lo === _d ? this.material.defines.REINHARD_TONE_MAPPING = "" : this.Lo === Td ? this.material.defines.CINEON_TONE_MAPPING = "" : this.Lo === Ed ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this.Lo === Ad ? this.material.defines.AGX_TONE_MAPPING = "" : this.Lo === mg && (this.material.defines.NEUTRAL_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const b3 = { name: "LuminosityHighPassShader", shaderID: "luminosityHighPass", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new oe(0) }, defaultOpacity: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}` };
class Qo extends Or {
  constructor(e, t, i, r) {
    super(), this.strength = t !== void 0 ? t : 1, this.radius = i, this.threshold = r, this.resolution = e !== void 0 ? new X(e.x, e.y) : new X(256, 256), this.clearColor = new oe(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
    let s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new ht(s, a, { type: Ht }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
    for (let c = 0; c < this.nMips; c++) {
      const u = new ht(s, a, { type: Ht });
      u.texture.name = "UnrealBloomPass.h" + c, u.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(u);
      const d = new ht(s, a, { type: Ht });
      d.texture.name = "UnrealBloomPass.v" + c, d.texture.generateMipmaps = !1, this.renderTargetsVertical.push(d), s = Math.round(s / 2), a = Math.round(a / 2);
    }
    const o = b3;
    this.highPassUniforms = Kt.clone(o.uniforms), this.highPassUniforms.luminosityThreshold.value = r, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new tt({ uniforms: this.highPassUniforms, vertexShader: o.vertexShader, fragmentShader: o.fragmentShader }), this.separableBlurMaterials = [];
    const l = [3, 5, 7, 9, 11];
    s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
    for (let c = 0; c < this.nMips; c++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[c])), this.separableBlurMaterials[c].uniforms.invSize.value = new X(1 / s, 1 / a), s = Math.round(s / 2), a = Math.round(a / 2);
    this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = 0.1, this.compositeMaterial.uniforms.bloomFactors.value = [1, 0.8, 0.6, 0.4, 0.2], this.bloomTintColors = [new _(1, 1, 1), new _(1, 1, 1), new _(1, 1, 1), new _(1, 1, 1), new _(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
    const h = Er;
    this.copyUniforms = Kt.clone(h.uniforms), this.blendMaterial = new tt({ uniforms: this.copyUniforms, vertexShader: h.vertexShader, fragmentShader: h.fragmentShader, blending: Ar, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this.Co = new oe(), this.oldClearAlpha = 1, this.basic = new Wt(), this.fsQuad = new nl(null);
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
    for (let e = 0; e < this.separableBlurMaterials.length; e++)
      this.separableBlurMaterials[e].dispose();
    this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose();
  }
  setSize(e, t) {
    let i = Math.round(e / 2), r = Math.round(t / 2);
    this.renderTargetBright.setSize(i, r);
    for (let s = 0; s < this.nMips; s++)
      this.renderTargetsHorizontal[s].setSize(i, r), this.renderTargetsVertical[s].setSize(i, r), this.separableBlurMaterials[s].uniforms.invSize.value = new X(1 / i, 1 / r), i = Math.round(i / 2), r = Math.round(r / 2);
  }
  render(e, t, i, r, s) {
    e.getClearColor(this.Co), this.oldClearAlpha = e.getClearAlpha();
    const a = e.autoClear;
    e.autoClear = !1, e.setClearColor(this.clearColor, 0), s && e.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = i.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = i.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
    let o = this.renderTargetBright;
    for (let l = 0; l < this.nMips; l++)
      this.fsQuad.material = this.separableBlurMaterials[l], this.separableBlurMaterials[l].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[l].uniforms.direction.value = Qo.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[l]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture, this.separableBlurMaterials[l].uniforms.direction.value = Qo.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[l]), e.clear(), this.fsQuad.render(e), o = this.renderTargetsVertical[l];
    this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, s && e.state.buffers.stencil.setTest(!0), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.fsQuad.render(e)), e.setClearColor(this.Co, this.oldClearAlpha), e.autoClear = a;
  }
  getSeperableBlurMaterial(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(0.39894 * Math.exp(-0.5 * i * i / (e * e)) / e);
    return new tt({ defines: { KERNEL_RADIUS: e }, uniforms: { colorTexture: { value: null }, invSize: { value: new X(0.5, 0.5) }, direction: { value: new X(0.5, 0.5) }, gaussianCoefficients: { value: t } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}` });
  }
  getCompositeMaterial(e) {
    return new tt({ defines: { NUM_MIPS: e }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}` });
  }
}
Qo.BlurDirectionX = new X(1, 0), Qo.BlurDirectionY = new X(0, 1);
class S3 extends R0 {
  constructor() {
    super({ name: "ScreenMaskShader", uniforms: { tDiffuse: { value: null }, opacity: { value: 1 }, intensity: { value: 1 }, maskColor: { value: new oe(1, 1, 1) }, R: { value: 0.2 }, sr: { value: 1.2 } }, vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
      `, fragmentShader: `
        uniform float opacity;
        uniform float intensity;
        uniform sampler2D tDiffuse;
        uniform vec3 maskColor;
        uniform float R;
        uniform float sr;
        varying vec2 vUv;
        void main() {
          // 阴影颜色
          vec4 texel = texture2D( tDiffuse, vUv );
          // 距离中心的距离
          float dist = sqrt((vUv.x-0.5)*(vUv.x-0.5)+(vUv.y-0.5)*(vUv.y-0.5));
          // 渐变, sr 是开始黑色参数
          float rr = (sr - smoothstep(R, R + 0.5, dist));
          // 叠加黑色
          texel *= vec4(maskColor * rr * vec3(intensity,intensity,intensity), 1.0);
          gl_FragColor = opacity * texel;
        }
      ` });
  }
}
const w3 = { name: "FXAAShader", uniforms: { tDiffuse: { value: null }, resolution: { value: new X(1 / 1024, 1 / 512) } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `
		precision highp float;

		uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

		//----------------------------------------------------------------------------------
		// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag
		// SDK Version: v3.00
		// Email:       gameworks@nvidia.com
		// Site:        http://developer.nvidia.com/
		//
		// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
		//
		// Redistribution and use in source and binary forms, with or without
		// modification, are permitted provided that the following conditions
		// are met:
		//  * Redistributions of source code must retain the above copyright
		//    notice, this list of conditions and the following disclaimer.
		//  * Redistributions in binary form must reproduce the above copyright
		//    notice, this list of conditions and the following disclaimer in the
		//    documentation and/or other materials provided with the distribution.
		//  * Neither the name of NVIDIA CORPORATION nor the names of its
		//    contributors may be used to endorse or promote products derived
		//    from this software without specific prior written permission.
		//
		// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
		// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
		// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
		// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
		// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		//
		//----------------------------------------------------------------------------------

		#ifndef FXAA_DISCARD
			//
			// Only valid for PC OpenGL currently.
			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
			//
			// 1 = Use discard on pixels which don't need AA.
			//     For APIs which enable concurrent TEX+ROP from same surface.
			// 0 = Return unchanged color on pixels which don't need AA.
			//
			#define FXAA_DISCARD 0
		#endif

		/*--------------------------------------------------------------------------*/
		#define FxaaTexTop(t, p) texture2D(t, p, -100.0)
		#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)
		/*--------------------------------------------------------------------------*/

		#define NUM_SAMPLES 5

		// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha
		float contrast( vec4 a, vec4 b ) {
			vec4 diff = abs( a - b );
			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );
		}

		/*============================================================================

									FXAA3 QUALITY - PC

		============================================================================*/

		/*--------------------------------------------------------------------------*/
		vec4 FxaaPixelShader(
			vec2 posM,
			sampler2D tex,
			vec2 fxaaQualityRcpFrame,
			float fxaaQualityEdgeThreshold,
			float fxaaQualityinvEdgeThreshold
		) {
			vec4 rgbaM = FxaaTexTop(tex, posM);
			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);
			// . S .
			// W M E
			// . N .

			bool earlyExit = max( max( max(
					contrast( rgbaM, rgbaN ),
					contrast( rgbaM, rgbaS ) ),
					contrast( rgbaM, rgbaE ) ),
					contrast( rgbaM, rgbaW ) )
					< fxaaQualityEdgeThreshold;
			// . 0 .
			// 0 0 0
			// . 0 .

			#if (FXAA_DISCARD == 1)
				if(earlyExit) FxaaDiscard;
			#else
				if(earlyExit) return rgbaM;
			#endif

			float contrastN = contrast( rgbaM, rgbaN );
			float contrastS = contrast( rgbaM, rgbaS );
			float contrastE = contrast( rgbaM, rgbaE );
			float contrastW = contrast( rgbaM, rgbaW );

			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );
			relativeVContrast *= fxaaQualityinvEdgeThreshold;

			bool horzSpan = relativeVContrast > 0.;
			// . 1 .
			// 0 0 0
			// . 1 .

			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar
			if( abs( relativeVContrast ) < .3 ) {
				// locate the edge
				vec2 dirToEdge;
				dirToEdge.x = contrastE > contrastW ? 1. : -1.;
				dirToEdge.y = contrastS > contrastN ? 1. : -1.;
				// . 2 .      . 1 .
				// 1 0 2  ~=  0 0 1
				// . 1 .      . 0 .

				// tap 2 pixels and see which ones are "outside" the edge, to
				// determine if the edge is vertical or horizontal

				vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);
				float matchAlongH = contrast( rgbaM, rgbaAlongH );
				// . 1 .
				// 0 0 1
				// . 0 H

				vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);
				float matchAlongV = contrast( rgbaM, rgbaAlongV );
				// V 1 .
				// 0 0 1
				// . 0 .

				relativeVContrast = matchAlongV - matchAlongH;
				relativeVContrast *= fxaaQualityinvEdgeThreshold;

				if( abs( relativeVContrast ) < .3 ) { // 45 deg edge
					// 1 1 .
					// 0 0 1
					// . 0 1

					// do a simple blur
					return mix(
						rgbaM,
						(rgbaN + rgbaS + rgbaE + rgbaW) * .25,
						.4
					);
				}

				horzSpan = relativeVContrast > 0.;
			}

			if(!horzSpan) rgbaN = rgbaW;
			if(!horzSpan) rgbaS = rgbaE;
			// . 0 .      1
			// 1 0 1  ->  0
			// . 0 .      1

			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );
			if(!pairN) rgbaN = rgbaS;

			vec2 offNP;
			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;

			bool doneN = false;
			bool doneP = false;

			float nDist = 0.;
			float pDist = 0.;

			vec2 posN = posM;
			vec2 posP = posM;

			int iterationsUsed = 0;
			int iterationsUsedN = 0;
			int iterationsUsedP = 0;
			for( int i = 0; i < NUM_SAMPLES; i++ ) {
				iterationsUsed = i;

				float increment = float(i + 1);

				if(!doneN) {
					nDist += increment;
					posN = posM + offNP * nDist;
					vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);
					doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );
					iterationsUsedN = i;
				}

				if(!doneP) {
					pDist += increment;
					posP = posM - offNP * pDist;
					vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);
					doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );
					iterationsUsedP = i;
				}

				if(doneN || doneP) break;
			}


			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge

			float dist = min(
				doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,
				doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.
			);

			// hacky way of reduces blurriness of mostly diagonal edges
			// but reduces AA quality
			dist = pow(dist, .5);

			dist = 1. - dist;

			return mix(
				rgbaM,
				rgbaN,
				dist * .5
			);
		}

		void main() {
			const float edgeDetectionQuality = .2;
			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;

			gl_FragColor = FxaaPixelShader(
				vUv,
				tDiffuse,
				resolution,
				edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard
				invEdgeDetectionQuality
			);

		}
	` }, wu = { name: "SAOShader", defines: { NUM_SAMPLES: 7, NUM_RINGS: 4, DIFFUSE_TEXTURE: 0, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, tDiffuse: { value: null }, tNormal: { value: null }, size: { value: new X(512, 512) }, cameraNear: { value: 1 }, cameraFar: { value: 100 }, cameraProjectionMatrix: { value: new fe() }, cameraInverseProjectionMatrix: { value: new fe() }, scale: { value: 1 }, intensity: { value: 0.1 }, bias: { value: 0.5 }, minResolution: { value: 0 }, kernelRadius: { value: 100 }, randomSeed: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `
		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform highp sampler2D tDepth;
		uniform highp sampler2D tNormal;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			return texture2D( tDepth, screenPosition ).x;
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}` }, qr = { name: "DepthLimitedBlurShader", defines: { KERNEL_RADIUS: 4, DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDiffuse: { value: null }, size: { value: new X(512, 512) }, sampleUvOffsets: { value: [new X(0, 0)] }, sampleWeights: { value: [1] }, tDepth: { value: null }, cameraNear: { value: 10 }, cameraFar: { value: 1e3 }, depthCutoff: { value: 10 } }, vertexShader: `

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}` }, vd = { createSampleWeights: function(n, e) {
  const t = [];
  for (let i = 0; i <= n; i++)
    t.push(_3(i, e));
  return t;
}, createSampleOffsets: function(n, e) {
  const t = [];
  for (let i = 0; i <= n; i++)
    t.push(e.clone().multiplyScalar(i));
  return t;
}, configure: function(n, e, t, i) {
  n.defines.KERNEL_RADIUS = e, n.uniforms.sampleUvOffsets.value = vd.createSampleOffsets(e, i), n.uniforms.sampleWeights.value = vd.createSampleWeights(e, t), n.needsUpdate = !0;
} };
function _3(n, e) {
  return Math.exp(-n * n / (e * e * 2)) / (Math.sqrt(2 * Math.PI) * e);
}
class Bh extends Or {
  constructor(e, t, i = new X(256, 256)) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.originalClearColor = new oe(), this.Co = new oe(), this.oldClearAlpha = 1, this.params = { output: 0, saoBias: 0.5, saoIntensity: 0.18, saoScale: 1, saoKernelRadius: 100, saoMinResolution: 0, saoBlur: !0, saoBlurRadius: 8, saoBlurStdDev: 4, saoBlurDepthCutoff: 0.01 }, this.resolution = new X(i.x, i.y), this.saoRenderTarget = new ht(this.resolution.x, this.resolution.y, { type: Ht }), this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
    const r = new Wh();
    r.format = gs, r.type = ms, this.normalRenderTarget = new ht(this.resolution.x, this.resolution.y, { minFilter: at, magFilter: at, type: Ht, depthTexture: r }), this.normalMaterial = new Wd(), this.normalMaterial.blending = 0, this.saoMaterial = new tt({ defines: Object.assign({}, wu.defines), fragmentShader: wu.fragmentShader, vertexShader: wu.vertexShader, uniforms: Kt.clone(wu.uniforms) }), this.saoMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.saoMaterial.uniforms.tDepth.value = r, this.saoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.saoMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.saoMaterial.uniforms.cameraProjectionMatrix.value = this.camera.projectionMatrix, this.saoMaterial.blending = 0, this.vBlurMaterial = new tt({ uniforms: Kt.clone(qr.uniforms), defines: Object.assign({}, qr.defines), vertexShader: qr.vertexShader, fragmentShader: qr.fragmentShader }), this.vBlurMaterial.defines.DEPTH_PACKING = 0, this.vBlurMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.vBlurMaterial.uniforms.tDiffuse.value = this.saoRenderTarget.texture, this.vBlurMaterial.uniforms.tDepth.value = r, this.vBlurMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.vBlurMaterial.blending = 0, this.hBlurMaterial = new tt({ uniforms: Kt.clone(qr.uniforms), defines: Object.assign({}, qr.defines), vertexShader: qr.vertexShader, fragmentShader: qr.fragmentShader }), this.hBlurMaterial.defines.DEPTH_PACKING = 0, this.hBlurMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.hBlurMaterial.uniforms.tDiffuse.value = this.blurIntermediateRenderTarget.texture, this.hBlurMaterial.uniforms.tDepth.value = r, this.hBlurMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.hBlurMaterial.blending = 0, this.materialCopy = new tt({ uniforms: Kt.clone(Er.uniforms), vertexShader: Er.vertexShader, fragmentShader: Er.fragmentShader, blending: 0 }), this.materialCopy.transparent = !0, this.materialCopy.depthTest = !1, this.materialCopy.depthWrite = !1, this.materialCopy.blending = Ro, this.materialCopy.blendSrc = Vh, this.materialCopy.blendDst = Io, this.materialCopy.blendEquation = $n, this.materialCopy.blendSrcAlpha = zh, this.materialCopy.blendDstAlpha = Io, this.materialCopy.blendEquationAlpha = $n, this.fsQuad = new nl(null);
  }
  render(e, t, i) {
    this.renderToScreen && (this.materialCopy.blending = 0, this.materialCopy.uniforms.tDiffuse.value = i.texture, this.materialCopy.needsUpdate = !0, this.renderPass(e, this.materialCopy, null)), e.getClearColor(this.Co), this.oldClearAlpha = e.getClearAlpha();
    const r = e.autoClear;
    e.autoClear = !1, this.saoMaterial.uniforms.bias.value = this.params.saoBias, this.saoMaterial.uniforms.intensity.value = this.params.saoIntensity, this.saoMaterial.uniforms.scale.value = this.params.saoScale, this.saoMaterial.uniforms.kernelRadius.value = this.params.saoKernelRadius, this.saoMaterial.uniforms.minResolution.value = this.params.saoMinResolution, this.saoMaterial.uniforms.cameraNear.value = this.camera.near, this.saoMaterial.uniforms.cameraFar.value = this.camera.far;
    const s = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
    this.vBlurMaterial.uniforms.depthCutoff.value = s, this.hBlurMaterial.uniforms.depthCutoff.value = s, this.vBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.vBlurMaterial.uniforms.cameraFar.value = this.camera.far, this.hBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.hBlurMaterial.uniforms.cameraFar.value = this.camera.far, this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius), this.prevStdDev === this.params.saoBlurStdDev && this.prevNumSamples === this.params.saoBlurRadius || (vd.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new X(0, 1)), vd.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new X(1, 0)), this.prevStdDev = this.params.saoBlurStdDev, this.prevNumSamples = this.params.saoBlurRadius), this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 7829503, 1), this.renderPass(e, this.saoMaterial, this.saoRenderTarget, 16777215, 1), this.params.saoBlur && (this.renderPass(e, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1), this.renderPass(e, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1));
    const a = this.materialCopy;
    this.params.output === Bh.OUTPUT.Normal ? (this.materialCopy.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.materialCopy.needsUpdate = !0) : (this.materialCopy.uniforms.tDiffuse.value = this.saoRenderTarget.texture, this.materialCopy.needsUpdate = !0), this.params.output === Bh.OUTPUT.Default ? a.blending = Ro : a.blending = 0, this.renderPass(e, a, this.renderToScreen ? null : i), e.setClearColor(this.Co, this.oldClearAlpha), e.autoClear = r;
  }
  renderPass(e, t, i, r, s) {
    e.getClearColor(this.originalClearColor);
    const a = e.getClearAlpha(), o = e.autoClear;
    e.setRenderTarget(i), e.autoClear = !1, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.fsQuad.material = t, this.fsQuad.render(e), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  renderOverride(e, t, i, r, s) {
    e.getClearColor(this.originalClearColor);
    const a = e.getClearAlpha(), o = e.autoClear;
    e.setRenderTarget(i), e.autoClear = !1, r = t.clearColor || r, s = t.clearAlpha || s, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.scene.overrideMaterial = t, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  setSize(e, t) {
    this.saoRenderTarget.setSize(e, t), this.blurIntermediateRenderTarget.setSize(e, t), this.normalRenderTarget.setSize(e, t), this.saoMaterial.uniforms.size.value.set(e, t), this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.saoMaterial.uniforms.cameraProjectionMatrix.value = this.camera.projectionMatrix, this.saoMaterial.needsUpdate = !0, this.vBlurMaterial.uniforms.size.value.set(e, t), this.vBlurMaterial.needsUpdate = !0, this.hBlurMaterial.uniforms.size.value.set(e, t), this.hBlurMaterial.needsUpdate = !0;
  }
  dispose() {
    this.saoRenderTarget.dispose(), this.blurIntermediateRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.normalMaterial.dispose(), this.saoMaterial.dispose(), this.vBlurMaterial.dispose(), this.hBlurMaterial.dispose(), this.materialCopy.dispose(), this.fsQuad.dispose();
  }
}
Bh.OUTPUT = { Default: 0, SAO: 1, Normal: 2 };
const qi = { name: "SSRShader", defines: { MAX_STEP: 0, PERSPECTIVE_CAMERA: !0, DISTANCE_ATTENUATION: !0, FRESNEL: !0, INFINITE_THICK: !1, SELECTIVE: !1 }, uniforms: { tDiffuse: { value: null }, tNormal: { value: null }, tMetalness: { value: null }, tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null }, resolution: { value: new X() }, cameraProjectionMatrix: { value: new fe() }, cameraInverseProjectionMatrix: { value: new fe() }, opacity: { value: 0.5 }, maxDistance: { value: 180 }, cameraRange: { value: 0 }, thickness: { value: 0.018 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float thickness;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef PERSPECTIVE_CAMERA
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef SELECTIVE
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef PERSPECTIVE_CAMERA
				vec3 viewIncidentDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#else
				vec3 viewIncidentDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef PERSPECTIVE_CAMERA
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<float(MAX_STEP);i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef PERSPECTIVE_CAMERA
					// https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
				#endif

				// if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
				// https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
				if(viewReflectRayZ<=vZ){

					bool hit;
					#ifdef INFINITE_THICK
						hit=true;
					#else
						float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

						float minThickness;
						vec2 xyNeighbor=xy;
						xyNeighbor.x+=1.;
						vec2 uvNeighbor=xyNeighbor/resolution;
						vec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);
						minThickness=vPNeighbor.x-vP.x;
						minThickness*=3.;
						float tk=max(minThickness,thickness);

						hit=away<=tk;
					#endif

					if(hit){
						vec3 vN=getViewNormal( uv );
						if(dot(viewReflectDir,vN)>=0.) continue;
						float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
						if(distance>maxDistance) break;
						float op=opacity;
						#ifdef DISTANCE_ATTENUATION
							float ratio=1.-(distance/maxDistance);
							float attenuation=ratio*ratio;
							op=opacity*attenuation;
						#endif
						#ifdef FRESNEL
							float fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;
							op*=fresnelCoe;
						#endif
						vec4 reflectColor=texture2D(tDiffuse,uv);
						gl_FragColor.xyz=reflectColor.xyz;
						gl_FragColor.a=op;
						break;
					}
				}
			}
		}
	` }, _u = { name: "SSRDepthShader", defines: { PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `

		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
			gl_FragColor = vec4( vec3( d ), 1.0 );

		}

	` }, Yr = { name: "SSRBlurShader", uniforms: { tDiffuse: { value: null }, resolution: { value: new X() }, opacity: { value: 0.5 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;
		void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

			vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	` };
class Mr extends Or {
  constructor({ renderer: e, scene: t, camera: i, width: r, height: s, selects: a, bouncing: o = !1, groundReflector: l }) {
    super(), this.width = r !== void 0 ? r : 512, this.height = s !== void 0 ? s : 512, this.clear = !0, this.renderer = e, this.scene = t, this.camera = i, this.groundReflector = l, this.opacity = qi.uniforms.opacity.value, this.output = 0, this.maxDistance = qi.uniforms.maxDistance.value, this.thickness = qi.uniforms.thickness.value, this.tempColor = new oe(), this.Ro = a, this.selective = Array.isArray(this.Ro), Object.defineProperty(this, "selects", { get() {
      return this.Ro;
    }, set(c) {
      this.Ro !== c && (this.Ro = c, Array.isArray(c) ? (this.selective = !0, this.ssrMaterial.defines.SELECTIVE = !0, this.ssrMaterial.needsUpdate = !0) : (this.selective = !1, this.ssrMaterial.defines.SELECTIVE = !1, this.ssrMaterial.needsUpdate = !0));
    } }), this.Do = o, Object.defineProperty(this, "bouncing", { get() {
      return this.Do;
    }, set(c) {
      this.Do !== c && (this.Do = c, this.ssrMaterial.uniforms.tDiffuse.value = c ? this.prevRenderTarget.texture : this.beautyRenderTarget.texture);
    } }), this.blur = !0, this.Io = qi.defines.DISTANCE_ATTENUATION, Object.defineProperty(this, "distanceAttenuation", { get() {
      return this.Io;
    }, set(c) {
      this.Io !== c && (this.Io = c, this.ssrMaterial.defines.DISTANCE_ATTENUATION = c, this.ssrMaterial.needsUpdate = !0);
    } }), this.Uo = qi.defines.FRESNEL, Object.defineProperty(this, "fresnel", { get() {
      return this.Uo;
    }, set(c) {
      this.Uo !== c && (this.Uo = c, this.ssrMaterial.defines.FRESNEL = c, this.ssrMaterial.needsUpdate = !0);
    } }), this.Oo = qi.defines.INFINITE_THICK, Object.defineProperty(this, "infiniteThick", { get() {
      return this.Oo;
    }, set(c) {
      this.Oo !== c && (this.Oo = c, this.ssrMaterial.defines.INFINITE_THICK = c, this.ssrMaterial.needsUpdate = !0);
    } });
    const h = new Wh();
    h.type = No, h.minFilter = at, h.magFilter = at, this.beautyRenderTarget = new ht(this.width, this.height, { minFilter: at, magFilter: at, type: Ht, depthTexture: h, depthBuffer: !0 }), this.prevRenderTarget = new ht(this.width, this.height, { minFilter: at, magFilter: at }), this.normalRenderTarget = new ht(this.width, this.height, { minFilter: at, magFilter: at, type: Ht }), this.metalnessRenderTarget = new ht(this.width, this.height, { minFilter: at, magFilter: at, type: Ht }), this.ssrRenderTarget = new ht(this.width, this.height, { minFilter: at, magFilter: at }), this.blurRenderTarget = this.ssrRenderTarget.clone(), this.blurRenderTarget2 = this.ssrRenderTarget.clone(), this.ssrMaterial = new tt({ defines: Object.assign({}, qi.defines, { MAX_STEP: Math.sqrt(this.width * this.width + this.height * this.height) }), uniforms: Kt.clone(qi.uniforms), vertexShader: qi.vertexShader, fragmentShader: qi.fragmentShader, blending: 0 }), this.ssrMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.ssrMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.ssrMaterial.defines.SELECTIVE = this.selective, this.ssrMaterial.needsUpdate = !0, this.ssrMaterial.uniforms.tMetalness.value = this.metalnessRenderTarget.texture, this.ssrMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.ssrMaterial.uniforms.cameraNear.value = this.camera.near, this.ssrMaterial.uniforms.cameraFar.value = this.camera.far, this.ssrMaterial.uniforms.thickness.value = this.thickness, this.ssrMaterial.uniforms.resolution.value.set(this.width, this.height), this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.normalMaterial = new Wd(), this.normalMaterial.blending = 0, this.metalnessOnMaterial = new Wt({ color: "white" }), this.metalnessOffMaterial = new Wt({ color: "black" }), this.blurMaterial = new tt({ defines: Object.assign({}, Yr.defines), uniforms: Kt.clone(Yr.uniforms), vertexShader: Yr.vertexShader, fragmentShader: Yr.fragmentShader }), this.blurMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.blurMaterial.uniforms.resolution.value.set(this.width, this.height), this.blurMaterial2 = new tt({ defines: Object.assign({}, Yr.defines), uniforms: Kt.clone(Yr.uniforms), vertexShader: Yr.vertexShader, fragmentShader: Yr.fragmentShader }), this.blurMaterial2.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.blurMaterial2.uniforms.resolution.value.set(this.width, this.height), this.depthRenderMaterial = new tt({ defines: Object.assign({}, _u.defines), uniforms: Kt.clone(_u.uniforms), vertexShader: _u.vertexShader, fragmentShader: _u.fragmentShader, blending: 0 }), this.depthRenderMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far, this.copyMaterial = new tt({ uniforms: Kt.clone(Er.uniforms), vertexShader: Er.vertexShader, fragmentShader: Er.fragmentShader, transparent: !0, depthTest: !1, depthWrite: !1, blendSrc: us, blendDst: ds, blendEquation: $n, blendSrcAlpha: us, blendDstAlpha: ds, blendEquationAlpha: $n }), this.fsQuad = new nl(null), this.originalClearColor = new oe();
  }
  dispose() {
    this.beautyRenderTarget.dispose(), this.prevRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.metalnessRenderTarget.dispose(), this.ssrRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.blurRenderTarget2.dispose(), this.normalMaterial.dispose(), this.metalnessOnMaterial.dispose(), this.metalnessOffMaterial.dispose(), this.blurMaterial.dispose(), this.blurMaterial2.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose(), this.fsQuad.dispose();
  }
  render(e, t) {
    switch (e.setRenderTarget(this.beautyRenderTarget), e.clear(), this.groundReflector && (this.groundReflector.visible = !1, this.groundReflector.doRender(this.renderer, this.scene, this.camera), this.groundReflector.visible = !0), e.render(this.scene, this.camera), this.groundReflector && (this.groundReflector.visible = !1), this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 0, 0), this.selective && this.renderMetalness(e, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0), this.ssrMaterial.uniforms.opacity.value = this.opacity, this.ssrMaterial.uniforms.maxDistance.value = this.maxDistance, this.ssrMaterial.uniforms.thickness.value = this.thickness, this.renderPass(e, this.ssrMaterial, this.ssrRenderTarget), this.blur && (this.renderPass(e, this.blurMaterial, this.blurRenderTarget), this.renderPass(e, this.blurMaterial2, this.blurRenderTarget2)), this.output) {
      case Mr.OUTPUT.Default:
        this.bouncing ? (this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.prevRenderTarget), this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = 1, this.renderPass(e, this.copyMaterial, this.prevRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = this.prevRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t)) : (this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t), this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = 1, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t));
        break;
      case Mr.OUTPUT.SSR:
        this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t), this.bouncing && (this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.prevRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = 1, this.renderPass(e, this.copyMaterial, this.prevRenderTarget));
        break;
      case Mr.OUTPUT.Beauty:
        this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
        break;
      case Mr.OUTPUT.Depth:
        this.renderPass(e, this.depthRenderMaterial, this.renderToScreen ? null : t);
        break;
      case Mr.OUTPUT.Normal:
        this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
        break;
      case Mr.OUTPUT.Metalness:
        this.copyMaterial.uniforms.tDiffuse.value = this.metalnessRenderTarget.texture, this.copyMaterial.blending = 0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
    }
  }
  renderPass(e, t, i, r, s) {
    this.originalClearColor.copy(e.getClearColor(this.tempColor));
    const a = e.getClearAlpha(this.tempColor), o = e.autoClear;
    e.setRenderTarget(i), e.autoClear = !1, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.fsQuad.material = t, this.fsQuad.render(e), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  renderOverride(e, t, i, r, s) {
    this.originalClearColor.copy(e.getClearColor(this.tempColor));
    const a = e.getClearAlpha(this.tempColor), o = e.autoClear;
    e.setRenderTarget(i), e.autoClear = !1, r = t.clearColor || r, s = t.clearAlpha || s, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.scene.overrideMaterial = t, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  renderMetalness(e, t, i, r, s) {
    this.originalClearColor.copy(e.getClearColor(this.tempColor));
    const a = e.getClearAlpha(this.tempColor), o = e.autoClear;
    e.setRenderTarget(i), e.autoClear = !1, r = t.clearColor || r, s = t.clearAlpha || s, r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()), this.scene.traverseVisible((l) => {
      l.ko = l.material, this.Ro.includes(l) ? l.material = this.metalnessOnMaterial : l.material = this.metalnessOffMaterial;
    }), e.render(this.scene, this.camera), this.scene.traverseVisible((l) => {
      l.material = l.ko;
    }), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a);
  }
  setSize(e, t) {
    this.width = e, this.height = t, this.ssrMaterial.defines.MAX_STEP = Math.sqrt(e * e + t * t), this.ssrMaterial.needsUpdate = !0, this.beautyRenderTarget.setSize(e, t), this.prevRenderTarget.setSize(e, t), this.ssrRenderTarget.setSize(e, t), this.normalRenderTarget.setSize(e, t), this.metalnessRenderTarget.setSize(e, t), this.blurRenderTarget.setSize(e, t), this.blurRenderTarget2.setSize(e, t), this.ssrMaterial.uniforms.resolution.value.set(e, t), this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.blurMaterial.uniforms.resolution.value.set(e, t), this.blurMaterial2.uniforms.resolution.value.set(e, t);
  }
}
function T3(n, e, t, i) {
  const r = new v3(t), s = t.getPixelRatio();
  r.setSize(i.clientWidth, i.clientHeight), r.setPixelRatio(s), r.setRenderWay = function(o = "效果渲染") {
    this.effectComposerRender = o === "源渲染" ? () => t.render(n, e) : () => this.render(), this.renderWay = o;
  }, r.effectPass = {}, r.setRenderWay();
  const a = new y3(n, e);
  return r.addPass(a), function(o, l, h) {
    const c = new Bh(l, h);
    c.enabled = !1, c.params.saoIntensity = 0.01, c.params.saoScale = 100, o.addPass(c), o.effectPass.saoPass = c;
  }(r, n, e), function(o, l) {
    const h = new Qo(new X(l.clientWidth, l.clientHeight), 1.5, 0.4, 0.85);
    h.enabled = !1, o.addPass(h), o.effectPass.unrealBloomPass = h;
  }(r, i), function(o, l, h, c, u) {
    const d = new Mr({ renderer: o, scene: l, camera: h, width: u.clientWidth, height: u.clientHeight, selects: l.ssrList });
    d.thickness = 0.018, d.infiniteThick = !1, d.maxDistance = 0.01, d.opacity = 0.5, d.enabled = !1, c.addPass(d), c.effectPass.ssrPass = d;
  }(t, n, e, r, i), function(o, l, h, c) {
    const u = new as(new X(c.clientWidth, c.clientHeight), l, h);
    u.renderToScreen = !0, u.edgeStrength = 3, u.edgeGlow = 0, u.edgeThickness = 1, u.pulsePeriod = 0, u.usePatternTexture = !1, u.visibleEdgeColor.set(16449071), u.hiddenEdgeColor.set(16449071), u.overlayMaterial.blending = Ro, u.overlayMaterial.blendSrc = kh, o.addPass(u), o.effectPass.outlinePass = u;
  }(r, n, e, i), function(o) {
    const l = new M3();
    o.addPass(l), o.effectPass.outputPass = l;
  }(r), function(o, l, h) {
    const c = new R0(w3);
    c.multPixel = 1, c.resize = function() {
      c.material.uniforms.resolution.value.x = c.multPixel / (l.clientWidth * h), c.material.uniforms.resolution.value.y = c.multPixel / (l.clientHeight * h);
    }, c.resize(), o.addPass(c), o.effectPass.fxaaPass = c;
  }(r, i, s), function(o) {
    const l = new S3();
    l.enabled = !1, o.addPass(l), o.effectPass.screenMaskPass = l;
  }(r), r.resize = function() {
    const { unrealBloomPass: o, fxaaPass: l } = r.effectPass;
    r.setSize(i.clientWidth, i.clientHeight), o.setSize(i.clientWidth, i.clientHeight), l.resize();
  }, r;
}
function E3(n, e = {}) {
  const t = i3(), i = function(m, g) {
    const f = new Gt(50, g.clientWidth / g.clientHeight, 0.1, 1e5);
    return f.position.set(10, 10, 10), f.name = "PerspectiveCamera", m.add(f), f;
  }(t, n), r = function({ webglRenderParams: m, pixelRatio: g }, f) {
    const v = new aM(Te({ antialias: !0, alpha: !0, logarithmicDepthBuffer: !0 }, m));
    return v.setSize(f.clientWidth, f.clientHeight), v.setPixelRatio(g || window.devicePixelRatio), f.appendChild(v.domElement), v;
  }(e, n), s = function(m, g) {
    const f = new s3(m, g.domElement);
    return f.enableDamping = !0, f.dampingFactor = 0.05, f.minDistance = 0.01, f.maxDistance = 1e6, f.maxPolarAngle = Math.PI, f;
  }(i, r), a = function(m, g, f, v) {
    const y = new a3(g, f.domElement);
    m.transformControls = y, y.name = "TransformControls", y.traverse((M) => M.isTransformControls = !0), m.add(y);
    const x = new yt();
    return y.addEventListener("dragging-changed", (M) => {
      var b;
      v.enabled = !M.value, y.drag_change_callback(M.value), (b = y.dragChangeCallback) == null || b.call(y, M.value);
    }), y.addEventListener("change", () => {
      var M;
      y.box3Helper && (["Group", "Mesh"].includes((M = y == null ? void 0 : y.object) == null ? void 0 : M.type) ? (y.box3Helper.box = x.setFromObject(y.object), y.box3Helper.visible = !0) : y.box3Helper.visible = !1);
    }), y;
  }(t, i, r, s), o = T3(t, i, r, n), l = function(m) {
    const g = new H2();
    return g.resize = () => {
      g.setSize(m.clientWidth, m.clientHeight), g.domElement.style.zIndex = 0, g.domElement.style.position = "relative", g.domElement.style.top = -m.clientHeight + "px", g.domElement.style.height = m.clientHeight + "px", g.domElement.style.width = m.clientWidth + "px", g.domElement.style.pointerEvents = "none";
    }, g.reset = () => g.domElement.childNodes.forEach((f) => f.remove()), g.resize(), m.appendChild(g.domElement), g;
  }(n), h = function(m) {
    const g = new k2();
    return g.resize = () => {
      g.setSize(m.clientWidth, m.clientHeight), g.domElement.style.zIndex = 0, g.domElement.style.position = "relative", g.domElement.style.top = 2 * -m.clientHeight + "px", g.domElement.style.height = m.clientHeight + "px", g.domElement.style.width = m.clientWidth + "px", g.domElement.style.pointerEvents = "none";
    }, g.reset = () => g.domElement.childNodes.forEach((f) => f.remove()), g.resize(), m.appendChild(g.domElement), g;
  }(n), c = function(m) {
    const g = new rh();
    return g.setMode(0), g.style = { offsetTop: 0, offsetLeft: 0 }, g.domElement.style.position = "relative", g.domElement.style.zIndex = "auto", g.domElement.style.width = "80px", g.domElement.style.height = "48px", g.resize = () => {
      const { offsetTop: f, offsetLeft: v } = g.style;
      g.domElement.style.top = f - 3 * m.getBoundingClientRect().height + "px", g.domElement.style.left = v + "px";
    }, g.resize(), g.setOffset = (f, v) => {
      g.style.offsetTop = f, g.style.offsetLeft = v, g.resize();
    }, g.showStats = !1, g.statsMode = 0, g.created = () => !m.contains(g.domElement) && m.appendChild(g.domElement), g.destroy = () => m.contains(g.domElement) && m.removeChild(g.domElement), g;
  }(n), u = t3({ scene: t, camera: i, renderer: r, controls: s, transformControls: a, effectComposer: o, css3DRender: l, css2DRender: h, stats: c, DOM: n }, e.sceneParams), d = function(m) {
    const g = new xh();
    if (!m)
      return (y) => y(g.getDelta());
    const f = 1 / m;
    let v = 0;
    return (y) => {
      const x = g.getDelta();
      v += x, v > f && (y(x), v = 0);
    };
  }(e.fps);
  let p = null;
  return function m() {
    d(() => {
      c.update(), s.update(), t.renderFrames(), o.effectComposerRender(), l.render(t, i), h.render(t, i);
    }), p = requestAnimationFrame(m);
  }(), Te({ scene: t, camera: i, renderer: r, controls: s, transformControls: a, effectComposer: o, css3DRender: l, css2DRender: h, stats: c, DOM: n, renderSceneResize: function() {
    i.aspect = n.clientWidth / n.clientHeight, i.updateProjectionMatrix(), r.setSize(n.clientWidth, n.clientHeight), o.resize(), t.shaderFrames.forEach((m) => m.uniforms.iResolution && (m.uniforms.iResolution.value = new X(n.clientWidth, n.clientHeight))), l.resize(), h.resize(), c.resize();
  }, destroySceneRender: function() {
    cancelAnimationFrame(p), yS(t), r.dispose();
    for (let m in this)
      delete this[m];
    for (; n.children.length; )
      n.removeChild(n.firstChild);
    (function() {
      const m = document.body.getElementsByClassName("vanui-window");
      for (let g = m.length - 1; g >= 0; g--)
        m[g].parentNode.removeChild(m[g]);
    })();
  } }, u);
}
Mr.OUTPUT = { Default: 0, SSR: 1, Beauty: 3, Depth: 4, Normal: 5, Metalness: 7 };
class dg {
  constructor(...e) {
    Object.assign(this, E3(...e));
  }
  setCss2dDOM(e, t) {
    e.style.pointerEvents = "auto";
    const { scene: i } = this, r = new rS(e);
    return r.position.copy(t), i.add(r), r.destroy = () => i.remove(r), r;
  }
  setCss3dDOM(e, t) {
    const { scene: i } = this, r = new sS(e);
    return r.position.copy(t), i.add(r), r.destroy = () => i.remove(r), r;
  }
  setLight(...e) {
    const t = _0(...e);
    return t.target && this.scene.add(t.target), this.scene.add(t), t;
  }
  getSceneEvent(e, t) {
    (function(i, r, s) {
      var M, b;
      const { scene: a, camera: o, handler: l, drawCore: h, transformControls: c, effectComposer: u, GUI: d } = i, { outlinePass: p } = u.effectPass;
      c.detach();
      const m = function(S, w, T) {
        const { raycaster: C } = T;
        return C.setFromCamera(S, w), C.intersectObjects(T.children).filter((I) => !I.object.isTransformControls && I.object.isMesh && I.object.visible);
      }(y1(r), o, a), g = m.find((S) => S.object.visible && Bx(S.object).visible);
      if (!g)
        return;
      const { object: f, point: v } = g, y = Bx(f);
      switch (l.mode) {
        case "变换":
          p.selectedObjects = [], l.isTransformChildren ? c.attach(f) : c.attach(y);
          break;
        case "选择":
          p.selectedObjects = [f], l.selectPanelEnable && ((M = d == null ? void 0 : d.createSelectPanel) == null || M.call(d, f));
          break;
        case "根选择":
          p.selectedObjects = [y], l.selectPanelEnable && ((b = d == null ? void 0 : d.createSelectPanel) == null || b.call(d, y));
          break;
        case "场景绘制":
          h.sceneEventCall(v, f);
      }
      const x = { currentModel: f, currentRootModel: y, point: v, mode: l.mode };
      i.currentInfo = x, l.currentInfo = x, s(x);
    })(this, e, (i) => t == null ? void 0 : t(i));
  }
  getRawSceneEvent() {
    return function(e) {
      const t = new qd();
      return { raycaster: t, getIntersects: (i, r) => (t.setFromCamera(y1(i), e), t.intersectObjects(r)) };
    }(this.camera);
  }
  setOutlinePass(e = []) {
    return this.effectComposer.effectPass.outlinePass.selectedObjects = e;
  }
  getSceneEditorImage(e) {
    return this.renderer.render(this.scene, this.camera), this.effectComposer.render(), this.renderer.domElement.toDataURL(...e);
  }
  setModelAnimationPlay(e) {
    if (e != null && e.animationPlayParams)
      return this.modelCore.modelAnimationPlay(e, e.animationPlayParams);
  }
  getSceneCurveList() {
    return this.scene.children.filter((e) => e.isCurveMesh).map((e) => {
      var t, i;
      return { path: e.curvePath || ((i = (t = e.geometry) == null ? void 0 : t.parameters) == null ? void 0 : i.path), mesh: e };
    });
  }
  setCurveAnimation(e, t = 1) {
    if (e)
      return function(i, r = 1, s) {
        return { id: Date.now(), curve: i, time: 0, pause: !1, speed: r, start: function() {
          s.indexOf(this) > -1 || (s.push(this), this.pause = !1);
        }, destroy: function() {
          const a = s.indexOf(this);
          a > -1 && s.splice(a, 1), delete this.start, delete this.destroy;
        }, frameCallback: null, frameEndCallback: null, commonAnimateRender: function() {
          var a, o;
          if (!this.pause) {
            if (this.time += this.speed / 1e3, this.time > 1 || this.time < 0)
              return this.time = this.time > 1 ? 1 : 0, this.pause = !0, (a = this.frameEndCallback) == null ? void 0 : a.call(this, "end");
            (o = this.frameCallback) == null || o.call(this, this.curve.getPointAt(this.time));
          }
        } };
      }(e, t, this.scene.commonFrames);
  }
}
up(dg, "dracoPath", "/draco/"), up(dg, "styleOverrides", Uh);
export {
  rS as CSS2DObject,
  sS as CSS3DObject,
  C3 as THREE,
  dg as ThreeEditor,
  D3 as cloneObjectMaterial,
  hC as createCanvasText,
  dd as createGsapAnimation,
  O3 as createMesh,
  F3 as createSpriteText,
  P3 as dat,
  L3 as getDirectionQuaternion,
  R3 as getDistanceScalePoint,
  Jd as getGeometry,
  xi as getMaterial,
  G2 as getObjectBox3,
  j2 as getObjectViews,
  l0 as gsap,
  N3 as objectChangeMaterial,
  U3 as objectChangeTransform,
  Bn as proj4,
  vS as setGsapMeshAction,
  I3 as syncVectorTransform
};
